{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-option/src/find-suggestion.ts"],"sourcesContent":["const { min } = Math;\n\n// a minimal leven distance implementation\n// balanced maintainability with code size\n// It is not blazingly fast but should be okay for Babel user case\n// where it will be run for at most tens of time on strings\n// that have less than 20 ASCII characters\n\n// https://rosettacode.org/wiki/Levenshtein_distance#ES5\nfunction levenshtein(a: string, b: string): number {\n  let t = [],\n    u: number[] = [],\n    i,\n    j;\n  const m = a.length,\n    n = b.length;\n  if (!m) {\n    return n;\n  }\n  if (!n) {\n    return m;\n  }\n  for (j = 0; j <= n; j++) {\n    t[j] = j;\n  }\n  for (i = 1; i <= m; i++) {\n    for (u = [i], j = 1; j <= n; j++) {\n      u[j] =\n        a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;\n    }\n    t = u;\n  }\n  return u[n];\n}\n\n/**\n * Given a string `str` and an array of candidates `arr`,\n * return the first of elements in candidates that has minimal\n * Levenshtein distance with `str`.\n * @export\n * @param {string} str\n * @param {string[]} arr\n * @returns {string}\n */\nexport function findSuggestion(str: string, arr: readonly string[]): string {\n  const distances = arr.map<number>(el => levenshtein(el, str));\n  return arr[distances.indexOf(min(...distances))];\n}\n"],"names":["min","Math","levenshtein","a","b","t","u","i","j","m","length","n","findSuggestion","str","arr","distances","map","el","indexOf"],"mappings":";;;;;AAAA,MAAM,EAAEA,GAAAA,EAAK,GAAGC,IAAI;AASpB,SAASC,WAAWA,CAACC,CAAS,EAAEC,CAAS,EAAU;IACjD,IAAIC,CAAC,GAAG,EAAE,EACRC,CAAW,GAAG,EAAE,EAChBC,CAAC,EACDC,CAAC;IACH,MAAMC,CAAC,GAAGN,CAAC,CAACO,MAAM,EAChBC,CAAC,GAAGP,CAAC,CAACM,MAAM;IACd,IAAI,CAACD,CAAC,EAAE;QACN,OAAOE,CAAC;IACV;IACA,IAAI,CAACA,CAAC,EAAE;QACN,OAAOF,CAAC;IACV;IACA,IAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIG,CAAC,EAAEH,CAAC,EAAE,CAAE;QACvBH,CAAC,CAACG,CAAC,CAAC,GAAGA,CAAC;IACV;IACA,IAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIE,CAAC,EAAEF,CAAC,EAAE,CAAE;QACvB,IAAKD,CAAC,GAAG;YAACC,CAAC;SAAC,EAAEC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIG,CAAC,EAAEH,CAAC,EAAE,CAAE;YAChCF,CAAC,CAACE,CAAC,CAAC,GACFL,CAAC,CAACI,CAAC,GAAG,CAAC,CAAC,KAAKH,CAAC,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGH,CAAC,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGR,GAAG,CAACK,CAAC,CAACG,CAAC,GAAG,CAAC,CAAC,EAAEH,CAAC,CAACG,CAAC,CAAC,EAAEF,CAAC,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;QACxE;QACAH,CAAC,GAAGC,CAAC;IACP;IACA,OAAOA,CAAC,CAACK,CAAC,CAAC;AACb;AAWO,SAASC,cAAcA,CAACC,GAAW,EAAEC,GAAsB,EAAU;IAC1E,MAAMC,SAAS,GAAGD,GAAG,CAACE,GAAG,EAASC,EAAE,GAAIf,WAAW,CAACe,EAAE,EAAEJ,GAAG,CAAC,CAAC;IAC7D,OAAOC,GAAG,CAACC,SAAS,CAACG,OAAO,CAAClB,GAAG,CAAC,GAAGe,SAAS,CAAC,CAAC,CAAC;AAClD","ignoreList":[0]}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 43, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-option/src/validator.ts"],"sourcesContent":["import { findSuggestion } from \"./find-suggestion.ts\";\n\nexport class OptionValidator {\n  declare descriptor: string;\n  constructor(descriptor: string) {\n    this.descriptor = descriptor;\n  }\n\n  /**\n   * Validate if the given `options` follow the name of keys defined in the `TopLevelOptionShape`\n   *\n   * @param {Object} options\n   * @param {Object} TopLevelOptionShape\n   *   An object with all the valid key names that `options` should be allowed to have\n   *   The property values of `TopLevelOptionShape` can be arbitrary\n   * @memberof OptionValidator\n   */\n  validateTopLevelOptions(options: object, TopLevelOptionShape: object): void {\n    const validOptionNames = Object.keys(TopLevelOptionShape);\n    for (const option of Object.keys(options)) {\n      if (!validOptionNames.includes(option)) {\n        throw new Error(\n          this.formatMessage(`'${option}' is not a valid top-level option.\n- Did you mean '${findSuggestion(option, validOptionNames)}'?`),\n        );\n      }\n    }\n  }\n\n  // note: we do not consider rewrite them to high order functions\n  // until we have to support `validateNumberOption`.\n  validateBooleanOption<T extends boolean>(\n    name: string,\n    value?: boolean,\n    defaultValue?: T,\n  ): boolean | T {\n    if (value === undefined) {\n      return defaultValue;\n    } else {\n      this.invariant(\n        typeof value === \"boolean\",\n        `'${name}' option must be a boolean.`,\n      );\n    }\n    return value;\n  }\n\n  validateStringOption<T extends string>(\n    name: string,\n    value?: string,\n    defaultValue?: T,\n  ): string | T {\n    if (value === undefined) {\n      return defaultValue;\n    } else {\n      this.invariant(\n        typeof value === \"string\",\n        `'${name}' option must be a string.`,\n      );\n    }\n    return value;\n  }\n  /**\n   * A helper interface copied from the `invariant` npm package.\n   * It throws given `message` when `condition` is not met\n   *\n   * @param {boolean} condition\n   * @param {string} message\n   * @memberof OptionValidator\n   */\n  invariant(condition: boolean, message: string): void {\n    if (!condition) {\n      throw new Error(this.formatMessage(message));\n    }\n  }\n\n  formatMessage(message: string): string {\n    return `${this.descriptor}: ${message}`;\n  }\n}\n"],"names":["_findSuggestion","require","OptionValidator","constructor","descriptor","validateTopLevelOptions","options","TopLevelOptionShape","validOptionNames","Object","keys","option","includes","Error","formatMessage","findSuggestion","validateBooleanOption","name","value","defaultValue","undefined","invariant","validateStringOption","condition","message","exports"],"mappings":";;;;;AAAA,IAAAA,eAAA,GAAAC,OAAA;AAEO,MAAMC,eAAe,CAAC;IAE3BC,WAAWA,CAACC,UAAkB,CAAE;QAC9B,IAAI,CAACA,UAAU,GAAGA,UAAU;IAC9B;IAWAC,uBAAuBA,CAACC,OAAe,EAAEC,mBAA2B,EAAQ;QAC1E,MAAMC,gBAAgB,GAAGC,MAAM,CAACC,IAAI,CAACH,mBAAmB,CAAC;QACzD,KAAK,MAAMI,MAAM,IAAIF,MAAM,CAACC,IAAI,CAACJ,OAAO,CAAC,CAAE;YACzC,IAAI,CAACE,gBAAgB,CAACI,QAAQ,CAACD,MAAM,CAAC,EAAE;gBACtC,MAAM,IAAIE,KAAK,CACb,IAAI,CAACC,aAAa,CAAC,CAAA,CAAA,EAAIH,MAAM,CAAA;gBACvC,EAAkB,CAAA,GAAAI,gBAAAA,cAAc,EAACJ,MAAM,EAAEH,gBAAgB,CAAC,CAAA,EAAA,CAAI,CACtD,CAAC;YACH;QACF;IACF;IAIAQ,qBAAqBA,CACnBC,IAAY,EACZC,KAAe,EACfC,YAAgB,EACH;QACb,IAAID,KAAK,KAAKE,SAAS,EAAE;YACvB,OAAOD,YAAY;QACrB,CAAC,MAAM;YACL,IAAI,CAACE,SAAS,CACZ,OAAOH,KAAK,KAAK,SAAS,EAC1B,CAAA,CAAA,EAAID,IAAI,CAAA,2BAAA,CACV,CAAC;QACH;QACA,OAAOC,KAAK;IACd;IAEAI,oBAAoBA,CAClBL,IAAY,EACZC,KAAc,EACdC,YAAgB,EACJ;QACZ,IAAID,KAAK,KAAKE,SAAS,EAAE;YACvB,OAAOD,YAAY;QACrB,CAAC,MAAM;YACL,IAAI,CAACE,SAAS,CACZ,OAAOH,KAAK,KAAK,QAAQ,EACzB,CAAA,CAAA,EAAID,IAAI,CAAA,0BAAA,CACV,CAAC;QACH;QACA,OAAOC,KAAK;IACd;IASAG,SAASA,CAACE,SAAkB,EAAEC,OAAe,EAAQ;QACnD,IAAI,CAACD,SAAS,EAAE;YACd,MAAM,IAAIV,KAAK,CAAC,IAAI,CAACC,aAAa,CAACU,OAAO,CAAC,CAAC;QAC9C;IACF;IAEAV,aAAaA,CAACU,OAAe,EAAU;QACrC,OAAO,GAAG,IAAI,CAACpB,UAAU,CAAA,EAAA,EAAKoB,OAAO,EAAE;IACzC;AACF;AAACC,OAAA,CAAAvB,eAAA,GAAAA,eAAA","ignoreList":[0]}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-option/src/index.ts"],"sourcesContent":["export { OptionValidator } from \"./validator.ts\";\nexport { findSuggestion } from \"./find-suggestion.ts\";\n"],"names":["_validator","require","_findSuggestion"],"mappings":";;;;;;;;;;;;;;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AACA,IAAAC,eAAA,GAAAD,OAAA","ignoreList":[0]}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/compat-data/native-modules.js"],"sourcesContent":["module.exports = require(\"./data/native-modules.json\");\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/compat-data/plugins.js"],"sourcesContent":["module.exports = require(\"./data/plugins.json\");\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 133, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/compat-data/plugin-bugfixes.js"],"sourcesContent":["module.exports = require(\"./data/plugin-bugfixes.json\");\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 144, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/compat-data/overlapping-plugins.js"],"sourcesContent":["module.exports = require(\"./data/overlapping-plugins.json\");\n"],"names":[],"mappings":"AAAA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/compat-data/corejs2-built-ins.js"],"sourcesContent":["// Todo (Babel 8): remove this file as Babel 8 drop support of core-js 2\nmodule.exports = require(\"./data/corejs2-built-ins.json\");\n"],"names":[],"mappings":"AAAA,wEAAwE;AACxE,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 172, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/targets.ts"],"sourcesContent":["export const unreleasedLabels = {\n  safari: \"tp\",\n} as const;\n\n// Map from browserslist|@mdn/browser-compat-data browser names to @kangax/compat-table browser names\nexport const browserNameMap = {\n  and_chr: \"chrome\",\n  and_ff: \"firefox\",\n  android: \"android\",\n  chrome: \"chrome\",\n  edge: \"edge\",\n  firefox: \"firefox\",\n  ie: \"ie\",\n  ie_mob: \"ie\",\n  ios_saf: \"ios\",\n  node: \"node\",\n  deno: \"deno\",\n  op_mob: \"opera_mobile\",\n  opera: \"opera\",\n  safari: \"safari\",\n  samsung: \"samsung\",\n} as const;\n\nexport type BrowserslistBrowserName = keyof typeof browserNameMap;\n"],"names":["unreleasedLabels","exports","safari","browserNameMap","and_chr","and_ff","android","chrome","edge","firefox","ie","ie_mob","ios_saf","node","deno","op_mob","opera","samsung"],"mappings":";;;;;AAAO,MAAMA,gBAAgB,GAAAC,OAAA,CAAAD,gBAAA,GAAG;IAC9BE,MAAM,EAAE;AACV,CAAU;AAGH,MAAMC,cAAc,GAAAF,OAAA,CAAAE,cAAA,GAAG;IAC5BC,OAAO,EAAE,QAAQ;IACjBC,MAAM,EAAE,SAAS;IACjBC,OAAO,EAAE,SAAS;IAClBC,MAAM,EAAE,QAAQ;IAChBC,IAAI,EAAE,MAAM;IACZC,OAAO,EAAE,SAAS;IAClBC,EAAE,EAAE,IAAI;IACRC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,KAAK;IACdC,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE,MAAM;IACZC,MAAM,EAAE,cAAc;IACtBC,KAAK,EAAE,OAAO;IACdd,MAAM,EAAE,QAAQ;IAChBe,OAAO,EAAE;AACX,CAAU","ignoreList":[0]}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 202, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/utils.ts"],"sourcesContent":["import semver from \"semver\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\nimport { unreleasedLabels } from \"./targets.ts\";\nimport type { Target, Targets } from \"./types.ts\";\n\nconst versionRegExp =\n  /^(?:\\d+|\\d(?:\\d?[^\\d\\n\\r\\u2028\\u2029]\\d+|\\d{2,}(?:[^\\d\\n\\r\\u2028\\u2029]\\d+)?))$/;\n\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nexport function semverMin(\n  first: string | undefined | null,\n  second: string,\n): string {\n  return first && semver.lt(first, second) ? first : second;\n}\n\n// Convert version to a semver value.\n// 2.5 -> 2.5.0; 1 -> 1.0.0;\nexport function semverify(version: number | string): string {\n  if (typeof version === \"string\" && semver.valid(version)) {\n    return version;\n  }\n\n  v.invariant(\n    typeof version === \"number\" ||\n      (typeof version === \"string\" && versionRegExp.test(version)),\n    `'${version}' is not a valid version`,\n  );\n\n  version = version.toString();\n\n  let pos = 0;\n  let num = 0;\n  while ((pos = version.indexOf(\".\", pos + 1)) > 0) {\n    num++;\n  }\n  return version + \".0\".repeat(2 - num);\n}\n\nexport function isUnreleasedVersion(\n  version: string | number,\n  env: Target,\n): boolean {\n  const unreleasedLabel =\n    // @ts-expect-error unreleasedLabel will be guarded later\n    unreleasedLabels[env];\n  return (\n    !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase()\n  );\n}\n\nexport function getLowestUnreleased(a: string, b: string, env: Target): string {\n  const unreleasedLabel:\n    | (typeof unreleasedLabels)[keyof typeof unreleasedLabels]\n    | undefined =\n    // @ts-expect-error unreleasedLabel is undefined when env is not safari\n    unreleasedLabels[env];\n  if (a === unreleasedLabel) {\n    return b;\n  }\n  if (b === unreleasedLabel) {\n    return a;\n  }\n  return semverMin(a, b);\n}\n\nexport function getHighestUnreleased(\n  a: string,\n  b: string,\n  env: Target,\n): string {\n  return getLowestUnreleased(a, b, env) === a ? b : a;\n}\n\nexport function getLowestImplementedVersion(\n  plugin: Targets,\n  environment: Target,\n): string {\n  const result = plugin[environment];\n  // When Android support data is absent, use Chrome data as fallback\n  if (!result && environment === \"android\") {\n    return plugin.chrome;\n  }\n  return result;\n}\n"],"names":["_semver","require","_helperValidatorOption","_targets","versionRegExp","v","OptionValidator","semverMin","first","second","semver","lt","semverify","version","valid","invariant","test","toString","pos","num","indexOf","repeat","isUnreleasedVersion","env","unreleasedLabel","unreleasedLabels","toLowerCase","getLowestUnreleased","a","b","getHighestUnreleased","getLowestImplementedVersion","plugin","environment","result","chrome"],"mappings":";;;;;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,sBAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AAGA,MAAMG,aAAa,GACjB,iFAAiF;AAEnF,MAAMC,CAAC,GAAG,IAAIC,uBAAAA,eAAe,CAAA,mCAAkB,CAAC;AAEzC,SAASC,SAASA,CACvBC,KAAgC,EAChCC,MAAc,EACN;IACR,OAAOD,KAAK,IAAIE,OAAM,CAACC,EAAE,CAACH,KAAK,EAAEC,MAAM,CAAC,GAAGD,KAAK,GAAGC,MAAM;AAC3D;AAIO,SAASG,SAASA,CAACC,OAAwB,EAAU;IAC1D,IAAI,OAAOA,OAAO,KAAK,QAAQ,IAAIH,OAAM,CAACI,KAAK,CAACD,OAAO,CAAC,EAAE;QACxD,OAAOA,OAAO;IAChB;IAEAR,CAAC,CAACU,SAAS,CACT,OAAOF,OAAO,KAAK,QAAQ,IACxB,OAAOA,OAAO,KAAK,QAAQ,IAAIT,aAAa,CAACY,IAAI,CAACH,OAAO,CAAE,EAC9D,CAAA,CAAA,EAAIA,OAAO,CAAA,wBAAA,CACb,CAAC;IAEDA,OAAO,GAAGA,OAAO,CAACI,QAAQ,CAAC,CAAC;IAE5B,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,GAAG,GAAG,CAAC;IACX,MAAO,CAACD,GAAG,GAAGL,OAAO,CAACO,OAAO,CAAC,GAAG,EAAEF,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,CAAE;QAChDC,GAAG,EAAE;IACP;IACA,OAAON,OAAO,GAAG,IAAI,CAACQ,MAAM,CAAC,CAAC,GAAGF,GAAG,CAAC;AACvC;AAEO,SAASG,mBAAmBA,CACjCT,OAAwB,EACxBU,GAAW,EACF;IACT,MAAMC,eAAe,GAEnBC,SAAAA,gBAAgB,CAACF,GAAG,CAAC;IACvB,OACE,CAAC,CAACC,eAAe,IAAIA,eAAe,KAAKX,OAAO,CAACI,QAAQ,CAAC,CAAC,CAACS,WAAW,CAAC,CAAC;AAE7E;AAEO,SAASC,mBAAmBA,CAACC,CAAS,EAAEC,CAAS,EAAEN,GAAW,EAAU;IAC7E,MAAMC,eAEO,GAEXC,SAAAA,gBAAgB,CAACF,GAAG,CAAC;IACvB,IAAIK,CAAC,KAAKJ,eAAe,EAAE;QACzB,OAAOK,CAAC;IACV;IACA,IAAIA,CAAC,KAAKL,eAAe,EAAE;QACzB,OAAOI,CAAC;IACV;IACA,OAAOrB,SAAS,CAACqB,CAAC,EAAEC,CAAC,CAAC;AACxB;AAEO,SAASC,oBAAoBA,CAClCF,CAAS,EACTC,CAAS,EACTN,GAAW,EACH;IACR,OAAOI,mBAAmB,CAACC,CAAC,EAAEC,CAAC,EAAEN,GAAG,CAAC,KAAKK,CAAC,GAAGC,CAAC,GAAGD,CAAC;AACrD;AAEO,SAASG,2BAA2BA,CACzCC,MAAe,EACfC,WAAmB,EACX;IACR,MAAMC,MAAM,GAAGF,MAAM,CAACC,WAAW,CAAC;IAElC,IAAI,CAACC,MAAM,IAAID,WAAW,KAAK,SAAS,EAAE;QACxC,OAAOD,MAAM,CAACG,MAAM;IACtB;IACA,OAAOD,MAAM;AACf","ignoreList":[0]}},
    {"offset": {"line": 257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/options.ts"],"sourcesContent":["export const TargetNames = {\n  node: \"node\",\n  deno: \"deno\",\n  chrome: \"chrome\",\n  opera: \"opera\",\n  edge: \"edge\",\n  firefox: \"firefox\",\n  safari: \"safari\",\n  ie: \"ie\",\n  ios: \"ios\",\n  android: \"android\",\n  electron: \"electron\",\n  samsung: \"samsung\",\n  rhino: \"rhino\",\n  opera_mobile: \"opera_mobile\",\n};\n"],"names":["TargetNames","exports","node","deno","chrome","opera","edge","firefox","safari","ie","ios","android","electron","samsung","rhino","opera_mobile"],"mappings":";;;;;AAAO,MAAMA,WAAW,GAAAC,OAAA,CAAAD,WAAA,GAAG;IACzBE,IAAI,EAAE,MAAM;IACZC,IAAI,EAAE,MAAM;IACZC,MAAM,EAAE,QAAQ;IAChBC,KAAK,EAAE,OAAO;IACdC,IAAI,EAAE,MAAM;IACZC,OAAO,EAAE,SAAS;IAClBC,MAAM,EAAE,QAAQ;IAChBC,EAAE,EAAE,IAAI;IACRC,GAAG,EAAE,KAAK;IACVC,OAAO,EAAE,SAAS;IAClBC,QAAQ,EAAE,UAAU;IACpBC,OAAO,EAAE,SAAS;IAClBC,KAAK,EAAE,OAAO;IACdC,YAAY,EAAE;AAChB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 288, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/pretty.ts"],"sourcesContent":["import semver from \"semver\";\nimport { unreleasedLabels } from \"./targets.ts\";\nimport type { Targets, Target } from \"./types.ts\";\n\nexport function prettifyVersion(version: string) {\n  if (typeof version !== \"string\") {\n    return version;\n  }\n\n  const { major, minor, patch } = semver.parse(version);\n\n  const parts = [major];\n\n  if (minor || patch) {\n    parts.push(minor);\n  }\n\n  if (patch) {\n    parts.push(patch);\n  }\n\n  return parts.join(\".\");\n}\n\nexport function prettifyTargets(targets: Targets): Targets {\n  return Object.keys(targets).reduce((results, target: Target) => {\n    let value = targets[target];\n\n    const unreleasedLabel =\n      // @ts-expect-error undefined is strictly compared with string later\n      unreleasedLabels[target];\n    if (typeof value === \"string\" && unreleasedLabel !== value) {\n      value = prettifyVersion(value);\n    }\n\n    results[target] = value;\n    return results;\n  }, {} as Targets);\n}\n"],"names":["_semver","require","_targets","prettifyVersion","version","major","minor","patch","semver","parse","parts","push","join","prettifyTargets","targets","Object","keys","reduce","results","target","value","unreleasedLabel","unreleasedLabels"],"mappings":";;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAGO,SAASE,eAAeA,CAACC,OAAe,EAAE;IAC/C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QAC/B,OAAOA,OAAO;IAChB;IAEA,MAAM,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAAA,EAAO,GAAGC,OAAM,CAACC,KAAK,CAACL,OAAO,CAAC;IAErD,MAAMM,KAAK,GAAG;QAACL,KAAK;KAAC;IAErB,IAAIC,KAAK,IAAIC,KAAK,EAAE;QAClBG,KAAK,CAACC,IAAI,CAACL,KAAK,CAAC;IACnB;IAEA,IAAIC,KAAK,EAAE;QACTG,KAAK,CAACC,IAAI,CAACJ,KAAK,CAAC;IACnB;IAEA,OAAOG,KAAK,CAACE,IAAI,CAAC,GAAG,CAAC;AACxB;AAEO,SAASC,eAAeA,CAACC,OAAgB,EAAW;IACzD,OAAOC,MAAM,CAACC,IAAI,CAACF,OAAO,CAAC,CAACG,MAAM,CAAC,CAACC,OAAO,EAAEC,MAAc,KAAK;QAC9D,IAAIC,KAAK,GAAGN,OAAO,CAACK,MAAM,CAAC;QAE3B,MAAME,eAAe,GAEnBC,SAAAA,gBAAgB,CAACH,MAAM,CAAC;QAC1B,IAAI,OAAOC,KAAK,KAAK,QAAQ,IAAIC,eAAe,KAAKD,KAAK,EAAE;YAC1DA,KAAK,GAAGjB,eAAe,CAACiB,KAAK,CAAC;QAChC;QAEAF,OAAO,CAACC,MAAM,CAAC,GAAGC,KAAK;QACvB,OAAOF,OAAO;IAChB,CAAC,EAAE,CAAC,CAAY,CAAC;AACnB","ignoreList":[0]}},
    {"offset": {"line": 323, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/debug.ts"],"sourcesContent":["import semver from \"semver\";\nimport { prettifyVersion } from \"./pretty.ts\";\nimport {\n  semverify,\n  isUnreleasedVersion,\n  getLowestImplementedVersion,\n} from \"./utils.ts\";\nimport type { Target, Targets } from \"./types.ts\";\n\nexport function getInclusionReasons(\n  item: string,\n  targetVersions: Targets,\n  list: { [key: string]: Targets },\n) {\n  const minVersions = list[item] || {};\n\n  return (Object.keys(targetVersions) as Target[]).reduce(\n    (result, env) => {\n      const minVersion = getLowestImplementedVersion(minVersions, env);\n      const targetVersion = targetVersions[env];\n\n      if (!minVersion) {\n        result[env] = prettifyVersion(targetVersion);\n      } else {\n        const minIsUnreleased = isUnreleasedVersion(minVersion, env);\n        const targetIsUnreleased = isUnreleasedVersion(targetVersion, env);\n\n        if (\n          !targetIsUnreleased &&\n          (minIsUnreleased ||\n            semver.lt(targetVersion.toString(), semverify(minVersion)))\n        ) {\n          result[env] = prettifyVersion(targetVersion);\n        }\n      }\n\n      return result;\n    },\n    {} as Partial<Record<Target, string>>,\n  );\n}\n"],"names":["_semver","require","_pretty","_utils","getInclusionReasons","item","targetVersions","list","minVersions","Object","keys","reduce","result","env","minVersion","getLowestImplementedVersion","targetVersion","prettifyVersion","minIsUnreleased","isUnreleasedVersion","targetIsUnreleased","semver","lt","toString","semverify"],"mappings":";;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,MAAA,GAAAF,OAAA;AAOO,SAASG,mBAAmBA,CACjCC,IAAY,EACZC,cAAuB,EACvBC,IAAgC,EAChC;IACA,MAAMC,WAAW,GAAGD,IAAI,CAACF,IAAI,CAAC,IAAI,CAAC,CAAC;IAEpC,OAAQI,MAAM,CAACC,IAAI,CAACJ,cAAc,CAAC,CAAcK,MAAM,CACrD,CAACC,MAAM,EAAEC,GAAG,KAAK;QACf,MAAMC,UAAU,GAAG,CAAA,GAAAC,OAAAA,2BAA2B,EAACP,WAAW,EAAEK,GAAG,CAAC;QAChE,MAAMG,aAAa,GAAGV,cAAc,CAACO,GAAG,CAAC;QAEzC,IAAI,CAACC,UAAU,EAAE;YACfF,MAAM,CAACC,GAAG,CAAC,GAAG,CAAA,GAAAI,QAAAA,eAAe,EAACD,aAAa,CAAC;QAC9C,CAAC,MAAM;YACL,MAAME,eAAe,GAAG,CAAA,GAAAC,OAAAA,mBAAmB,EAACL,UAAU,EAAED,GAAG,CAAC;YAC5D,MAAMO,kBAAkB,GAAG,CAAA,GAAAD,OAAAA,mBAAmB,EAACH,aAAa,EAAEH,GAAG,CAAC;YAElE,IACE,CAACO,kBAAkB,IAAA,CAClBF,eAAe,IACdG,OAAM,CAACC,EAAE,CAACN,aAAa,CAACO,QAAQ,CAAC,CAAC,EAAE,CAAA,GAAAC,OAAAA,SAAS,EAACV,UAAU,CAAC,CAAC,CAAC,EAC7D;gBACAF,MAAM,CAACC,GAAG,CAAC,GAAG,CAAA,GAAAI,QAAAA,eAAe,EAACD,aAAa,CAAC;YAC9C;QACF;QAEA,OAAOJ,MAAM;IACf,CAAC,EACD,CAAC,CACH,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/filter-items.ts"],"sourcesContent":["import semver from \"semver\";\n\nimport pluginsCompatData from \"@babel/compat-data/plugins\";\n\nimport type { Targets } from \"./types.ts\";\nimport {\n  getLowestImplementedVersion,\n  isUnreleasedVersion,\n  semverify,\n} from \"./utils.ts\";\n\nexport function targetsSupported(target: Targets, support: Targets) {\n  const targetEnvironments = Object.keys(target) as Array<keyof Targets>;\n\n  if (targetEnvironments.length === 0) {\n    return false;\n  }\n\n  const unsupportedEnvironments = targetEnvironments.filter(environment => {\n    const lowestImplementedVersion = getLowestImplementedVersion(\n      support,\n      environment,\n    );\n\n    // Feature is not implemented in that environment\n    if (!lowestImplementedVersion) {\n      return true;\n    }\n\n    const lowestTargetedVersion = target[environment];\n\n    // If targets has unreleased value as a lowest version, then don't require a plugin.\n    if (isUnreleasedVersion(lowestTargetedVersion, environment)) {\n      return false;\n    }\n\n    // Include plugin if it is supported in the unreleased environment, which wasn't specified in targets\n    if (isUnreleasedVersion(lowestImplementedVersion, environment)) {\n      return true;\n    }\n\n    if (!semver.valid(lowestTargetedVersion.toString())) {\n      throw new Error(\n        `Invalid version passed for target \"${environment}\": \"${lowestTargetedVersion}\". ` +\n          \"Versions must be in semver format (major.minor.patch)\",\n      );\n    }\n\n    return semver.gt(\n      semverify(lowestImplementedVersion),\n      lowestTargetedVersion.toString(),\n    );\n  });\n\n  return unsupportedEnvironments.length === 0;\n}\n\nexport function isRequired(\n  name: string,\n  targets: Targets,\n  {\n    compatData = pluginsCompatData,\n    includes,\n    excludes,\n  }: {\n    compatData?: { [feature: string]: Targets };\n    includes?: Set<string>;\n    excludes?: Set<string>;\n  } = {},\n) {\n  if (excludes?.has(name)) return false;\n  if (includes?.has(name)) return true;\n  return !targetsSupported(targets, compatData[name]);\n}\n\nexport default function filterItems(\n  list: { [feature: string]: Targets },\n  includes: Set<string>,\n  excludes: Set<string>,\n  targets: Targets,\n  defaultIncludes: Array<string> | null,\n  defaultExcludes?: Array<string> | null,\n  pluginSyntaxMap?: Map<string, string | null>,\n) {\n  const result = new Set<string>();\n  const options = { compatData: list, includes, excludes };\n\n  for (const item in list) {\n    if (isRequired(item, targets, options)) {\n      result.add(item);\n    } else if (pluginSyntaxMap) {\n      const shippedProposalsSyntax = pluginSyntaxMap.get(item);\n\n      if (shippedProposalsSyntax) {\n        result.add(shippedProposalsSyntax);\n      }\n    }\n  }\n\n  defaultIncludes?.forEach(item => !excludes.has(item) && result.add(item));\n  defaultExcludes?.forEach(item => !includes.has(item) && result.delete(item));\n\n  return result;\n}\n"],"names":["_semver","require","_plugins","_utils","targetsSupported","target","support","targetEnvironments","Object","keys","length","unsupportedEnvironments","filter","environment","lowestImplementedVersion","getLowestImplementedVersion","lowestTargetedVersion","isUnreleasedVersion","semver","valid","toString","Error","gt","semverify","isRequired","name","targets","compatData","pluginsCompatData","includes","excludes","has","filterItems","list","defaultIncludes","defaultExcludes","pluginSyntaxMap","result","Set","options","item","add","shippedProposalsSyntax","get","forEach","delete"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-compilation-targets/src/index.ts"],"sourcesContent":["import browserslist from \"browserslist\";\nimport { findSuggestion } from \"@babel/helper-validator-option\";\nimport browserModulesData from \"@babel/compat-data/native-modules\";\nimport LruCache from \"lru-cache\";\n\nimport {\n  semverify,\n  semverMin,\n  isUnreleasedVersion,\n  getLowestUnreleased,\n  getHighestUnreleased,\n} from \"./utils.ts\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\nimport { browserNameMap } from \"./targets.ts\";\nimport { TargetNames } from \"./options.ts\";\nimport type {\n  Target,\n  Targets,\n  InputTargets,\n  Browsers,\n  BrowserslistBrowserName,\n  TargetsTuple,\n} from \"./types.ts\";\n\nexport type { Target, Targets, InputTargets };\n\nexport { prettifyTargets } from \"./pretty.ts\";\nexport { getInclusionReasons } from \"./debug.ts\";\nexport { default as filterItems, isRequired } from \"./filter-items.ts\";\nexport { unreleasedLabels } from \"./targets.ts\";\nexport { TargetNames };\n\nconst ESM_SUPPORT = browserModulesData[\"es6.module\"];\n\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nfunction validateTargetNames(targets: Targets): TargetsTuple {\n  const validTargets = Object.keys(TargetNames);\n  for (const target of Object.keys(targets)) {\n    if (!(target in TargetNames)) {\n      throw new Error(\n        v.formatMessage(`'${target}' is not a valid target\n- Did you mean '${findSuggestion(target, validTargets)}'?`),\n      );\n    }\n  }\n\n  return targets;\n}\n\nexport function isBrowsersQueryValid(browsers: unknown): boolean {\n  return (\n    typeof browsers === \"string\" ||\n    (Array.isArray(browsers) && browsers.every(b => typeof b === \"string\"))\n  );\n}\n\nfunction validateBrowsers(browsers: Browsers | undefined) {\n  v.invariant(\n    browsers === undefined || isBrowsersQueryValid(browsers),\n    `'${String(browsers)}' is not a valid browserslist query`,\n  );\n\n  return browsers;\n}\n\nfunction getLowestVersions(browsers: Array<string>): Targets {\n  return browsers.reduce(\n    (all, browser) => {\n      const [browserName, browserVersion] = browser.split(\" \") as [\n        BrowserslistBrowserName,\n        string,\n      ];\n      const target = browserNameMap[browserName];\n\n      if (!target) {\n        return all;\n      }\n\n      try {\n        // Browser version can return as \"10.0-10.2\"\n        const splitVersion = browserVersion.split(\"-\")[0].toLowerCase();\n        const isSplitUnreleased = isUnreleasedVersion(splitVersion, target);\n\n        if (!all[target]) {\n          all[target] = isSplitUnreleased\n            ? splitVersion\n            : semverify(splitVersion);\n          return all;\n        }\n\n        const version = all[target];\n        const isUnreleased = isUnreleasedVersion(version, target);\n\n        if (isUnreleased && isSplitUnreleased) {\n          all[target] = getLowestUnreleased(version, splitVersion, target);\n        } else if (isUnreleased) {\n          all[target] = semverify(splitVersion);\n        } else if (!isUnreleased && !isSplitUnreleased) {\n          const parsedBrowserVersion = semverify(splitVersion);\n\n          all[target] = semverMin(version, parsedBrowserVersion);\n        }\n      } catch (_) {}\n\n      return all;\n    },\n    {} as Record<Target, string>,\n  );\n}\n\nfunction outputDecimalWarning(\n  decimalTargets: Array<{ target: string; value: number }>,\n) {\n  if (!decimalTargets.length) {\n    return;\n  }\n\n  console.warn(\"Warning, the following targets are using a decimal version:\\n\");\n  decimalTargets.forEach(({ target, value }) =>\n    console.warn(`  ${target}: ${value}`),\n  );\n  console.warn(`\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n`);\n}\n\nfunction semverifyTarget(target: Target, value: string) {\n  try {\n    return semverify(value);\n  } catch (_) {\n    throw new Error(\n      v.formatMessage(\n        `'${value}' is not a valid value for 'targets.${target}'.`,\n      ),\n    );\n  }\n}\n\n// Parse `node: true` and `node: \"current\"` to version\nfunction nodeTargetParser(value: true | string) {\n  const parsed =\n    value === true || value === \"current\"\n      ? process.versions.node\n      : semverifyTarget(\"node\", value);\n  return [\"node\", parsed] as const;\n}\n\nfunction defaultTargetParser(\n  target: Exclude<Target, \"node\">,\n  value: string,\n): readonly [Exclude<Target, \"node\">, string] {\n  const version = isUnreleasedVersion(value, target)\n    ? value.toLowerCase()\n    : semverifyTarget(target, value);\n  return [target, version] as const;\n}\n\nfunction generateTargets(inputTargets: InputTargets): Targets {\n  const input = { ...inputTargets };\n  delete input.esmodules;\n  delete input.browsers;\n  return input;\n}\n\nfunction resolveTargets(queries: Browsers, env?: string): Targets {\n  const resolved = browserslist(queries, {\n    mobileToDesktop: true,\n    env,\n  });\n  return getLowestVersions(resolved);\n}\n\nconst targetsCache = new LruCache({ max: 64 });\n\nfunction resolveTargetsCached(queries: Browsers, env?: string): Targets {\n  const cacheKey = typeof queries === \"string\" ? queries : queries.join() + env;\n  let cached = targetsCache.get(cacheKey) as Targets | undefined;\n  if (!cached) {\n    cached = resolveTargets(queries, env);\n    targetsCache.set(cacheKey, cached);\n  }\n  return { ...cached };\n}\n\ntype GetTargetsOption = {\n  // This is not the path of the config file, but the path where start searching it from\n  configPath?: string;\n  // The path of the config file\n  configFile?: string;\n  // The env to pass to browserslist\n  browserslistEnv?: string;\n  // true to disable config loading\n  ignoreBrowserslistConfig?: boolean;\n  // custom hook when browserslist config is found\n  onBrowserslistConfigFound?: (configFile: string) => void;\n};\n\nexport default function getTargets(\n  inputTargets: InputTargets = {},\n  options: GetTargetsOption = {},\n): Targets {\n  let { browsers, esmodules } = inputTargets;\n  const { configPath = \".\", onBrowserslistConfigFound } = options;\n\n  validateBrowsers(browsers);\n\n  const input = generateTargets(inputTargets);\n  let targets = validateTargetNames(input);\n\n  const shouldParseBrowsers = !!browsers;\n  const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;\n  const shouldSearchForConfig =\n    !options.ignoreBrowserslistConfig && !hasTargets;\n\n  if (!browsers && shouldSearchForConfig) {\n    // https://github.com/browserslist/browserslist/blob/8ae85caa905d130f4ca86f7a998a5b63abbbe582/node.js#L243\n    browsers = process.env.BROWSERSLIST;\n    if (!browsers) {\n      const configFile =\n        options.configFile ||\n        process.env.BROWSERSLIST_CONFIG ||\n        browserslist.findConfigFile(configPath);\n      if (configFile != null) {\n        onBrowserslistConfigFound?.(configFile);\n        browsers = browserslist.loadConfig({\n          config: configFile,\n          env: options.browserslistEnv,\n        });\n      }\n    }\n\n    if (browsers == null) {\n      if (process.env.BABEL_8_BREAKING) {\n        // In Babel 8, if no targets are passed, we use browserslist's defaults.\n        browsers = [\"defaults\"];\n      } else {\n        // If no targets are passed, we need to overwrite browserslist's defaults\n        // so that we enable all transforms (acting like the now deprecated\n        // preset-latest).\n        browsers = [];\n      }\n    }\n  }\n\n  // `esmodules` as a target indicates the specific set of browsers supporting ES Modules.\n  // These values OVERRIDE the `browsers` field.\n  if (esmodules && (esmodules !== \"intersect\" || !browsers?.length)) {\n    browsers = Object.keys(ESM_SUPPORT)\n      .map(\n        (browser: keyof typeof ESM_SUPPORT) =>\n          `${browser} >= ${ESM_SUPPORT[browser]}`,\n      )\n      .join(\", \");\n    esmodules = false;\n  }\n\n  // If current value of `browsers` is undefined (`ignoreBrowserslistConfig` should be `false`)\n  // or an empty array (without any user config, use default config),\n  // we don't need to call `resolveTargets` to execute the related methods of `browserslist` library.\n  if (browsers?.length) {\n    const queryBrowsers = resolveTargetsCached(\n      browsers,\n      options.browserslistEnv,\n    );\n\n    if (esmodules === \"intersect\") {\n      for (const browser of Object.keys(queryBrowsers) as Target[]) {\n        if (browser !== \"deno\" && browser !== \"ie\") {\n          const esmSupportVersion =\n            ESM_SUPPORT[browser === \"opera_mobile\" ? \"op_mob\" : browser];\n\n          if (esmSupportVersion) {\n            const version = queryBrowsers[browser];\n            queryBrowsers[browser] = getHighestUnreleased(\n              version,\n              semverify(esmSupportVersion),\n              browser,\n            );\n          } else {\n            delete queryBrowsers[browser];\n          }\n        } else {\n          delete queryBrowsers[browser];\n        }\n      }\n    }\n\n    targets = Object.assign(queryBrowsers, targets);\n  }\n\n  // Parse remaining targets\n  const result: Targets = {};\n  const decimalWarnings = [];\n  for (const target of Object.keys(targets).sort() as Target[]) {\n    const value = targets[target];\n\n    // Warn when specifying minor/patch as a decimal\n    if (typeof value === \"number\" && value % 1 !== 0) {\n      decimalWarnings.push({ target, value });\n    }\n\n    const [parsedTarget, parsedValue] =\n      target === \"node\"\n        ? nodeTargetParser(value)\n        : defaultTargetParser(target, value as string);\n\n    if (parsedValue) {\n      // Merge (lowest wins)\n      result[parsedTarget] = parsedValue;\n    }\n  }\n\n  outputDecimalWarning(decimalWarnings);\n\n  return result;\n}\n"],"names":["_browserslist","require","_helperValidatorOption","_nativeModules","_lruCache","_utils","_targets","_options","_pretty","_debug","_filterItems","ESM_SUPPORT","browserModulesData","v","OptionValidator","validateTargetNames","targets","validTargets","Object","keys","TargetNames","target","Error","formatMessage","findSuggestion","isBrowsersQueryValid","browsers","Array","isArray","every","b","validateBrowsers","invariant","undefined","String","getLowestVersions","reduce","all","browser","browserName","browserVersion","split","browserNameMap","splitVersion","toLowerCase","isSplitUnreleased","isUnreleasedVersion","semverify","version","isUnreleased","getLowestUnreleased","parsedBrowserVersion","semverMin","_","outputDecimalWarning","decimalTargets","length","console","warn","forEach","value","semverifyTarget","nodeTargetParser","parsed","process","versions","node","defaultTargetParser","generateTargets","inputTargets","input","assign","esmodules","resolveTargets","queries","env","resolved","browserslist","mobileToDesktop","targetsCache","LruCache","max","resolveTargetsCached","cacheKey","join","cached","get","set","getTargets","options","_browsers","_browsers2","configPath","onBrowserslistConfigFound","shouldParseBrowsers","hasTargets","shouldSearchForConfig","ignoreBrowserslistConfig","BROWSERSLIST","configFile","BROWSERSLIST_CONFIG","findConfigFile","loadConfig","config","browserslistEnv","map","queryBrowsers","esmSupportVersion","getHighestUnreleased","result","decimalWarnings","sort","push","parsedTarget","parsedValue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 649, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 654, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-identifier/src/identifier.ts"],"sourcesContent":["// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.cjs`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.cjs`.\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `name` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n"],"names":["nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","test","String","fromCharCode","isIdentifierChar","isIdentifierName","name","isFirst","cp","charCodeAt","trail"],"mappings":";;;;;;;AAaA,IAAIA,4BAA4B,GAAG,8qIAA8qI;AAEjtI,IAAIC,uBAAuB,GAAG,+kFAA+kF;AAE7mF,MAAMC,uBAAuB,GAAG,IAAIC,MAAM,CACxC,GAAG,GAAGH,4BAA4B,GAAG,GACvC,CAAC;AACD,MAAMI,kBAAkB,GAAG,IAAID,MAAM,CACnC,GAAG,GAAGH,4BAA4B,GAAGC,uBAAuB,GAAG,GACjE,CAAC;AAEDD,4BAA4B,GAAGC,uBAAuB,GAAG,IAAI;AAQ7D,MAAMI,0BAA0B,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,GAAG;IAAC,GAAG;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,IAAI;IAAC,EAAE;IAAC,EAAE;IAAC,IAAI;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,IAAI;IAAC,CAAC;IAAC,GAAG;IAAC,IAAI;IAAC,EAAE;IAAC,IAAI;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,IAAI;IAAC,CAAC;IAAC,IAAI;IAAC,EAAE;IAAC,CAAC;IAAC,IAAI;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,IAAI;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,IAAI;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,IAAI;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,IAAI;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,IAAI;IAAC,KAAK;IAAC,EAAE;IAAC,IAAI;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,IAAI;IAAC,EAAE;IAAC,IAAI;IAAC,EAAE;IAAC,GAAG;IAAC,IAAI;IAAC,GAAG;IAAC,IAAI;IAAC,IAAI;IAAC,CAAC;IAAC,IAAI;CAAC;AAEjkD,MAAMC,qBAAqB,GAAG;IAAC,GAAG;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,IAAI;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC,EAAE;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,EAAE;IAAC,GAAG;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,EAAE;IAAC,CAAC;IAAC,EAAE;IAAC,GAAG;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,EAAE;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,CAAC;IAAC,GAAG;IAAC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","ignoreList":[0]}},
    {"offset": {"line": 1639, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1644, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-identifier/src/keyword.ts"],"sourcesContent":["const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n"],"names":["reservedWords","keyword","strict","strictBind","keywords","Set","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","isKeyword"],"mappings":";;;;;;;;;AAAA,MAAMA,aAAa,GAAG;IACpBC,OAAO,EAAE;QACP,OAAO;QACP,MAAM;QACN,OAAO;QACP,UAAU;QACV,UAAU;QACV,SAAS;QACT,IAAI;QACJ,MAAM;QACN,SAAS;QACT,KAAK;QACL,UAAU;QACV,IAAI;QACJ,QAAQ;QACR,QAAQ;QACR,OAAO;QACP,KAAK;QACL,KAAK;QACL,OAAO;QACP,OAAO;QACP,MAAM;QACN,KAAK;QACL,MAAM;QACN,OAAO;QACP,OAAO;QACP,SAAS;QACT,QAAQ;QACR,QAAQ;QACR,MAAM;QACN,MAAM;QACN,OAAO;QACP,IAAI;QACJ,YAAY;QACZ,QAAQ;QACR,MAAM;QACN,QAAQ;KACT;IACDC,MAAM,EAAE;QACN,YAAY;QACZ,WAAW;QACX,KAAK;QACL,SAAS;QACT,SAAS;QACT,WAAW;QACX,QAAQ;QACR,QAAQ;QACR,OAAO;KACR;IACDC,UAAU,EAAE;QAAC,MAAM;QAAE,WAAW;KAAA;AAClC,CAAC;AACD,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAACL,aAAa,CAACC,OAAO,CAAC;AAC/C,MAAMK,sBAAsB,GAAG,IAAID,GAAG,CAACL,aAAa,CAACE,MAAM,CAAC;AAC5D,MAAMK,0BAA0B,GAAG,IAAIF,GAAG,CAACL,aAAa,CAACG,UAAU,CAAC;AAK7D,SAASK,cAAcA,CAACC,IAAY,EAAEC,QAAiB,EAAW;IACvE,OAAQA,QAAQ,IAAID,IAAI,KAAK,OAAO,IAAKA,IAAI,KAAK,MAAM;AAC1D;AAOO,SAASE,oBAAoBA,CAACF,IAAY,EAAEC,QAAiB,EAAW;IAC7E,OAAOF,cAAc,CAACC,IAAI,EAAEC,QAAQ,CAAC,IAAIJ,sBAAsB,CAACM,GAAG,CAACH,IAAI,CAAC;AAC3E;AAMO,SAASI,4BAA4BA,CAACJ,IAAY,EAAW;IAClE,OAAOF,0BAA0B,CAACK,GAAG,CAACH,IAAI,CAAC;AAC7C;AAOO,SAASK,wBAAwBA,CACtCL,IAAY,EACZC,QAAiB,EACR;IACT,OACEC,oBAAoB,CAACF,IAAI,EAAEC,QAAQ,CAAC,IAAIG,4BAA4B,CAACJ,IAAI,CAAC;AAE9E;AAEO,SAASM,SAASA,CAACN,IAAY,EAAW;IAC/C,OAAOL,QAAQ,CAACQ,GAAG,CAACH,IAAI,CAAC;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 1725, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1730, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-validator-identifier/src/index.ts"],"sourcesContent":["export {\n  isIdentifierName,\n  isIdentifierChar,\n  isIdentifierStart,\n} from \"./identifier.ts\";\nexport {\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"./keyword.ts\";\n"],"names":["_identifier","require","_keyword"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,WAAA,GAAAC,OAAA;AAKA,IAAAC,QAAA,GAAAD,OAAA","ignoreList":[0]}},
    {"offset": {"line": 1784, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1789, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-string-parser/src/index.ts"],"sourcesContent":["// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ]),\n  hex: new Set<number>([\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ]),\n};\n\nconst isAllowedNumericSeparatorSibling = {\n  // 0 - 1\n  bin: (ch: number) => ch === charCodes.digit0 || ch === charCodes.digit1,\n\n  // 0 - 7\n  oct: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit7,\n\n  // 0 - 9\n  dec: (ch: number) => ch >= charCodes.digit0 && ch <= charCodes.digit9,\n\n  // 0 - 9, A - F, a - f,\n  hex: (ch: number) =>\n    (ch >= charCodes.digit0 && ch <= charCodes.digit9) ||\n    (ch >= charCodes.uppercaseA && ch <= charCodes.uppercaseF) ||\n    (ch >= charCodes.lowercaseA && ch <= charCodes.lowercaseF),\n};\n\nexport type StringContentsErrorHandlers = EscapedCharErrorHandlers & {\n  unterminated(\n    initialPos: number,\n    initialLineStart: number,\n    initialCurLine: number,\n  ): void;\n};\n\nexport function readStringContents(\n  type: \"single\" | \"double\" | \"template\",\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  errors: StringContentsErrorHandlers,\n) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const { length } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === charCodes.backslash) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        type === \"template\",\n        errors,\n      );\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = { pos, lineStart, curLine };\n      } else {\n        out += res.ch;\n      }\n      ({ pos, lineStart, curLine } = res);\n      chunkStart = pos;\n    } else if (\n      ch === charCodes.lineSeparator ||\n      ch === charCodes.paragraphSeparator\n    ) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === charCodes.lineFeed || ch === charCodes.carriageReturn) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (\n          ch === charCodes.carriageReturn &&\n          input.charCodeAt(pos) === charCodes.lineFeed\n        ) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return process.env.BABEL_8_BREAKING\n    ? { pos, str: out, firstInvalidLoc, lineStart, curLine }\n    : {\n        pos,\n        str: out,\n        firstInvalidLoc,\n        lineStart,\n        curLine,\n        containsInvalid: !!firstInvalidLoc,\n      };\n}\n\nfunction isStringEnd(\n  type: \"single\" | \"double\" | \"template\",\n  ch: number,\n  input: string,\n  pos: number,\n) {\n  if (type === \"template\") {\n    return (\n      ch === charCodes.graveAccent ||\n      (ch === charCodes.dollarSign &&\n        input.charCodeAt(pos + 1) === charCodes.leftCurlyBrace)\n    );\n  }\n  return (\n    ch === (type === \"double\" ? charCodes.quotationMark : charCodes.apostrophe)\n  );\n}\n\ntype EscapedCharErrorHandlers = HexCharErrorHandlers &\n  CodePointErrorHandlers & {\n    strictNumericEscape(pos: number, lineStart: number, curLine: number): void;\n  };\n\nfunction readEscapedChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  inTemplate: boolean,\n  errors: EscapedCharErrorHandlers,\n) {\n  const throwOnInvalid = !inTemplate;\n  pos++; // skip '\\'\n\n  const res = (ch: string | null) => ({ pos, ch, lineStart, curLine });\n\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case charCodes.lowercaseN:\n      return res(\"\\n\");\n    case charCodes.lowercaseR:\n      return res(\"\\r\");\n    case charCodes.lowercaseX: {\n      let code;\n      ({ code, pos } = readHexChar(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        2,\n        false,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCharCode(code));\n    }\n    case charCodes.lowercaseU: {\n      let code;\n      ({ code, pos } = readCodePoint(\n        input,\n        pos,\n        lineStart,\n        curLine,\n        throwOnInvalid,\n        errors,\n      ));\n      return res(code === null ? null : String.fromCodePoint(code));\n    }\n    case charCodes.lowercaseT:\n      return res(\"\\t\");\n    case charCodes.lowercaseB:\n      return res(\"\\b\");\n    case charCodes.lowercaseV:\n      return res(\"\\u000b\");\n    case charCodes.lowercaseF:\n      return res(\"\\f\");\n    case charCodes.carriageReturn:\n      if (input.charCodeAt(pos) === charCodes.lineFeed) {\n        ++pos;\n      }\n    // fall through\n    case charCodes.lineFeed:\n      lineStart = pos;\n      ++curLine;\n    // fall through\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return res(\"\");\n    case charCodes.digit8:\n    case charCodes.digit9:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    // fall through\n    default:\n      if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n\n        let octalStr = match[0];\n\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (\n          octalStr !== \"0\" ||\n          next === charCodes.digit8 ||\n          next === charCodes.digit9\n        ) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\ntype HexCharErrorHandlers = IntErrorHandlers & {\n  invalidEscapeSequence(pos: number, lineStart: number, curLine: number): void;\n};\n\n// Used to read character escape sequences ('\\x', '\\u').\nfunction readHexChar(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  len: number,\n  forceLen: boolean,\n  throwOnInvalid: boolean,\n  errors: HexCharErrorHandlers,\n) {\n  const initialPos = pos;\n  let n;\n  ({ n, pos } = readInt(\n    input,\n    pos,\n    lineStart,\n    curLine,\n    16,\n    len,\n    forceLen,\n    false,\n    errors,\n    /* bailOnError */ !throwOnInvalid,\n  ));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return { code: n, pos };\n}\n\nexport type IntErrorHandlers = {\n  numericSeparatorInEscapeSequence(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  unexpectedNumericSeparator(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n  ): void;\n  // It can return \"true\" to indicate that the error was handled\n  // and the int parsing should continue.\n  invalidDigit(\n    pos: number,\n    lineStart: number,\n    curLine: number,\n    radix: number,\n  ): boolean;\n};\n\nexport function readInt(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  radix: number,\n  len: number | undefined,\n  forceLen: boolean,\n  allowNumSeparator: boolean | \"bail\",\n  errors: IntErrorHandlers,\n  bailOnError: boolean,\n) {\n  const start = pos;\n  const forbiddenSiblings =\n    radix === 16\n      ? forbiddenNumericSeparatorSiblings.hex\n      : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling =\n    radix === 16\n      ? isAllowedNumericSeparatorSibling.hex\n      : radix === 10\n        ? isAllowedNumericSeparatorSibling.dec\n        : radix === 8\n          ? isAllowedNumericSeparatorSibling.oct\n          : isAllowedNumericSeparatorSibling.bin;\n\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === charCodes.underscore && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        if (bailOnError) return { n: null, pos };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (\n        Number.isNaN(next) ||\n        !isAllowedSibling(next) ||\n        forbiddenSiblings.has(prev) ||\n        forbiddenSiblings.has(next)\n      ) {\n        if (bailOnError) return { n: null, pos };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      // Ignore this _ character\n      ++pos;\n      continue;\n    }\n\n    if (code >= charCodes.lowercaseA) {\n      val = code - charCodes.lowercaseA + charCodes.lineFeed;\n    } else if (code >= charCodes.uppercaseA) {\n      val = code - charCodes.uppercaseA + charCodes.lineFeed;\n    } else if (charCodes.isDigit(code)) {\n      val = code - charCodes.digit0; // 0-9\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      // If we found a digit which is too big, errors.invalidDigit can return true to avoid\n      // breaking the loop (this is used for error recovery).\n      if (val <= 9 && bailOnError) {\n        return { n: null, pos };\n      } else if (\n        val <= 9 &&\n        errors.invalidDigit(pos, lineStart, curLine, radix)\n      ) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || (len != null && pos - start !== len) || invalid) {\n    return { n: null, pos };\n  }\n\n  return { n: total, pos };\n}\n\nexport type CodePointErrorHandlers = HexCharErrorHandlers & {\n  invalidCodePoint(pos: number, lineStart: number, curLine: number): void;\n};\n\nexport function readCodePoint(\n  input: string,\n  pos: number,\n  lineStart: number,\n  curLine: number,\n  throwOnInvalid: boolean,\n  errors: CodePointErrorHandlers,\n) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === charCodes.leftCurlyBrace) {\n    ++pos;\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      input.indexOf(\"}\", pos) - pos,\n      true,\n      throwOnInvalid,\n      errors,\n    ));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return { code: null, pos };\n      }\n    }\n  } else {\n    ({ code, pos } = readHexChar(\n      input,\n      pos,\n      lineStart,\n      curLine,\n      4,\n      false,\n      throwOnInvalid,\n      errors,\n    ));\n  }\n  return { code, pos };\n}\n"],"names":["isDigit","code","forbiddenNumericSeparatorSiblings","decBinOct","Set","hex","isAllowedNumericSeparatorSibling","bin","ch","oct","dec","readStringContents","type","input","pos","lineStart","curLine","errors","initialPos","initialLineStart","initialCurLine","out","firstInvalidLoc","chunkStart","length","unterminated","slice","charCodeAt","isStringEnd","res","readEscapedChar","str","containsInvalid","inTemplate","throwOnInvalid","readHexChar","String","fromCharCode","readCodePoint","fromCodePoint","strictNumericEscape","startPos","match","exec","octalStr","octal","parseInt","next","len","forceLen","n","readInt","invalidEscapeSequence","radix","allowNumSeparator","bailOnError","start","forbiddenSiblings","isAllowedSibling","invalid","total","i","e","Infinity","val","prev","numericSeparatorInEscapeSequence","Number","isNaN","has","unexpectedNumericSeparator","_isDigit","invalidDigit","indexOf","invalidCodePoint"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2074, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2084, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/traverse/node_modules/globals/index.js"],"sourcesContent":["'use strict';\nmodule.exports = require('./globals.json');\n"],"names":[],"mappings":"AAAA;AACA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2096, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-classes/node_modules/globals/index.js"],"sourcesContent":["'use strict';\nmodule.exports = require('./globals.json');\n"],"names":[],"mappings":"AAAA;AACA,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 2098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2103, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/code-frame/src/defs.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/code-frame/src/highlight.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/code-frame/src/index.ts"],"sourcesContent":["import picocolors, { createColors } from \"picocolors\";\nimport type { Colors, Formatter } from \"picocolors/types\";\n\nexport function isColorSupported() {\n  return (\n    // See https://github.com/alexeyraspopov/picocolors/issues/62\n    typeof process === \"object\" &&\n      (process.env.FORCE_COLOR === \"0\" || process.env.FORCE_COLOR === \"false\")\n      ? false\n      : picocolors.isColorSupported\n  );\n}\n\nexport type InternalTokenType =\n  | \"keyword\"\n  | \"capitalized\"\n  | \"jsxIdentifier\"\n  | \"punctuator\"\n  | \"number\"\n  | \"string\"\n  | \"regex\"\n  | \"comment\"\n  | \"invalid\";\n\ntype UITokens = \"gutter\" | \"marker\" | \"message\";\n\nexport type Defs = {\n  [_ in InternalTokenType | UITokens | \"reset\"]: Formatter;\n};\n\nconst compose: <T, U, V>(f: (gv: U) => V, g: (v: T) => U) => (v: T) => V =\n  (f, g) => v =>\n    f(g(v));\n\n/**\n * Styles for token types.\n */\nfunction buildDefs(colors: Colors): Defs {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n\n    reset: colors.reset,\n  };\n}\n\nconst defsOn = buildDefs(createColors(true));\nconst defsOff = buildDefs(createColors(false));\n\nexport function getDefs(enabled: boolean): Defs {\n  return enabled ? defsOn : defsOff;\n}\n","import type { Token as JSToken, JSXToken } from \"js-tokens\";\nimport jsTokens from \"js-tokens\";\n\nimport {\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nimport { getDefs, type InternalTokenType } from \"./defs.ts\";\n\n/**\n * Names that are always allowed as identifiers, but also appear as keywords\n * within certain syntactic productions.\n *\n * https://tc39.es/ecma262/#sec-keywords-and-reserved-words\n *\n * `target` has been omitted since it is very likely going to be a false\n * positive.\n */\nconst sometimesKeywords = new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n\ntype Token = {\n  type: InternalTokenType | \"uncolored\";\n  value: string;\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * RegExp to test for the three types of brackets.\n */\nconst BRACKET = /^[()[\\]{}]$/;\n\nlet tokenize: (\n  text: string,\n) => Generator<{ type: InternalTokenType | \"uncolored\"; value: string }>;\n\nif (process.env.BABEL_8_BREAKING) {\n  /**\n   * Get the type of token, specifying punctuator type.\n   */\n  const getTokenType = function (\n    token: JSToken | JSXToken,\n  ): InternalTokenType | \"uncolored\" {\n    if (token.type === \"IdentifierName\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"Punctuator\" && BRACKET.test(token.value)) {\n      return \"uncolored\";\n    }\n\n    if (token.type === \"Invalid\" && token.value === \"@\") {\n      return \"punctuator\";\n    }\n\n    switch (token.type) {\n      case \"NumericLiteral\":\n        return \"number\";\n\n      case \"StringLiteral\":\n      case \"JSXString\":\n      case \"NoSubstitutionTemplate\":\n        return \"string\";\n\n      case \"RegularExpressionLiteral\":\n        return \"regex\";\n\n      case \"Punctuator\":\n      case \"JSXPunctuator\":\n        return \"punctuator\";\n\n      case \"MultiLineComment\":\n      case \"SingleLineComment\":\n        return \"comment\";\n\n      case \"Invalid\":\n      case \"JSXInvalid\":\n        return \"invalid\";\n\n      case \"JSXIdentifier\":\n        return \"jsxIdentifier\";\n\n      default:\n        return \"uncolored\";\n    }\n  };\n\n  /**\n   * Turn a string of JS into an array of objects.\n   */\n  tokenize = function* (text: string): Generator<Token> {\n    for (const token of jsTokens(text, { jsx: true })) {\n      switch (token.type) {\n        case \"TemplateHead\":\n          yield { type: \"string\", value: token.value.slice(0, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateMiddle\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1, -2) };\n          yield { type: \"punctuator\", value: \"${\" };\n          break;\n\n        case \"TemplateTail\":\n          yield { type: \"punctuator\", value: \"}\" };\n          yield { type: \"string\", value: token.value.slice(1) };\n          break;\n\n        default:\n          yield {\n            type: getTokenType(token),\n            value: token.value,\n          };\n      }\n    }\n  };\n} else {\n  /**\n   * RegExp to test for what seems to be a JSX tag name.\n   */\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n\n  // The token here is defined in js-tokens@4. However we don't bother\n  // typing it since the whole block will be removed in Babel 8\n  const getTokenType = function (token: any, offset: number, text: string) {\n    if (token.type === \"name\") {\n      if (\n        isKeyword(token.value) ||\n        isStrictReservedWord(token.value, true) ||\n        sometimesKeywords.has(token.value)\n      ) {\n        return \"keyword\";\n      }\n\n      if (\n        JSX_TAG.test(token.value) &&\n        (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) === \"</\")\n      ) {\n        return \"jsxIdentifier\";\n      }\n\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return \"capitalized\";\n      }\n    }\n\n    if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n      return \"bracket\";\n    }\n\n    if (\n      token.type === \"invalid\" &&\n      (token.value === \"@\" || token.value === \"#\")\n    ) {\n      return \"punctuator\";\n    }\n\n    return token.type;\n  };\n\n  tokenize = function* (text: string) {\n    let match;\n    while ((match = (jsTokens as any).default.exec(text))) {\n      const token = (jsTokens as any).matchToToken(match);\n\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value,\n      };\n    }\n  };\n}\n\nexport function highlight(text: string) {\n  if (text === \"\") return \"\";\n\n  const defs = getDefs(true);\n\n  let highlighted = \"\";\n\n  for (const { type, value } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value\n        .split(NEWLINE)\n        .map(str => defs[type as InternalTokenType](str))\n        .join(\"\\n\");\n    } else {\n      highlighted += value;\n    }\n  }\n\n  return highlighted;\n}\n","import { getDefs, isColorSupported } from \"./defs.ts\";\nimport { highlight } from \"./highlight.ts\";\n\nexport { highlight };\n\nlet deprecationWarningShown = false;\n\ntype Location = {\n  column: number;\n  line: number;\n};\n\ntype NodeLocation = {\n  end?: Location;\n  start: Location;\n};\n\nexport interface Options {\n  /** Syntax highlight the code as JavaScript for terminals. default: false */\n  highlightCode?: boolean;\n  /**  The number of lines to show above the error. default: 2 */\n  linesAbove?: number;\n  /**  The number of lines to show below the error. default: 3 */\n  linesBelow?: number;\n  /**\n   * Forcibly syntax highlight the code as JavaScript (for non-terminals);\n   * overrides highlightCode.\n   * default: false\n   */\n  forceColor?: boolean;\n  /**\n   * Pass in a string to be displayed inline (if possible) next to the\n   * highlighted location in the code. If it can't be positioned inline,\n   * it will be placed above the code frame.\n   * default: nothing\n   */\n  message?: string;\n}\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Extract what lines should be marked and highlighted.\n */\n\ntype MarkerLines = Record<number, true | [number, number]>;\n\nfunction getMarkerLines(\n  loc: NodeLocation,\n  source: Array<string>,\n  opts: Options,\n): {\n  start: number;\n  end: number;\n  markerLines: MarkerLines;\n} {\n  const startLoc: Location = {\n    column: 0,\n    line: -1,\n    ...loc.start,\n  };\n  const endLoc: Location = {\n    ...startLoc,\n    ...loc.end,\n  };\n  const { linesAbove = 2, linesBelow = 3 } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n\n  if (startLine === -1) {\n    start = 0;\n  }\n\n  if (endLine === -1) {\n    end = source.length;\n  }\n\n  const lineDiff = endLine - startLine;\n  const markerLines: MarkerLines = {};\n\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n\n  return { start, end, markerLines };\n}\n\nexport function codeFrameColumns(\n  rawLines: string,\n  loc: NodeLocation,\n  opts: Options = {},\n): string {\n  const shouldHighlight =\n    opts.forceColor || (isColorSupported() && opts.highlightCode);\n  const defs = getDefs(shouldHighlight);\n\n  const lines = rawLines.split(NEWLINE);\n  const { start, end, markerLines } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === \"number\";\n\n  const numberMaxWidth = String(end).length;\n\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n\n  let frame = highlightedLines\n    .split(NEWLINE, end)\n    .slice(start, end)\n    .map((line, index) => {\n      const number = start + 1 + index;\n      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n      const gutter = ` ${paddedNumber} |`;\n      const hasMarker = markerLines[number];\n      const lastMarkerLine = !markerLines[number + 1];\n      if (hasMarker) {\n        let markerLine = \"\";\n        if (Array.isArray(hasMarker)) {\n          const markerSpacing = line\n            .slice(0, Math.max(hasMarker[0] - 1, 0))\n            .replace(/[^\\t]/g, \" \");\n          const numberOfMarkers = hasMarker[1] || 1;\n\n          markerLine = [\n            \"\\n \",\n            defs.gutter(gutter.replace(/\\d/g, \" \")),\n            \" \",\n            markerSpacing,\n            defs.marker(\"^\").repeat(numberOfMarkers),\n          ].join(\"\");\n\n          if (lastMarkerLine && opts.message) {\n            markerLine += \" \" + defs.message(opts.message);\n          }\n        }\n        return [\n          defs.marker(\">\"),\n          defs.gutter(gutter),\n          line.length > 0 ? ` ${line}` : \"\",\n          markerLine,\n        ].join(\"\");\n      } else {\n        return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : \"\"}`;\n      }\n    })\n    .join(\"\\n\");\n\n  if (opts.message && !hasColumns) {\n    frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexport default function (\n  rawLines: string,\n  lineNumber: number,\n  colNumber?: number | null,\n  opts: Options = {},\n): string {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n\n    const message =\n      \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n\n    if (process.emitWarning) {\n      // A string is directly supplied to emitWarning, because when supplying an\n      // Error object node throws in the tests because of different contexts\n      process.emitWarning(message, \"DeprecationWarning\");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = \"DeprecationWarning\";\n      console.warn(new Error(message));\n    }\n  }\n\n  colNumber = Math.max(colNumber, 0);\n\n  const location: NodeLocation = {\n    start: { column: colNumber, line: lineNumber },\n  };\n\n  return codeFrameColumns(rawLines, location, opts);\n}\n"],"names":["isColorSupported","process","env","FORCE_COLOR","picocolors","compose","f","g","v","buildDefs","colors","keyword","cyan","capitalized","yellow","jsxIdentifier","punctuator","number","magenta","string","green","regex","comment","gray","invalid","white","bgRed","bold","gutter","marker","red","message","reset","defsOn","createColors","defsOff","getDefs","enabled","sometimesKeywords","Set","NEWLINE","BRACKET","tokenize","JSX_TAG","getTokenType","token","offset","text","type","isKeyword","value","isStrictReservedWord","has","test","slice","toLowerCase","match","jsTokens","default","exec","matchToToken","index","highlight","defs","highlighted","split","map","str","join","deprecationWarningShown","getMarkerLines","loc","source","opts","startLoc","Object","assign","column","line","start","endLoc","end","linesAbove","linesBelow","startLine","startColumn","endLine","endColumn","Math","max","min","length","lineDiff","markerLines","i","lineNumber","sourceLength","codeFrameColumns","rawLines","shouldHighlight","forceColor","highlightCode","lines","hasColumns","numberMaxWidth","String","highlightedLines","frame","paddedNumber","hasMarker","lastMarkerLine","markerLine","Array","isArray","markerSpacing","replace","numberOfMarkers","repeat","colNumber","emitWarning","deprecationError","Error","name","console","warn","location"],"mappings":"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","ignoreList":[0,1,2]}},
    {"offset": {"line": 2336, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2341, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/formatters.ts"],"sourcesContent":["import { assertExpressionStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport type Formatter<T> = {\n  code: (source: string) => string;\n  validate: (ast: t.File) => void;\n  unwrap: (ast: t.File) => T;\n};\n\nfunction makeStatementFormatter<T>(\n  fn: (statements: Array<t.Statement>) => T,\n): Formatter<T> {\n  return {\n    // We need to prepend a \";\" to force statement parsing so that\n    // ExpressionStatement strings won't be parsed as directives.\n    // Alongside that, we also prepend a comment so that when a syntax error\n    // is encountered, the user will be less likely to get confused about\n    // where the random semicolon came from.\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: (ast: t.File): T => {\n      return fn(ast.program.body.slice(1));\n    },\n  };\n}\n\nexport const smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\n\nexport const statements = makeStatementFormatter(body => body);\n\nexport const statement = makeStatementFormatter(body => {\n  // We do this validation when unwrapping since the replacement process\n  // could have added or removed statements.\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\n\nexport const expression: Formatter<t.Expression> = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({ program }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  },\n};\n\nexport const program: Formatter<t.Program> = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program,\n};\n"],"names":["_t","require","assertExpressionStatement","makeStatementFormatter","fn","code","str","validate","unwrap","ast","program","body","slice","smart","exports","length","statements","statement","Error","expression","start","stmt"],"mappings":";;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAAyD,MAAA,EAAhDC,yBAAAA,EAAyB,GAAAF,EAAA;AASlC,SAASG,sBAAsBA,CAC7BC,EAAyC,EAC3B;IACd,OAAO;QAMLC,IAAI,GAAEC,GAAG,GAAI,CAAA,wBAAA,EAA2BA,GAAG,EAAE;QAC7CC,QAAQ,EAAEA,CAAA,IAAO,CAAD,AAAE;QAClBC,MAAM,GAAGC,GAAW,IAAQ;YAC1B,OAAOL,EAAE,CAACK,GAAG,CAACC,OAAO,CAACC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;QACtC;IACF,CAAC;AACH;AAEO,MAAMC,KAAK,GAAAC,OAAA,CAAAD,KAAA,GAAGV,sBAAsB,EAACQ,IAAI,IAAI;IAClD,IAAIA,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;QACnB,OAAOJ,IAAI;IACb,CAAC,MAAM;QACL,OAAOA,IAAI,CAAC,CAAC,CAAC;IAChB;AACF,CAAC,CAAC;AAEK,MAAMK,UAAU,GAAAF,OAAA,CAAAE,UAAA,GAAGb,sBAAsB,EAACQ,IAAI,GAAIA,IAAI,CAAC;AAEvD,MAAMM,SAAS,GAAAH,OAAA,CAAAG,SAAA,GAAGd,sBAAsB,EAACQ,IAAI,IAAI;IAGtD,IAAIA,IAAI,CAACI,MAAM,KAAK,CAAC,EAAE;QACrB,MAAM,IAAIG,KAAK,CAAC,0BAA0B,CAAC;IAC7C;IACA,IAAIP,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;QACnB,MAAM,IAAIG,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IAEA,OAAOP,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC;AAEK,MAAMQ,UAAmC,GAAAL,OAAA,CAAAK,UAAA,GAAG;IACjDd,IAAI,GAAEC,GAAG,GAAI,CAAA,GAAA,EAAMA,GAAG,CAAA,GAAA,CAAK;IAC3BC,QAAQ,GAAEE,GAAG,IAAI;QACf,IAAIA,GAAG,CAACC,OAAO,CAACC,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;YAC/B,MAAM,IAAIG,KAAK,CAAC,0CAA0C,CAAC;QAC7D;QACA,IAAIC,UAAU,CAACX,MAAM,CAACC,GAAG,CAAC,CAACW,KAAK,KAAK,CAAC,EAAE;YACtC,MAAM,IAAIF,KAAK,CAAC,+BAA+B,CAAC;QAClD;IACF,CAAC;IACDV,MAAM,EAAEA,CAAC,EAAEE,OAAAA,EAAS,KAAK;QACvB,MAAM,CAACW,IAAI,CAAC,GAAGX,OAAO,CAACC,IAAI;QAC3BT,yBAAyB,CAACmB,IAAI,CAAC;QAC/B,OAAOA,IAAI,CAACF,UAAU;IACxB;AACF,CAAC;AAEM,MAAMT,OAA6B,GAAAI,OAAA,CAAAJ,OAAA,GAAG;IAC3CL,IAAI,GAAEC,GAAG,GAAIA,GAAG;IAChBC,QAAQ,EAAEA,CAAA,IAAO,CAAD,AAAE;IAClBC,MAAM,GAAEC,GAAG,GAAIA,GAAG,CAACC,OAAAA;AACrB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2395, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2400, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/options.ts"],"sourcesContent":["import type { ParserOptions as ParserOpts } from \"@babel/parser\";\n\nexport type { ParserOpts };\n\n/**\n * These are the options that 'babel-template' actually accepts and typechecks\n * when called. All other options are passed through to the parser.\n */\nexport type PublicOpts = {\n  /**\n   * A set of placeholder names to automatically accept, ignoring the given\n   * pattern entirely.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderWhitelist?: Set<string>;\n  /**\n   * A pattern to search for when looking for Identifier and StringLiteral\n   * nodes that can be replaced.\n   *\n   * 'false' will disable placeholder searching entirely, leaving only the\n   * 'placeholderWhitelist' value to find replacements.\n   *\n   * Defaults to /^[_$A-Z0-9]+$/.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderPattern?: RegExp | false;\n  /**\n   * 'true' to pass through comments from the template into the resulting AST,\n   * or 'false' to automatically discard comments. Defaults to 'false'.\n   */\n  preserveComments?: boolean;\n  /**\n   * 'true' to use %%foo%% style placeholders, 'false' to use legacy placeholders\n   * described by placeholderPattern or placeholderWhitelist.\n   * When it is not set, it behaves as 'true' if there are syntactic placeholders,\n   * otherwise as 'false'.\n   */\n  syntacticPlaceholders?: boolean | null;\n};\n\nexport type TemplateOpts = {\n  parser: ParserOpts;\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  preserveComments?: boolean;\n  syntacticPlaceholders?: boolean;\n};\n\nexport function merge(a: TemplateOpts, b: TemplateOpts): TemplateOpts {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders,\n  } = b;\n\n  return {\n    parser: {\n      ...a.parser,\n      ...b.parser,\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  };\n}\n\nexport function validate(opts: unknown): TemplateOpts {\n  if (opts != null && typeof opts !== \"object\") {\n    throw new Error(\"Unknown template options.\");\n  }\n\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n    ...parser\n  } = opts || ({} as any);\n\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error(\n      \"'.placeholderWhitelist' must be a Set, null, or undefined\",\n    );\n  }\n\n  if (\n    placeholderPattern != null &&\n    !(placeholderPattern instanceof RegExp) &&\n    placeholderPattern !== false\n  ) {\n    throw new Error(\n      \"'.placeholderPattern' must be a RegExp, false, null, or undefined\",\n    );\n  }\n\n  if (preserveComments != null && typeof preserveComments !== \"boolean\") {\n    throw new Error(\n      \"'.preserveComments' must be a boolean, null, or undefined\",\n    );\n  }\n\n  if (\n    syntacticPlaceholders != null &&\n    typeof syntacticPlaceholders !== \"boolean\"\n  ) {\n    throw new Error(\n      \"'.syntacticPlaceholders' must be a boolean, null, or undefined\",\n    );\n  }\n  if (\n    syntacticPlaceholders === true &&\n    (placeholderWhitelist != null || placeholderPattern != null)\n  ) {\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern:\n      placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders:\n      syntacticPlaceholders == null ? undefined : syntacticPlaceholders,\n  };\n}\n\nexport type PublicReplacements = { [x: string]: unknown } | Array<unknown>;\nexport type TemplateReplacements = { [x: string]: unknown } | void;\n\nexport function normalizeReplacements(\n  replacements: unknown,\n): TemplateReplacements {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc[\"$\" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === \"object\" || replacements == null) {\n    return (replacements as any) || undefined;\n  }\n\n  throw new Error(\n    \"Template replacements must be an array, object, null, or undefined\",\n  );\n}\n"],"names":["merge","a","b","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","parser","Object","assign","validate","opts","Error","_ref","_objectWithoutPropertiesLoose","_excluded","Set","RegExp","undefined","normalizeReplacements","replacements","Array","isArray","reduce","acc","replacement","i"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAkDO,SAASA,KAAKA,CAACC,CAAe,EAAEC,CAAe,EAAgB;IACpE,MAAM,EACJC,oBAAoB,GAAGF,CAAC,CAACE,oBAAoB,EAC7CC,kBAAkB,GAAGH,CAAC,CAACG,kBAAkB,EACzCC,gBAAgB,GAAGJ,CAAC,CAACI,gBAAgB,EACrCC,qBAAqB,GAAGL,CAAC,CAACK,qBAAAA,EAC3B,GAAGJ,CAAC;IAEL,OAAO;QACLK,MAAM,EAAAC,MAAA,CAAAC,MAAA,CAAA,CAAA,GACDR,CAAC,CAACM,MAAM,EACRL,CAAC,CAACK,MAAM,CACZ;QACDJ,oBAAoB;QACpBC,kBAAkB;QAClBC,gBAAgB;QAChBC;IACF,CAAC;AACH;AAEO,SAASI,QAAQA,CAACC,IAAa,EAAgB;IACpD,IAAIA,IAAI,IAAI,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;QAC5C,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IAEA,MAAAC,IAAA,GAMIF,IAAI,IAAK,CAAC,CAAS,EANjB,EACJR,oBAAoB,EACpBC,kBAAkB,EAClBC,gBAAgB,EAChBC,qBAAAA,EAED,GAAAO,IAAA,EADIN,MAAM,GAAAO,6BAAA,CAAAD,IAAA,EAAAE,SAAA;IAGX,IAAIZ,oBAAoB,IAAI,IAAI,IAAI,CAAA,CAAEA,oBAAoB,YAAYa,GAAG,CAAC,EAAE;QAC1E,MAAM,IAAIJ,KAAK,CACb,2DACF,CAAC;IACH;IAEA,IACER,kBAAkB,IAAI,IAAI,IAC1B,CAAA,CAAEA,kBAAkB,YAAYa,MAAM,CAAC,IACvCb,kBAAkB,KAAK,KAAK,EAC5B;QACA,MAAM,IAAIQ,KAAK,CACb,mEACF,CAAC;IACH;IAEA,IAAIP,gBAAgB,IAAI,IAAI,IAAI,OAAOA,gBAAgB,KAAK,SAAS,EAAE;QACrE,MAAM,IAAIO,KAAK,CACb,2DACF,CAAC;IACH;IAEA,IACEN,qBAAqB,IAAI,IAAI,IAC7B,OAAOA,qBAAqB,KAAK,SAAS,EAC1C;QACA,MAAM,IAAIM,KAAK,CACb,gEACF,CAAC;IACH;IACA,IACEN,qBAAqB,KAAK,IAAI,IAAA,CAC7BH,oBAAoB,IAAI,IAAI,IAAIC,kBAAkB,IAAI,IAAI,CAAC,EAC5D;QACA,MAAM,IAAIQ,KAAK,CACb,qEAAqE,GACnE,sCACJ,CAAC;IACH;IAEA,OAAO;QACLL,MAAM;QACNJ,oBAAoB,EAAEA,oBAAoB,IAAIe,SAAS;QACvDd,kBAAkB,EAChBA,kBAAkB,IAAI,IAAI,GAAGc,SAAS,GAAGd,kBAAkB;QAC7DC,gBAAgB,EAAEA,gBAAgB,IAAI,IAAI,GAAGa,SAAS,GAAGb,gBAAgB;QACzEC,qBAAqB,EACnBA,qBAAqB,IAAI,IAAI,GAAGY,SAAS,GAAGZ;IAChD,CAAC;AACH;AAKO,SAASa,qBAAqBA,CACnCC,YAAqB,EACC;IACtB,IAAIC,KAAK,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;QAC/B,OAAOA,YAAY,CAACG,MAAM,CAAC,CAACC,GAAG,EAAEC,WAAW,EAAEC,CAAC,KAAK;YAClDF,GAAG,CAAC,GAAG,GAAGE,CAAC,CAAC,GAAGD,WAAW;YAC1B,OAAOD,GAAG;QACZ,CAAC,EAAE,CAAC,CAAC,CAAC;IACR,CAAC,MAAM,IAAI,OAAOJ,YAAY,KAAK,QAAQ,IAAIA,YAAY,IAAI,IAAI,EAAE;QACnE,OAAQA,YAAY,IAAYF,SAAS;IAC3C;IAEA,MAAM,IAAIN,KAAK,CACb,oEACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 2471, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/parse.ts"],"sourcesContent":["import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const state: MetadataState = {\n    syntactic: { placeholders: [], placeholderNames: new Set() },\n    legacy: { placeholders: [], placeholderNames: new Set() },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  };\n\n  traverse(ast, placeholderVisitorHandler, state);\n\n  return {\n    ast,\n    ...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n\n  if (\n    hasSyntacticPlaceholders &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    !hasSyntacticPlaceholders &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = !hasSyntacticPlaceholders\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n"],"names":["_t","require","_parser","_codeFrame","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","parseAndBuildMetadata","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","state","syntactic","placeholders","placeholderNames","Set","legacy","placeholderVisitorHandler","Object","assign","length","node","ancestors","_state$placeholderWhi","name","hasSyntacticPlaceholders","Error","value","test","has","slice","parent","key","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","undefined","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","start"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2609, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/populate.ts"],"sourcesContent":["import {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { TemplateReplacements } from \"./options.ts\";\nimport type { Metadata, Placeholder } from \"./parse.ts\";\n\nexport default function populatePlaceholders(\n  metadata: Metadata,\n  replacements: TemplateReplacements,\n): t.File {\n  const ast = cloneNode(metadata.ast);\n\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!Object.hasOwn(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n\n        throw new Error(\n          `Error: No substitution given for \"${placeholderName}\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`,\n        );\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution \"${key}\" given`);\n      }\n    });\n  }\n\n  // Process in reverse order so AST mutation doesn't change indices that\n  // will be needed for later calls to `placeholder.resolve()`.\n  metadata.placeholders\n    .slice()\n    .reverse()\n    .forEach(placeholder => {\n      try {\n        applyReplacement(\n          placeholder,\n          ast,\n          (replacements && replacements[placeholder.name]) || null,\n        );\n      } catch (e) {\n        e.message = `@babel/template placeholder \"${placeholder.name}\": ${e.message}`;\n        throw e;\n      }\n    });\n\n  return ast;\n}\n\nfunction applyReplacement(\n  placeholder: Placeholder,\n  ast: t.File,\n  replacement: any,\n) {\n  // Track inserted nodes and clone them if they are inserted more than\n  // once to avoid injecting the same node multiple times.\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === \"object\") {\n      replacement = cloneNode(replacement);\n    }\n  }\n\n  const { parent, key, index } = placeholder.resolve(ast);\n\n  if (placeholder.type === \"string\") {\n    if (typeof replacement === \"string\") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error(\"Expected string substitution\");\n    }\n  } else if (placeholder.type === \"statement\") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === \"string\") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === \"string\") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === \"param\") {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n\n    if (index === undefined) throw new Error(\"Assertion failure.\");\n  } else {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error(\"Cannot replace single expression with an array.\");\n    }\n  }\n\n  function set(parent: any, key: any, value: any) {\n    const node = parent[key] as t.Node;\n    parent[key] = value;\n    if (node.type === \"Identifier\" || node.type === \"Placeholder\") {\n      if (node.typeAnnotation) {\n        value.typeAnnotation = node.typeAnnotation;\n      }\n      if (node.optional) {\n        value.optional = node.optional;\n      }\n      if (node.decorators) {\n        value.decorators = node.decorators;\n      }\n    }\n  }\n\n  if (index === undefined) {\n    validate(parent, key, replacement);\n\n    set(parent, key, replacement);\n  } else {\n    const items: Array<t.Node> = (parent as any)[key].slice();\n\n    if (placeholder.type === \"statement\" || placeholder.type === \"param\") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        set(items, index, replacement);\n      }\n    } else {\n      set(items, index, replacement);\n    }\n\n    validate(parent, key, items);\n    (parent as any)[key] = items;\n  }\n}\n"],"names":["_t","require","blockStatement","cloneNode","emptyStatement","expressionStatement","identifier","isStatement","isStringLiteral","stringLiteral","validate","populatePlaceholders","metadata","replacements","ast","placeholders","forEach","placeholder","hasOwnProperty","call","name","placeholderName","Error","Object","keys","key","placeholderNames","has","slice","reverse","applyReplacement","e","message","replacement","isDuplicate","Array","isArray","map","node","parent","index","resolve","type","undefined","set","value","typeAnnotation","optional","decorators","items","splice"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2729, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2734, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/string.ts"],"sourcesContent":["import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateOpts } from \"./options.ts\";\nimport type { Metadata } from \"./parse.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function stringTemplate<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): (arg?: unknown) => T {\n  code = formatter.code(code);\n\n  let metadata: Metadata;\n\n  return (arg?: unknown) => {\n    const replacements = normalizeReplacements(arg);\n\n    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);\n\n    return formatter.unwrap(populatePlaceholders(metadata, replacements));\n  };\n}\n"],"names":["_options","require","_parse","_populate","stringTemplate","formatter","code","opts","metadata","arg","replacements","normalizeReplacements","parseAndBuildMetadata","unwrap","populatePlaceholders"],"mappings":";;;;;AAGA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AACA,IAAAE,SAAA,GAAAF,OAAA;AAEe,SAASG,cAAcA,CACpCC,SAAuB,EACvBC,IAAY,EACZC,IAAkB,EACI;IACtBD,IAAI,GAAGD,SAAS,CAACC,IAAI,CAACA,IAAI,CAAC;IAE3B,IAAIE,QAAkB;IAEtB,QAAQC,GAAa,IAAK;QACxB,MAAMC,YAAY,GAAG,CAAA,GAAAC,SAAAA,qBAAqB,EAACF,GAAG,CAAC;QAE/C,IAAI,CAACD,QAAQ,EAAEA,QAAQ,GAAG,CAAA,GAAAI,OAAAA,OAAqB,EAACP,SAAS,EAAEC,IAAI,EAAEC,IAAI,CAAC;QAEtE,OAAOF,SAAS,CAACQ,MAAM,CAAC,CAAA,GAAAC,UAAAA,OAAoB,EAACN,QAAQ,EAAEE,YAAY,CAAC,CAAC;IACvE,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 2751, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2756, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/literal.ts"],"sourcesContent":["import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateReplacements, TemplateOpts } from \"./options.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function literalTemplate<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n): (_: Array<unknown>) => (_: unknown) => T {\n  const { metadata, names } = buildLiteralData(formatter, tpl, opts);\n\n  return arg => {\n    const defaultReplacements: TemplateReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n\n    return (arg: unknown) => {\n      const replacements = normalizeReplacements(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.hasOwn(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap(\n        populatePlaceholders(\n          metadata,\n          replacements\n            ? Object.assign(replacements, defaultReplacements)\n            : defaultReplacements,\n        ),\n      );\n    };\n  };\n}\n\nfunction buildLiteralData<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n) {\n  let prefix = \"BABEL_TPL$\";\n\n  const raw = tpl.join(\"\");\n\n  do {\n    // If there are cases where the template already contains $$BABEL_TPL$0 or any other\n    // matching pattern, we keep adding \"$$\" characters until a unique prefix\n    // is found.\n    prefix = \"$$\" + prefix;\n  } while (raw.includes(prefix));\n\n  const { names, code } = buildTemplateCode(tpl, prefix);\n\n  const metadata = parseAndBuildMetadata(formatter, formatter.code(code), {\n    parser: opts.parser,\n\n    // Explicitly include our generated names in the whitelist so users never\n    // have to think about whether their placeholder pattern will match.\n    placeholderWhitelist: new Set(\n      names.concat(\n        opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [],\n      ),\n    ),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders,\n  });\n\n  return { metadata, names };\n}\n\nfunction buildTemplateCode(\n  tpl: Array<string>,\n  prefix: string,\n): { names: Array<string>; code: string } {\n  const names = [];\n\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n\n    code += value + tpl[i];\n  }\n\n  return { names, code };\n}\n"],"names":["_options","require","_parse","_populate","literalTemplate","formatter","tpl","opts","metadata","names","buildLiteralData","arg","defaultReplacements","forEach","replacement","i","replacements","normalizeReplacements","Object","keys","key","hasOwnProperty","call","Error","unwrap","populatePlaceholders","assign","prefix","raw","join","includes","code","buildTemplateCode","parseAndBuildMetadata","parser","placeholderWhitelist","Set","concat","Array","from","placeholderPattern","preserveComments","syntacticPlaceholders","length","value","push"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2816, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2821, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/builder.ts"],"sourcesContent":["import { merge, validate } from \"./options.ts\";\nimport type {\n  TemplateOpts,\n  PublicOpts,\n  PublicReplacements,\n} from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nimport stringTemplate from \"./string.ts\";\nimport literalTemplate from \"./literal.ts\";\n\nexport type TemplateBuilder<T> = {\n  // Build a new builder, merging the given options with the previous ones.\n  (opts: PublicOpts): TemplateBuilder<T>;\n\n  // Building from a string produces an AST builder function by default.\n  (tpl: string, opts?: PublicOpts): (replacements?: PublicReplacements) => T;\n\n  // Building from a template literal produces an AST builder function by default.\n  (\n    tpl: TemplateStringsArray,\n    ...args: Array<unknown>\n  ): (replacements?: PublicReplacements) => T;\n\n  // Allow users to explicitly create templates that produce ASTs, skipping\n  // the need for an intermediate function.\n  ast: {\n    (tpl: string, opts?: PublicOpts): T;\n    (tpl: TemplateStringsArray, ...args: Array<unknown>): T;\n  };\n};\n\n// Prebuild the options that will be used when parsing a `.ast` template.\n// These do not use a pattern because there is no way for users to pass in\n// replacement patterns to begin with, and disabling pattern matching means\n// users have more flexibility in what type of content they have in their\n// template JS.\nconst NO_PLACEHOLDER: TemplateOpts = validate({\n  placeholderPattern: false,\n});\n\nexport default function createTemplateBuilder<T>(\n  formatter: Formatter<T>,\n  defaultOpts?: TemplateOpts,\n): TemplateBuilder<T> {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || validate(null);\n\n  return Object.assign(\n    ((tpl, ...args) => {\n      if (typeof tpl === \"string\") {\n        if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n        return extendedTrace(\n          stringTemplate(formatter, tpl, merge(cachedOpts, validate(args[0]))),\n        );\n      } else if (Array.isArray(tpl)) {\n        let builder = templateFnCache.get(tpl);\n        if (!builder) {\n          builder = literalTemplate(formatter, tpl, cachedOpts);\n          templateFnCache.set(tpl, builder);\n        }\n        return extendedTrace(builder(args));\n      } else if (typeof tpl === \"object\" && tpl) {\n        if (args.length > 0) throw new Error(\"Unexpected extra params.\");\n        return createTemplateBuilder(\n          formatter,\n          merge(cachedOpts, validate(tpl)),\n        );\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }) as TemplateBuilder<T>,\n    {\n      ast: (tpl: string | Array<string>, ...args: Array<unknown>) => {\n        if (typeof tpl === \"string\") {\n          if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n          return stringTemplate(\n            formatter,\n            tpl,\n            merge(merge(cachedOpts, validate(args[0])), NO_PLACEHOLDER),\n          )();\n        } else if (Array.isArray(tpl)) {\n          let builder = templateAstCache.get(tpl);\n          if (!builder) {\n            builder = literalTemplate(\n              formatter,\n              tpl,\n              merge(cachedOpts, NO_PLACEHOLDER),\n            );\n            templateAstCache.set(tpl, builder);\n          }\n          return builder(args)();\n        }\n\n        throw new Error(`Unexpected template param ${typeof tpl}`);\n      },\n    },\n  );\n}\n\nfunction extendedTrace<Arg, Result>(\n  fn: (_: Arg) => Result,\n): (_: Arg) => Result {\n  // Since we lazy parse the template, we get the current stack so we have the\n  // original stack to append if it errors when parsing\n  let rootStack = \"\";\n  try {\n    // error stack gets populated in IE only on throw\n    // (https://msdn.microsoft.com/en-us/library/hh699850(v=vs.94).aspx)\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      // error.stack does not exists in IE <= 9\n      // We slice off the top 3 items in the stack to remove the call to\n      // 'extendedTrace', and the anonymous builder function, with the final\n      // stripped line being the error message itself since we threw it\n      // in the first place and it doesn't matter.\n      rootStack = error.stack.split(\"\\n\").slice(3).join(\"\\n\");\n    }\n  }\n\n  return (arg: Arg) => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n"],"names":["_options","require","_string","_literal","NO_PLACEHOLDER","validate","placeholderPattern","createTemplateBuilder","formatter","defaultOpts","templateFnCache","WeakMap","templateAstCache","cachedOpts","Object","assign","tpl","args","length","Error","extendedTrace","stringTemplate","merge","Array","isArray","builder","get","literalTemplate","set","ast","fn","rootStack","error","stack","split","slice","join","arg","err"],"mappings":";;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AAQA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,QAAA,GAAAF,OAAA;AA4BA,MAAMG,cAA4B,GAAG,CAAA,GAAAC,SAAAA,QAAQ,EAAC;IAC5CC,kBAAkB,EAAE;AACtB,CAAC,CAAC;AAEa,SAASC,qBAAqBA,CAC3CC,SAAuB,EACvBC,WAA0B,EACN;IACpB,MAAMC,eAAe,GAAG,IAAIC,OAAO,CAAC,CAAC;IACrC,MAAMC,gBAAgB,GAAG,IAAID,OAAO,CAAC,CAAC;IACtC,MAAME,UAAU,GAAGJ,WAAW,IAAI,CAAA,GAAAJ,SAAAA,QAAQ,EAAC,IAAI,CAAC;IAEhD,OAAOS,MAAM,CAACC,MAAM,CACjB,CAACC,GAAG,EAAE,GAAGC,IAAI,KAAK;QACjB,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;YAC3B,IAAIC,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;YAChE,OAAOC,aAAa,CAClB,CAAA,GAAAC,QAAAA,OAAc,EAACb,SAAS,EAAEQ,GAAG,EAAE,CAAA,GAAAM,SAAAA,KAAK,EAACT,UAAU,EAAE,CAAA,GAAAR,SAAAA,QAAQ,EAACY,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CACrE,CAAC;QACH,CAAC,MAAM,IAAIM,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,EAAE;YAC7B,IAAIS,OAAO,GAAGf,eAAe,CAACgB,GAAG,CAACV,GAAG,CAAC;YACtC,IAAI,CAACS,OAAO,EAAE;gBACZA,OAAO,GAAG,CAAA,GAAAE,SAAAA,OAAe,EAACnB,SAAS,EAAEQ,GAAG,EAAEH,UAAU,CAAC;gBACrDH,eAAe,CAACkB,GAAG,CAACZ,GAAG,EAAES,OAAO,CAAC;YACnC;YACA,OAAOL,aAAa,CAACK,OAAO,CAACR,IAAI,CAAC,CAAC;QACrC,CAAC,MAAM,IAAI,OAAOD,GAAG,KAAK,QAAQ,IAAIA,GAAG,EAAE;YACzC,IAAIC,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;YAChE,OAAOZ,qBAAqB,CAC1BC,SAAS,EACT,CAAA,GAAAc,SAAAA,KAAK,EAACT,UAAU,EAAE,CAAA,GAAAR,SAAAA,QAAQ,EAACW,GAAG,CAAC,CACjC,CAAC;QACH;QACA,MAAM,IAAIG,KAAK,CAAC,CAAA,0BAAA,EAA6B,OAAOH,GAAG,EAAE,CAAC;IAC5D,CAAC,EACD;QACEa,GAAG,EAAEA,CAACb,GAA2B,EAAE,GAAGC,IAAoB,KAAK;YAC7D,IAAI,OAAOD,GAAG,KAAK,QAAQ,EAAE;gBAC3B,IAAIC,IAAI,CAACC,MAAM,GAAG,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,0BAA0B,CAAC;gBAChE,OAAO,CAAA,GAAAE,QAAAA,OAAc,EACnBb,SAAS,EACTQ,GAAG,EACH,CAAA,GAAAM,SAAAA,KAAK,EAAC,CAAA,GAAAA,SAAAA,KAAK,EAACT,UAAU,EAAE,CAAA,GAAAR,SAAAA,QAAQ,EAACY,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEb,cAAc,CAC5D,CAAC,CAAC,CAAC;YACL,CAAC,MAAM,IAAImB,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,EAAE;gBAC7B,IAAIS,OAAO,GAAGb,gBAAgB,CAACc,GAAG,CAACV,GAAG,CAAC;gBACvC,IAAI,CAACS,OAAO,EAAE;oBACZA,OAAO,GAAG,CAAA,GAAAE,SAAAA,OAAe,EACvBnB,SAAS,EACTQ,GAAG,EACH,CAAA,GAAAM,SAAAA,KAAK,EAACT,UAAU,EAAET,cAAc,CAClC,CAAC;oBACDQ,gBAAgB,CAACgB,GAAG,CAACZ,GAAG,EAAES,OAAO,CAAC;gBACpC;gBACA,OAAOA,OAAO,CAACR,IAAI,CAAC,CAAC,CAAC;YACxB;YAEA,MAAM,IAAIE,KAAK,CAAC,CAAA,0BAAA,EAA6B,OAAOH,GAAG,EAAE,CAAC;QAC5D;IACF,CACF,CAAC;AACH;AAEA,SAASI,aAAaA,CACpBU,EAAsB,EACF;IAGpB,IAAIC,SAAS,GAAG,EAAE;IAClB,IAAI;QAGF,MAAM,IAAIZ,KAAK,CAAC,CAAC;IACnB,CAAC,CAAC,OAAOa,KAAK,EAAE;QACd,IAAIA,KAAK,CAACC,KAAK,EAAE;YAMfF,SAAS,GAAGC,KAAK,CAACC,KAAK,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;QACzD;IACF;IAEA,QAAQC,GAAQ,IAAK;QACnB,IAAI;YACF,OAAOP,EAAE,CAACO,GAAG,CAAC;QAChB,CAAC,CAAC,OAAOC,GAAG,EAAE;YACZA,GAAG,CAACL,KAAK,IAAI,CAAA,qBAAA,EAAwBF,SAAS,EAAE;YAChD,MAAMO,GAAG;QACX;IACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 2887, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2892, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/template/src/index.ts"],"sourcesContent":["import * as formatters from \"./formatters.ts\";\nimport createTemplateBuilder from \"./builder.ts\";\n\nexport const smart = createTemplateBuilder(formatters.smart);\nexport const statement = createTemplateBuilder(formatters.statement);\nexport const statements = createTemplateBuilder(formatters.statements);\nexport const expression = createTemplateBuilder(formatters.expression);\nexport const program = createTemplateBuilder(formatters.program);\n\ntype DefaultTemplateBuilder = typeof smart & {\n  smart: typeof smart;\n  statement: typeof statement;\n  statements: typeof statements;\n  expression: typeof expression;\n  program: typeof program;\n};\n\nexport default Object.assign(smart.bind(undefined) as DefaultTemplateBuilder, {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast,\n});\n\nexport type {\n  PublicOpts as Options,\n  PublicReplacements as Replacements,\n} from \"./options.ts\";\n"],"names":["formatters","require","_builder","smart","exports","createTemplateBuilder","statement","statements","expression","program","_default","default","Object","assign","bind","undefined","ast"],"mappings":";;;;;AAAA,IAAAA,UAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAEO,MAAME,KAAK,GAAAC,OAAA,CAAAD,KAAA,GAAG,CAAA,GAAAE,SAAAA,OAAqB,EAACL,UAAU,CAACG,KAAK,CAAC;AACrD,MAAMG,SAAS,GAAAF,OAAA,CAAAE,SAAA,GAAG,CAAA,GAAAD,SAAAA,OAAqB,EAACL,UAAU,CAACM,SAAS,CAAC;AAC7D,MAAMC,UAAU,GAAAH,OAAA,CAAAG,UAAA,GAAG,CAAA,GAAAF,SAAAA,OAAqB,EAACL,UAAU,CAACO,UAAU,CAAC;AAC/D,MAAMC,UAAU,GAAAJ,OAAA,CAAAI,UAAA,GAAG,CAAA,GAAAH,SAAAA,OAAqB,EAACL,UAAU,CAACQ,UAAU,CAAC;AAC/D,MAAMC,OAAO,GAAAL,OAAA,CAAAK,OAAA,GAAG,CAAA,GAAAJ,SAAAA,OAAqB,EAACL,UAAU,CAACS,OAAO,CAAC;AAAC,IAAAC,QAAA,GAAAN,OAAA,CAAAO,OAAA,GAUlDC,MAAM,CAACC,MAAM,CAACV,KAAK,CAACW,IAAI,CAACC,SAAS,CAAC,EAA4B;IAC5EZ,KAAK;IACLG,SAAS;IACTC,UAAU;IACVC,UAAU;IACVC,OAAO;IACPO,GAAG,EAAEb,KAAK,CAACa,GAAAA;AACb,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2912, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2917, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-imports/src/import-builder.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  importDeclaration,\n  importDefaultSpecifier,\n  importNamespaceSpecifier,\n  importSpecifier,\n  memberExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { Scope, HubInterface } from \"@babel/traverse\";\n\n/**\n * A class to track and accumulate mutations to the AST that will eventually\n * output a new require/import statement list.\n */\nexport default class ImportBuilder {\n  private _statements: t.Statement[] = [];\n  private _resultName: t.Identifier | t.MemberExpression = null;\n\n  declare _scope: Scope;\n  declare _hub: HubInterface;\n  private _importedSource: string;\n\n  constructor(importedSource: string, scope: Scope, hub: HubInterface) {\n    this._scope = scope;\n    this._hub = hub;\n    this._importedSource = importedSource;\n  }\n\n  done() {\n    return {\n      statements: this._statements,\n      resultName: this._resultName,\n    };\n  }\n\n  import() {\n    this._statements.push(\n      importDeclaration([], stringLiteral(this._importedSource)),\n    );\n    return this;\n  }\n\n  require() {\n    this._statements.push(\n      expressionStatement(\n        callExpression(identifier(\"require\"), [\n          stringLiteral(this._importedSource),\n        ]),\n      ),\n    );\n    return this;\n  }\n\n  namespace(name = \"namespace\") {\n    const local = this._scope.generateUidIdentifier(name);\n\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importNamespaceSpecifier(local)];\n    this._resultName = cloneNode(local);\n    return this;\n  }\n  default(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importDefaultSpecifier(id)];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  named(name: string, importName: string) {\n    if (importName === \"default\") return this.default(name);\n\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importSpecifier(id, identifier(importName))];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  var(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    let statement = this._statements[this._statements.length - 1];\n    if (statement.type !== \"ExpressionStatement\") {\n      assert(this._resultName);\n      statement = expressionStatement(this._resultName);\n      this._statements.push(statement);\n    }\n    this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [\n      variableDeclarator(id, statement.expression),\n    ]);\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  defaultInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n  }\n  wildcardInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n  }\n\n  _interop(callee: t.Expression) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = callExpression(callee, [statement.expression]);\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = callExpression(callee, [\n        statement.declarations[0].init,\n      ]);\n    } else {\n      assert.fail(\"Unexpected type.\");\n    }\n    return this;\n  }\n\n  prop(name: string) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = memberExpression(\n        statement.expression,\n        identifier(name),\n      );\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = memberExpression(\n        statement.declarations[0].init,\n        identifier(name),\n      );\n    } else {\n      assert.fail(\"Unexpected type:\" + statement.type);\n    }\n    return this;\n  }\n\n  read(name: string) {\n    this._resultName = memberExpression(this._resultName, identifier(name));\n  }\n}\n"],"names":["_assert","require","_t","callExpression","cloneNode","expressionStatement","identifier","importDeclaration","importDefaultSpecifier","importNamespaceSpecifier","importSpecifier","memberExpression","stringLiteral","variableDeclaration","variableDeclarator","ImportBuilder","constructor","importedSource","scope","hub","_statements","_resultName","_importedSource","_scope","_hub","done","statements","resultName","import","push","namespace","name","local","generateUidIdentifier","statement","length","assert","type","specifiers","default","id","named","importName","var","expression","defaultInterop","_interop","addHelper","wildcardInterop","callee","declarations","init","fail","prop","read","exports"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3037, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3042, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-imports/src/is-module.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\n/**\n * A small utility to check if a file qualifies as a module.\n */\nexport default function isModule(path: NodePath<t.Program>) {\n  return path.node.sourceType === \"module\";\n}\n"],"names":["isModule","path","node","sourceType"],"mappings":";;;;;AAMe,SAASA,QAAQA,CAACC,IAAyB,EAAE;IAC1D,OAAOA,IAAI,CAACC,IAAI,CAACC,UAAU,KAAK,QAAQ;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3055, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-imports/src/import-injector.ts"],"sourcesContent":["import assert from \"assert\";\nimport {\n  identifier,\n  importSpecifier,\n  numericLiteral,\n  sequenceExpression,\n  isImportDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope, HubInterface } from \"@babel/traverse\";\n\nimport ImportBuilder from \"./import-builder.ts\";\nimport isModule from \"./is-module.ts\";\n\nexport type ImportOptions = {\n  /**\n   * The module being referenced.\n   */\n  importedSource: string | null;\n  /**\n   * The type of module being imported:\n   *\n   *  * 'es6'      - An ES6 module.\n   *  * 'commonjs' - A CommonJS module. (Default)\n   */\n  importedType: \"es6\" | \"commonjs\";\n  /**\n   * The type of interop behavior for namespace/default/named when loading\n   * CommonJS modules.\n   *\n   * ## 'babel' (Default)\n   *\n   * Load using Babel's interop.\n   *\n   * If '.__esModule' is true, treat as 'compiled', else:\n   *\n   * * Namespace: A copy of the module.exports with .default\n   *     populated by the module.exports object.\n   * * Default: The module.exports value.\n   * * Named: The .named property of module.exports.\n   *\n   * The 'ensureLiveReference' has no effect on the liveness of these.\n   *\n   * ## 'compiled'\n   *\n   * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting\n   * interop logic if you are confident that the module is a certain format.\n   *\n   * * Namespace: The root module.exports object.\n   * * Default: The .default property of the namespace.\n   * * Named: The .named property of the namespace.\n   *\n   * Will return erroneous results if the imported module is _not_ compiled\n   * from ES6 with Babel.\n   *\n   * ## 'uncompiled'\n   *\n   * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified\n   * access pattern that doesn't require additional function calls.\n   *\n   * Will return erroneous results if the imported module _is_ compiled\n   * from ES6 with Babel.\n   *\n   * * Namespace: The module.exports object.\n   * * Default: The module.exports object.\n   * * Named: The .named property of module.exports.\n   */\n  importedInterop: \"babel\" | \"node\" | \"compiled\" | \"uncompiled\";\n  /**\n   * The type of CommonJS interop included in the environment that will be\n   * loading the output code.\n   *\n   *  * 'babel' - CommonJS modules load with Babel's interop. (Default)\n   *  * 'node'  - CommonJS modules load with Node's interop.\n   *\n   * See descriptions in 'importedInterop' for more details.\n   */\n  importingInterop: \"babel\" | \"node\";\n  /**\n   * Define whether we explicitly care that the import be a live reference.\n   * Only applies when importing default and named imports, not the namespace.\n   *\n   *  * true  - Force imported values to be live references.\n   *  * false - No particular requirements. Keeps the code simplest. (Default)\n   */\n  ensureLiveReference: boolean;\n  /**\n   * Define if we explicitly care that the result not be a property reference.\n   *\n   *  * true  - Force calls to exclude context. Useful if the value is going to\n   *            be used as function callee.\n   *  * false - No particular requirements for context of the access. (Default)\n   */\n  ensureNoContext: boolean;\n  /**\n   * Define whether the import should be loaded before or after the existing imports.\n   * \"after\" is only allowed inside ECMAScript modules, since it's not possible to\n   * reliably pick the location _after_ require() calls but _before_ other code in CJS.\n   */\n  importPosition: \"before\" | \"after\";\n\n  nameHint?: string;\n  blockHoist?: number;\n};\n\n/**\n * A general helper classes add imports via transforms. See README for usage.\n */\nexport default class ImportInjector {\n  /**\n   * The path used for manipulation.\n   */\n  declare _programPath: NodePath<t.Program>;\n\n  /**\n   * The scope used to generate unique variable names.\n   */\n  declare _programScope: Scope;\n\n  /**\n   * The file used to inject helpers and resolve paths.\n   */\n  declare _hub: HubInterface;\n\n  /**\n   * The default options to use with this instance when imports are added.\n   */\n  _defaultOpts: ImportOptions = {\n    importedSource: null,\n    importedType: \"commonjs\",\n    importedInterop: \"babel\",\n    importingInterop: \"babel\",\n    ensureLiveReference: false,\n    ensureNoContext: false,\n    importPosition: \"before\",\n  };\n\n  constructor(\n    path: NodePath,\n    importedSource?: string,\n    opts?: Partial<ImportOptions>,\n  ) {\n    const programPath = path.find(p => p.isProgram()) as NodePath<t.Program>;\n\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub;\n\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n\n  addDefault(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n\n  addNamed(\n    importName: string,\n    importedSourceIn: string,\n    opts: Partial<ImportOptions>,\n  ) {\n    assert(typeof importName === \"string\");\n\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      importName,\n    );\n  }\n\n  addNamespace(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      null,\n    );\n  }\n\n  addSideEffect(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      void 0,\n    );\n  }\n\n  _applyDefaults(\n    importedSource: string | Partial<ImportOptions>,\n    opts: Partial<ImportOptions> | undefined,\n    isInit = false,\n  ) {\n    let newOpts: ImportOptions;\n    if (typeof importedSource === \"string\") {\n      newOpts = { ...this._defaultOpts, importedSource, ...opts };\n    } else {\n      assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = { ...this._defaultOpts, ...importedSource };\n    }\n\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n\n  _generateImport(\n    opts: Partial<ImportOptions>,\n    importName: string | null | undefined,\n  ) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n\n      // Not meant for public usage. Allows code that absolutely must control\n      // ordering to set a specific hoist value on the import nodes.\n      // This is ignored when \"importPosition\" is \"after\".\n      blockHoist,\n    } = opts;\n\n    // Provide a hint for generateUidIdentifier for the local variable name\n    // to use for the import, if the code will generate a simple assignment\n    // to a variable.\n    let name = nameHint || importName;\n\n    const isMod = isModule(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n\n    const builder = new ImportBuilder(\n      importedSource,\n      this._programScope,\n      this._hub,\n    );\n\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n\n      // import * as namespace from ''; namespace\n      // import def from ''; def\n      // import { named } from ''; named\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        // import _tmp from ''; var namespace = interopRequireWildcard(_tmp); namespace\n        // import _tmp from ''; var def = interopRequireDefault(_tmp).default; def\n        // import _tmp from ''; _tmp.named\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n\n        builder.import();\n        if (isNamespace) {\n          builder\n            .default(es6Default)\n            .var(name || importedSource)\n            .wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder\n              .default(es6Default)\n              .var(name || importedSource)\n              .defaultInterop()\n              .read(\"default\");\n          } else {\n            builder\n              .default(es6Default)\n              .var(name)\n              .defaultInterop()\n              .prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = interopRequireWildcard(require(''));\n        // var def = interopRequireDefault(require('')).default; def\n        // var named = require('').named; named\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import namespace from ''; namespace.default\n        // import namespace from ''; namespace.named\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        // Note: These lookups will break if the module has no __esModule set,\n        // hence the warning that 'compiled' will not work on standard CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var namespace = require(''); namespace.default\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import def from ''; def;\n        // import namespace from ''; namespace.named\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import namespace from '';\n        // import def from '';\n        // import { named } from ''; named;\n        // Note: These lookups will break if the module has __esModule set,\n        // hence the warning that 'uncompiled' will not work on ES6 transpiled\n        // to CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var def = require(''); def\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n\n    const { statements, resultName } = builder.done();\n\n    this._insertStatements(statements, importPosition, blockHoist);\n\n    if (\n      (isDefault || isNamed) &&\n      ensureNoContext &&\n      resultName.type !== \"Identifier\"\n    ) {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n\n  _insertStatements(\n    statements: t.Statement[],\n    importPosition = \"before\",\n    blockHoist = 3,\n  ) {\n    if (importPosition === \"after\") {\n      if (this._insertStatementsAfter(statements)) return;\n    } else {\n      if (this._insertStatementsBefore(statements, blockHoist)) return;\n    }\n\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n\n  _insertStatementsBefore(statements: t.Statement[], blockHoist: number) {\n    if (\n      statements.length === 1 &&\n      isImportDeclaration(statements[0]) &&\n      isValueImport(statements[0])\n    ) {\n      const firstImportDecl = this._programPath\n        .get(\"body\")\n        .find((p): p is NodePath<t.ImportDeclaration> => {\n          return p.isImportDeclaration() && isValueImport(p.node);\n        });\n\n      if (\n        firstImportDecl?.node.source.value === statements[0].source.value &&\n        maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])\n      ) {\n        return true;\n      }\n    }\n\n    statements.forEach(node => {\n      // @ts-expect-error handle _blockHoist\n      node._blockHoist = blockHoist;\n    });\n\n    const targetPath = this._programPath.get(\"body\").find(p => {\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      const val = p.node._blockHoist;\n      return Number.isFinite(val) && val < 4;\n    });\n\n    if (targetPath) {\n      targetPath.insertBefore(statements);\n      return true;\n    }\n\n    return false;\n  }\n\n  _insertStatementsAfter(statements: t.Statement[]): boolean {\n    const statementsSet = new Set(statements);\n    const importDeclarations: Map<string, t.ImportDeclaration[]> = new Map();\n\n    for (const statement of statements) {\n      if (isImportDeclaration(statement) && isValueImport(statement)) {\n        const source = statement.source.value;\n        if (!importDeclarations.has(source)) importDeclarations.set(source, []);\n        importDeclarations.get(source).push(statement);\n      }\n    }\n\n    let lastImportPath = null;\n    for (const bodyStmt of this._programPath.get(\"body\")) {\n      if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {\n        lastImportPath = bodyStmt;\n\n        const source = bodyStmt.node.source.value;\n        const newImports = importDeclarations.get(source);\n        if (!newImports) continue;\n\n        for (const decl of newImports) {\n          if (!statementsSet.has(decl)) continue;\n          if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {\n            statementsSet.delete(decl);\n          }\n        }\n      }\n    }\n\n    if (statementsSet.size === 0) return true;\n\n    if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));\n\n    return !!lastImportPath;\n  }\n}\n\nfunction isValueImport(node: t.ImportDeclaration) {\n  return node.importKind !== \"type\" && node.importKind !== \"typeof\";\n}\n\nfunction hasNamespaceImport(node: t.ImportDeclaration) {\n  return (\n    (node.specifiers.length === 1 &&\n      node.specifiers[0].type === \"ImportNamespaceSpecifier\") ||\n    (node.specifiers.length === 2 &&\n      node.specifiers[1].type === \"ImportNamespaceSpecifier\")\n  );\n}\n\nfunction hasDefaultImport(node: t.ImportDeclaration) {\n  return (\n    node.specifiers.length > 0 &&\n    node.specifiers[0].type === \"ImportDefaultSpecifier\"\n  );\n}\n\nfunction maybeAppendImportSpecifiers(\n  target: t.ImportDeclaration,\n  source: t.ImportDeclaration,\n): boolean {\n  if (!target.specifiers.length) {\n    target.specifiers = source.specifiers;\n    return true;\n  }\n  if (!source.specifiers.length) return true;\n\n  if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;\n\n  if (hasDefaultImport(source)) {\n    if (hasDefaultImport(target)) {\n      source.specifiers[0] = importSpecifier(\n        source.specifiers[0].local,\n        identifier(\"default\"),\n      );\n    } else {\n      target.specifiers.unshift(source.specifiers.shift());\n    }\n  }\n\n  target.specifiers.push(...source.specifiers);\n\n  return true;\n}\n"],"names":["_assert","require","_t","_importBuilder","_isModule","identifier","importSpecifier","numericLiteral","sequenceExpression","isImportDeclaration","ImportInjector","constructor","path","importedSource","opts","_defaultOpts","importedType","importedInterop","importingInterop","ensureLiveReference","ensureNoContext","importPosition","programPath","find","p","isProgram","_programPath","_programScope","scope","_hub","hub","_applyDefaults","addDefault","importedSourceIn","addNamed","importName","assert","_generateImport","addNamespace","addSideEffect","isInit","newOpts","Object","assign","nameHint","undefined","blockHoist","isDefault","isNamed","isNamespace","name","isMod","isModule","isModuleForNode","isModuleForBabel","Error","builder","ImportBuilder","import","namespace","named","es6Default","default","var","wildcardInterop","defaultInterop","read","prop","statements","resultName","done","_insertStatements","type","_insertStatementsAfter","_insertStatementsBefore","unshiftContainer","length","isValueImport","firstImportDecl","get","node","source","value","maybeAppendImportSpecifiers","forEach","_blockHoist","targetPath","val","Number","isFinite","insertBefore","statementsSet","Set","importDeclarations","Map","statement","has","set","push","lastImportPath","bodyStmt","newImports","decl","delete","size","insertAfter","Array","from","exports","importKind","hasNamespaceImport","specifiers","hasDefaultImport","target","local","unshift","shift"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3340, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3345, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-imports/src/index.ts"],"sourcesContent":["import ImportInjector, { type ImportOptions } from \"./import-injector.ts\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport { ImportInjector };\n\nexport { default as isModule } from \"./is-module.ts\";\n\nexport function addDefault(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addDefault(importedSource, opts);\n}\n\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<\n    Partial<ImportOptions>,\n    \"ensureLiveReference\" | \"ensureNoContext\"\n  >,\n): t.Identifier;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureLiveReference\"> & {\n    ensureLiveReference: true;\n  },\n): t.MemberExpression;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureNoContext\"> & {\n    ensureNoContext: true;\n  },\n): t.SequenceExpression;\n/**\n * add a named import to the program path of given path\n *\n * @export\n * @param {NodePath} path The starting path to find a program path\n * @param {string} name The name of the generated binding. Babel will prefix it with `_`\n * @param {string} importedSource The source of the import\n * @param {Partial<ImportOptions>} [opts]\n * @returns {t.Identifier | t.MemberExpression | t.SequenceExpression} If opts.ensureNoContext is true, returns a SequenceExpression,\n *   else if opts.ensureLiveReference is true, returns a MemberExpression, else returns an Identifier\n */\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamed(name, importedSource, opts);\n}\nexport { addNamed };\n\nexport function addNamespace(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamespace(importedSource, opts);\n}\n\nexport function addSideEffect(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addSideEffect(importedSource, opts);\n}\n"],"names":["_importInjector","require","_isModule","addDefault","path","importedSource","opts","ImportInjector","addNamed","name","addNamespace","addSideEffect"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,eAAA,GAAAC,OAAA;AAMA,IAAAC,SAAA,GAAAD,OAAA;AAEO,SAASE,UAAUA,CACxBC,IAAc,EACdC,cAAsB,EACtBC,IAA6B,EAC7B;IACA,OAAO,IAAIC,gBAAAA,OAAc,CAACH,IAAI,CAAC,CAACD,UAAU,CAACE,cAAc,EAAEC,IAAI,CAAC;AAClE;AAsCA,SAASE,QAAQA,CACfJ,IAAc,EACdK,IAAY,EACZJ,cAAsB,EACtBC,IAA6B,EAC7B;IACA,OAAO,IAAIC,gBAAAA,OAAc,CAACH,IAAI,CAAC,CAACI,QAAQ,CAACC,IAAI,EAAEJ,cAAc,EAAEC,IAAI,CAAC;AACtE;AAGO,SAASI,YAAYA,CAC1BN,IAAc,EACdC,cAAsB,EACtBC,IAA6B,EAC7B;IACA,OAAO,IAAIC,gBAAAA,OAAc,CAACH,IAAI,CAAC,CAACM,YAAY,CAACL,cAAc,EAAEC,IAAI,CAAC;AACpE;AAEO,SAASK,aAAaA,CAC3BP,IAAc,EACdC,cAAsB,EACtBC,IAA6B,EAC7B;IACA,OAAO,IAAIC,gBAAAA,OAAc,CAACH,IAAI,CAAC,CAACO,aAAa,CAACN,cAAc,EAAEC,IAAI,CAAC;AACrE","ignoreList":[0]}},
    {"offset": {"line": 3379, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3384, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/rewrite-this.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport traverse, { visitors, type NodePath } from \"@babel/traverse\";\n\n/**\n * A lazily constructed visitor to walk the tree, rewriting all `this` references in the\n * top-level scope to be `void 0` (undefined).\n *\n */\nlet rewriteThisVisitor: Parameters<typeof traverse>[1];\n\nexport default function rewriteThis(programPath: NodePath) {\n  if (!rewriteThisVisitor) {\n    rewriteThisVisitor = visitors.environmentVisitor({\n      ThisExpression(path) {\n        path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0), true));\n      },\n    });\n    rewriteThisVisitor.noScope = true;\n  }\n  // Rewrite \"this\" to be \"undefined\".\n  traverse(programPath.node, rewriteThisVisitor);\n}\n"],"names":["_core","require","_traverse","rewriteThisVisitor","rewriteThis","programPath","visitors","environmentVisitor","ThisExpression","path","replaceWith","t","unaryExpression","numericLiteral","noScope","traverse","node"],"mappings":";;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AAOA,IAAIE,kBAAkD;AAEvC,SAASC,WAAWA,CAACC,WAAqB,EAAE;IACzD,IAAI,CAACF,kBAAkB,EAAE;QACvBA,kBAAkB,GAAGG,UAAAA,QAAQ,CAACC,kBAAkB,CAAC;YAC/CC,cAAcA,EAACC,IAAI,EAAE;gBACnBA,IAAI,CAACC,WAAW,CAACC,MAAAA,KAAC,CAACC,eAAe,CAAC,MAAM,EAAED,MAAAA,KAAC,CAACE,cAAc,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACxE;QACF,CAAC,CAAC;QACFV,kBAAkB,CAACW,OAAO,GAAG,IAAI;IACnC;IAEA,CAAA,GAAAC,UAAAA,OAAQ,EAACV,WAAW,CAACW,IAAI,EAAEb,kBAAkB,CAAC;AAChD","ignoreList":[0]}},
    {"offset": {"line": 3403, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3408, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/rewrite-live-references.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/core\";\n\nimport type { ModuleMetadata } from \"./normalize-and-load-metadata.ts\";\n\ninterface RewriteReferencesVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n  imported: Map<any, any>;\n  buildImportReference: (\n    [source, importName, localName]: readonly [string, string, string],\n    identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,\n  ) => any;\n  seen: WeakSet<object>;\n}\n\ninterface RewriteBindingInitVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n}\n\nfunction isInType(path: NodePath) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n      case \"ExportSpecifier\":\n        return (\n          (\n            path.parentPath.parent as\n              | t.ExportDefaultDeclaration\n              | t.ExportNamedDeclaration\n          ).exportKind === \"type\"\n        );\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n    }\n  } while ((path = path.parentPath));\n}\n\nexport default function rewriteLiveReferences(\n  programPath: NodePath<t.Program>,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => null | t.Expression,\n) {\n  const imported = new Map();\n  const exported = new Map();\n  const requeueInParent = (path: NodePath) => {\n    // Manually re-queue `exports.default =` expressions so that the ES3\n    // transform has an opportunity to convert them. Ideally this would\n    // happen automatically from the replaceWith above. See #4140 for\n    // more info.\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  // Rewrite initialization of bindings to update exports.\n  const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported, // local name => exported name list\n  };\n  programPath.traverse(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    rewriteBindingInitVisitor,\n    rewriteBindingInitVisitorState,\n  );\n\n  // Rewrite reads/writes from imports and exports to have the correct behavior.\n  const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported, // local / import\n    exported, // local name => exported name list\n    buildImportReference([source, importName, localName], identNode) {\n      const meta = metadata.source.get(source);\n      meta.referenced = true;\n\n      if (localName) {\n        if (meta.wrap) {\n          // @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier\n          identNode = wrapReference(identNode, meta.wrap) ?? identNode;\n        }\n        return identNode;\n      }\n\n      let namespace: t.Expression = t.identifier(meta.name);\n      if (meta.wrap) {\n        namespace = wrapReference(namespace, meta.wrap) ?? namespace;\n      }\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n\n      return t.memberExpression(\n        namespace,\n        computed ? t.stringLiteral(importName) : t.identifier(importName),\n        computed,\n      );\n    },\n  };\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\n/**\n * A visitor to inject export update statements during binding initialization.\n */\nconst rewriteBindingInitVisitor: Visitor<RewriteBindingInitVisitorState> = {\n  Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    const { id } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n\n    const exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        buildBindingExportAssignmentExpression(\n          metadata,\n          exportNames,\n          t.identifier(localName),\n          path.scope,\n        ),\n      );\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      statement._blockHoist = path.node._blockHoist;\n\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    const isVar = path.node.kind === \"var\";\n\n    for (const decl of path.get(\"declarations\")) {\n      const { id } = decl.node;\n      let { init } = decl.node;\n      if (\n        t.isIdentifier(id) &&\n        exported.has(id.name) &&\n        !t.isArrowFunctionExpression(init) &&\n        (!t.isFunctionExpression(init) || init.id) &&\n        (!t.isClassExpression(init) || init.id)\n      ) {\n        if (!init) {\n          if (isVar) {\n            // This variable might have already been assigned to, and the\n            // uninitalized declaration doesn't set it to `undefined` and does\n            // not updated the exported value.\n            continue;\n          } else {\n            init = path.scope.buildUndefinedNode();\n          }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        decl.node.init = buildBindingExportAssignmentExpression(\n          metadata,\n          exported.get(id.name),\n          init,\n          path.scope,\n        );\n        requeueInParent(decl.get(\"init\"));\n      } else {\n        for (const localName of Object.keys(\n          decl.getOuterBindingIdentifiers(),\n        )) {\n          if (exported.has(localName)) {\n            const statement = t.expressionStatement(\n              // eslint-disable-next-line @typescript-eslint/no-use-before-define\n              buildBindingExportAssignmentExpression(\n                metadata,\n                exported.get(localName),\n                t.identifier(localName),\n                path.scope,\n              ),\n            );\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            statement._blockHoist = path.node._blockHoist;\n\n            requeueInParent(path.insertAfter(statement)[0]);\n          }\n        }\n      }\n    }\n  },\n};\n\nconst buildBindingExportAssignmentExpression = (\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  localExpr: t.Expression,\n  scope: Scope,\n) => {\n  const exportsObjectName = metadata.exportName;\n  for (\n    let currentScope = scope;\n    currentScope != null;\n    currentScope = currentScope.parent\n  ) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n  return (exportNames || []).reduce((expr, exportName) => {\n    // class Foo {} export { Foo, Foo as Bar };\n    // as\n    // class Foo {} exports.Foo = exports.Bar = Foo;\n    const { stringSpecifiers } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return t.assignmentExpression(\n      \"=\",\n      t.memberExpression(\n        t.identifier(exportsObjectName),\n        computed ? t.stringLiteral(exportName) : t.identifier(exportName),\n        /* computed */ computed,\n      ),\n      expr,\n    );\n  }, localExpr);\n};\n\nconst buildImportThrow = (localName: string) => {\n  return template.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor: Visitor<RewriteReferencesVisitorState> = {\n  ReferencedIdentifier(path) {\n    const { seen, buildImportReference, scope, imported, requeueInParent } =\n      this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n\n    const localName = path.node.name;\n\n    const importData = imported.get(localName);\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(\n          `Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` +\n            `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,\n        );\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n\n      // redeclared in this scope\n      if (rootBinding !== localBinding) return;\n\n      const ref = buildImportReference(importData, path.node);\n\n      // Preserve the binding location so that sourcemaps are nicer.\n      ref.loc = path.node.loc;\n\n      if (\n        (path.parentPath.isCallExpression({ callee: path.node }) ||\n          path.parentPath.isOptionalCallExpression({ callee: path.node }) ||\n          path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &&\n        t.isMemberExpression(ref)\n      ) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const { object, property } = ref;\n        path.replaceWith(\n          t.jsxMemberExpression(\n            // @ts-expect-error todo(flow->ts): possible bug `object` might not have a name\n            t.jsxIdentifier(object.name),\n            // @ts-expect-error todo(flow->ts): possible bug `property` might not have a name\n            t.jsxIdentifier(property.name),\n          ),\n        );\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n\n      // The path could have been replaced with an identifier that would\n      // otherwise be re-visited, so we skip processing its children.\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference,\n    } = this;\n\n    if (seen.has(path.node)) return;\n\n    seen.add(path.node);\n\n    const arg = path.get(\"argument\");\n\n    // No change needed\n    if (arg.isMemberExpression()) return;\n\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      // redeclared in this scope\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if (exportedNames?.length > 0 || importData) {\n        if (importData) {\n          path.replaceWith(\n            t.assignmentExpression(\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n              (update.operator[0] + \"=\") as t.AssignmentExpression[\"operator\"],\n              buildImportReference(importData, arg.node),\n              buildImportThrow(localName),\n            ),\n          );\n        } else if (update.prefix) {\n          // ++foo\n          // =>   exports.foo = ++foo\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              t.cloneNode(update),\n              path.scope,\n            ),\n          );\n        } else {\n          // foo++\n          // =>   (ref = i++, exports.i = i, ref)\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n\n          path.replaceWith(\n            t.sequenceExpression([\n              t.assignmentExpression(\n                \"=\",\n                t.cloneNode(ref),\n                t.cloneNode(update),\n              ),\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                t.identifier(localName),\n                path.scope,\n              ),\n              t.cloneNode(ref),\n            ]),\n          );\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference,\n      } = this;\n\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n\n      const left = path.get(\"left\");\n\n      // No change needed\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        // Simple update-assign foo += 1; export { foo };\n        // =>   exports.foo =  (foo += 1);\n        const localName = left.node.name;\n\n        // redeclared in this scope\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n        if (exportedNames?.length > 0 || importData) {\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n\n            assignment.right = t.sequenceExpression([\n              assignment.right,\n              buildImportThrow(localName),\n            ]);\n          }\n\n          const { operator } = assignment;\n          let newExpr;\n          if (operator === \"=\") {\n            newExpr = assignment;\n          } else if (\n            operator === \"&&=\" ||\n            operator === \"||=\" ||\n            operator === \"??=\"\n          ) {\n            newExpr = t.assignmentExpression(\n              \"=\",\n              assignment.left,\n              t.logicalExpression(\n                operator.slice(0, -1) as t.LogicalExpression[\"operator\"],\n                t.cloneNode(assignment.left) as t.Expression,\n                assignment.right,\n              ),\n            );\n          } else {\n            newExpr = t.assignmentExpression(\n              \"=\",\n              assignment.left,\n              t.binaryExpression(\n                operator.slice(0, -1) as t.BinaryExpression[\"operator\"],\n                t.cloneNode(assignment.left) as t.Expression,\n                assignment.right,\n              ),\n            );\n          }\n\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              newExpr,\n              path.scope,\n            ),\n          );\n\n          requeueInParent(path);\n\n          path.skip();\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(\n          localName =>\n            scope.getBinding(localName) === path.scope.getBinding(localName),\n        );\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = t.sequenceExpression([\n            path.node.right,\n            buildImportThrow(id),\n          ]);\n        }\n\n        // Complex ({a, b, c} = {}); export { a, c };\n        // =>   ({a, b, c} = {}), (exports.a = a, exports.c = c);\n        const items: t.Expression[] = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                t.identifier(localName),\n                path.scope,\n              ),\n            );\n          }\n        });\n\n        if (items.length > 0) {\n          let node: t.Node = t.sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    },\n  },\n  ForXStatement(path) {\n    const { scope, node } = path;\n    const { left } = node;\n    const { exported, imported, scope: programScope } = this;\n\n    if (!t.isVariableDeclaration(left)) {\n      let didTransformExport = false,\n        importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\") as NodePath<t.BlockStatement>;\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path\n        .get(\"left\")\n        .replaceWith(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(t.cloneNode(newLoopId)),\n          ]),\n        );\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)),\n        );\n      }\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          t.expressionStatement(buildImportThrow(importConstViolationName)),\n        );\n      }\n    }\n  },\n};\n"],"names":["_core","require","isInType","path","parent","type","parentPath","exportKind","isStatement","isExpression","rewriteLiveReferences","programPath","metadata","wrapReference","imported","Map","exported","requeueInParent","requeue","source","data","localName","importName","imports","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","referenced","wrap","_wrapReference","namespace","t","identifier","name","_wrapReference2","interop","computed","stringSpecifiers","has","memberExpression","stringLiteral","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","expressionStatement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","isVar","kind","decl","init","isIdentifier","isArrowFunctionExpression","isFunctionExpression","isClassExpression","buildUndefinedNode","Object","keys","getOuterBindingIdentifiers","localExpr","exportsObjectName","exportName","currentScope","hasOwnBinding","rename","reduce","expr","assignmentExpression","buildImportThrow","template","expression","ast","ReferencedIdentifier","add","importData","buildCodeFrameError","localBinding","getBinding","rootBinding","ref","loc","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","isMemberExpression","replaceWith","sequenceExpression","numericLiteral","isJSXIdentifier","object","property","jsxMemberExpression","jsxIdentifier","UpdateExpression","arg","update","exportedNames","operator","prefix","cloneNode","generateDeclaredUidIdentifier","AssignmentExpression","exit","left","assignment","right","newExpr","logicalExpression","slice","binaryExpression","ids","programScopeIds","filter","find","items","forEach","isExpressionStatement","ForXStatement","programScope","isVariableDeclaration","didTransformExport","importConstViolationName","loopBodyScope","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","variableDeclaration","variableDeclarator","registerDeclaration","unshiftContainer"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3737, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3742, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/normalize-and-load-metadata.ts"],"sourcesContent":["import { basename, extname } from \"path\";\nimport type { types as t, NodePath } from \"@babel/core\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  wrap?: unknown;\n  referenced: boolean;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    getWrapperPayload,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, sources, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, getWrapperPayload },\n    stringSpecifiers,\n  );\n\n  removeImportExportDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [source, metadata] of sources) {\n    const { importsNamespace, imports } = metadata;\n    // If there is at least one namespace import and other imports, it may collipse with local ident, can be seen in issue 15879.\n    if (importsNamespace.size > 0 && imports.size === 0) {\n      const [nameOfnamespace] = importsNamespace;\n      metadata.name = nameOfnamespace;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source: sources,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    getWrapperPayload,\n    initializeReexports,\n  }: {\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const importNodes = new Map<string, t.Node[]>();\n  const sourceData = new Map<string, SourceModuleMetadata>();\n  const getData = (sourceNode: t.StringLiteral, node: t.Node) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        wrap: null,\n\n        // @ts-expect-error lazy is not listed in the type.\n        // This is needed for compatibility with older version of the commonjs\n        // plusing.\n        // TODO(Babel 8): Remove this\n        get lazy() {\n          return this.wrap === \"lazy\";\n        },\n\n        referenced: false,\n      };\n      sourceData.set(source, data);\n      importNodes.set(source, [node]);\n    } else {\n      importNodes.get(source).push(node);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n            data.referenced = true;\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n      data.referenced = true;\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n        data.referenced = true;\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  if (getWrapperPayload) {\n    for (const [source, metadata] of sourceData) {\n      metadata.wrap = getWrapperPayload(\n        source,\n        metadata,\n        importNodes.get(source),\n      );\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    sources: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n      // polyfill when being run by an older Babel version\n      child.splitExportDeclaration ??=\n        // eslint-disable-next-line no-restricted-globals\n        require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n    }\n    child.splitExportDeclaration();\n  });\n}\n\nfunction removeImportExportDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n"],"names":["_path","require","_helperValidatorIdentifier","hasExports","metadata","isSideEffectImport","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","Error","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","programPath","exportName","initializeReexports","getWrapperPayload","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","sources","getModuleMetadata","removeImportExportDeclarations","nameOfnamespace","resolvedInterop","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","value","isIdentifierName","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","localData","getLocalExportMetadata","importNodes","Map","sourceData","getData","sourceNode","data","get","basename","extname","loc","wrap","lazy","referenced","set","push","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","values","needsDefault","needsNamed","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","Object","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","exported","_child$splitExportDec","splitExportDeclaration","NodePath","prototype","remove","_blockHoist","replaceWith"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4088, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4093, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/lazy-modules.ts"],"sourcesContent":["// TODO: Move `lazy` implementation logic into the CommonJS plugin, since other\n// modules systems do not support `lazy`.\n\nimport { types as t } from \"@babel/core\";\nimport {\n  type SourceModuleMetadata,\n  isSideEffectImport,\n} from \"./normalize-and-load-metadata.ts\";\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport function toGetWrapperPayload(lazy: Lazy) {\n  return (source: string, metadata: SourceModuleMetadata): null | \"lazy\" => {\n    if (lazy === false) return null;\n    if (isSideEffectImport(metadata) || metadata.reexportAll) return null;\n    if (lazy === true) {\n      // 'true' means that local relative files are eagerly loaded and\n      // dependency modules are loaded lazily.\n      return source.includes(\".\") ? null : \"lazy\";\n    }\n    if (Array.isArray(lazy)) {\n      return !lazy.includes(source) ? null : \"lazy\";\n    }\n    if (typeof lazy === \"function\") {\n      return lazy(source) ? \"lazy\" : null;\n    }\n    throw new Error(`.lazy must be a boolean, string array, or function`);\n  };\n}\n\nexport function wrapReference(\n  ref: t.Identifier,\n  payload: unknown,\n): t.Expression | null {\n  if (payload === \"lazy\") return t.callExpression(ref, []);\n  return null;\n}\n"],"names":["_core","require","_normalizeAndLoadMetadata","toGetWrapperPayload","lazy","source","metadata","isSideEffectImport","reexportAll","includes","Array","isArray","Error","wrapReference","ref","payload","t","callExpression"],"mappings":";;;;;;AAGA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,yBAAA,GAAAD,OAAA;AAOO,SAASE,mBAAmBA,CAACC,IAAU,EAAE;IAC9C,OAAO,CAACC,MAAc,EAAEC,QAA8B,KAAoB;QACxE,IAAIF,IAAI,KAAK,KAAK,EAAE,OAAO,IAAI;QAC/B,IAAI,CAAA,GAAAG,0BAAAA,kBAAkB,EAACD,QAAQ,CAAC,IAAIA,QAAQ,CAACE,WAAW,EAAE,OAAO,IAAI;QACrE,IAAIJ,IAAI,KAAK,IAAI,EAAE;YAGjB,OAAOC,MAAM,CAACI,QAAQ,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,MAAM;QAC7C;QACA,IAAIC,KAAK,CAACC,OAAO,CAACP,IAAI,CAAC,EAAE;YACvB,OAAO,CAACA,IAAI,CAACK,QAAQ,CAACJ,MAAM,CAAC,GAAG,IAAI,GAAG,MAAM;QAC/C;QACA,IAAI,OAAOD,IAAI,KAAK,UAAU,EAAE;YAC9B,OAAOA,IAAI,CAACC,MAAM,CAAC,GAAG,MAAM,GAAG,IAAI;QACrC;QACA,MAAM,IAAIO,KAAK,CAAC,CAAA,kDAAA,CAAoD,CAAC;IACvE,CAAC;AACH;AAEO,SAASC,aAAaA,CAC3BC,GAAiB,EACjBC,OAAgB,EACK;IACrB,IAAIA,OAAO,KAAK,MAAM,EAAE,OAAOC,MAAAA,KAAC,CAACC,cAAc,CAACH,GAAG,EAAE,EAAE,CAAC;IACxD,OAAO,IAAI;AACb","ignoreList":[0]}},
    {"offset": {"line": 4121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4126, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/dynamic-import.ts"],"sourcesContent":["// Heavily inspired by\n// https://github.com/airbnb/babel-plugin-dynamic-import-node/blob/master/src/utils.js\n\nimport { types as t, template } from \"@babel/core\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource = function getDynamicImportSource(\n    node: t.CallExpression,\n  ): t.StringLiteral | t.TemplateLiteral {\n    const [source] = node.arguments;\n\n    return t.isStringLiteral(source) || t.isTemplateLiteral(source)\n      ? source\n      : (template.expression.ast`\\`\\${${source}}\\`` as t.TemplateLiteral);\n  };\n}\n\nexport function buildDynamicImport(\n  node: t.CallExpression | t.ImportExpression,\n  deferToThen: boolean,\n  wrapWithPromise: boolean,\n  builder: (specifier: t.Expression) => t.Expression,\n): t.Expression {\n  const specifier = t.isCallExpression(node) ? node.arguments[0] : node.source;\n\n  if (\n    t.isStringLiteral(specifier) ||\n    (t.isTemplateLiteral(specifier) && specifier.quasis.length === 0)\n  ) {\n    if (deferToThen) {\n      return template.expression.ast`\n        Promise.resolve().then(() => ${builder(specifier)})\n      `;\n    } else return builder(specifier);\n  }\n\n  const specifierToString = t.isTemplateLiteral(specifier)\n    ? t.identifier(\"specifier\")\n    : t.templateLiteral(\n        [t.templateElement({ raw: \"\" }), t.templateElement({ raw: \"\" })],\n        [t.identifier(\"specifier\")],\n      );\n\n  if (deferToThen) {\n    return template.expression.ast`\n      (specifier =>\n        new Promise(r => r(${specifierToString}))\n          .then(s => ${builder(t.identifier(\"s\"))})\n      )(${specifier})\n    `;\n  } else if (wrapWithPromise) {\n    return template.expression.ast`\n      (specifier =>\n        new Promise(r => r(${builder(specifierToString)}))\n      )(${specifier})\n    `;\n  } else {\n    return template.expression.ast`\n      (specifier => ${builder(specifierToString)})(${specifier})\n    `;\n  }\n}\n"],"names":["_core","require","exports","getDynamicImportSource","node","source","arguments","t","isStringLiteral","isTemplateLiteral","template","expression","ast","buildDynamicImport","deferToThen","wrapWithPromise","builder","specifier","isCallExpression","quasis","length","specifierToString","identifier","templateLiteral","templateElement","raw"],"mappings":";;;;;AAGA,IAAAA,KAAA,GAAAC,OAAA;AAEiE;IAE/DC,OAAO,CAACC,sBAAsB,GAAG,SAASA,sBAAsBA,CAC9DC,IAAsB,EACe;QACrC,MAAM,CAACC,MAAM,CAAC,GAAGD,IAAI,CAACE,SAAS;QAE/B,OAAOC,MAAAA,KAAC,CAACC,eAAe,CAACH,MAAM,CAAC,IAAIE,MAAAA,KAAC,CAACE,iBAAiB,CAACJ,MAAM,CAAC,GAC3DA,MAAM,GACLK,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA,KAAA,EAAQP,MAAM,CAAA,GAAA,CAA2B;IACvE,CAAC;AACH,CAEO,SAASQ,kBAAkBA,CAChCT,IAA2C,EAC3CU,WAAoB,EACpBC,eAAwB,EACxBC,OAAkD,EACpC;IACd,MAAMC,SAAS,GAAGV,MAAAA,KAAC,CAACW,gBAAgB,CAACd,IAAI,CAAC,GAAGA,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,GAAGF,IAAI,CAACC,MAAM;IAE5E,IACEE,MAAAA,KAAC,CAACC,eAAe,CAACS,SAAS,CAAC,IAC3BV,MAAAA,KAAC,CAACE,iBAAiB,CAACQ,SAAS,CAAC,IAAIA,SAAS,CAACE,MAAM,CAACC,MAAM,KAAK,CAAE,EACjE;QACA,IAAIN,WAAW,EAAE;YACf,OAAOJ,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA;qCACpC,EAAuCI,OAAO,CAACC,SAAS,CAAC,CAAA;MACzD,CAAO;QACH,CAAC,MAAM,OAAOD,OAAO,CAACC,SAAS,CAAC;IAClC;IAEA,MAAMI,iBAAiB,GAAGd,MAAAA,KAAC,CAACE,iBAAiB,CAACQ,SAAS,CAAC,GACpDV,MAAAA,KAAC,CAACe,UAAU,CAAC,WAAW,CAAC,GACzBf,MAAAA,KAAC,CAACgB,eAAe,CACf;QAAChB,MAAAA,KAAC,CAACiB,eAAe,CAAC;YAAEC,GAAG,EAAE;QAAG,CAAC,CAAC;QAAElB,MAAAA,KAAC,CAACiB,eAAe,CAAC;YAAEC,GAAG,EAAE;QAAG,CAAC,CAAC;KAAC,EAChE;QAAClB,MAAAA,KAAC,CAACe,UAAU,CAAC,WAAW,CAAC;KAC5B,CAAC;IAEL,IAAIR,WAAW,EAAE;QACf,OAAOJ,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA;;2BAElC,EAA6BS,iBAAiB,CAAA;qBAC9C,EAAuBL,OAAO,CAACT,MAAAA,KAAC,CAACe,UAAU,CAAC,GAAG,CAAC,CAAC,CAAA;QACjD,EAAUL,SAAS,CAAA;IACnB,CAAK;IACH,CAAC,MAAM,IAAIF,eAAe,EAAE;QAC1B,OAAOL,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA;;2BAElC,EAA6BI,OAAO,CAACK,iBAAiB,CAAC,CAAA;QACvD,EAAUJ,SAAS,CAAA;IACnB,CAAK;IACH,CAAC,MAAM;QACL,OAAOP,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA;oBAClC,EAAsBI,OAAO,CAACK,iBAAiB,CAAC,CAAA,EAAA,EAAKJ,SAAS,CAAA;IAC9D,CAAK;IACH;AACF","ignoreList":[0]}},
    {"offset": {"line": 4175, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4180, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/get-module-name.ts"],"sourcesContent":["type RootOptions = {\n  filename?: string;\n  filenameRelative?: string;\n  sourceRoot?: string;\n};\n\nexport type PluginOptions = {\n  moduleId?: string;\n  moduleIds?: boolean;\n  getModuleId?: (moduleName: string) => string | null | undefined;\n  moduleRoot?: string;\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  const originalGetModuleName = getModuleName;\n\n  // @ts-expect-error TS doesn't like reassigning a function.\n  getModuleName = function getModuleName(\n    rootOpts: RootOptions & PluginOptions,\n    pluginOpts: PluginOptions,\n  ): string | null {\n    return originalGetModuleName(rootOpts, {\n      moduleId: pluginOpts.moduleId ?? rootOpts.moduleId,\n      moduleIds: pluginOpts.moduleIds ?? rootOpts.moduleIds,\n      getModuleId: pluginOpts.getModuleId ?? rootOpts.getModuleId,\n      moduleRoot: pluginOpts.moduleRoot ?? rootOpts.moduleRoot,\n    });\n  };\n}\n\nexport default function getModuleName(\n  rootOpts: RootOptions,\n  pluginOpts: PluginOptions,\n): string | null {\n  const {\n    filename,\n    filenameRelative = filename,\n    sourceRoot = pluginOpts.moduleRoot,\n  } = rootOpts;\n\n  const {\n    moduleId,\n    moduleIds = !!moduleId,\n\n    getModuleId,\n\n    moduleRoot = sourceRoot,\n  } = pluginOpts;\n\n  if (!moduleIds) return null;\n\n  // moduleId is n/a if a `getModuleId()` is provided\n  if (moduleId != null && !getModuleId) {\n    return moduleId;\n  }\n\n  let moduleName = moduleRoot != null ? moduleRoot + \"/\" : \"\";\n\n  if (filenameRelative) {\n    const sourceRootReplacer =\n      sourceRoot != null ? new RegExp(\"^\" + sourceRoot + \"/?\") : \"\";\n\n    moduleName += filenameRelative\n      // remove sourceRoot from filename\n      .replace(sourceRootReplacer, \"\")\n      // remove extension\n      .replace(/\\.\\w*$/, \"\");\n  }\n\n  // normalize path separators\n  moduleName = moduleName.replace(/\\\\/g, \"/\");\n\n  if (getModuleId) {\n    // If return is falsy, assume they want us to use our generated default name\n    return getModuleId(moduleName) || moduleName;\n  } else {\n    return moduleName;\n  }\n}\n"],"names":["originalGetModuleName","getModuleName","exports","default","rootOpts","pluginOpts","_pluginOpts$moduleId","_pluginOpts$moduleIds","_pluginOpts$getModule","_pluginOpts$moduleRoo","moduleId","moduleIds","getModuleId","moduleRoot","filename","filenameRelative","sourceRoot","moduleName","sourceRootReplacer","RegExp","replace"],"mappings":";;;;;AAamC;IACjC,MAAMA,qBAAqB,GAAGC,aAAa;IAG3CC,OAAA,CAAAC,OAAA,GAAAF,aAAa,GAAG,SAASA,aAAaA,CACpCG,QAAqC,EACrCC,UAAyB,EACV;QAAA,IAAAC,oBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA;QACf,OAAOT,qBAAqB,CAACI,QAAQ,EAAE;YACrCM,QAAQ,EAAA,CAAAJ,oBAAA,GAAED,UAAU,CAACK,QAAQ,KAAA,OAAAJ,oBAAA,GAAIF,QAAQ,CAACM,QAAQ;YAClDC,SAAS,EAAA,CAAAJ,qBAAA,GAAEF,UAAU,CAACM,SAAS,KAAA,OAAAJ,qBAAA,GAAIH,QAAQ,CAACO,SAAS;YACrDC,WAAW,EAAA,CAAAJ,qBAAA,GAAEH,UAAU,CAACO,WAAW,KAAA,OAAAJ,qBAAA,GAAIJ,QAAQ,CAACQ,WAAW;YAC3DC,UAAU,EAAA,CAAAJ,qBAAA,GAAEJ,UAAU,CAACQ,UAAU,KAAA,OAAAJ,qBAAA,GAAIL,QAAQ,CAACS,UAAAA;QAChD,CAAC,CAAC;IACJ,CAAC;AACH,CAEe,SAASZ,aAAaA,CACnCG,QAAqB,EACrBC,UAAyB,EACV;IACf,MAAM,EACJS,QAAQ,EACRC,gBAAgB,GAAGD,QAAQ,EAC3BE,UAAU,GAAGX,UAAU,CAACQ,UAAAA,EACzB,GAAGT,QAAQ;IAEZ,MAAM,EACJM,QAAQ,EACRC,SAAS,GAAG,CAAC,CAACD,QAAQ,EAEtBE,WAAW,EAEXC,UAAU,GAAGG,UAAAA,EACd,GAAGX,UAAU;IAEd,IAAI,CAACM,SAAS,EAAE,OAAO,IAAI;IAG3B,IAAID,QAAQ,IAAI,IAAI,IAAI,CAACE,WAAW,EAAE;QACpC,OAAOF,QAAQ;IACjB;IAEA,IAAIO,UAAU,GAAGJ,UAAU,IAAI,IAAI,GAAGA,UAAU,GAAG,GAAG,GAAG,EAAE;IAE3D,IAAIE,gBAAgB,EAAE;QACpB,MAAMG,kBAAkB,GACtBF,UAAU,IAAI,IAAI,GAAG,IAAIG,MAAM,CAAC,GAAG,GAAGH,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE;QAE/DC,UAAU,IAAIF,gBAAgB,CAE3BK,OAAO,CAACF,kBAAkB,EAAE,EAAE,CAAC,CAE/BE,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAC1B;IAGAH,UAAU,GAAGA,UAAU,CAACG,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;IAE3C,IAAIR,WAAW,EAAE;QAEf,OAAOA,WAAW,CAACK,UAAU,CAAC,IAAIA,UAAU;IAC9C,CAAC,MAAM;QACL,OAAOA,UAAU;IACnB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4215, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4220, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-module-transforms/src/index.ts"],"sourcesContent":["import assert from \"assert\";\nimport { template, types as t } from \"@babel/core\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this.ts\";\nimport rewriteLiveReferences from \"./rewrite-live-references.ts\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata.ts\";\nimport type {\n  ImportInterop,\n  InteropType,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata.ts\";\nimport * as Lazy from \"./lazy-modules.ts\";\nimport type { NodePath } from \"@babel/core\";\n\nexport { buildDynamicImport } from \"./dynamic-import.ts\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource =\n    // eslint-disable-next-line no-restricted-globals, import/extensions\n    require(\"./dynamic-import\").getDynamicImportSource;\n}\n\nexport { default as getModuleName } from \"./get-module-name.ts\";\nexport type { PluginOptions } from \"./get-module-name.ts\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy.Lazy;\n  getWrapperPayload?: (\n    source: string,\n    metadata: SourceModuleMetadata,\n    importNodes: t.Node[],\n  ) => unknown;\n  wrapReference?: (ref: t.Expression, payload: unknown) => t.Expression | null;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    // TODO(Babel 8): After that `lazy` implementation is moved to the CJS\n    // transform, remove this parameter.\n    lazy,\n    getWrapperPayload = Lazy.toGetWrapperPayload(lazy ?? false),\n    wrapReference = Lazy.wrapReference,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    enumerableModuleMeta = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    getWrapperPayload,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta, wrapReference);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        t.directive(t.directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      wrapReference,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath<t.Program>,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return t.callExpression(\n      programPath.hub.addHelper(\"interopRequireWildcard\"),\n      [expr, t.booleanLiteral(true)],\n    );\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return t.callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n  wrapReference: (\n    ref: t.Identifier,\n    payload: unknown,\n  ) => t.Expression | null = Lazy.wrapReference,\n) {\n  const statements = [];\n\n  const srcNamespaceId = t.identifier(sourceMetadata.name);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: t.cloneNode(srcNamespaceId),\n      }),\n    );\n  }\n\n  const srcNamespace =\n    wrapReference(srcNamespaceId, sourceMetadata.wrap) ?? srcNamespaceId;\n\n  if (constantReexports) {\n    statements.push(\n      ...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference),\n    );\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (!t.isIdentifier(srcNamespace)\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: t.cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      t.cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\ninterface ReexportParts {\n  exports: string;\n  exportName: string;\n  namespaceImport: t.Expression;\n}\n\nconst ReexportTemplate = {\n  constant: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      ${exports}.${exportName} = ${namespaceImport};\n    `,\n  constantComputed: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      ${exports}[\"${exportName}\"] = ${namespaceImport};\n    `,\n  spec: ({ exports, exportName, namespaceImport }: ReexportParts) =>\n    template.statement.ast`\n      Object.defineProperty(${exports}, \"${exportName}\", {\n        enumerable: true,\n        get: function() {\n          return ${namespaceImport};\n        },\n      });\n    `,\n};\n\nfunction buildReexportsFromMeta(\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n): t.Statement[] {\n  let namespace: t.Expression = t.identifier(metadata.name);\n  namespace = wrapReference(namespace, metadata.wrap) ?? namespace;\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let namespaceImport: t.Expression = t.cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      namespaceImport = t.memberExpression(\n        namespaceImport,\n        t.stringLiteral(importName),\n        true,\n      );\n    } else {\n      namespaceImport = t.memberExpression(\n        namespaceImport,\n        t.identifier(importName),\n      );\n    }\n    const astNodes: ReexportParts = {\n      exports: meta.exportName,\n      exportName,\n      namespaceImport,\n    };\n    if (constantReexports || t.isIdentifier(namespaceImport)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Expression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambiguous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: t.variableDeclaration(\"var\", [\n      t.variableDeclarator(name, t.valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, t.identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(\n        metadata,\n        data,\n        false,\n        wrapReference,\n      );\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\ninterface InitParts {\n  exports: string;\n  name: string;\n  value: t.Expression;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`${exports}[\"${name}\"] = ${value}`,\n  default: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`${exports}.${name} = ${value}`,\n  define: ({ exports, name, value }: InitParts) =>\n    template.expression.ast`\n      Object.defineProperty(${exports}, \"${name}\", {\n        enumerable: true,\n        value: void 0,\n        writable: true\n      })[\"${name}\"] = ${value}`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: exports } = metadata;\n  return t.expressionStatement(\n    exportNames.reduce((value, name) => {\n      const params = {\n        exports,\n        name,\n        value,\n      };\n\n      if (name === \"__proto__\") {\n        return InitTemplate.define(params);\n      }\n\n      if (stringSpecifiers.has(name)) {\n        return InitTemplate.computed(params);\n      }\n\n      return InitTemplate.default(params);\n    }, initExpr),\n  );\n}\n"],"names":["_assert","require","_core","_helperModuleImports","_rewriteThis","_rewriteLiveReferences","_normalizeAndLoadMetadata","Lazy","_dynamicImport","_getModuleName","exports","getDynamicImportSource","rewriteModuleStatementsAndPrepareHeader","path","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","getWrapperPayload","toGetWrapperPayload","wrapReference","esNamespaceOnly","filename","constantReexports","arguments","loose","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","assert","isModule","node","sourceType","meta","normalizeModuleAndLoadMetadata","initializeReexports","rewriteThis","rewriteLiveReferences","hasStrict","directives","some","directive","value","unshiftContainer","t","directiveLiteral","headers","hasExports","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","ensureStatementsHoisted","statements","forEach","header","_blockHoist","wrapInterop","programPath","expr","type","callExpression","hub","addHelper","booleanLiteral","helper","Error","buildNamespaceInitStatements","metadata","sourceMetadata","_wrapReference","srcNamespaceId","identifier","localName","importsNamespace","template","NAME","SOURCE","cloneNode","srcNamespace","wrap","buildReexportsFromMeta","reexportNamespace","isIdentifier","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","namespaceImport","ast","constantComputed","spec","_wrapReference2","namespace","stringSpecifiers","Array","from","reexports","importName","interop","has","memberExpression","stringLiteral","astNodes","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","Object","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","default","variableDeclaration","variableDeclarator","valueToNode","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","define","exportNames","initExpr","expressionStatement","reduce","params"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4591, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4596, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-plugin-utils/src/index.ts"],"sourcesContent":["import type {\n  PluginAPI,\n  PluginObject,\n  PluginPass,\n  PresetAPI,\n  PresetObject,\n} from \"@babel/core\";\n\ntype APIPolyfillFactory<T extends keyof PluginAPI> = (\n  api: PluginAPI,\n) => PluginAPI[T];\n\ntype APIPolyfills = {\n  assertVersion: APIPolyfillFactory<\"assertVersion\">;\n};\n\nconst apiPolyfills: APIPolyfills = {\n  // Not supported by Babel 7 and early versions of Babel 7 beta.\n  // It's important that this is polyfilled for older Babel versions\n  // since it's needed to report the version mismatch.\n  assertVersion: (api: PluginAPI) => (range: number | string) => {\n    throwVersionError(range, api.version);\n  },\n};\nif (!process.env.BABEL_8_BREAKING) {\n  Object.assign(apiPolyfills, {\n    // This is supported starting from Babel 7.13\n    targets: () => () => {\n      return {};\n    },\n    // This is supported starting from Babel 7.13\n    assumption: () => () => {\n      return undefined;\n    },\n    // This is supported starting from Babel 7.17\n    addExternalDependency: () => () => {},\n  });\n}\n\nexport function declare<State = object, Option = object>(\n  builder: (\n    api: PluginAPI,\n    options: Option,\n    dirname: string,\n  ) => PluginObject<State & PluginPass>,\n): (\n  api: PluginAPI,\n  options: Option,\n  dirname: string,\n) => PluginObject<State & PluginPass> {\n  return (api, options: Option, dirname: string) => {\n    let clonedApi: PluginAPI;\n\n    for (const name of Object.keys(\n      apiPolyfills,\n    ) as (keyof typeof apiPolyfills)[]) {\n      if (api[name]) continue;\n\n      clonedApi ??= copyApiObject(api);\n      clonedApi[name] = apiPolyfills[name](clonedApi);\n    }\n\n    // @ts-expect-error options || {} may not be assigned to Options\n    return builder(clonedApi ?? api, options || {}, dirname);\n  };\n}\n\nexport const declarePreset = declare as <Option = object>(\n  builder: (api: PresetAPI, options: Option, dirname: string) => PresetObject,\n) => (api: PresetAPI, options: Option, dirname: string) => PresetObject;\n\nfunction copyApiObject(api: PluginAPI): PluginAPI {\n  // Babel >= 7 <= beta.41 passed the API as a new object that had\n  // babel/core as the prototype. While slightly faster, it also\n  // means that the Object.assign copy below fails. Rather than\n  // keep complexity, the Babel 6 behavior has been reverted and this\n  // normalizes all that for Babel 7.\n  let proto = null;\n  if (typeof api.version === \"string\" && /^7\\./.test(api.version)) {\n    proto = Object.getPrototypeOf(api);\n    if (\n      proto &&\n      (!Object.hasOwn(proto, \"version\") ||\n        !Object.hasOwn(proto, \"transform\") ||\n        !Object.hasOwn(proto, \"template\") ||\n        !Object.hasOwn(proto, \"types\"))\n    ) {\n      proto = null;\n    }\n  }\n\n  return {\n    ...proto,\n    ...api,\n  };\n}\n\nfunction throwVersionError(range: string | number, version: string) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    // Bump up the limit if needed so that users are more likely\n    // to be able to see what is calling Babel.\n    Error.stackTraceLimit = 25;\n  }\n\n  let err;\n  if (version.slice(0, 2) === \"7.\") {\n    err = new Error(\n      `Requires Babel \"^7.0.0-beta.41\", but was loaded with \"${version}\". ` +\n        `You'll need to update your @babel/core version.`,\n    );\n  } else {\n    err = new Error(\n      `Requires Babel \"${range}\", but was loaded with \"${version}\". ` +\n        `If you are sure you have a compatible version of @babel/core, ` +\n        `it is likely that something in your build process is loading the ` +\n        `wrong version. Inspect the stack trace of this error to look for ` +\n        `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` +\n        `to see what is calling Babel.`,\n    );\n  }\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version,\n    range,\n  } as any);\n}\n"],"names":["apiPolyfills","assertVersion","api","range","throwVersionError","version","Object","assign","targets","assumption","undefined","addExternalDependency","declare","builder","options","dirname","_clonedApi2","clonedApi","name","keys","_clonedApi","copyApiObject","declarePreset","exports","proto","test","getPrototypeOf","hasOwnProperty","call","Number","isInteger","Error","limit","stackTraceLimit","err","slice","code"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4670, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4675, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-syntax-jsx/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"syntax-jsx\",\n\n    manipulateOptions(opts, parserOpts) {\n      if (!process.env.BABEL_8_BREAKING) {\n        // If the Typescript plugin already ran, it will have decided whether\n        // or not this is a TSX file.\n        if (\n          parserOpts.plugins.some(\n            p => (Array.isArray(p) ? p[0] : p) === \"typescript\",\n          )\n        ) {\n          return;\n        }\n      }\n\n      parserOpts.plugins.push(\"jsx\");\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","opts","parserOpts","plugins","some","p","Array","isArray","push"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,YAAY;QAElBC,iBAAiBA,EAACC,IAAI,EAAEC,UAAU,EAAE;YACC;gBAGjC,IACEA,UAAU,CAACC,OAAO,CAACC,IAAI,EACrBC,CAAC,GAAI,CAACC,KAAK,CAACC,OAAO,CAACF,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,MAAM,YACzC,CAAC,EACD;oBACA;gBACF;YACF;YAEAH,UAAU,CAACC,OAAO,CAACK,IAAI,CAAC,KAAK,CAAC;QAChC;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4700, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-annotate-as-pure/src/index.ts"],"sourcesContent":["import { addComment, type Node } from \"@babel/types\";\n\nconst PURE_ANNOTATION = \"#__PURE__\";\n\nconst isPureAnnotated = ({ leadingComments }: Node): boolean =>\n  !!leadingComments &&\n  leadingComments.some(comment => /[@#]__PURE__/.test(comment.value));\n\nexport default function annotateAsPure(\n  pathOrNode: Node | { node: Node },\n): void {\n  const node =\n    // @ts-expect-error Node will not have `node` property\n    (pathOrNode[\"node\"] || pathOrNode) as Node;\n  if (isPureAnnotated(node)) {\n    return;\n  }\n  addComment(node, \"leading\", PURE_ANNOTATION);\n}\n"],"names":["_t","require","addComment","PURE_ANNOTATION","isPureAnnotated","leadingComments","some","comment","test","value","annotateAsPure","pathOrNode","node"],"mappings":";;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAAqD,MAAA,EAA5CC,UAAAA,EAAU,GAAAF,EAAA;AAEnB,MAAMG,eAAe,GAAG,WAAW;AAEnC,MAAMC,eAAe,GAAGA,CAAC,EAAEC,eAAAA,EAAuB,GAChD,CAAC,CAACA,eAAe,IACjBA,eAAe,CAACC,IAAI,EAACC,OAAO,GAAI,cAAc,CAACC,IAAI,CAACD,OAAO,CAACE,KAAK,CAAC,CAAC;AAEtD,SAASC,cAAcA,CACpCC,UAAiC,EAC3B;IACN,MAAMC,IAAI,GAEPD,UAAU,CAAC,MAAM,CAAC,IAAIA,UAAmB;IAC5C,IAAIP,eAAe,CAACQ,IAAI,CAAC,EAAE;QACzB;IACF;IACAV,UAAU,CAACU,IAAI,EAAE,SAAS,EAAET,eAAe,CAAC;AAC9C","ignoreList":[0]}},
    {"offset": {"line": 4716, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4721, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-jsx/src/create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginPass, NodePath, Scope, Visitor } from \"@babel/core\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*(?:\\*\\s*)?@jsxImportSource\\s+(\\S+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*(?:\\*\\s*)?@jsxRuntime\\s+(\\S+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*(?:\\*\\s*)?@jsx\\s+(\\S+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*(?:\\*\\s*)?@jsxFrag\\s+(\\S+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n          ? \"automatic\"\n          : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-transform-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n\n      if (filter != null && RUNTIME_DEFAULT === \"automatic\") {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: \"filter\" option can not be used with automatic runtime. If you are upgrading from Babel 7, please specify `runtime: \"classic\"`.',\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO(Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      },\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if the method is a constructor.\n          if (path.node.kind !== \"constructor\") {\n            // We are not in a constructor, therefore it is always fine to use `this`.\n            return true;\n          }\n          // Now we are in a constructor. If it is a derived class, we do not reference `this`.\n          return !isDerivedClass(path.parentPath.parentPath as NodePath<Class>);\n        }\n        if (path.isTSModuleBlock()) {\n          // If the closest parent is a TS Module block, `this` will not be allowed.\n          return false;\n        }\n      } while ((scope = scope.parent));\n      // We are not in a method or function. It is fine to use `this`.\n      return true;\n    }\n\n    function call(\n      pass: PluginPass,\n      name: string,\n      args: CallExpression[\"arguments\"],\n    ) {\n      const node = t.callExpression(get(pass, `id/${name}`)(), args);\n      if (PURE_ANNOTATION ?? get(pass, \"defaultPure\")) annotateAsPure(node);\n      return node;\n    }\n\n    // We want to use React.createElement, even in the case of\n    // jsx, for <div {...props} key={key} /> to distinguish it\n    // from <div key={key} {...props} />. This is an intermediary\n    // step while we deprecate key spread from props. Afterwards,\n    // we will stop using createElement in the transform.\n    function shouldUseCreateElement(path: NodePath<JSXElement>) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n\n      let seenPropsSpread = false;\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        if (\n          seenPropsSpread &&\n          t.isJSXAttribute(attr) &&\n          attr.name.name === \"key\"\n        ) {\n          return true;\n        } else if (t.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n      return false;\n    }\n\n    function convertJSXIdentifier(\n      node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n      parent: t.JSXOpeningElement | t.JSXMemberExpression,\n    ): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {\n      if (t.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && t.isReferenced(node, parent)) {\n          return t.thisExpression();\n        } else if (t.isValidIdentifier(node.name, false)) {\n          // @ts-expect-error cast AST type to Identifier\n          node.type = \"Identifier\";\n          return node as unknown as t.Identifier;\n        } else {\n          return t.stringLiteral(node.name);\n        }\n      } else if (t.isJSXMemberExpression(node)) {\n        return t.memberExpression(\n          convertJSXIdentifier(node.object, node),\n          convertJSXIdentifier(node.property, node),\n        );\n      } else if (t.isJSXNamespacedName(node)) {\n        /**\n         * If the flag \"throwIfNamespace\" is false\n         * print XMLNamespace like string literal\n         */\n        return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      // todo: this branch should be unreachable\n      return node;\n    }\n\n    function convertAttributeValue(\n      node: t.JSXAttribute[\"value\"] | t.BooleanLiteral,\n    ) {\n      if (t.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(\n      array: ObjectExpression[\"properties\"],\n      attribute: NodePath<JSXAttribute | JSXSpreadAttribute>,\n    ) {\n      if (t.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n        // Collect properties into props array if spreading object expression\n        if (t.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(t.spreadElement(arg));\n        }\n        return array;\n      }\n\n      const value = convertAttributeValue(\n        attribute.node.name.name !== \"key\"\n          ? attribute.node.value || t.booleanLiteral(true)\n          : attribute.node.value,\n      );\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError(\n          'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n        );\n      }\n\n      if (\n        t.isStringLiteral(value) &&\n        !t.isJSXExpressionContainer(attribute.node.value)\n      ) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n        // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n        delete value.extra?.raw;\n      }\n\n      if (t.isJSXNamespacedName(attribute.node.name)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(\n          attribute.node.name.namespace.name +\n            \":\" +\n            attribute.node.name.name.name,\n        );\n      } else if (t.isValidIdentifier(attribute.node.name.name, false)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(\n        t.inherits(\n          t.objectProperty(\n            // @ts-expect-error The attribute.node.name is an Identifier now\n            attribute.node.name,\n            value,\n          ),\n          attribute.node,\n        ),\n      );\n      return array;\n    }\n\n    function buildChildrenProperty(children: Expression[]) {\n      let childrenNode;\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = t.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return t.objectProperty(t.identifier(\"children\"), childrenNode);\n    }\n\n    // Builds JSX into:\n    // Production: React.jsx(type, arguments, key)\n    // Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)\n    function buildJSXElementCall(path: NodePath<JSXElement>, file: PluginPass) {\n      const openingPath = path.get(\"openingElement\");\n      const args: t.Expression[] = [getTag(openingPath)];\n\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      // for React.jsx, key, __source (dev), and __self (dev) is passed in as\n      // a separate argument rather than in the args object. We go through the\n      // props and filter out these three keywords so we can pass them in\n      // as separate arguments later\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n          const { name } = attr.node.name;\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n            /* falls through */\n            case \"key\": {\n              const keyValue = convertAttributeValue(attr.node.value);\n              if (keyValue === null) {\n                throw attr.buildCodeFrameError(\n                  'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n                );\n              }\n\n              extracted[name] = keyValue;\n              break;\n            }\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = t.react.buildChildren(path.node);\n\n      let attribs: t.ObjectExpression;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(\n          attribsArray,\n          //@ts-expect-error The children here contains JSXSpreadChild,\n          // which will be thrown later\n          children,\n        );\n      } else {\n        // attributes should never be null\n        attribs = t.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        // isStaticChildren, __source, and __self are only used in development\n        // automatically include __source and __self in this plugin\n        // so we can eliminate the need for separate Babel plugins in Babel 8\n        args.push(\n          extracted.key ?? path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n        if (extracted.__source) {\n          args.push(extracted.__source);\n          if (extracted.__self) args.push(extracted.__self);\n        } else if (extracted.__self) {\n          args.push(path.scope.buildUndefinedNode(), extracted.__self);\n        }\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds props for React.jsx. This function adds children into the props\n    // and ensures that props is always an object\n    function buildJSXOpeningElementAttributes(\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n      children: Expression[],\n    ) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      // In React.jsx, children is no longer a separate argument, but passed in\n      // through the argument object\n      if (children?.length > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return t.objectExpression(props);\n    }\n\n    // Builds JSX Fragment <></> into\n    // Production: React.jsx(type, arguments)\n    // Development: React.jsxDEV(type, { children })\n    function buildJSXFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = t.react.buildChildren(path.node);\n\n      args.push(\n        t.objectExpression(\n          children.length > 0\n            ? [\n                buildChildrenProperty(\n                  //@ts-expect-error The children here contains JSXSpreadChild,\n                  // which will be thrown later\n                  children,\n                ),\n              ]\n            : [],\n        ),\n      );\n\n      if (development) {\n        args.push(\n          path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds JSX Fragment <></> into\n    // React.createElement(React.Fragment, null, ...children)\n    function buildCreateElementFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      if (filter && !filter(path.node, file)) return;\n\n      return call(file, \"createElement\", [\n        get(file, \"id/fragment\")(),\n        t.nullLiteral(),\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    // Builds JSX into:\n    // Production: React.createElement(type, arguments, children)\n    // Development: React.createElement(type, arguments, children, source, self)\n    function buildCreateElementCall(\n      path: NodePath<JSXElement>,\n      file: PluginPass,\n    ) {\n      const openingPath = path.get(\"openingElement\");\n\n      return call(file, \"createElement\", [\n        getTag(openingPath),\n        buildCreateElementOpeningElementAttributes(\n          file,\n          path,\n          openingPath.get(\"attributes\"),\n        ),\n        // @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    function getTag(openingPath: NodePath<JSXOpeningElement>) {\n      const tagExpr = convertJSXIdentifier(\n        openingPath.node.name,\n        openingPath.node,\n      );\n\n      let tagName: string;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (t.react.isCompatTag(tagName)) {\n        return t.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    /**\n     * The logic for this is quite terse. It's because we need to\n     * support spread elements. We loop over all attributes,\n     * breaking on spreads, we then push a new object containing\n     * all prior attributes to an array for later processing.\n     */\n    function buildCreateElementOpeningElementAttributes(\n      file: PluginPass,\n      path: NodePath<JSXElement>,\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n    ) {\n      const runtime = get(file, \"runtime\");\n      if (!process.env.BABEL_8_BREAKING) {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            // Convert syntax to use multiple objects instead of spread\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (t.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(t.objectExpression(props.slice(start, i)));\n                }\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n            if (props.length > start) {\n              objs.push(t.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(t.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return t.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (\n              !(\n                t.isSpreadElement(props[0]) &&\n                // If an object expression is spread element's argument\n                // it is very likely to contain __proto__ and we should stop\n                // optimizing spread element\n                t.isObjectExpression(props[0].argument)\n              )\n            ) {\n              return objs[0];\n            }\n          }\n\n          // looks like we have multiple objects\n          if (!t.isObjectExpression(objs[0])) {\n            objs.unshift(t.objectExpression([]));\n          }\n\n          const helper = useBuiltIns\n            ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n            : file.addHelper(\"extends\");\n\n          // spread it\n          return t.callExpression(helper, objs);\n        }\n      }\n\n      const props: ObjectExpression[\"properties\"] = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const { node } = attr;\n        const name =\n          t.isJSXAttribute(node) &&\n          t.isJSXIdentifier(node.name) &&\n          node.name.name;\n\n        if (\n          runtime === \"automatic\" &&\n          (name === \"__source\" || name === \"__self\")\n        ) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 &&\n        t.isSpreadElement(props[0]) &&\n        // If an object expression is spread element's argument\n        // it is very likely to contain __proto__ and we should stop\n        // optimizing spread element\n        !t.isObjectExpression(props[0].argument)\n        ? props[0].argument\n        : props.length > 0\n          ? t.objectExpression(props)\n          : t.nullLiteral();\n    }\n  });\n\n  function getSource(source: string, importName: string) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(\n    pass: PluginPass,\n    path: NodePath<Program>,\n    importName: string,\n    source: string,\n  ): () => Identifier | MemberExpression {\n    return () => {\n      const actualSource = getSource(source, importName);\n      if (isModule(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return t.cloneNode(reference);\n\n        reference = addNamed(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\",\n        });\n        set(pass, `imports/${importName}`, reference);\n\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n        if (reference) {\n          reference = t.cloneNode(reference);\n        } else {\n          reference = addNamespace(path, actualSource, {\n            importedInterop: \"uncompiled\",\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return t.memberExpression(reference, t.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id: string): Identifier | MemberExpression {\n  return (\n    id\n      .split(\".\")\n      .map(name => t.identifier(name))\n      // @ts-expect-error - The Array#reduce does not have a signature\n      // where the type of initial value differs from callback return type\n      .reduce((object, property) => t.memberExpression(object, property))\n  );\n}\n\nfunction makeSource(path: NodePath, state: PluginPass) {\n  const location = path.node.loc;\n  if (!location) {\n    // the element was generated and doesn't have location information\n    return path.scope.buildUndefinedNode();\n  }\n\n  // @ts-expect-error todo: avoid mutating PluginPass\n  if (!state.fileNameIdentifier) {\n    const { filename = \"\" } = state;\n\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    path.scope.getProgramParent().push({\n      id: fileNameIdentifier,\n      init: t.stringLiteral(filename),\n    });\n    // @ts-expect-error todo: avoid mutating PluginPass\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(\n    t.cloneNode(\n      // @ts-expect-error todo: avoid mutating PluginPass\n      state.fileNameIdentifier,\n    ),\n    location.start.line,\n    location.start.column,\n  );\n}\n\nfunction makeTrace(\n  fileNameIdentifier: Identifier,\n  lineNumber?: number,\n  column0Based?: number,\n) {\n  const fileLineLiteral =\n    lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n\n  const fileColumnLiteral =\n    column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n\n  return template.expression.ast`{\n    fileName: ${fileNameIdentifier},\n    lineNumber: ${fileLineLiteral},\n    columnNumber: ${fileColumnLiteral},\n  }`;\n}\n\nfunction sourceSelfError(path: NodePath, name: string) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n\n  return path.buildCodeFrameError(\n    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,\n  );\n}\n"],"names":["_pluginSyntaxJsx","require","_helperPluginUtils","_core","_helperModuleImports","_helperAnnotateAsPure","DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","declare","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXFragment","exit","callExpr","buildCreateElementFragmentCall","buildJSXFragmentCall","replaceWith","JSXElement","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","annotateAsPure","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","_value$extra","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","_extracted$key","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","getProgramParent","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","template","pluginName"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5215, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5220, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-jsx/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\n\nimport createPlugin from \"./create-plugin.ts\";\n\nexport default createPlugin({\n  name: \"transform-react-jsx\",\n  development: false,\n});\n\nexport type { Options } from \"./create-plugin.ts\";\n"],"names":["_createPlugin","require","_default","exports","default","createPlugin","name","development"],"mappings":";;;;;AAEA,IAAAA,aAAA,GAAAC,OAAA;AAA8C,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE/B,CAAA,GAAAC,cAAAA,OAAY,EAAC;IAC1BC,IAAI,EAAE,qBAAqB;IAC3BC,WAAW,EAAE;AACf,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5230, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5235, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-jsx/src/development.ts"],"sourcesContent":["import createPlugin from \"./create-plugin.ts\";\n\nexport default createPlugin({\n  name: \"transform-react-jsx/development\",\n  development: true,\n});\n"],"names":["_createPlugin","require","_default","exports","default","createPlugin","name","development"],"mappings":";;;;;AAAA,IAAAA,aAAA,GAAAC,OAAA;AAA8C,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE/B,CAAA,GAAAC,cAAAA,OAAY,EAAC;IAC1BC,IAAI,EAAE,iCAAiC;IACvCC,WAAW,EAAE;AACf,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5245, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5250, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-jsx-development/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\n\nimport plugin from \"@babel/plugin-transform-react-jsx/lib/development\";\n// We need to explicitly annotate this export because\n// @babel/plugin-transform-react-jsx/lib/development has no type definitions\n// (it's not a public entry point)\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\nexport default plugin as typeof import(\"@babel/plugin-transform-react-jsx\").default;\n"],"names":["_development","require","_default","exports","default","plugin"],"mappings":";;;;;AAEA,IAAAA,YAAA,GAAAC,OAAA;AAAuE,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAKxDC,aAAAA,OAAM","ignoreList":[0]}},
    {"offset": {"line": 5257, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5262, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-display-name/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport path from \"path\";\nimport { types as t } from \"@babel/core\";\n\ntype ReactCreateClassCall = t.CallExpression & {\n  arguments: [t.ObjectExpression];\n};\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  function addDisplayName(id: string, call: ReactCreateClassCall) {\n    const props = call.arguments[0].properties;\n    let safe = true;\n\n    for (let i = 0; i < props.length; i++) {\n      const prop = props[i];\n      if (t.isSpreadElement(prop)) {\n        continue;\n      }\n      const key = t.toComputedKey(prop);\n      if (t.isStringLiteral(key, { value: \"displayName\" })) {\n        safe = false;\n        break;\n      }\n    }\n\n    if (safe) {\n      props.unshift(\n        t.objectProperty(t.identifier(\"displayName\"), t.stringLiteral(id)),\n      );\n    }\n  }\n\n  const isCreateClassCallExpression =\n    t.buildMatchMemberExpression(\"React.createClass\");\n  const isCreateClassAddon = (callee: t.CallExpression[\"callee\"]) =>\n    t.isIdentifier(callee, { name: \"createReactClass\" });\n\n  function isCreateClass(node?: t.Node): node is ReactCreateClassCall {\n    if (!node || !t.isCallExpression(node)) return false;\n\n    // not createReactClass nor React.createClass call member object\n    if (\n      !isCreateClassCallExpression(node.callee) &&\n      !isCreateClassAddon(node.callee)\n    ) {\n      return false;\n    }\n\n    // no call arguments\n    const args = node.arguments;\n    if (args.length !== 1) return false;\n\n    // first node arg is not an object\n    const first = args[0];\n    if (!t.isObjectExpression(first)) return false;\n\n    return true;\n  }\n\n  return {\n    name: \"transform-react-display-name\",\n\n    visitor: {\n      ExportDefaultDeclaration({ node }, state) {\n        if (isCreateClass(node.declaration)) {\n          const filename = state.filename || \"unknown\";\n\n          let displayName = path.basename(filename, path.extname(filename));\n\n          // ./{module name}/index.js\n          if (displayName === \"index\") {\n            displayName = path.basename(path.dirname(filename));\n          }\n\n          addDisplayName(displayName, node.declaration);\n        }\n      },\n\n      CallExpression(path) {\n        const { node } = path;\n        if (!isCreateClass(node)) return;\n\n        let id: t.LVal | t.Expression | t.PrivateName | null;\n\n        // crawl up the ancestry looking for possible candidates for displayName inference\n        path.find(function (path) {\n          if (path.isAssignmentExpression()) {\n            id = path.node.left;\n          } else if (path.isObjectProperty()) {\n            id = path.node.key;\n          } else if (path.isVariableDeclarator()) {\n            id = path.node.id;\n          } else if (path.isStatement()) {\n            // we've hit a statement, we should stop crawling up\n            return true;\n          }\n\n          // we've got an id! no need to continue\n          if (id) return true;\n        });\n\n        // ensure that we have an identifier we can inherit from\n        if (!id) return;\n\n        // foo.bar -> bar\n        if (t.isMemberExpression(id)) {\n          id = id.property;\n        }\n\n        // identifiers are the only thing we can reliably get a name from\n        if (t.isIdentifier(id)) {\n          addDisplayName(id.name, node);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_path","_core","_default","exports","default","declare","api","assertVersion","addDisplayName","id","call","props","arguments","properties","safe","i","length","prop","t","isSpreadElement","key","toComputedKey","isStringLiteral","value","unshift","objectProperty","identifier","stringLiteral","isCreateClassCallExpression","buildMatchMemberExpression","isCreateClassAddon","callee","isIdentifier","name","isCreateClass","node","isCallExpression","args","first","isObjectExpression","visitor","ExportDefaultDeclaration","state","declaration","filename","displayName","path","basename","extname","dirname","CallExpression","find","isAssignmentExpression","left","isObjectProperty","isVariableDeclarator","isStatement","isMemberExpression","property"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5347, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5352, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-pure-annotations/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\n// Mapping of React top-level methods that are pure.\n// This plugin adds a /*#__PURE__#/ annotation to calls to these methods,\n// so that terser and other minifiers can safely remove them during dead\n// code elimination.\n// See https://reactjs.org/docs/react-api.html\nconst PURE_CALLS: [string, Set<string>][] = [\n  [\n    \"react\",\n    new Set([\n      \"cloneElement\",\n      \"createContext\",\n      \"createElement\",\n      \"createFactory\",\n      \"createRef\",\n      \"forwardRef\",\n      \"isValidElement\",\n      \"memo\",\n      \"lazy\",\n    ]),\n  ],\n  [\"react-dom\", new Set([\"createPortal\"])],\n];\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-react-pure-annotations\",\n    visitor: {\n      CallExpression(path) {\n        if (isReactCall(path)) {\n          annotateAsPure(path);\n        }\n      },\n    },\n  };\n});\n\nfunction isReactCall(path: NodePath<t.CallExpression>) {\n  // If the callee is not a member expression, then check if it matches\n  // a named import, e.g. `import {forwardRef} from 'react'`.\n  const calleePath = path.get(\"callee\");\n  if (!calleePath.isMemberExpression()) {\n    for (const [module, methods] of PURE_CALLS) {\n      for (const method of methods) {\n        if (calleePath.referencesImport(module, method)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  // Otherwise, check if the member expression's object matches\n  // a default import (`import React from 'react'`) or namespace\n  // import (`import * as React from 'react'), and check if the\n  // property matches one of the pure methods.\n  const object = calleePath.get(\"object\");\n  const callee = calleePath.node;\n  if (!callee.computed && t.isIdentifier(callee.property)) {\n    const propertyName = callee.property.name;\n    for (const [module, methods] of PURE_CALLS) {\n      if (\n        object.referencesImport(module, \"default\") ||\n        object.referencesImport(module, \"*\")\n      ) {\n        return methods.has(propertyName);\n      }\n    }\n  }\n\n  return false;\n}\n"],"names":["_helperPluginUtils","require","_helperAnnotateAsPure","_core","PURE_CALLS","Set","_default","exports","default","declare","api","assertVersion","name","visitor","CallExpression","path","isReactCall","annotateAsPure","calleePath","get","isMemberExpression","module","methods","method","referencesImport","object","callee","node","computed","t","isIdentifier","property","propertyName","has"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,qBAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAOA,MAAMG,UAAmC,GAAG;IAC1C;QACE,OAAO;QACP,IAAIC,GAAG,CAAC;YACN,cAAc;YACd,eAAe;YACf,eAAe;YACf,eAAe;YACf,WAAW;YACX,YAAY;YACZ,gBAAgB;YAChB,MAAM;YACN,MAAM;SACP,CAAC;KACH;IACD;QAAC,WAAW;QAAE,IAAIA,GAAG,CAAC;YAAC,cAAc;SAAC,CAAC;KAAC;CACzC;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEa,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,kCAAkC;QACxCC,OAAO,EAAE;YACPC,cAAcA,EAACC,IAAI,EAAE;gBACnB,IAAIC,WAAW,CAACD,IAAI,CAAC,EAAE;oBACrB,CAAA,GAAAE,sBAAAA,OAAc,EAACF,IAAI,CAAC;gBACtB;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC;AAEF,SAASC,WAAWA,CAACD,IAAgC,EAAE;IAGrD,MAAMG,UAAU,GAAGH,IAAI,CAACI,GAAG,CAAC,QAAQ,CAAC;IACrC,IAAI,CAACD,UAAU,CAACE,kBAAkB,CAAC,CAAC,EAAE;QACpC,KAAK,MAAM,CAACC,MAAM,EAAEC,OAAO,CAAC,IAAIlB,UAAU,CAAE;YAC1C,KAAK,MAAMmB,MAAM,IAAID,OAAO,CAAE;gBAC5B,IAAIJ,UAAU,CAACM,gBAAgB,CAACH,MAAM,EAAEE,MAAM,CAAC,EAAE;oBAC/C,OAAO,IAAI;gBACb;YACF;QACF;QAEA,OAAO,KAAK;IACd;IAMA,MAAME,MAAM,GAAGP,UAAU,CAACC,GAAG,CAAC,QAAQ,CAAC;IACvC,MAAMO,MAAM,GAAGR,UAAU,CAACS,IAAI;IAC9B,IAAI,CAACD,MAAM,CAACE,QAAQ,IAAIC,MAAAA,KAAC,CAACC,YAAY,CAACJ,MAAM,CAACK,QAAQ,CAAC,EAAE;QACvD,MAAMC,YAAY,GAAGN,MAAM,CAACK,QAAQ,CAACnB,IAAI;QACzC,KAAK,MAAM,CAACS,MAAM,EAAEC,OAAO,CAAC,IAAIlB,UAAU,CAAE;YAC1C,IACEqB,MAAM,CAACD,gBAAgB,CAACH,MAAM,EAAE,SAAS,CAAC,IAC1CI,MAAM,CAACD,gBAAgB,CAACH,MAAM,EAAE,GAAG,CAAC,EACpC;gBACA,OAAOC,OAAO,CAACW,GAAG,CAACD,YAAY,CAAC;YAClC;QACF;IACF;IAEA,OAAO,KAAK;AACd","ignoreList":[0]}},
    {"offset": {"line": 5419, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5424, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-react/src/normalize-options.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-react/src/index.ts"],"sourcesContent":["import {\n  OptionValidator,\n  findSuggestion,\n} from \"@babel/helper-validator-option\";\nconst v = new OptionValidator(\"@babel/preset-react\");\n\nexport default function normalizeOptions(options: any = {}) {\n  if (process.env.BABEL_8_BREAKING) {\n    if (\"useSpread\" in options) {\n      throw new Error(\n        '@babel/preset-react: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n      );\n    }\n\n    if (\"useBuiltIns\" in options) {\n      const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n      throw new Error(\n        `@babel/preset-react: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    [\"@babel/plugin-transform-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ],\n  \"presets\": [\"@babel/preset-react\"]\n}`,\n      );\n    }\n\n    const TopLevelOptions = {\n      development: \"development\",\n      importSource: \"importSource\",\n      pragma: \"pragma\",\n      pragmaFrag: \"pragmaFrag\",\n      pure: \"pure\",\n      runtime: \"runtime\",\n      throwIfNamespace: \"throwIfNamespace\",\n    };\n    v.validateTopLevelOptions(options, TopLevelOptions);\n    const development = v.validateBooleanOption(\n      TopLevelOptions.development,\n      options.development,\n    );\n    let importSource = v.validateStringOption(\n      TopLevelOptions.importSource,\n      options.importSource,\n    );\n    let pragma = v.validateStringOption(TopLevelOptions.pragma, options.pragma);\n    let pragmaFrag = v.validateStringOption(\n      TopLevelOptions.pragmaFrag,\n      options.pragmaFrag,\n    );\n    const pure = v.validateBooleanOption(TopLevelOptions.pure, options.pure);\n    const runtime = v.validateStringOption(\n      TopLevelOptions.runtime,\n      options.runtime,\n      \"automatic\",\n    );\n    const throwIfNamespace = v.validateBooleanOption(\n      TopLevelOptions.throwIfNamespace,\n      options.throwIfNamespace,\n      true,\n    );\n\n    const validRuntime = [\"classic\", \"automatic\"];\n\n    if (runtime === \"classic\") {\n      pragma = pragma || \"React.createElement\";\n      pragmaFrag = pragmaFrag || \"React.Fragment\";\n    } else if (runtime === \"automatic\") {\n      importSource = importSource || \"react\";\n    } else {\n      throw new Error(\n        `@babel/preset-react: 'runtime' must be one of ['automatic', 'classic'] but we have '${runtime}'\\n` +\n          `- Did you mean '${findSuggestion(runtime, validRuntime)}'?`,\n      );\n    }\n\n    return {\n      development,\n      importSource,\n      pragma,\n      pragmaFrag,\n      pure,\n      runtime,\n      throwIfNamespace,\n    };\n  } else {\n    let { pragma, pragmaFrag } = options;\n\n    const {\n      pure,\n      throwIfNamespace = true,\n      runtime = \"classic\",\n      importSource,\n      useBuiltIns,\n      useSpread,\n    } = options;\n\n    if (runtime === \"classic\") {\n      pragma = pragma || \"React.createElement\";\n      pragmaFrag = pragmaFrag || \"React.Fragment\";\n    }\n\n    const development =\n      options.development == null ? undefined : !!options.development;\n\n    return {\n      development,\n      importSource,\n      pragma,\n      pragmaFrag,\n      pure,\n      runtime,\n      throwIfNamespace,\n      useBuiltIns,\n      useSpread,\n    };\n  }\n}\n","import { declarePreset } from \"@babel/helper-plugin-utils\";\nimport transformReactJSX from \"@babel/plugin-transform-react-jsx\";\nimport transformReactJSXDevelopment from \"@babel/plugin-transform-react-jsx-development\";\nimport transformReactDisplayName from \"@babel/plugin-transform-react-display-name\";\nimport transformReactPure from \"@babel/plugin-transform-react-pure-annotations\";\nimport normalizeOptions from \"./normalize-options.ts\";\n\nexport interface Options {\n  development?: boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns?: boolean;\n  useSpread?: boolean;\n}\n\nexport default declarePreset((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    development = process.env.BABEL_8_BREAKING\n      ? api.env(env => env === \"development\")\n      : false,\n    importSource,\n    pragma,\n    pragmaFrag,\n    pure,\n    runtime,\n    throwIfNamespace,\n  } = normalizeOptions(opts);\n\n  return {\n    plugins: [\n      [\n        development ? transformReactJSXDevelopment : transformReactJSX,\n        process.env.BABEL_8_BREAKING\n          ? {\n              importSource,\n              pragma,\n              pragmaFrag,\n              runtime,\n              throwIfNamespace,\n              pure,\n            }\n          : {\n              importSource,\n              pragma,\n              pragmaFrag,\n              runtime,\n              throwIfNamespace,\n              pure,\n              useBuiltIns: !!opts.useBuiltIns,\n              useSpread: opts.useSpread,\n            },\n      ],\n      transformReactDisplayName,\n      pure !== false && transformReactPure,\n    ].filter(Boolean),\n  };\n});\n"],"names":["OptionValidator","normalizeOptions","options","pragma","pragmaFrag","pure","throwIfNamespace","runtime","importSource","useBuiltIns","useSpread","development","undefined","declarePreset","api","opts","assertVersion","plugins","transformReactJSXDevelopment","transformReactJSX","transformReactDisplayName","transformReactPure","filter","Boolean"],"mappings":";;;;;;;;;;;;;;;;;;;AAIU,IAAIA,sBAAAA,eAAe,CAAC,qBAAqB,EAAC;AAErC,SAASC,gBAAgBA,CAACC,OAAY,GAAG,CAAA,CAAE,EAAE;IAiFnD;QACL,IAAI,EAAEC,MAAM,EAAEC,UAAAA,EAAY,GAAGF,OAAO,CAAA;QAEpC,MAAM,EACJG,IAAI,EACJC,gBAAgB,GAAG,IAAI,EACvBC,OAAO,GAAG,SAAS,EACnBC,YAAY,EACZC,WAAW,EACXC,SAAAA,EACD,GAAGR,OAAO,CAAA;QAEX,IAAIK,OAAO,KAAK,SAAS,EAAE;YACzBJ,MAAM,GAAGA,MAAM,IAAI,qBAAqB,CAAA;YACxCC,UAAU,GAAGA,UAAU,IAAI,gBAAgB,CAAA;QAC7C,CAAA;QAEA,MAAMO,WAAW,GACfT,OAAO,CAACS,WAAW,IAAI,IAAI,GAAGC,SAAS,GAAG,CAAC,CAACV,OAAO,CAACS,WAAW,CAAA;QAEjE,OAAO;YACLA,WAAW;YACXH,YAAY;YACZL,MAAM;YACNC,UAAU;YACVC,IAAI;YACJE,OAAO;YACPD,gBAAgB;YAChBG,WAAW;YACXC,SAAAA;SACD,CAAA;IACH,CAAA;AACF;ACpGA,IAAA,QAAeG,kBAAAA,aAAa,CAAC,CAACC,GAAG,EAAEC,IAAa,KAAK;IACnDD,GAAG,CAACE,aAAa,CAAkB,CAAE,CAAC,CAAA;IAEtC,MAAM,EACJL,WAAW,GAEP,KAAK,EACTH,YAAY,EACZL,MAAM,EACNC,UAAU,EACVC,IAAI,EACJE,OAAO,EACPD,gBAAAA,EACD,GAAGL,gBAAgB,CAACc,IAAI,CAAC,CAAA;IAE1B,OAAO;QACLE,OAAO,EAAE;YACP;gBACEN,WAAW,GAAGO,sCAAAA,OAA4B,GAAGC,2BAAAA,OAAiB;gBAU1D;oBACEX,YAAY;oBACZL,MAAM;oBACNC,UAAU;oBACVG,OAAO;oBACPD,gBAAgB;oBAChBD,IAAI;oBACJI,WAAW,EAAE,CAAC,CAACM,IAAI,CAACN,WAAW;oBAC/BC,SAAS,EAAEK,IAAI,CAACL,SAAAA;gBAClB,CAAC;aACN;YACDU,mCAAAA,OAAyB;YACzBf,IAAI,KAAK,KAAK,IAAIgB,4BAAAA,OAAkB;SACrC,CAACC,MAAM,CAACC,OAAO,CAAA;KACjB,CAAA;AACH,CAAC,CAAC","ignoreList":[0,1]}},
    {"offset": {"line": 5490, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5495, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/debug.ts"],"sourcesContent":["import {\n  getInclusionReasons,\n  type Targets,\n  type Target,\n} from \"@babel/helper-compilation-targets\";\nimport compatData from \"@babel/compat-data/plugins\";\n\n// Outputs a message that shows which target(s) caused an item to be included:\n// transform-foo { \"edge\":\"13\", \"firefox\":\"49\", \"ie\":\"10\" }\nexport const logPlugin = (\n  item: string,\n  targetVersions: Targets,\n  list: { [key: string]: Targets },\n) => {\n  const filteredList = getInclusionReasons(item, targetVersions, list);\n\n  const support = list[item];\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // It's needed to keep outputting proposal- in the debug log.\n    if (item.startsWith(\"transform-\")) {\n      const proposalName = `proposal-${item.slice(10)}`;\n      if (\n        proposalName === \"proposal-dynamic-import\" ||\n        Object.hasOwn(compatData, proposalName)\n      ) {\n        item = proposalName;\n      }\n    }\n  }\n\n  if (!support) {\n    console.log(`  ${item}`);\n    return;\n  }\n\n  let formattedTargets = `{`;\n  let first = true;\n  for (const target of Object.keys(filteredList) as Target[]) {\n    if (!first) formattedTargets += `,`;\n    first = false;\n    formattedTargets += ` ${target}`;\n    if (support[target]) formattedTargets += ` < ${support[target]}`;\n  }\n  formattedTargets += ` }`;\n\n  console.log(`  ${item} ${formattedTargets}`);\n};\n"],"names":["_helperCompilationTargets","require","_plugins","logPlugin","item","targetVersions","list","filteredList","getInclusionReasons","support","startsWith","proposalName","slice","hasOwnProperty","call","compatData","console","log","formattedTargets","first","target","Object","keys","exports"],"mappings":";;;;;AAAA,IAAAA,yBAAA,GAAAC,OAAA;AAKA,IAAAC,QAAA,GAAAD,OAAA;AAIO,MAAME,SAAS,GAAGA,CACvBC,IAAY,EACZC,cAAuB,EACvBC,IAAgC,KAC7B;IACH,MAAMC,YAAY,GAAG,CAAA,GAAAC,0BAAAA,mBAAmB,EAACJ,IAAI,EAAEC,cAAc,EAAEC,IAAI,CAAC;IAEpE,MAAMG,OAAO,GAAGH,IAAI,CAACF,IAAI,CAAC;IAES;QAEjC,IAAIA,IAAI,CAACM,UAAU,CAAC,YAAY,CAAC,EAAE;YACjC,MAAMC,YAAY,GAAG,CAAA,SAAA,EAAYP,IAAI,CAACQ,KAAK,CAAC,EAAE,CAAC,EAAE;YACjD,IACED,YAAY,KAAK,yBAAyB,IAC1CE,cAAA,CAAAC,IAAA,CAAcC,QAAU,EAAEJ,YAAY,CAAC,EACvC;gBACAP,IAAI,GAAGO,YAAY;YACrB;QACF;IACF;IAEA,IAAI,CAACF,OAAO,EAAE;QACZO,OAAO,CAACC,GAAG,CAAC,CAAA,EAAA,EAAKb,IAAI,EAAE,CAAC;QACxB;IACF;IAEA,IAAIc,gBAAgB,GAAG,CAAA,CAAA,CAAG;IAC1B,IAAIC,KAAK,GAAG,IAAI;IAChB,KAAK,MAAMC,MAAM,IAAIC,MAAM,CAACC,IAAI,CAACf,YAAY,CAAC,CAAc;QAC1D,IAAI,CAACY,KAAK,EAAED,gBAAgB,IAAI,CAAA,CAAA,CAAG;QACnCC,KAAK,GAAG,KAAK;QACbD,gBAAgB,IAAI,CAAA,CAAA,EAAIE,MAAM,EAAE;QAChC,IAAIX,OAAO,CAACW,MAAM,CAAC,EAAEF,gBAAgB,IAAI,CAAA,GAAA,EAAMT,OAAO,CAACW,MAAM,CAAC,EAAE;IAClE;IACAF,gBAAgB,IAAI,CAAA,EAAA,CAAI;IAExBF,OAAO,CAACC,GAAG,CAAC,CAAA,EAAA,EAAKb,IAAI,CAAA,CAAA,EAAIc,gBAAgB,EAAE,CAAC;AAC9C,CAAC;AAACK,OAAA,CAAApB,SAAA,GAAAA,SAAA","ignoreList":[0]}},
    {"offset": {"line": 5529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5534, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/babel-7-available-plugins.cjs"],"sourcesContent":["// TODO(Babel 8): Remove this file\n\nif (!process.env.BABEL_8_BREAKING) {\n  // We need to keep these plugins because they do not simply enable a\n  // feature, but can affect the AST shape (.attributes vs .assertions).\n  // TLA is only used for local development with ESM.\n  const availablePlugins = {\n    \"syntax-import-assertions\": () =>\n      require(\"@babel/plugin-syntax-import-assertions\"),\n    \"syntax-import-attributes\": () =>\n      require(\"@babel/plugin-syntax-import-attributes\"),\n  };\n\n  module.exports = availablePlugins;\n}\n"],"names":["availablePlugins","syntax-import-assertions","require","syntax-import-attributes","module","exports"],"mappings":"AAEmC;IAIjC,MAAMA,gBAAgB,GAAG;QACvB,0BAA0B,EAAEC,CAAA,KAC1BC,OAAO,CAAC,wCAAwC,CAAC;QACnD,0BAA0B,EAAEC,CAAA,KAC1BD,OAAO,CAAC,wCAAwC;IACpD,CAAC;IAEDE,MAAM,CAACC,OAAO,GAAGL,gBAAgB;AACnC","ignoreList":[0]}},
    {"offset": {"line": 5541, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5546, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/available-plugins.ts"],"sourcesContent":["/* eslint sort-keys: \"error\" */\n\nimport otherBabel7Plugins from \"./babel-7-available-plugins.cjs\";\n\nimport transformAsyncGeneratorFunctions from \"@babel/plugin-transform-async-generator-functions\";\nimport transformAsyncToGenerator from \"@babel/plugin-transform-async-to-generator\";\nimport transformArrowFunctions from \"@babel/plugin-transform-arrow-functions\";\nimport transformBlockScopedFunctions from \"@babel/plugin-transform-block-scoped-functions\";\nimport transformBlockScoping from \"@babel/plugin-transform-block-scoping\";\nimport transformClasses from \"@babel/plugin-transform-classes\";\nimport transformClassProperties from \"@babel/plugin-transform-class-properties\";\nimport transformClassStaticBlock from \"@babel/plugin-transform-class-static-block\";\nimport transformComputedProperties from \"@babel/plugin-transform-computed-properties\";\nimport transformDestructuring from \"@babel/plugin-transform-destructuring\";\nimport transformDotallRegex from \"@babel/plugin-transform-dotall-regex\";\nimport transformDuplicateKeys from \"@babel/plugin-transform-duplicate-keys\";\nimport transformDuplicateNamedCapturingGroupsRegex from \"@babel/plugin-transform-duplicate-named-capturing-groups-regex\";\nimport transformDynamicImport from \"@babel/plugin-transform-dynamic-import\";\nimport transformExponentialOperator from \"@babel/plugin-transform-exponentiation-operator\";\nimport transformExportNamespaceFrom from \"@babel/plugin-transform-export-namespace-from\";\nimport transformForOf from \"@babel/plugin-transform-for-of\";\nimport transformFunctionName from \"@babel/plugin-transform-function-name\";\nimport transformJsonStrings from \"@babel/plugin-transform-json-strings\";\nimport transformLiterals from \"@babel/plugin-transform-literals\";\nimport transformLogicalAssignmentOperators from \"@babel/plugin-transform-logical-assignment-operators\";\nimport transformMemberExpressionLiterals from \"@babel/plugin-transform-member-expression-literals\";\nimport transformModulesAmd from \"@babel/plugin-transform-modules-amd\";\nimport transformModulesCommonjs from \"@babel/plugin-transform-modules-commonjs\";\nimport transformModulesSystemjs from \"@babel/plugin-transform-modules-systemjs\";\nimport transformModulesUmd from \"@babel/plugin-transform-modules-umd\";\nimport transformNamedCapturingGroupsRegex from \"@babel/plugin-transform-named-capturing-groups-regex\";\nimport transformNewTarget from \"@babel/plugin-transform-new-target\";\nimport transformNullishCoalescingOperator from \"@babel/plugin-transform-nullish-coalescing-operator\";\nimport transformNumericSeparator from \"@babel/plugin-transform-numeric-separator\";\nimport transformObjectRestSpread from \"@babel/plugin-transform-object-rest-spread\";\nimport transformObjectSuper from \"@babel/plugin-transform-object-super\";\nimport transformOptionalCatchBinding from \"@babel/plugin-transform-optional-catch-binding\";\nimport transformOptionalChaining from \"@babel/plugin-transform-optional-chaining\";\nimport transformParameters from \"@babel/plugin-transform-parameters\";\nimport transformPrivateMethods from \"@babel/plugin-transform-private-methods\";\nimport transformPrivatePropertyInObject from \"@babel/plugin-transform-private-property-in-object\";\nimport transformPropertyLiterals from \"@babel/plugin-transform-property-literals\";\nimport transformRegenerator from \"@babel/plugin-transform-regenerator\";\nimport transformRegExpModifiers from \"@babel/plugin-transform-regexp-modifiers\";\nimport transformReservedWords from \"@babel/plugin-transform-reserved-words\";\nimport transformShorthandProperties from \"@babel/plugin-transform-shorthand-properties\";\nimport transformSpread from \"@babel/plugin-transform-spread\";\nimport transformStickyRegex from \"@babel/plugin-transform-sticky-regex\";\nimport transformTemplateLiterals from \"@babel/plugin-transform-template-literals\";\nimport transformTypeofSymbol from \"@babel/plugin-transform-typeof-symbol\";\nimport transformUnicodeEscapes from \"@babel/plugin-transform-unicode-escapes\";\nimport transformUnicodePropertyRegex from \"@babel/plugin-transform-unicode-property-regex\";\nimport transformUnicodeRegex from \"@babel/plugin-transform-unicode-regex\";\nimport transformUnicodeSetsRegex from \"@babel/plugin-transform-unicode-sets-regex\";\n\nimport bugfixAsyncArrowsInClass from \"@babel/preset-modules/lib/plugins/transform-async-arrows-in-class/index.js\";\nimport bugfixEdgeDefaultParameters from \"@babel/preset-modules/lib/plugins/transform-edge-default-parameters/index.js\";\nimport bugfixEdgeFunctionName from \"@babel/preset-modules/lib/plugins/transform-edge-function-name/index.js\";\nimport bugfixFirefoxClassInComputedKey from \"@babel/plugin-bugfix-firefox-class-in-computed-class-key\";\nimport bugfixTaggedTemplateCaching from \"@babel/preset-modules/lib/plugins/transform-tagged-template-caching/index.js\";\nimport bugfixSafariBlockShadowing from \"@babel/preset-modules/lib/plugins/transform-safari-block-shadowing/index.js\";\nimport bugfixSafariForShadowing from \"@babel/preset-modules/lib/plugins/transform-safari-for-shadowing/index.js\";\nimport bugfixSafariIdDestructuringCollisionInFunctionExpression from \"@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression\";\nimport bugfixSafariClassFieldInitializerScope from \"@babel/plugin-bugfix-safari-class-field-initializer-scope\";\nimport bugfixV8SpreadParametersInOptionalChaining from \"@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining\";\nimport bugfixV8StaticClassFieldsRedefineReadonly from \"@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly\";\n\nexport { availablePlugins as default };\nconst availablePlugins = {\n  \"bugfix/transform-async-arrows-in-class\": () => bugfixAsyncArrowsInClass,\n  \"bugfix/transform-edge-default-parameters\": () => bugfixEdgeDefaultParameters,\n  \"bugfix/transform-edge-function-name\": () => bugfixEdgeFunctionName,\n  \"bugfix/transform-firefox-class-in-computed-class-key\": () =>\n    bugfixFirefoxClassInComputedKey,\n  \"bugfix/transform-safari-block-shadowing\": () => bugfixSafariBlockShadowing,\n  \"bugfix/transform-safari-class-field-initializer-scope\": () =>\n    bugfixSafariClassFieldInitializerScope,\n  \"bugfix/transform-safari-for-shadowing\": () => bugfixSafariForShadowing,\n  \"bugfix/transform-safari-id-destructuring-collision-in-function-expression\":\n    () => bugfixSafariIdDestructuringCollisionInFunctionExpression,\n  \"bugfix/transform-tagged-template-caching\": () => bugfixTaggedTemplateCaching,\n  \"bugfix/transform-v8-spread-parameters-in-optional-chaining\": () =>\n    bugfixV8SpreadParametersInOptionalChaining,\n  \"bugfix/transform-v8-static-class-fields-redefine-readonly\": () =>\n    bugfixV8StaticClassFieldsRedefineReadonly,\n  \"transform-arrow-functions\": () => transformArrowFunctions,\n  \"transform-async-generator-functions\": () => transformAsyncGeneratorFunctions,\n  \"transform-async-to-generator\": () => transformAsyncToGenerator,\n  \"transform-block-scoped-functions\": () => transformBlockScopedFunctions,\n  \"transform-block-scoping\": () => transformBlockScoping,\n  \"transform-class-properties\": () => transformClassProperties,\n  \"transform-class-static-block\": () => transformClassStaticBlock,\n  \"transform-classes\": () => transformClasses,\n  \"transform-computed-properties\": () => transformComputedProperties,\n  \"transform-destructuring\": () => transformDestructuring,\n  \"transform-dotall-regex\": () => transformDotallRegex,\n  \"transform-duplicate-keys\": () => transformDuplicateKeys,\n  \"transform-duplicate-named-capturing-groups-regex\": () =>\n    transformDuplicateNamedCapturingGroupsRegex,\n  \"transform-dynamic-import\": () => transformDynamicImport,\n  \"transform-exponentiation-operator\": () => transformExponentialOperator,\n  \"transform-export-namespace-from\": () => transformExportNamespaceFrom,\n  \"transform-for-of\": () => transformForOf,\n  \"transform-function-name\": () => transformFunctionName,\n  \"transform-json-strings\": () => transformJsonStrings,\n  \"transform-literals\": () => transformLiterals,\n  \"transform-logical-assignment-operators\": () =>\n    transformLogicalAssignmentOperators,\n  \"transform-member-expression-literals\": () =>\n    transformMemberExpressionLiterals,\n  \"transform-modules-amd\": () => transformModulesAmd,\n  \"transform-modules-commonjs\": () => transformModulesCommonjs,\n  \"transform-modules-systemjs\": () => transformModulesSystemjs,\n  \"transform-modules-umd\": () => transformModulesUmd,\n  \"transform-named-capturing-groups-regex\": () =>\n    transformNamedCapturingGroupsRegex,\n  \"transform-new-target\": () => transformNewTarget,\n  \"transform-nullish-coalescing-operator\": () =>\n    transformNullishCoalescingOperator,\n  \"transform-numeric-separator\": () => transformNumericSeparator,\n  \"transform-object-rest-spread\": () => transformObjectRestSpread,\n  \"transform-object-super\": () => transformObjectSuper,\n  \"transform-optional-catch-binding\": () => transformOptionalCatchBinding,\n  \"transform-optional-chaining\": () => transformOptionalChaining,\n  \"transform-parameters\": () => transformParameters,\n  \"transform-private-methods\": () => transformPrivateMethods,\n  \"transform-private-property-in-object\": () =>\n    transformPrivatePropertyInObject,\n  \"transform-property-literals\": () => transformPropertyLiterals,\n  \"transform-regenerator\": () => transformRegenerator,\n  \"transform-regexp-modifiers\": () => transformRegExpModifiers,\n  \"transform-reserved-words\": () => transformReservedWords,\n  \"transform-shorthand-properties\": () => transformShorthandProperties,\n  \"transform-spread\": () => transformSpread,\n  \"transform-sticky-regex\": () => transformStickyRegex,\n  \"transform-template-literals\": () => transformTemplateLiterals,\n  \"transform-typeof-symbol\": () => transformTypeofSymbol,\n  \"transform-unicode-escapes\": () => transformUnicodeEscapes,\n  \"transform-unicode-property-regex\": () => transformUnicodePropertyRegex,\n  \"transform-unicode-regex\": () => transformUnicodeRegex,\n  \"transform-unicode-sets-regex\": () => transformUnicodeSetsRegex,\n};\n\nexport const minVersions = {};\n// TODO(Babel 8): Remove this\nexport let legacyBabel7SyntaxPlugins: Set<string>;\n\nif (!process.env.BABEL_8_BREAKING) {\n  /* eslint-disable no-restricted-globals */\n\n  Object.assign(minVersions, {\n    \"bugfix/transform-safari-id-destructuring-collision-in-function-expression\":\n      \"7.16.0\",\n    \"bugfix/transform-v8-static-class-fields-redefine-readonly\": \"7.12.0\",\n    \"syntax-import-attributes\": \"7.22.0\",\n    \"transform-class-static-block\": \"7.12.0\",\n    \"transform-duplicate-named-capturing-groups-regex\": \"7.19.0\",\n    \"transform-private-property-in-object\": \"7.10.0\",\n    \"transform-regexp-modifiers\": \"7.19.0\",\n  });\n\n  // This is a factory to create a plugin that enables a parser plugin\n  const syntax =\n    (name: ParserPlugin) => (): typeof transformJsonStrings => () => ({\n      manipulateOptions: (_, p) => p.plugins.push(name),\n    });\n  type ParserPlugin = Parameters<\n    ReturnType<typeof transformJsonStrings>[\"manipulateOptions\"]\n  >[1][\"plugins\"][number];\n\n  const legacyBabel7SyntaxPluginsLoaders = {\n    \"syntax-async-generators\": syntax(\"asyncGenerators\"),\n    \"syntax-class-properties\": syntax(\"classProperties\"),\n    \"syntax-class-static-block\": syntax(\"classStaticBlock\"),\n    \"syntax-dynamic-import\": syntax(\"dynamicImport\"),\n    \"syntax-export-namespace-from\": syntax(\"exportNamespaceFrom\"),\n    \"syntax-import-meta\": syntax(\"importMeta\"),\n    \"syntax-json-strings\": syntax(\"jsonStrings\"),\n    \"syntax-logical-assignment-operators\": syntax(\"logicalAssignment\"),\n    \"syntax-nullish-coalescing-operator\": syntax(\"nullishCoalescingOperator\"),\n    \"syntax-numeric-separator\": syntax(\"numericSeparator\"),\n    \"syntax-object-rest-spread\": syntax(\"objectRestSpread\"),\n    \"syntax-optional-catch-binding\": syntax(\"optionalCatchBinding\"),\n    \"syntax-optional-chaining\": syntax(\"optionalChaining\"),\n    \"syntax-private-property-in-object\": syntax(\"privateIn\"),\n    \"syntax-top-level-await\": syntax(\"topLevelAwait\"),\n\n    // These are CJS plugins that depend on a package from the monorepo, so it\n    // breaks using ESM. Given that ESM builds are new enough to have this\n    // syntax enabled by default, we can safely skip enabling it.\n\n    \"syntax-unicode-sets-regex\":\n      USE_ESM || IS_STANDALONE\n        ? () => () => ({})\n        : () => require(\"@babel/plugin-syntax-unicode-sets-regex\"),\n\n    // We need to keep these plugins because they do not simply enable a\n    // feature, but can affect the AST shape (.attributes vs .assertions).\n    // TLA is only used for local development with ESM, since we cannot\n    // require() monorepo files in that case.\n    // eslint-disable-next-line sort-keys\n    \"syntax-import-assertions\":\n      USE_ESM && !IS_STANDALONE\n        ? await import(\"@babel/plugin-syntax-import-assertions\").then(\n            m => () => m.default,\n          )\n        : otherBabel7Plugins[\"syntax-import-assertions\"],\n    \"syntax-import-attributes\":\n      USE_ESM && !IS_STANDALONE\n        ? await import(\"@babel/plugin-syntax-import-attributes\").then(\n            m => () => m.default,\n          )\n        : otherBabel7Plugins[\"syntax-import-attributes\"],\n  };\n\n  Object.assign(availablePlugins, legacyBabel7SyntaxPluginsLoaders);\n\n  legacyBabel7SyntaxPlugins = new Set(\n    Object.keys(legacyBabel7SyntaxPluginsLoaders),\n  );\n}\n"],"names":["_babel7AvailablePlugins","require","_pluginTransformAsyncGeneratorFunctions","_pluginTransformAsyncToGenerator","_pluginTransformArrowFunctions","_pluginTransformBlockScopedFunctions","_pluginTransformBlockScoping","_pluginTransformClasses","_pluginTransformClassProperties","_pluginTransformClassStaticBlock","_pluginTransformComputedProperties","_pluginTransformDestructuring","_pluginTransformDotallRegex","_pluginTransformDuplicateKeys","_pluginTransformDuplicateNamedCapturingGroupsRegex","_pluginTransformDynamicImport","_pluginTransformExponentiationOperator","_pluginTransformExportNamespaceFrom","_pluginTransformForOf","_pluginTransformFunctionName","_pluginTransformJsonStrings","_pluginTransformLiterals","_pluginTransformLogicalAssignmentOperators","_pluginTransformMemberExpressionLiterals","_pluginTransformModulesAmd","_pluginTransformModulesCommonjs","_pluginTransformModulesSystemjs","_pluginTransformModulesUmd","_pluginTransformNamedCapturingGroupsRegex","_pluginTransformNewTarget","_pluginTransformNullishCoalescingOperator","_pluginTransformNumericSeparator","_pluginTransformObjectRestSpread","_pluginTransformObjectSuper","_pluginTransformOptionalCatchBinding","_pluginTransformOptionalChaining","_pluginTransformParameters","_pluginTransformPrivateMethods","_pluginTransformPrivatePropertyInObject","_pluginTransformPropertyLiterals","_pluginTransformRegenerator","_pluginTransformRegexpModifiers","_pluginTransformReservedWords","_pluginTransformShorthandProperties","_pluginTransformSpread","_pluginTransformStickyRegex","_pluginTransformTemplateLiterals","_pluginTransformTypeofSymbol","_pluginTransformUnicodeEscapes","_pluginTransformUnicodePropertyRegex","_pluginTransformUnicodeRegex","_pluginTransformUnicodeSetsRegex","_index","_index2","_index3","_pluginBugfixFirefoxClassInComputedClassKey","_index4","_index5","_index6","_pluginBugfixSafariIdDestructuringCollisionInFunctionExpression","_pluginBugfixSafariClassFieldInitializerScope","_pluginBugfixV8SpreadParametersInOptionalChaining","_pluginBugfixV8StaticClassFieldsRedefineReadonly","availablePlugins","exports","default","bugfix/transform-async-arrows-in-class","bugfixAsyncArrowsInClass","bugfix/transform-edge-default-parameters","bugfixEdgeDefaultParameters","bugfix/transform-edge-function-name","bugfixEdgeFunctionName","bugfix/transform-firefox-class-in-computed-class-key","bugfixFirefoxClassInComputedKey","bugfix/transform-safari-block-shadowing","bugfixSafariBlockShadowing","bugfix/transform-safari-class-field-initializer-scope","bugfixSafariClassFieldInitializerScope","bugfix/transform-safari-for-shadowing","bugfixSafariForShadowing","bugfix/transform-safari-id-destructuring-collision-in-function-expression","bugfixSafariIdDestructuringCollisionInFunctionExpression","bugfix/transform-tagged-template-caching","bugfixTaggedTemplateCaching","bugfix/transform-v8-spread-parameters-in-optional-chaining","bugfixV8SpreadParametersInOptionalChaining","bugfix/transform-v8-static-class-fields-redefine-readonly","bugfixV8StaticClassFieldsRedefineReadonly","transform-arrow-functions","transformArrowFunctions","transform-async-generator-functions","transformAsyncGeneratorFunctions","transform-async-to-generator","transformAsyncToGenerator","transform-block-scoped-functions","transformBlockScopedFunctions","transform-block-scoping","transformBlockScoping","transform-class-properties","transformClassProperties","transform-class-static-block","transformClassStaticBlock","transform-classes","transformClasses","transform-computed-properties","transformComputedProperties","transform-destructuring","transformDestructuring","transform-dotall-regex","transformDotallRegex","transform-duplicate-keys","transformDuplicateKeys","transform-duplicate-named-capturing-groups-regex","transformDuplicateNamedCapturingGroupsRegex","transform-dynamic-import","transformDynamicImport","transform-exponentiation-operator","transformExponentialOperator","transform-export-namespace-from","transformExportNamespaceFrom","transform-for-of","transformForOf","transform-function-name","transformFunctionName","transform-json-strings","transformJsonStrings","transform-literals","transformLiterals","transform-logical-assignment-operators","transformLogicalAssignmentOperators","transform-member-expression-literals","transformMemberExpressionLiterals","transform-modules-amd","transformModulesAmd","transform-modules-commonjs","transformModulesCommonjs","transform-modules-systemjs","transformModulesSystemjs","transform-modules-umd","transformModulesUmd","transform-named-capturing-groups-regex","transformNamedCapturingGroupsRegex","transform-new-target","transformNewTarget","transform-nullish-coalescing-operator","transformNullishCoalescingOperator","transform-numeric-separator","transformNumericSeparator","transform-object-rest-spread","transformObjectRestSpread","transform-object-super","transformObjectSuper","transform-optional-catch-binding","transformOptionalCatchBinding","transform-optional-chaining","transformOptionalChaining","transform-parameters","transformParameters","transform-private-methods","transformPrivateMethods","transform-private-property-in-object","transformPrivatePropertyInObject","transform-property-literals","transformPropertyLiterals","transform-regenerator","transformRegenerator","transform-regexp-modifiers","transformRegExpModifiers","transform-reserved-words","transformReservedWords","transform-shorthand-properties","transformShorthandProperties","transform-spread","transformSpread","transform-sticky-regex","transformStickyRegex","transform-template-literals","transformTemplateLiterals","transform-typeof-symbol","transformTypeofSymbol","transform-unicode-escapes","transformUnicodeEscapes","transform-unicode-property-regex","transformUnicodePropertyRegex","transform-unicode-regex","transformUnicodeRegex","transform-unicode-sets-regex","transformUnicodeSetsRegex","minVersions","legacyBabel7SyntaxPlugins","Object","assign","syntax","name","manipulateOptions","_","p","plugins","push","legacyBabel7SyntaxPluginsLoaders","syntax-unicode-sets-regex","otherBabel7Plugins","Set","keys"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5714, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5719, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/filter-items.ts"],"sourcesContent":["import semver from \"semver\";\nimport { minVersions, legacyBabel7SyntaxPlugins } from \"./available-plugins.ts\";\n\nexport function addProposalSyntaxPlugins(\n  items: Set<string>,\n  proposalSyntaxPlugins: readonly string[],\n) {\n  proposalSyntaxPlugins.forEach(plugin => {\n    items.add(plugin);\n  });\n}\nexport function removeUnnecessaryItems(\n  items: Set<string>,\n  overlapping: { [name: string]: string[] },\n) {\n  items.forEach(item => {\n    overlapping[item]?.forEach(name => items.delete(name));\n  });\n}\nexport function removeUnsupportedItems(\n  items: Set<string>,\n  babelVersion: string,\n) {\n  items.forEach(item => {\n    if (\n      Object.hasOwn(minVersions, item) &&\n      semver.lt(\n        babelVersion,\n        // @ts-expect-error we have checked minVersions[item] in has call\n        minVersions[item],\n      )\n    ) {\n      items.delete(item);\n    } else if (\n      !process.env.BABEL_8_BREAKING &&\n      babelVersion[0] === \"8\" &&\n      legacyBabel7SyntaxPlugins.has(item)\n    ) {\n      items.delete(item);\n    }\n  });\n}\n"],"names":["_semver","require","_availablePlugins","addProposalSyntaxPlugins","items","proposalSyntaxPlugins","forEach","plugin","add","removeUnnecessaryItems","overlapping","item","_overlapping$item","name","delete","removeUnsupportedItems","babelVersion","hasOwnProperty","call","minVersions","semver","lt","legacyBabel7SyntaxPlugins","has"],"mappings":";;;;;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,iBAAA,GAAAD,OAAA;AAEO,SAASE,wBAAwBA,CACtCC,KAAkB,EAClBC,qBAAwC,EACxC;IACAA,qBAAqB,CAACC,OAAO,EAACC,MAAM,IAAI;QACtCH,KAAK,CAACI,GAAG,CAACD,MAAM,CAAC;IACnB,CAAC,CAAC;AACJ;AACO,SAASE,sBAAsBA,CACpCL,KAAkB,EAClBM,WAAyC,EACzC;IACAN,KAAK,CAACE,OAAO,EAACK,IAAI,IAAI;QAAA,IAAAC,iBAAA;QACpB,CAAAA,iBAAA,GAAAF,WAAW,CAACC,IAAI,CAAC,KAAA,QAAjBC,iBAAA,CAAmBN,OAAO,EAACO,IAAI,GAAIT,KAAK,CAACU,MAAM,CAACD,IAAI,CAAC,CAAC;IACxD,CAAC,CAAC;AACJ;AACO,SAASE,sBAAsBA,CACpCX,KAAkB,EAClBY,YAAoB,EACpB;IACAZ,KAAK,CAACE,OAAO,EAACK,IAAI,IAAI;QACpB,IACEM,cAAA,CAAAC,IAAA,CAAcC,kBAAAA,WAAW,EAAER,IAAI,CAAC,IAChCS,OAAM,CAACC,EAAE,CACPL,YAAY,EAEZG,kBAAAA,WAAW,CAACR,IAAI,CAClB,CAAC,EACD;YACAP,KAAK,CAACU,MAAM,CAACH,IAAI,CAAC;QACpB,CAAC,MAAM,IAELK,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,IACvBM,kBAAAA,yBAAyB,CAACC,GAAG,CAACZ,IAAI,CAAC,EACnC;YACAP,KAAK,CAACU,MAAM,CAACH,IAAI,CAAC;QACpB;IACF,CAAC,CAAC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5748, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5753, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/module-transformations.ts"],"sourcesContent":["type AvailablePlugins = typeof import(\"./available-plugins\").default;\n\nexport default {\n  amd: \"transform-modules-amd\",\n  commonjs: \"transform-modules-commonjs\",\n  cjs: \"transform-modules-commonjs\",\n  systemjs: \"transform-modules-systemjs\",\n  umd: \"transform-modules-umd\",\n} as { [transform: string]: keyof AvailablePlugins };\n"],"names":["amd","commonjs","cjs","systemjs","umd"],"mappings":";;;;;iCAEe;IACbA,GAAG,EAAE,uBAAuB;IAC5BC,QAAQ,EAAE,4BAA4B;IACtCC,GAAG,EAAE,4BAA4B;IACjCC,QAAQ,EAAE,4BAA4B;IACtCC,GAAG,EAAE;AACP,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5770, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/plugins-compat-data.ts"],"sourcesContent":["import originalPlugins from \"@babel/compat-data/plugins\";\nimport originalPluginsBugfixes from \"@babel/compat-data/plugin-bugfixes\";\nimport originalOverlappingPlugins from \"@babel/compat-data/overlapping-plugins\";\nimport availablePlugins from \"./available-plugins.ts\";\n\nconst keys: <O extends object>(o: O) => (keyof O)[] = Object.keys;\n\nexport const plugins = filterAvailable(originalPlugins);\nexport const pluginsBugfixes = filterAvailable(originalPluginsBugfixes);\nexport const overlappingPlugins = filterAvailable(originalOverlappingPlugins);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error: we extend this here, since it's a syntax plugin and thus\n  // doesn't make sense to store it in a compat-data package.\n  overlappingPlugins[\"syntax-import-attributes\"] = [\"syntax-import-assertions\"];\n}\n\nfunction filterAvailable<Data extends { [name: string]: unknown }>(\n  data: Data,\n): { [Name in keyof Data & keyof typeof availablePlugins]: Data[Name] } {\n  const result = {} as any;\n  for (const plugin of keys(data)) {\n    if (Object.hasOwn(availablePlugins, plugin)) {\n      result[plugin] = data[plugin];\n    }\n  }\n  return result;\n}\n"],"names":["_plugins","require","_pluginBugfixes","_overlappingPlugins","_availablePlugins","keys","Object","plugins","exports","filterAvailable","originalPlugins","pluginsBugfixes","originalPluginsBugfixes","overlappingPlugins","originalOverlappingPlugins","data","result","plugin","hasOwnProperty","call","availablePlugins"],"mappings":";;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,eAAA,GAAAD,OAAA;AACA,IAAAE,mBAAA,GAAAF,OAAA;AACA,IAAAG,iBAAA,GAAAH,OAAA;AAEA,MAAMI,IAA6C,GAAGC,MAAM,CAACD,IAAI;AAE1D,MAAME,OAAO,GAAAC,OAAA,CAAAD,OAAA,GAAGE,eAAe,CAACC,QAAe,CAAC;AAChD,MAAMC,eAAe,GAAAH,OAAA,CAAAG,eAAA,GAAGF,eAAe,CAACG,eAAuB,CAAC;AAChE,MAAMC,kBAAkB,GAAAL,OAAA,CAAAK,kBAAA,GAAGJ,eAAe,CAACK,mBAA0B,CAAC;AAE1C;IAGjCD,kBAAkB,CAAC,0BAA0B,CAAC,GAAG;QAAC,0BAA0B;KAAC;AAC/E,CAEA,SAASJ,eAAeA,CACtBM,IAAU,EAC4D;IACtE,MAAMC,MAAM,GAAG,CAAC,CAAQ;IACxB,KAAK,MAAMC,MAAM,IAAIZ,IAAI,CAACU,IAAI,CAAC,CAAE;QAC/B,IAAIG,cAAA,CAAAC,IAAA,CAAcC,kBAAAA,OAAgB,EAAEH,MAAM,CAAC,EAAE;YAC3CD,MAAM,CAACC,MAAM,CAAC,GAAGF,IAAI,CAACE,MAAM,CAAC;QAC/B;IACF;IACA,OAAOD,MAAM;AACf","ignoreList":[0]}},
    {"offset": {"line": 5796, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5801, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/options.ts"],"sourcesContent":["export const TopLevelOptions = {\n  bugfixes: \"bugfixes\",\n  configPath: \"configPath\",\n  corejs: \"corejs\",\n  debug: \"debug\",\n  exclude: \"exclude\",\n  forceAllTransforms: \"forceAllTransforms\",\n  ignoreBrowserslistConfig: \"ignoreBrowserslistConfig\",\n  include: \"include\",\n  modules: \"modules\",\n  shippedProposals: \"shippedProposals\",\n  targets: \"targets\",\n  useBuiltIns: \"useBuiltIns\",\n  browserslistEnv: \"browserslistEnv\",\n} as const;\n\nif (!process.env.BABEL_8_BREAKING) {\n  Object.assign(TopLevelOptions, {\n    loose: \"loose\",\n    spec: \"spec\",\n  });\n}\n\nexport const ModulesOption = {\n  false: false,\n  auto: \"auto\",\n  amd: \"amd\",\n  commonjs: \"commonjs\",\n  cjs: \"cjs\",\n  systemjs: \"systemjs\",\n  umd: \"umd\",\n} as const;\n\nexport const UseBuiltInsOption = {\n  false: false,\n  entry: \"entry\",\n  usage: \"usage\",\n} as const;\n"],"names":["TopLevelOptions","exports","bugfixes","configPath","corejs","debug","exclude","forceAllTransforms","ignoreBrowserslistConfig","include","modules","shippedProposals","targets","useBuiltIns","browserslistEnv","Object","assign","loose","spec","ModulesOption","false","auto","amd","commonjs","cjs","systemjs","umd","UseBuiltInsOption","entry","usage"],"mappings":";;;;;AAAO,MAAMA,eAAe,GAAAC,OAAA,CAAAD,eAAA,GAAG;IAC7BE,QAAQ,EAAE,UAAU;IACpBC,UAAU,EAAE,YAAY;IACxBC,MAAM,EAAE,QAAQ;IAChBC,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,SAAS;IAClBC,kBAAkB,EAAE,oBAAoB;IACxCC,wBAAwB,EAAE,0BAA0B;IACpDC,OAAO,EAAE,SAAS;IAClBC,OAAO,EAAE,SAAS;IAClBC,gBAAgB,EAAE,kBAAkB;IACpCC,OAAO,EAAE,SAAS;IAClBC,WAAW,EAAE,aAAa;IAC1BC,eAAe,EAAE;AACnB,CAAU;AAEyB;IACjCC,MAAM,CAACC,MAAM,CAAChB,eAAe,EAAE;QAC7BiB,KAAK,EAAE,OAAO;QACdC,IAAI,EAAE;IACR,CAAC,CAAC;AACJ,CAEO,MAAMC,aAAa,GAAAlB,OAAA,CAAAkB,aAAA,GAAG;IAC3BC,KAAK,EAAE,KAAK;IACZC,IAAI,EAAE,MAAM;IACZC,GAAG,EAAE,KAAK;IACVC,QAAQ,EAAE,UAAU;IACpBC,GAAG,EAAE,KAAK;IACVC,QAAQ,EAAE,UAAU;IACpBC,GAAG,EAAE;AACP,CAAU;AAEH,MAAMC,iBAAiB,GAAA1B,OAAA,CAAA0B,iBAAA,GAAG;IAC/BP,KAAK,EAAE,KAAK;IACZQ,KAAK,EAAE,OAAO;IACdC,KAAK,EAAE;AACT,CAAU","ignoreList":[0]}},
    {"offset": {"line": 5840, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5845, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/polyfills/utils.cjs"],"sourcesContent":["// TODO(Babel 8) Remove this file\nif (process.env.BABEL_8_BREAKING) {\n  throw new Error(\n    \"Internal Babel error: This file should only be loaded in Babel 7\",\n  );\n}\n\nexports.getImportSource = function ({ node }) {\n  if (node.specifiers.length === 0) return node.source.value;\n};\n\nexports.getRequireSource = function ({ node }) {\n  if (node.type !== \"ExpressionStatement\") return;\n  const { expression } = node;\n  if (\n    expression.type === \"CallExpression\" &&\n    expression.callee.type === \"Identifier\" &&\n    expression.callee.name === \"require\" &&\n    expression.arguments.length === 1 &&\n    expression.arguments[0].type === \"StringLiteral\"\n  ) {\n    return expression.arguments[0].value;\n  }\n};\n\nexports.isPolyfillSource = function (source) {\n  return source === \"@babel/polyfill\" || source === \"core-js\";\n};\n"],"names":["exports","getImportSource","node","specifiers","length","source","value","getRequireSource","type","expression","callee","name","arguments","isPolyfillSource"],"mappings":";AAOAA,OAAO,CAACC,eAAe,GAAG,SAAU,EAAEC,IAAAA,EAAM,EAAE;IAC5C,IAAIA,IAAI,CAACC,UAAU,CAACC,MAAM,KAAK,CAAC,EAAE,OAAOF,IAAI,CAACG,MAAM,CAACC,KAAK;AAC5D,CAAC;AAEDN,OAAO,CAACO,gBAAgB,GAAG,SAAU,EAAEL,IAAAA,EAAM,EAAE;IAC7C,IAAIA,IAAI,CAACM,IAAI,KAAK,qBAAqB,EAAE;IACzC,MAAM,EAAEC,UAAAA,EAAY,GAAGP,IAAI;IAC3B,IACEO,UAAU,CAACD,IAAI,KAAK,gBAAgB,IACpCC,UAAU,CAACC,MAAM,CAACF,IAAI,KAAK,YAAY,IACvCC,UAAU,CAACC,MAAM,CAACC,IAAI,KAAK,SAAS,IACpCF,UAAU,CAACG,SAAS,CAACR,MAAM,KAAK,CAAC,IACjCK,UAAU,CAACG,SAAS,CAAC,CAAC,CAAC,CAACJ,IAAI,KAAK,eAAe,EAChD;QACA,OAAOC,UAAU,CAACG,SAAS,CAAC,CAAC,CAAC,CAACN,KAAK;IACtC;AACF,CAAC;AAEDN,OAAO,CAACa,gBAAgB,GAAG,SAAUR,MAAM,EAAE;IAC3C,OAAOA,MAAM,KAAK,iBAAiB,IAAIA,MAAM,KAAK,SAAS;AAC7D,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5859, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5864, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/polyfills/babel-polyfill.cjs"],"sourcesContent":["// TODO(Babel 8) Remove this file\nif (process.env.BABEL_8_BREAKING) {\n  throw new Error(\n    \"Internal Babel error: This file should only be loaded in Babel 7\",\n  );\n}\n\nconst {\n  getImportSource,\n  getRequireSource,\n  isPolyfillSource,\n} = require(\"./utils.cjs\");\n\nconst BABEL_POLYFILL_DEPRECATION = `\n  \\`@babel/polyfill\\` is deprecated. Please, use required parts of \\`core-js\\`\n  and \\`regenerator-runtime/runtime\\` separately`;\n\nconst NO_DIRECT_POLYFILL_IMPORT = `\n  When setting \\`useBuiltIns: 'usage'\\`, polyfills are automatically imported when needed.\n  Please remove the direct import of \\`SPECIFIER\\` or use \\`useBuiltIns: 'entry'\\` instead.`;\n\nmodule.exports = function ({ template }, { regenerator, deprecated, usage }) {\n  return {\n    name: \"preset-env/replace-babel-polyfill\",\n    visitor: {\n      ImportDeclaration(path) {\n        const src = getImportSource(path);\n        if (usage && isPolyfillSource(src)) {\n          console.warn(NO_DIRECT_POLYFILL_IMPORT.replace(\"SPECIFIER\", src));\n          if (!deprecated) path.remove();\n        } else if (src === \"@babel/polyfill\") {\n          if (deprecated) {\n            console.warn(BABEL_POLYFILL_DEPRECATION);\n          } else if (regenerator) {\n            path.replaceWithMultiple(template.ast`\n              import \"core-js\";\n              import \"regenerator-runtime/runtime.js\";\n            `);\n          } else {\n            path.replaceWith(template.ast`\n              import \"core-js\";\n            `);\n          }\n        }\n      },\n      Program(path) {\n        path.get(\"body\").forEach(bodyPath => {\n          const src = getRequireSource(bodyPath);\n          if (usage && isPolyfillSource(src)) {\n            console.warn(NO_DIRECT_POLYFILL_IMPORT.replace(\"SPECIFIER\", src));\n            if (!deprecated) bodyPath.remove();\n          } else if (src === \"@babel/polyfill\") {\n            if (deprecated) {\n              console.warn(BABEL_POLYFILL_DEPRECATION);\n            } else if (regenerator) {\n              bodyPath.replaceWithMultiple(template.ast`\n                require(\"core-js\");\n                require(\"regenerator-runtime/runtime.js\");\n              `);\n            } else {\n              bodyPath.replaceWith(template.ast`\n                require(\"core-js\");\n              `);\n            }\n          }\n        });\n      },\n    },\n  };\n};\n"],"names":["getImportSource","getRequireSource","isPolyfillSource","require","BABEL_POLYFILL_DEPRECATION","NO_DIRECT_POLYFILL_IMPORT","module","exports","template","regenerator","deprecated","usage","name","visitor","ImportDeclaration","path","src","console","warn","replace","remove","replaceWithMultiple","ast","replaceWith","Program","get","forEach","bodyPath"],"mappings":";AAOA,MAAM,EACJA,eAAe,EACfC,gBAAgB,EAChBC,gBAAAA,EACD,GAAGC,OAAO,CAAC,aAAa,CAAC;AAE1B,MAAMC,0BAA0B,GAAG,CAAA;;gDAEnC,CAAiD;AAEjD,MAAMC,yBAAyB,GAAG,CAAA;;2FAElC,CAA4F;AAE5FC,MAAM,CAACC,OAAO,GAAG,SAAU,EAAEC,QAAAA,EAAU,EAAE,EAAEC,WAAW,EAAEC,UAAU,EAAEC,KAAAA,EAAO,EAAE;IAC3E,OAAO;QACLC,IAAI,EAAE,mCAAmC;QACzCC,OAAO,EAAE;YACPC,iBAAiBA,EAACC,IAAI,EAAE;gBACtB,MAAMC,GAAG,GAAGhB,eAAe,CAACe,IAAI,CAAC;gBACjC,IAAIJ,KAAK,IAAIT,gBAAgB,CAACc,GAAG,CAAC,EAAE;oBAClCC,OAAO,CAACC,IAAI,CAACb,yBAAyB,CAACc,OAAO,CAAC,WAAW,EAAEH,GAAG,CAAC,CAAC;oBACjE,IAAI,CAACN,UAAU,EAAEK,IAAI,CAACK,MAAM,CAAC,CAAC;gBAChC,CAAC,MAAM,IAAIJ,GAAG,KAAK,iBAAiB,EAAE;oBACpC,IAAIN,UAAU,EAAE;wBACdO,OAAO,CAACC,IAAI,CAACd,0BAA0B,CAAC;oBAC1C,CAAC,MAAM,IAAIK,WAAW,EAAE;wBACtBM,IAAI,CAACM,mBAAmB,CAACb,QAAQ,CAACc,GAAG,CAAA;;;YAGjD,CAAa,CAAC;oBACJ,CAAC,MAAM;wBACLP,IAAI,CAACQ,WAAW,CAACf,QAAQ,CAACc,GAAG,CAAA;;YAEzC,CAAa,CAAC;oBACJ;gBACF;YACF,CAAC;YACDE,OAAOA,EAACT,IAAI,EAAE;gBACZA,IAAI,CAACU,GAAG,CAAC,MAAM,CAAC,CAACC,OAAO,EAACC,QAAQ,IAAI;oBACnC,MAAMX,GAAG,GAAGf,gBAAgB,CAAC0B,QAAQ,CAAC;oBACtC,IAAIhB,KAAK,IAAIT,gBAAgB,CAACc,GAAG,CAAC,EAAE;wBAClCC,OAAO,CAACC,IAAI,CAACb,yBAAyB,CAACc,OAAO,CAAC,WAAW,EAAEH,GAAG,CAAC,CAAC;wBACjE,IAAI,CAACN,UAAU,EAAEiB,QAAQ,CAACP,MAAM,CAAC,CAAC;oBACpC,CAAC,MAAM,IAAIJ,GAAG,KAAK,iBAAiB,EAAE;wBACpC,IAAIN,UAAU,EAAE;4BACdO,OAAO,CAACC,IAAI,CAACd,0BAA0B,CAAC;wBAC1C,CAAC,MAAM,IAAIK,WAAW,EAAE;4BACtBkB,QAAQ,CAACN,mBAAmB,CAACb,QAAQ,CAACc,GAAG,CAAA;;;cAGvD,CAAe,CAAC;wBACJ,CAAC,MAAM;4BACLK,QAAQ,CAACJ,WAAW,CAACf,QAAQ,CAACc,GAAG,CAAA;;cAE/C,CAAe,CAAC;wBACJ;oBACF;gBACF,CAAC,CAAC;YACJ;QACF;IACF,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5921, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5926, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/polyfills/regenerator.cjs"],"sourcesContent":["// TODO(Babel 8) Remove this file\nif (process.env.BABEL_8_BREAKING) {\n  throw new Error(\n    \"Internal Babel error: This file should only be loaded in Babel 7\",\n  );\n}\n\nconst { getImportSource, getRequireSource } = require(\"./utils.cjs\");\n\nfunction isRegeneratorSource(source) {\n  return (\n    source === \"regenerator-runtime/runtime\" ||\n    source === \"regenerator-runtime/runtime.js\"\n  );\n}\n\nmodule.exports = function () {\n  const visitor = {\n    ImportDeclaration(path) {\n      if (isRegeneratorSource(getImportSource(path))) {\n        this.regeneratorImportExcluded = true;\n        path.remove();\n      }\n    },\n    Program(path) {\n      path.get(\"body\").forEach(bodyPath => {\n        if (isRegeneratorSource(getRequireSource(bodyPath))) {\n          this.regeneratorImportExcluded = true;\n          bodyPath.remove();\n        }\n      });\n    },\n  };\n\n  return {\n    name: \"preset-env/remove-regenerator\",\n    visitor,\n    pre() {\n      this.regeneratorImportExcluded = false;\n    },\n    post() {\n      if (this.opts.debug && this.regeneratorImportExcluded) {\n        let filename = this.file.opts.filename;\n        // normalize filename to generate consistent preset-env test fixtures\n        if (process.env.BABEL_ENV === \"test\") {\n          filename = filename.replace(/\\\\/g, \"/\");\n        }\n        console.log(\n          `\\n[${filename}] Based on your targets, regenerator-runtime import excluded.`,\n        );\n      }\n    },\n  };\n};\n"],"names":["getImportSource","getRequireSource","require","isRegeneratorSource","source","module","exports","visitor","ImportDeclaration","path","regeneratorImportExcluded","remove","Program","get","forEach","bodyPath","name","pre","post","opts","debug","filename","file","process","env","BABEL_ENV","replace","console","log"],"mappings":"AA4CYuB;;AArCZ,MAAM,EAAEvB,eAAe,EAAEC,gBAAAA,EAAkB,GAAGC,OAAO,CAAC,aAAa,CAAC;AAEpE,SAASC,mBAAmBA,CAACC,MAAM,EAAE;IACnC,OACEA,MAAM,KAAK,6BAA6B,IACxCA,MAAM,KAAK,gCAAgC;AAE/C;AAEAC,MAAM,CAACC,OAAO,GAAG,YAAY;IAC3B,MAAMC,OAAO,GAAG;QACdC,iBAAiBA,EAACC,IAAI,EAAE;YACtB,IAAIN,mBAAmB,CAACH,eAAe,CAACS,IAAI,CAAC,CAAC,EAAE;gBAC9C,IAAI,CAACC,yBAAyB,GAAG,IAAI;gBACrCD,IAAI,CAACE,MAAM,CAAC,CAAC;YACf;QACF,CAAC;QACDC,OAAOA,EAACH,IAAI,EAAE;YACZA,IAAI,CAACI,GAAG,CAAC,MAAM,CAAC,CAACC,OAAO,EAACC,QAAQ,IAAI;gBACnC,IAAIZ,mBAAmB,CAACF,gBAAgB,CAACc,QAAQ,CAAC,CAAC,EAAE;oBACnD,IAAI,CAACL,yBAAyB,GAAG,IAAI;oBACrCK,QAAQ,CAACJ,MAAM,CAAC,CAAC;gBACnB;YACF,CAAC,CAAC;QACJ;IACF,CAAC;IAED,OAAO;QACLK,IAAI,EAAE,+BAA+B;QACrCT,OAAO;QACPU,GAAGA,CAAA,EAAG;YACJ,IAAI,CAACP,yBAAyB,GAAG,KAAK;QACxC,CAAC;QACDQ,IAAIA,CAAA,EAAG;YACL,IAAI,IAAI,CAACC,IAAI,CAACC,KAAK,IAAI,IAAI,CAACV,yBAAyB,EAAE;gBACrD,IAAIW,QAAQ,GAAG,IAAI,CAACC,IAAI,CAACH,IAAI,CAACE,QAAQ;gBAEtC,+KAAW,CAACG,GAAG,CAACC,SAAS,KAAK,MAAM,EAAE;oBACpCJ,QAAQ,GAAGA,QAAQ,CAACK,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;gBACzC;gBACAC,OAAO,CAACC,GAAG,CACT,CAAA,GAAA,EAAMP,QAAQ,CAAA,6DAAA,CAChB,CAAC;YACH;QACF;IACF,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 5966, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5971, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/polyfills/babel-7-plugins.cjs"],"sourcesContent":["// TODO(Babel 8): Remove this file\n\nif (!process.env.BABEL_8_BREAKING) {\n  Object.defineProperties(exports, {\n    pluginCoreJS2: {\n      get: () => require(\"babel-plugin-polyfill-corejs2\").default,\n    },\n    pluginRegenerator: {\n      get: () => require(\"babel-plugin-polyfill-regenerator\").default,\n    },\n    legacyBabelPolyfillPlugin: { get: () => require(\"./babel-polyfill.cjs\") },\n    removeRegeneratorEntryPlugin: { get: () => require(\"./regenerator.cjs\") },\n    corejs2Polyfills: {\n      get: () => require(\"@babel/compat-data/corejs2-built-ins\"),\n    },\n  });\n}\n"],"names":["Object","defineProperties","exports","pluginCoreJS2","get","require","default","pluginRegenerator","legacyBabelPolyfillPlugin","removeRegeneratorEntryPlugin","corejs2Polyfills"],"mappings":"AAEmC;IACjCA,MAAM,CAACC,gBAAgB,CAACC,OAAO,EAAE;QAC/BC,aAAa,EAAE;YACbC,GAAG,EAAEA,CAAA,GAAMC,OAAO,CAAC,+BAA+B,CAAC,6EAACC,OAAAA;QACtD,CAAC;QACDC,iBAAiB,EAAE;YACjBH,GAAG,EAAEA,CAAA,GAAMC,OAAO,CAAC,mCAAmC,CAAC,6EAACC,OAAAA;QAC1D,CAAC;QACDE,yBAAyB,EAAE;YAAEJ,GAAG,EAAEA,CAAA,KAAMC,OAAO,CAAC,sBAAsB;QAAE,CAAC;QACzEI,4BAA4B,EAAE;YAAEL,GAAG,EAAEA,CAAA,KAAMC,OAAO,CAAC,mBAAmB;QAAE,CAAC;QACzEK,gBAAgB,EAAE;YAChBN,GAAG,EAAEA,CAAA,KAAMC,OAAO,CAAC,sCAAsC;QAC3D;IACF,CAAC,CAAC;AACJ","ignoreList":[0]}},
    {"offset": {"line": 5990, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5995, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/normalize-options.ts"],"sourcesContent":["import semver, { type SemVer } from \"semver\";\nimport corejs3Polyfills from \"core-js-compat/data.json\" with { type: \"json\" };\nimport { plugins as pluginsList } from \"./plugins-compat-data.ts\";\nimport moduleTransformations from \"./module-transformations.ts\";\nimport {\n  TopLevelOptions,\n  ModulesOption,\n  UseBuiltInsOption,\n} from \"./options.ts\";\nimport { OptionValidator } from \"@babel/helper-validator-option\";\n\n// TODO(Babel 8): Remove this\nimport babel7 from \"./polyfills/babel-7-plugins.cjs\";\n\nimport type {\n  BuiltInsOption,\n  CorejsOption,\n  ModuleOption,\n  Options,\n  PluginListOption,\n} from \"./types.ts\";\n\nconst v = new OptionValidator(PACKAGE_JSON.name);\n\nconst allPluginsList = Object.keys(pluginsList);\n\n// NOTE: Since module plugins are handled separately compared to other plugins (via the \"modules\" option) it\n// should only be possible to exclude and not include module plugins, otherwise it's possible that preset-env\n// will add a module plugin twice.\nconst modulePlugins = [\n  \"transform-dynamic-import\",\n  ...Object.keys(moduleTransformations).map(m => moduleTransformations[m]),\n];\n\nconst getValidIncludesAndExcludes = (\n  type: \"include\" | \"exclude\",\n  corejs: number | false,\n) => {\n  const set = new Set(allPluginsList);\n  if (type === \"exclude\") modulePlugins.map(set.add, set);\n  if (corejs) {\n    if (!process.env.BABEL_8_BREAKING && corejs === 2) {\n      Object.keys(babel7.corejs2Polyfills).map(set.add, set);\n      set.add(\"web.timers\").add(\"web.immediate\").add(\"web.dom.iterable\");\n    } else {\n      Object.keys(corejs3Polyfills).map(set.add, set);\n    }\n  }\n  return Array.from(set);\n};\n\nfunction flatMap<T, U>(array: Array<T>, fn: (item: T) => Array<U>): Array<U> {\n  return Array.prototype.concat.apply([], array.map(fn));\n}\n\nexport const normalizePluginName = (plugin: string) =>\n  plugin.replace(/^(?:@babel\\/|babel-)(?:plugin-)?/, \"\");\n\nconst expandIncludesAndExcludes = (\n  filterList: PluginListOption = [],\n  type: \"include\" | \"exclude\",\n  corejs: number | false,\n) => {\n  if (filterList.length === 0) return [];\n\n  const filterableItems = getValidIncludesAndExcludes(type, corejs);\n\n  const invalidFilters: PluginListOption = [];\n  const selectedPlugins = flatMap(filterList, filter => {\n    let re: RegExp;\n    if (typeof filter === \"string\") {\n      try {\n        re = new RegExp(`^${normalizePluginName(filter)}$`);\n      } catch (_) {\n        invalidFilters.push(filter);\n        return [];\n      }\n    } else {\n      re = filter;\n    }\n    const items = filterableItems.filter(item => {\n      return process.env.BABEL_8_BREAKING\n        ? re.test(item)\n        : re.test(item) ||\n            // For backwards compatibility, we also support matching against the\n            // proposal- name.\n            re.test(item.replace(/^transform-/, \"proposal-\"));\n    });\n    if (items.length === 0) invalidFilters.push(filter);\n    return items;\n  });\n\n  v.invariant(\n    invalidFilters.length === 0,\n    `The plugins/built-ins '${invalidFilters.join(\n      \", \",\n    )}' passed to the '${type}' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`,\n  );\n\n  return selectedPlugins;\n};\n\nexport const checkDuplicateIncludeExcludes = (\n  include: Array<string> = [],\n  exclude: Array<string> = [],\n) => {\n  const duplicates = include.filter(opt => exclude.includes(opt));\n\n  v.invariant(\n    duplicates.length === 0,\n    `The plugins/built-ins '${duplicates.join(\n      \", \",\n    )}' were found in both the \"include\" and\n    \"exclude\" options.`,\n  );\n};\n\nconst normalizeTargets = (\n  targets: string | string[] | Options[\"targets\"],\n): Options[\"targets\"] => {\n  // TODO: Allow to use only query or strings as a targets from next breaking change.\n  if (typeof targets === \"string\" || Array.isArray(targets)) {\n    return { browsers: targets };\n  }\n  return { ...targets };\n};\n\nexport const validateModulesOption = (\n  modulesOpt: ModuleOption = ModulesOption.auto,\n) => {\n  v.invariant(\n    // @ts-expect-error we have provided fallback for undefined keys\n    ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption.false,\n    `The 'modules' option must be one of \\n` +\n      ` - 'false' to indicate no module processing\\n` +\n      ` - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'` +\n      ` - 'auto' (default) which will automatically select 'false' if the current\\n` +\n      `   process is known to support ES module syntax, or \"commonjs\" otherwise\\n`,\n  );\n\n  return modulesOpt;\n};\n\nexport const validateUseBuiltInsOption = (\n  builtInsOpt: BuiltInsOption = false,\n) => {\n  v.invariant(\n    // @ts-expect-error we have provided fallback for undefined keys\n    UseBuiltInsOption[builtInsOpt.toString()] ||\n      builtInsOpt === UseBuiltInsOption.false,\n    `The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file`,\n  );\n\n  return builtInsOpt;\n};\n\nexport type NormalizedCorejsOption = {\n  proposals: boolean;\n  version: SemVer | null | false;\n};\n\nexport function normalizeCoreJSOption(\n  corejs: CorejsOption | undefined | null,\n  useBuiltIns: BuiltInsOption,\n): NormalizedCorejsOption {\n  let proposals = false;\n  let rawVersion: false | string | number | undefined | null;\n\n  if (useBuiltIns && corejs === undefined) {\n    if (process.env.BABEL_8_BREAKING) {\n      throw new Error(\n        \"When using the `useBuiltIns` option you must specify\" +\n          ' the code-js version you are using, such as `\"corejs\": \"3.32.0\"`.',\n      );\n    } else {\n      rawVersion = 2;\n      console.warn(\n        \"\\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a \" +\n          `core-js version. Currently, we assume version 2.x when no version ` +\n          \"is passed. Since this default version will likely change in future \" +\n          \"versions of Babel, we recommend explicitly setting the core-js version \" +\n          \"you are using via the `corejs` option.\\n\" +\n          \"\\nYou should also be sure that the version you pass to the `corejs` \" +\n          \"option matches the version specified in your `package.json`'s \" +\n          \"`dependencies` section. If it doesn't, you need to run one of the \" +\n          \"following commands:\\n\\n\" +\n          \"  npm install --save core-js@2    npm install --save core-js@3\\n\" +\n          \"  yarn add core-js@2              yarn add core-js@3\\n\\n\" +\n          \"More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\\n\" +\n          \"More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs\",\n      );\n    }\n  } else if (typeof corejs === \"object\" && corejs !== null) {\n    rawVersion = corejs.version;\n    proposals = Boolean(corejs.proposals);\n  } else {\n    rawVersion = corejs as false | string | number | undefined | null;\n  }\n\n  const version = rawVersion ? semver.coerce(String(rawVersion)) : false;\n\n  if (version) {\n    if (useBuiltIns) {\n      if (process.env.BABEL_8_BREAKING) {\n        if (version.major !== 3) {\n          throw new RangeError(\n            \"Invalid Option: The version passed to `corejs` is invalid. Currently, \" +\n              \"only core-js@3 is supported.\",\n          );\n        }\n\n        if (\n          typeof rawVersion !== \"string\" ||\n          !String(rawVersion).includes(\".\")\n        ) {\n          throw new Error(\n            'Invalid Option: The version passed to `corejs` is invalid. Please use string and specify the minor version, such as `\"3.33\"`.',\n          );\n        }\n      } else {\n        if (version.major < 2 || version.major > 3) {\n          throw new RangeError(\n            \"Invalid Option: The version passed to `corejs` is invalid. Currently, \" +\n              \"only core-js@2 and core-js@3 are supported.\",\n          );\n        }\n      }\n    } else {\n      console.warn(\n        \"\\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\\n\",\n      );\n    }\n  }\n\n  return { version, proposals };\n}\n\nexport default function normalizeOptions(opts: Options) {\n  v.validateTopLevelOptions(opts, TopLevelOptions);\n\n  const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);\n\n  const corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);\n\n  const include = expandIncludesAndExcludes(\n    opts.include,\n    TopLevelOptions.include,\n    !!corejs.version && corejs.version.major,\n  );\n\n  const exclude = expandIncludesAndExcludes(\n    opts.exclude,\n    TopLevelOptions.exclude,\n    !!corejs.version && corejs.version.major,\n  );\n\n  checkDuplicateIncludeExcludes(include, exclude);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    v.validateBooleanOption(\"loose\", opts.loose);\n    v.validateBooleanOption(\"spec\", opts.spec);\n  }\n\n  return {\n    bugfixes: v.validateBooleanOption(\n      TopLevelOptions.bugfixes,\n      opts.bugfixes,\n      process.env.BABEL_8_BREAKING ? true : false,\n    ),\n    configPath: v.validateStringOption(\n      TopLevelOptions.configPath,\n      opts.configPath,\n      process.cwd(),\n    ),\n    corejs,\n    debug: v.validateBooleanOption(TopLevelOptions.debug, opts.debug, false),\n    include,\n    exclude,\n    forceAllTransforms: v.validateBooleanOption(\n      TopLevelOptions.forceAllTransforms,\n      opts.forceAllTransforms,\n      false,\n    ),\n    ignoreBrowserslistConfig: v.validateBooleanOption(\n      TopLevelOptions.ignoreBrowserslistConfig,\n      opts.ignoreBrowserslistConfig,\n      false,\n    ),\n    modules: validateModulesOption(opts.modules),\n    shippedProposals: v.validateBooleanOption(\n      TopLevelOptions.shippedProposals,\n      opts.shippedProposals,\n      false,\n    ),\n    targets: normalizeTargets(opts.targets),\n    useBuiltIns: useBuiltIns,\n    browserslistEnv: v.validateStringOption(\n      TopLevelOptions.browserslistEnv,\n      opts.browserslistEnv,\n    ),\n  };\n}\n"],"names":["_semver","require","_pluginsCompatData","_moduleTransformations","_options","_helperValidatorOption","_babel7Plugins","corejs3Polyfills","v","OptionValidator","allPluginsList","Object","keys","pluginsList","modulePlugins","moduleTransformations","map","m","getValidIncludesAndExcludes","type","corejs","set","Set","add","babel7","corejs2Polyfills","Array","from","flatMap","array","fn","prototype","concat","apply","normalizePluginName","plugin","replace","exports","expandIncludesAndExcludes","filterList","length","filterableItems","invalidFilters","selectedPlugins","filter","re","RegExp","_","push","items","item","test","invariant","join","checkDuplicateIncludeExcludes","include","exclude","duplicates","opt","includes","normalizeTargets","targets","isArray","browsers","assign","validateModulesOption","modulesOpt","ModulesOption","auto","toString","false","validateUseBuiltInsOption","builtInsOpt","UseBuiltInsOption","normalizeCoreJSOption","useBuiltIns","proposals","rawVersion","undefined","console","warn","version","Boolean","semver","coerce","String","major","RangeError","normalizeOptions","opts","validateTopLevelOptions","TopLevelOptions","validateBooleanOption","loose","spec","bugfixes","configPath","validateStringOption","process","cwd","debug","forceAllTransforms","ignoreBrowserslistConfig","modules","shippedProposals","browserslistEnv"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6151, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/shipped-proposals.ts"],"sourcesContent":["// TODO(Babel 8): Remove this file\n/* eslint sort-keys: \"error\" */\n// These mappings represent the transform plugins that have been\n// shipped by browsers, and are enabled by the `shippedProposals` option.\n\nconst proposalPlugins = new Set<string>([]);\n\n// proposal syntax plugins enabled by the `shippedProposals` option.\n// Unlike proposalPlugins above, they are independent of compiler targets.\nconst proposalSyntaxPlugins = process.env.BABEL_8_BREAKING\n  ? ([] as const)\n  : ([\"syntax-import-assertions\", \"syntax-import-attributes\"] as const);\n\n// use intermediary object to enforce alphabetical key order\nconst pluginSyntaxObject = process.env.BABEL_8_BREAKING\n  ? {}\n  : ({\n      \"transform-async-generator-functions\": \"syntax-async-generators\",\n      \"transform-class-properties\": \"syntax-class-properties\",\n      \"transform-class-static-block\": \"syntax-class-static-block\",\n      \"transform-export-namespace-from\": \"syntax-export-namespace-from\",\n      \"transform-json-strings\": \"syntax-json-strings\",\n      \"transform-nullish-coalescing-operator\":\n        \"syntax-nullish-coalescing-operator\",\n      \"transform-numeric-separator\": \"syntax-numeric-separator\",\n      \"transform-object-rest-spread\": \"syntax-object-rest-spread\",\n      \"transform-optional-catch-binding\": \"syntax-optional-catch-binding\",\n      \"transform-optional-chaining\": \"syntax-optional-chaining\",\n      // note: we don't have syntax-private-methods\n      \"transform-private-methods\": \"syntax-class-properties\",\n      \"transform-private-property-in-object\":\n        \"syntax-private-property-in-object\",\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      \"transform-unicode-property-regex\": null as null,\n    } as const);\n\ntype PluginSyntaxObjectKeys = keyof typeof pluginSyntaxObject;\n\nconst pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map<\n  [PluginSyntaxObjectKeys, string | null]\n>(function (key: PluginSyntaxObjectKeys) {\n  return [key, pluginSyntaxObject[key]];\n});\n\nconst pluginSyntaxMap = new Map(pluginSyntaxEntries);\n\nexport { proposalPlugins, proposalSyntaxPlugins, pluginSyntaxMap };\n"],"names":["proposalPlugins","exports","Set","proposalSyntaxPlugins","pluginSyntaxObject","pluginSyntaxEntries","Object","keys","map","key","pluginSyntaxMap","Map"],"mappings":";;;;;AAKA,MAAMA,eAAe,GAAAC,OAAA,CAAAD,eAAA,GAAG,IAAIE,GAAG,CAAS,EAAE,CAAC;AAI3C,MAAMC,qBAAqB,GAAAF,OAAA,CAAAE,qBAAA,GAEtB;IAAC,0BAA0B;IAAE,0BAA0B;CAAW;AAGvE,MAAMC,kBAAkB,GAEnB;IACC,qCAAqC,EAAE,yBAAyB;IAChE,4BAA4B,EAAE,yBAAyB;IACvD,8BAA8B,EAAE,2BAA2B;IAC3D,iCAAiC,EAAE,8BAA8B;IACjE,wBAAwB,EAAE,qBAAqB;IAC/C,uCAAuC,EACrC,oCAAoC;IACtC,6BAA6B,EAAE,0BAA0B;IACzD,8BAA8B,EAAE,2BAA2B;IAC3D,kCAAkC,EAAE,+BAA+B;IACnE,6BAA6B,EAAE,0BAA0B;IAEzD,2BAA2B,EAAE,yBAAyB;IACtD,sCAAsC,EACpC,mCAAmC;IAErC,kCAAkC,EAAE;AACtC,CAAW;AAIf,MAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAI,CAACH,kBAAkB,CAAC,CAACI,GAAG,CAE7D,SAAUC,GAA2B,EAAE;IACvC,OAAO;QAACA,GAAG;QAAEL,kBAAkB,CAACK,GAAG,CAAC;KAAC;AACvC,CAAC,CAAC;AAEF,MAAMC,eAAe,GAAAT,OAAA,CAAAS,eAAA,GAAG,IAAIC,GAAG,CAACN,mBAAmB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6183, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6188, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-env/src/index.ts"],"sourcesContent":["import semver, { type SemVer } from \"semver\";\nimport { logPlugin } from \"./debug.ts\";\nimport {\n  addProposalSyntaxPlugins,\n  removeUnnecessaryItems,\n  removeUnsupportedItems,\n} from \"./filter-items.ts\";\nimport moduleTransformations from \"./module-transformations.ts\";\nimport normalizeOptions from \"./normalize-options.ts\";\nimport {\n  pluginSyntaxMap,\n  proposalPlugins,\n  proposalSyntaxPlugins,\n} from \"./shipped-proposals.ts\";\nimport {\n  plugins as pluginsList,\n  pluginsBugfixes as pluginsBugfixesList,\n  overlappingPlugins,\n} from \"./plugins-compat-data.ts\";\n\nimport type { CallerMetadata, PresetAPI } from \"@babel/core\";\n\nimport _pluginCoreJS3 from \"babel-plugin-polyfill-corejs3\";\n// TODO(Babel 8): Just use the default import\nconst pluginCoreJS3 = _pluginCoreJS3.default || _pluginCoreJS3;\n\n// TODO(Babel 8): Remove this\nimport babel7 from \"./polyfills/babel-7-plugins.cjs\";\n\nimport getTargets, {\n  prettifyTargets,\n  filterItems,\n  isRequired,\n} from \"@babel/helper-compilation-targets\";\nimport type { Targets, InputTargets } from \"@babel/helper-compilation-targets\";\nimport availablePlugins from \"./available-plugins.ts\";\nimport { declarePreset } from \"@babel/helper-plugin-utils\";\n\nimport type { BuiltInsOption, ModuleOption, Options } from \"./types.ts\";\nexport type { Options };\n\n// TODO: Remove in Babel 8\nexport function isPluginRequired(targets: Targets, support: Targets) {\n  return isRequired(\"fake-name\", targets, {\n    compatData: { \"fake-name\": support },\n  });\n}\n\nfunction filterStageFromList(\n  list: { [feature: string]: Targets },\n  stageList: Set<string>,\n) {\n  return Object.keys(list).reduce((result, item) => {\n    if (!stageList.has(item)) {\n      // @ts-expect-error todo: refine result types\n      result[item] = list[item];\n    }\n\n    return result;\n  }, {});\n}\n\nconst pluginLists = {\n  withProposals: {\n    withoutBugfixes: pluginsList,\n    withBugfixes: Object.assign({}, pluginsList, pluginsBugfixesList),\n  },\n  withoutProposals: {\n    withoutBugfixes: filterStageFromList(pluginsList, proposalPlugins),\n    withBugfixes: filterStageFromList(\n      Object.assign({}, pluginsList, pluginsBugfixesList),\n      proposalPlugins,\n    ),\n  },\n};\n\nfunction getPluginList(proposals: boolean, bugfixes: boolean) {\n  if (proposals) {\n    if (bugfixes) return pluginLists.withProposals.withBugfixes;\n    else return pluginLists.withProposals.withoutBugfixes;\n  } else {\n    if (bugfixes) return pluginLists.withoutProposals.withBugfixes;\n    else return pluginLists.withoutProposals.withoutBugfixes;\n  }\n}\n\nconst getPlugin = (pluginName: string) => {\n  const plugin =\n    // @ts-expect-error plugin name is constructed from available plugin list\n    availablePlugins[pluginName]();\n\n  if (!plugin) {\n    throw new Error(\n      `Could not find plugin \"${pluginName}\". Ensure there is an entry in ./available-plugins.js for it.`,\n    );\n  }\n\n  return plugin;\n};\n\nexport const transformIncludesAndExcludes = (opts: Array<string>): any => {\n  return opts.reduce(\n    (result, opt) => {\n      const target = /^(?:es|es6|es7|esnext|web)\\./.test(opt)\n        ? \"builtIns\"\n        : \"plugins\";\n      result[target].add(opt);\n      return result;\n    },\n    {\n      all: opts,\n      plugins: new Set(),\n      builtIns: new Set(),\n    },\n  );\n};\n\nfunction getSpecialModulesPluginNames(\n  modules: Exclude<ModuleOption, \"auto\">,\n  shouldTransformDynamicImport: boolean,\n  babelVersion: string,\n) {\n  const modulesPluginNames = [];\n  if (modules) {\n    modulesPluginNames.push(moduleTransformations[modules]);\n  }\n\n  if (shouldTransformDynamicImport) {\n    if (modules && modules !== \"umd\") {\n      modulesPluginNames.push(\"transform-dynamic-import\");\n    } else {\n      console.warn(\n        \"Dynamic import can only be transformed when transforming ES\" +\n          \" modules to AMD, CommonJS or SystemJS.\",\n      );\n    }\n  }\n\n  if (!process.env.BABEL_8_BREAKING && babelVersion[0] !== \"8\") {\n    // Enable module-related syntax plugins for older Babel versions\n    if (!shouldTransformDynamicImport) {\n      modulesPluginNames.push(\"syntax-dynamic-import\");\n    }\n    modulesPluginNames.push(\"syntax-top-level-await\");\n    modulesPluginNames.push(\"syntax-import-meta\");\n  }\n\n  return modulesPluginNames;\n}\n\nconst getCoreJSOptions = ({\n  useBuiltIns,\n  corejs,\n  polyfillTargets,\n  include,\n  exclude,\n  proposals,\n  shippedProposals,\n  debug,\n}: {\n  useBuiltIns: BuiltInsOption;\n  corejs: SemVer | null | false;\n  polyfillTargets: Targets;\n  include: Set<string>;\n  exclude: Set<string>;\n  proposals: boolean;\n  shippedProposals: boolean;\n  debug: boolean;\n}) => ({\n  method: `${useBuiltIns}-global`,\n  version: corejs ? corejs.toString() : undefined,\n  targets: polyfillTargets,\n  include,\n  exclude,\n  proposals,\n  shippedProposals,\n  debug,\n  \"#__secret_key__@babel/preset-env__compatibility\": {\n    noRuntimeName: true,\n  },\n});\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var getPolyfillPlugins = ({\n    useBuiltIns,\n    corejs,\n    polyfillTargets,\n    include,\n    exclude,\n    proposals,\n    shippedProposals,\n    regenerator,\n    debug,\n  }: {\n    useBuiltIns: BuiltInsOption;\n    corejs: SemVer | null | false;\n    polyfillTargets: Targets;\n    include: Set<string>;\n    exclude: Set<string>;\n    proposals: boolean;\n    shippedProposals: boolean;\n    regenerator: boolean;\n    debug: boolean;\n  }) => {\n    const polyfillPlugins = [];\n    if (useBuiltIns === \"usage\" || useBuiltIns === \"entry\") {\n      const pluginOptions = getCoreJSOptions({\n        useBuiltIns,\n        corejs,\n        polyfillTargets,\n        include,\n        exclude,\n        proposals,\n        shippedProposals,\n        debug,\n      });\n\n      if (corejs) {\n        if (process.env.BABEL_8_BREAKING) {\n          polyfillPlugins.push([pluginCoreJS3, pluginOptions]);\n        } else {\n          if (useBuiltIns === \"usage\") {\n            if (corejs.major === 2) {\n              polyfillPlugins.push(\n                [babel7.pluginCoreJS2, pluginOptions],\n                [babel7.legacyBabelPolyfillPlugin, { usage: true }],\n              );\n            } else {\n              polyfillPlugins.push(\n                [pluginCoreJS3, pluginOptions],\n                [\n                  babel7.legacyBabelPolyfillPlugin,\n                  { usage: true, deprecated: true },\n                ],\n              );\n            }\n            if (regenerator) {\n              polyfillPlugins.push([\n                babel7.pluginRegenerator,\n                { method: \"usage-global\", debug },\n              ]);\n            }\n          } else {\n            if (corejs.major === 2) {\n              polyfillPlugins.push(\n                [babel7.legacyBabelPolyfillPlugin, { regenerator }],\n                [babel7.pluginCoreJS2, pluginOptions],\n              );\n            } else {\n              polyfillPlugins.push(\n                [pluginCoreJS3, pluginOptions],\n                [babel7.legacyBabelPolyfillPlugin, { deprecated: true }],\n              );\n              if (!regenerator) {\n                polyfillPlugins.push([\n                  babel7.removeRegeneratorEntryPlugin,\n                  pluginOptions,\n                ]);\n              }\n            }\n          }\n        }\n      }\n    }\n    return polyfillPlugins;\n  };\n\n  if (!USE_ESM) {\n    // eslint-disable-next-line no-restricted-globals\n    exports.getPolyfillPlugins = getPolyfillPlugins;\n  }\n}\n\nfunction getLocalTargets(\n  optionsTargets: Options[\"targets\"],\n  ignoreBrowserslistConfig: boolean,\n  configPath: string,\n  browserslistEnv: string,\n  api: PresetAPI,\n) {\n  if (optionsTargets?.esmodules && optionsTargets.browsers) {\n    console.warn(`\n@babel/preset-env: esmodules and browsers targets have been specified together.\n\\`browsers\\` target, \\`${optionsTargets.browsers.toString()}\\` will be ignored.\n`);\n  }\n\n  return getTargets(optionsTargets as InputTargets, {\n    ignoreBrowserslistConfig,\n    configPath,\n    browserslistEnv,\n    onBrowserslistConfigFound(config) {\n      api.addExternalDependency(config);\n    },\n  });\n}\n\nfunction supportsStaticESM(caller: CallerMetadata | undefined) {\n  // TODO(Babel 8): Fallback to true\n  // @ts-expect-error supportsStaticESM is not defined in CallerMetadata\n  return !!caller?.supportsStaticESM;\n}\n\nfunction supportsDynamicImport(caller: CallerMetadata | undefined) {\n  // TODO(Babel 8): Fallback to true\n  // @ts-expect-error supportsDynamicImport is not defined in CallerMetadata\n  return !!caller?.supportsDynamicImport;\n}\n\nfunction supportsExportNamespaceFrom(caller: CallerMetadata | undefined) {\n  // TODO(Babel 8): Fallback to null\n  // @ts-expect-error supportsExportNamespaceFrom is not defined in CallerMetadata\n  return !!caller?.supportsExportNamespaceFrom;\n}\n\nexport default declarePreset((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const babelTargets = api.targets();\n\n  if (process.env.BABEL_8_BREAKING && (\"loose\" in opts || \"spec\" in opts)) {\n    throw new Error(\n      \"@babel/preset-env: The 'loose' and 'spec' options have been removed, \" +\n        \"and you should configure granular compiler assumptions instead. See \" +\n        \"https://babeljs.io/assumptions for more information.\",\n    );\n  }\n\n  const {\n    bugfixes,\n    configPath,\n    debug,\n    exclude: optionsExclude,\n    forceAllTransforms,\n    ignoreBrowserslistConfig,\n    include: optionsInclude,\n    modules: optionsModules,\n    shippedProposals,\n    targets: optionsTargets,\n    useBuiltIns,\n    corejs: { version: corejs, proposals },\n    browserslistEnv,\n  } = normalizeOptions(opts);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { loose, spec = false } = opts;\n  }\n\n  let targets = babelTargets;\n\n  if (\n    // @babel/core < 7.13.0 doesn't load targets (api.targets() always\n    // returns {} thanks to @babel/helper-plugin-utils), so we always want\n    // to fallback to the old targets behavior in this case.\n    semver.lt(api.version, \"7.13.0\") ||\n    // If any browserslist-related option is specified, fallback to the old\n    // behavior of not using the targets specified in the top-level options.\n    opts.targets ||\n    opts.configPath ||\n    opts.browserslistEnv ||\n    opts.ignoreBrowserslistConfig\n  ) {\n    if (!process.env.BABEL_8_BREAKING) {\n      // eslint-disable-next-line no-var\n      var hasUglifyTarget = false;\n\n      if (optionsTargets?.uglify) {\n        hasUglifyTarget = true;\n        delete optionsTargets.uglify;\n\n        console.warn(`\nThe uglify target has been deprecated. Set the top level\noption \\`forceAllTransforms: true\\` instead.\n`);\n      }\n    }\n\n    targets = getLocalTargets(\n      optionsTargets,\n      ignoreBrowserslistConfig,\n      configPath,\n      browserslistEnv,\n      api,\n    );\n  }\n\n  const transformTargets = (\n    process.env.BABEL_8_BREAKING\n      ? forceAllTransforms\n      : forceAllTransforms || hasUglifyTarget\n  )\n    ? ({} as Targets)\n    : targets;\n\n  const include = transformIncludesAndExcludes(optionsInclude);\n  const exclude = transformIncludesAndExcludes(optionsExclude);\n\n  const compatData = getPluginList(shippedProposals, bugfixes);\n  const modules =\n    optionsModules === \"auto\"\n      ? api.caller(supportsStaticESM)\n        ? false\n        : \"commonjs\"\n      : optionsModules;\n  const shouldTransformDynamicImport =\n    optionsModules === \"auto\" ? !api.caller(supportsDynamicImport) : !!modules;\n\n  // If the caller does not support export-namespace-from, we forcefully add\n  // the plugin to `includes`.\n  // TODO(Babel 8): stop doing this, similarly to how we don't do this for any\n  // other plugin. We can consider adding bundlers as targets in the future,\n  // but we should not have a one-off special case for this plugin.\n  if (\n    !exclude.plugins.has(\"transform-export-namespace-from\") &&\n    (optionsModules === \"auto\"\n      ? !api.caller(supportsExportNamespaceFrom)\n      : !!modules)\n  ) {\n    include.plugins.add(\"transform-export-namespace-from\");\n  }\n\n  const pluginNames = filterItems(\n    compatData,\n    include.plugins,\n    exclude.plugins,\n    transformTargets,\n    getSpecialModulesPluginNames(\n      modules,\n      shouldTransformDynamicImport,\n      api.version,\n    ),\n    process.env.BABEL_8_BREAKING || !loose\n      ? undefined\n      : [\"transform-typeof-symbol\"],\n    pluginSyntaxMap,\n  );\n  if (shippedProposals) {\n    addProposalSyntaxPlugins(pluginNames, proposalSyntaxPlugins);\n  }\n  removeUnsupportedItems(pluginNames, api.version);\n  removeUnnecessaryItems(pluginNames, overlappingPlugins);\n\n  const polyfillPlugins = process.env.BABEL_8_BREAKING\n    ? useBuiltIns\n      ? [\n          [\n            pluginCoreJS3,\n            getCoreJSOptions({\n              useBuiltIns,\n              corejs,\n              polyfillTargets: targets,\n              include: include.builtIns,\n              exclude: exclude.builtIns,\n              proposals,\n              shippedProposals,\n              debug,\n            }),\n          ],\n        ]\n      : []\n    : getPolyfillPlugins({\n        useBuiltIns,\n        corejs,\n        polyfillTargets: targets,\n        include: include.builtIns,\n        exclude: exclude.builtIns,\n        proposals,\n        shippedProposals,\n        regenerator: pluginNames.has(\"transform-regenerator\"),\n        debug,\n      });\n\n  const pluginUseBuiltIns = useBuiltIns !== false;\n  const plugins = Array.from(pluginNames)\n    .map(pluginName => {\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        (pluginName === \"transform-class-properties\" ||\n          pluginName === \"transform-private-methods\" ||\n          pluginName === \"transform-private-property-in-object\")\n      ) {\n        return [\n          getPlugin(pluginName),\n          {\n            loose: loose\n              ? \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\"\n              : \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\",\n          },\n        ];\n      }\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        pluginName === \"syntax-import-attributes\"\n      ) {\n        // For backward compatibility with the import-assertions plugin, we\n        // allow the deprecated `assert` keyword.\n        // TODO(Babel 8): Revisit this.\n        return [getPlugin(pluginName), { deprecatedAssertSyntax: true }];\n      }\n      return [\n        getPlugin(pluginName),\n        process.env.BABEL_8_BREAKING\n          ? { useBuiltIns: pluginUseBuiltIns }\n          : { spec, loose, useBuiltIns: pluginUseBuiltIns },\n      ];\n    })\n    .concat(polyfillPlugins);\n\n  if (debug) {\n    console.log(\"@babel/preset-env: `DEBUG` option\");\n    console.log(\"\\nUsing targets:\");\n    console.log(JSON.stringify(prettifyTargets(targets), null, 2));\n    console.log(`\\nUsing modules transform: ${optionsModules.toString()}`);\n    console.log(\"\\nUsing plugins:\");\n    pluginNames.forEach(pluginName => {\n      logPlugin(pluginName, targets, compatData);\n    });\n\n    if (!useBuiltIns) {\n      console.log(\n        \"\\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.\",\n      );\n    }\n  }\n\n  return { plugins };\n});\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getModulesPluginNames = ({\n    modules,\n    transformations,\n    shouldTransformESM,\n    shouldTransformDynamicImport,\n    shouldTransformExportNamespaceFrom,\n  }: {\n    modules: ModuleOption;\n    transformations: typeof import(\"./module-transformations\").default;\n    shouldTransformESM: boolean;\n    shouldTransformDynamicImport: boolean;\n    shouldTransformExportNamespaceFrom: boolean;\n  }) => {\n    const modulesPluginNames = [];\n    if (modules !== false && transformations[modules]) {\n      if (shouldTransformESM) {\n        modulesPluginNames.push(transformations[modules]);\n      }\n\n      if (shouldTransformDynamicImport) {\n        if (shouldTransformESM && modules !== \"umd\") {\n          modulesPluginNames.push(\"transform-dynamic-import\");\n        } else {\n          console.warn(\n            \"Dynamic import can only be transformed when transforming ES\" +\n              \" modules to AMD, CommonJS or SystemJS.\",\n          );\n        }\n      }\n    }\n\n    if (shouldTransformExportNamespaceFrom) {\n      modulesPluginNames.push(\"transform-export-namespace-from\");\n    }\n    if (!shouldTransformDynamicImport) {\n      modulesPluginNames.push(\"syntax-dynamic-import\");\n    }\n    if (!shouldTransformExportNamespaceFrom) {\n      modulesPluginNames.push(\"syntax-export-namespace-from\");\n    }\n    modulesPluginNames.push(\"syntax-top-level-await\");\n    modulesPluginNames.push(\"syntax-import-meta\");\n\n    return modulesPluginNames;\n  };\n}\n"],"names":["_semver","require","_debug","_filterItems","_moduleTransformations","_normalizeOptions","_shippedProposals","_pluginsCompatData","_babelPluginPolyfillCorejs","_babel7Plugins","_helperCompilationTargets","_availablePlugins","_helperPluginUtils","pluginCoreJS3","_pluginCoreJS3","default","isPluginRequired","targets","support","isRequired","compatData","filterStageFromList","list","stageList","Object","keys","reduce","result","item","has","pluginLists","withProposals","withoutBugfixes","pluginsList","withBugfixes","assign","pluginsBugfixesList","withoutProposals","proposalPlugins","getPluginList","proposals","bugfixes","getPlugin","pluginName","plugin","availablePlugins","Error","transformIncludesAndExcludes","opts","opt","target","test","add","all","plugins","Set","builtIns","exports","getSpecialModulesPluginNames","modules","shouldTransformDynamicImport","babelVersion","modulesPluginNames","push","moduleTransformations","console","warn","getCoreJSOptions","useBuiltIns","corejs","polyfillTargets","include","exclude","shippedProposals","debug","method","version","toString","undefined","noRuntimeName","getPolyfillPlugins","regenerator","polyfillPlugins","pluginOptions","major","babel7","pluginCoreJS2","legacyBabelPolyfillPlugin","usage","deprecated","pluginRegenerator","removeRegeneratorEntryPlugin","getLocalTargets","optionsTargets","ignoreBrowserslistConfig","configPath","browserslistEnv","api","esmodules","browsers","getTargets","onBrowserslistConfigFound","config","addExternalDependency","supportsStaticESM","caller","supportsDynamicImport","supportsExportNamespaceFrom","_default","declarePreset","assertVersion","babelTargets","optionsExclude","forceAllTransforms","optionsInclude","optionsModules","normalizeOptions","loose","spec","semver","lt","hasUglifyTarget","uglify","transformTargets","pluginNames","filterItems","pluginSyntaxMap","addProposalSyntaxPlugins","proposalSyntaxPlugins","removeUnsupportedItems","removeUnnecessaryItems","overlappingPlugins","pluginUseBuiltIns","Array","from","map","deprecatedAssertSyntax","concat","log","JSON","stringify","prettifyTargets","forEach","logPlugin","getModulesPluginNames","transformations","shouldTransformESM","shouldTransformExportNamespaceFrom"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6529, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6534, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-syntax-import-assertions/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const isPlugin = (plugin: string | [string, object], name: string) =>\n    name === \"plugin\" || (Array.isArray(plugin) && plugin[0] === \"plugin\");\n  const options = (plugin: string | [string, object]) =>\n    Array.isArray(plugin) && plugin.length > 1 ? plugin[1] : {};\n\n  return {\n    name: \"syntax-import-assertions\",\n\n    manipulateOptions(opts, { plugins }) {\n      for (let i = 0; i < plugins.length; i++) {\n        const plugin = plugins[i];\n\n        if (isPlugin(plugin, \"deprecatedImportAssert\")) return;\n\n        if (isPlugin(plugin, \"importAttributes\")) {\n          plugins.splice(i, 1, \"deprecatedImportAssert\", [\n            \"importAttributes\",\n            { ...options(plugin), deprecatedAssertSyntax: true },\n          ]);\n          return;\n        }\n      }\n\n      plugins.push(\"importAssertions\");\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","isPlugin","plugin","name","Array","isArray","options","length","manipulateOptions","opts","plugins","i","splice","Object","assign","deprecatedAssertSyntax","push"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAMC,QAAQ,GAAGA,CAACC,MAAiC,EAAEC,IAAY,GAC/DA,IAAI,KAAK,QAAQ,IAAKC,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,IAAIA,MAAM,CAAC,CAAC,CAAC,KAAK,QAAS;IACxE,MAAMI,OAAO,IAAIJ,MAAiC,GAChDE,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,IAAIA,MAAM,CAACK,MAAM,GAAG,CAAC,GAAGL,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAE7D,OAAO;QACLC,IAAI,EAAE,0BAA0B;QAEhCK,iBAAiBA,EAACC,IAAI,EAAE,EAAEC,OAAAA,EAAS,EAAE;YACnC,IAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,OAAO,CAACH,MAAM,EAAEI,CAAC,EAAE,CAAE;gBACvC,MAAMT,MAAM,GAAGQ,OAAO,CAACC,CAAC,CAAC;gBAEzB,IAAIV,QAAQ,CAACC,MAAM,EAAE,wBAAwB,CAAC,EAAE;gBAEhD,IAAID,QAAQ,CAACC,MAAM,EAAE,kBAAkB,CAAC,EAAE;oBACxCQ,OAAO,CAACE,MAAM,CAACD,CAAC,EAAE,CAAC,EAAE,wBAAwB,EAAE;wBAC7C,kBAAkB;wBAAAE,MAAA,CAAAC,MAAA,CAAA,CAAA,GACbR,OAAO,CAACJ,MAAM,CAAC,EAAA;4BAAEa,sBAAsB,EAAE;wBAAI;qBACnD,CAAC;oBACF;gBACF;YACF;YAEAL,OAAO,CAACM,IAAI,CAAC,kBAAkB,CAAC;QAClC;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6564, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6569, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-syntax-import-attributes/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  deprecatedAssertSyntax?: boolean;\n}\n\nexport default declare((api, { deprecatedAssertSyntax }: Options) => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.22.0\"));\n\n  if (\n    deprecatedAssertSyntax != null &&\n    typeof deprecatedAssertSyntax !== \"boolean\"\n  ) {\n    throw new Error(\n      \"'deprecatedAssertSyntax' must be a boolean, if specified.\",\n    );\n  }\n\n  return {\n    name: \"syntax-import-attributes\",\n\n    manipulateOptions({ parserOpts, generatorOpts }) {\n      generatorOpts.importAttributesKeyword ??= \"with\";\n\n      const importAssertionsPluginIndex =\n        parserOpts.plugins.indexOf(\"importAssertions\");\n      if (importAssertionsPluginIndex !== -1) {\n        parserOpts.plugins.splice(importAssertionsPluginIndex, 1);\n        deprecatedAssertSyntax = true;\n      }\n\n      if (deprecatedAssertSyntax) {\n        parserOpts.plugins.push(\"deprecatedImportAssert\", [\n          \"importAttributes\",\n          { deprecatedAssertSyntax: true },\n        ]);\n      } else {\n        parserOpts.plugins.push(\"importAttributes\");\n      }\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","deprecatedAssertSyntax","assertVersion","Error","name","manipulateOptions","parserOpts","generatorOpts","_generatorOpts$import","importAttributesKeyword","importAssertionsPluginIndex","plugins","indexOf","splice","push"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMtC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAE,EAAEC,sBAAAA,EAAiC,KAAK;IACnED,GAAG,CAACE,aAAa,CAAA,qCAA4B,CAAC;IAE9C,IACED,sBAAsB,IAAI,IAAI,IAC9B,OAAOA,sBAAsB,KAAK,SAAS,EAC3C;QACA,MAAM,IAAIE,KAAK,CACb,2DACF,CAAC;IACH;IAEA,OAAO;QACLC,IAAI,EAAE,0BAA0B;QAEhCC,iBAAiBA,EAAC,EAAEC,UAAU,EAAEC,aAAAA,EAAe,EAAE;YAAA,IAAAC,qBAAA;YAC/C,CAAAA,qBAAA,GAAAD,aAAa,CAACE,uBAAuB,KAAA,OAAAD,qBAAA,GAArCD,aAAa,CAACE,uBAAuB,GAAK,MAAM;YAEhD,MAAMC,2BAA2B,GAC/BJ,UAAU,CAACK,OAAO,CAACC,OAAO,CAAC,kBAAkB,CAAC;YAChD,IAAIF,2BAA2B,KAAK,CAAC,CAAC,EAAE;gBACtCJ,UAAU,CAACK,OAAO,CAACE,MAAM,CAACH,2BAA2B,EAAE,CAAC,CAAC;gBACzDT,sBAAsB,GAAG,IAAI;YAC/B;YAEA,IAAIA,sBAAsB,EAAE;gBAC1BK,UAAU,CAACK,OAAO,CAACG,IAAI,CAAC,wBAAwB,EAAE;oBAChD,kBAAkB;oBAClB;wBAAEb,sBAAsB,EAAE;oBAAK,CAAC;iBACjC,CAAC;YACJ,CAAC,MAAM;gBACLK,UAAU,CAACK,OAAO,CAACG,IAAI,CAAC,kBAAkB,CAAC;YAC7C;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6603, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6608, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-wrap-function/src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  const container = functionExpression(\n    null,\n    [],\n    blockStatement(body.body),\n    true,\n  );\n  body.body = [\n    returnStatement(callExpression(callExpression(callId, [container]), [])),\n  ];\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n\n  // Unwrap the wrapper IIFE's environment so super and this and such still work.\n  (\n    path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n  ).unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n  hadName: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    // TODO: Use `functionId` rather than `hadName` for the condition\n    REF: path.scope.generateUidIdentifier(hadName ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (hadName) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliance\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    const hadName = \"id\" in path.node && !!path.node.id;\n    if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n      // polyfill when being run by an older Babel version\n      path.ensureFunctionName ??=\n        // eslint-disable-next-line no-restricted-globals\n        require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n    }\n    // @ts-expect-error It is invalid to call this on an arrow expression,\n    // but we'll convert it to a function expression anyway.\n    path = path.ensureFunctionName(false);\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n      hadName,\n    );\n  }\n}\n"],"names":["_template","require","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","inPath","noNewArrows","ignoreFunctionLength","hadName","functionId","nodeParams","params","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","param","push","scope","generateUidIdentifier","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","length","wrapFunction","isMethod","_path","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6723, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6728, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-remap-async-to-generator/src/index.ts"],"sourcesContent":["/* @noflow */\n\nimport type { NodePath } from \"@babel/core\";\nimport wrapFunction from \"@babel/helper-wrap-function\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nconst {\n  callExpression,\n  cloneNode,\n  isIdentifier,\n  isThisExpression,\n  yieldExpression,\n} = t;\n\nconst awaitVisitor = visitors.environmentVisitor<{ wrapAwait: t.Expression }>({\n  ArrowFunctionExpression(path) {\n    path.skip();\n  },\n\n  AwaitExpression(path, { wrapAwait }) {\n    const argument = path.get(\"argument\");\n\n    path.replaceWith(\n      yieldExpression(\n        wrapAwait\n          ? callExpression(cloneNode(wrapAwait), [argument.node])\n          : argument.node,\n      ),\n    );\n  },\n});\n\nexport default function (\n  path: NodePath<t.Function>,\n  helpers: {\n    wrapAsync: t.Expression;\n    wrapAwait?: t.Expression;\n  },\n  noNewArrows?: boolean,\n  ignoreFunctionLength?: boolean,\n) {\n  path.traverse(awaitVisitor, {\n    wrapAwait: helpers.wrapAwait,\n  });\n\n  const isIIFE = checkIsIIFE(path);\n\n  path.node.async = false;\n  path.node.generator = true;\n\n  wrapFunction(\n    path,\n    cloneNode(helpers.wrapAsync),\n    noNewArrows,\n    ignoreFunctionLength,\n  );\n\n  const isProperty =\n    path.isObjectMethod() ||\n    path.isClassMethod() ||\n    path.parentPath.isObjectProperty() ||\n    path.parentPath.isClassProperty();\n\n  if (!isProperty && !isIIFE && path.isExpression()) {\n    annotateAsPure(path);\n  }\n\n  function checkIsIIFE(path: NodePath) {\n    if (path.parentPath.isCallExpression({ callee: path.node })) {\n      return true;\n    }\n\n    // try to catch calls to Function#bind, as emitted by arrowFunctionToExpression in spec mode\n    // this may also catch .bind(this) written by users, but does it matter? 🤔\n    const { parentPath } = path;\n    if (\n      parentPath.isMemberExpression() &&\n      isIdentifier(parentPath.node.property, { name: \"bind\" })\n    ) {\n      const { parentPath: bindCall } = parentPath;\n\n      // (function () { ... }).bind(this)()\n\n      return (\n        // first, check if the .bind is actually being called\n        bindCall.isCallExpression() &&\n        // and whether its sole argument is 'this'\n        bindCall.node.arguments.length === 1 &&\n        isThisExpression(bindCall.node.arguments[0]) &&\n        // and whether the result of the .bind(this) is being called\n        bindCall.parentPath.isCallExpression({ callee: bindCall.node })\n      );\n    }\n\n    return false;\n  }\n}\n"],"names":["_helperWrapFunction","require","_helperAnnotateAsPure","_core","_traverse","callExpression","cloneNode","isIdentifier","isThisExpression","yieldExpression","t","awaitVisitor","visitors","environmentVisitor","ArrowFunctionExpression","path","skip","AwaitExpression","wrapAwait","argument","get","replaceWith","node","_default","helpers","noNewArrows","ignoreFunctionLength","traverse","isIIFE","checkIsIIFE","async","generator","wrapFunction","wrapAsync","isProperty","isObjectMethod","isClassMethod","parentPath","isObjectProperty","isClassProperty","isExpression","annotateAsPure","isCallExpression","callee","isMemberExpression","property","name","bindCall","arguments","length"],"mappings":";;;;;AAGA,IAAAA,mBAAA,GAAAC,OAAA;AACA,IAAAC,qBAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AACA,IAAAG,SAAA,GAAAH,OAAA;AACA,MAAM,EACJI,cAAc,EACdC,SAAS,EACTC,YAAY,EACZC,gBAAgB,EAChBC,eAAAA,EACD,GAAGC,MAAAA,KAAC;AAEL,MAAMC,YAAY,GAAGC,UAAAA,QAAQ,CAACC,kBAAkB,CAA8B;IAC5EC,uBAAuBA,EAACC,IAAI,EAAE;QAC5BA,IAAI,CAACC,IAAI,CAAC,CAAC;IACb,CAAC;IAEDC,eAAeA,EAACF,IAAI,EAAE,EAAEG,SAAAA,EAAW,EAAE;QACnC,MAAMC,QAAQ,GAAGJ,IAAI,CAACK,GAAG,CAAC,UAAU,CAAC;QAErCL,IAAI,CAACM,WAAW,CACdZ,eAAe,CACbS,SAAS,GACLb,cAAc,CAACC,SAAS,CAACY,SAAS,CAAC,EAAE;YAACC,QAAQ,CAACG,IAAI;SAAC,CAAC,GACrDH,QAAQ,CAACG,IACf,CACF,CAAC;IACH;AACF,CAAC,CAAC;AAEa,SAAAC,SACbR,IAA0B,EAC1BS,OAGC,EACDC,WAAqB,EACrBC,oBAA8B,EAC9B;IACAX,IAAI,CAACY,QAAQ,CAAChB,YAAY,EAAE;QAC1BO,SAAS,EAAEM,OAAO,CAACN,SAAAA;IACrB,CAAC,CAAC;IAEF,MAAMU,MAAM,GAAGC,WAAW,CAACd,IAAI,CAAC;IAEhCA,IAAI,CAACO,IAAI,CAACQ,KAAK,GAAG,KAAK;IACvBf,IAAI,CAACO,IAAI,CAACS,SAAS,GAAG,IAAI;IAE1B,CAAA,GAAAC,oBAAAA,OAAY,EACVjB,IAAI,EACJT,SAAS,CAACkB,OAAO,CAACS,SAAS,CAAC,EAC5BR,WAAW,EACXC,oBACF,CAAC;IAED,MAAMQ,UAAU,GACdnB,IAAI,CAACoB,cAAc,CAAC,CAAC,IACrBpB,IAAI,CAACqB,aAAa,CAAC,CAAC,IACpBrB,IAAI,CAACsB,UAAU,CAACC,gBAAgB,CAAC,CAAC,IAClCvB,IAAI,CAACsB,UAAU,CAACE,eAAe,CAAC,CAAC;IAEnC,IAAI,CAACL,UAAU,IAAI,CAACN,MAAM,IAAIb,IAAI,CAACyB,YAAY,CAAC,CAAC,EAAE;QACjD,CAAA,GAAAC,sBAAAA,OAAc,EAAC1B,IAAI,CAAC;IACtB;IAEA,SAASc,WAAWA,CAACd,IAAc,EAAE;QACnC,IAAIA,IAAI,CAACsB,UAAU,CAACK,gBAAgB,CAAC;YAAEC,MAAM,EAAE5B,IAAI,CAACO,IAAAA;QAAK,CAAC,CAAC,EAAE;YAC3D,OAAO,IAAI;QACb;QAIA,MAAM,EAAEe,UAAAA,EAAY,GAAGtB,IAAI;QAC3B,IACEsB,UAAU,CAACO,kBAAkB,CAAC,CAAC,IAC/BrC,YAAY,CAAC8B,UAAU,CAACf,IAAI,CAACuB,QAAQ,EAAE;YAAEC,IAAI,EAAE;QAAO,CAAC,CAAC,EACxD;YACA,MAAM,EAAET,UAAU,EAAEU,QAAAA,EAAU,GAAGV,UAAU;YAI3C,OAEEU,QAAQ,CAACL,gBAAgB,CAAC,CAAC,IAE3BK,QAAQ,CAACzB,IAAI,CAAC0B,SAAS,CAACC,MAAM,KAAK,CAAC,IACpCzC,gBAAgB,CAACuC,QAAQ,CAACzB,IAAI,CAAC0B,SAAS,CAAC,CAAC,CAAC,CAAC,IAE5CD,QAAQ,CAACV,UAAU,CAACK,gBAAgB,CAAC;gBAAEC,MAAM,EAAEI,QAAQ,CAACzB,IAAAA;YAAK,CAAC,CAAC;QAEnE;QAEA,OAAO,KAAK;IACd;AACF","ignoreList":[0]}},
    {"offset": {"line": 6779, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6784, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-async-generator-functions/src/for-await.ts"],"sourcesContent":["import { types as t, template, type NodePath } from \"@babel/core\";\n\nconst buildForAwait = template(`\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n`);\n\nexport default function (\n  path: NodePath<t.ForOfStatement>,\n  { getAsyncIterator }: { getAsyncIterator: t.Identifier },\n) {\n  const { node, scope, parent } = path;\n\n  const stepKey = scope.generateUidIdentifier(\"step\");\n  const stepValue = t.memberExpression(stepKey, t.identifier(\"value\"));\n  const left = node.left;\n  let declar;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for await (i of test), for await ({ i } of test)\n    declar = t.expressionStatement(\n      t.assignmentExpression(\"=\", left, stepValue),\n    );\n  } else if (t.isVariableDeclaration(left)) {\n    // for await (let i of test)\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, stepValue),\n    ]);\n  }\n  let template = buildForAwait({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier(\n      \"iteratorAbruptCompletion\",\n    ),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: getAsyncIterator,\n    OBJECT: node.right,\n    STEP_KEY: t.cloneNode(stepKey),\n  });\n\n  // remove async function wrapper\n  // @ts-expect-error todo(flow->ts) improve type annotation for buildForAwait\n  template = template.body.body as t.Statement[];\n\n  const isLabeledParent = t.isLabeledStatement(parent);\n  const tryBody = (template[3] as t.TryStatement).block.body;\n  const loop = tryBody[0] as t.ForStatement;\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar,\n    loop,\n  };\n}\n"],"names":["_core","require","buildForAwait","template","_default","path","getAsyncIterator","node","scope","parent","stepKey","generateUidIdentifier","stepValue","t","memberExpression","identifier","left","declar","isIdentifier","isPattern","isMemberExpression","expressionStatement","assignmentExpression","isVariableDeclaration","variableDeclaration","kind","variableDeclarator","declarations","id","ITERATOR_HAD_ERROR_KEY","ITERATOR_ABRUPT_COMPLETION","ITERATOR_ERROR_KEY","ITERATOR_KEY","GET_ITERATOR","OBJECT","right","STEP_KEY","cloneNode","body","isLabeledParent","isLabeledStatement","tryBody","block","loop","labeledStatement","label","replaceParent"],"mappings":";;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,MAAMC,aAAa,GAAG,CAAA,GAAAC,MAAAA,QAAQ,EAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2B/B,CAAC,CAAC;AAEa,SAAAC,SACbC,IAAgC,EAChC,EAAEC,gBAAAA,EAAsD,EACxD;IACA,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAEC,MAAAA,EAAQ,GAAGJ,IAAI;IAEpC,MAAMK,OAAO,GAAGF,KAAK,CAACG,qBAAqB,CAAC,MAAM,CAAC;IACnD,MAAMC,SAAS,GAAGC,MAAAA,KAAC,CAACC,gBAAgB,CAACJ,OAAO,EAAEG,MAAAA,KAAC,CAACE,UAAU,CAAC,OAAO,CAAC,CAAC;IACpE,MAAMC,IAAI,GAAGT,IAAI,CAACS,IAAI;IACtB,IAAIC,MAAM;IAEV,IAAIJ,MAAAA,KAAC,CAACK,YAAY,CAACF,IAAI,CAAC,IAAIH,MAAAA,KAAC,CAACM,SAAS,CAACH,IAAI,CAAC,IAAIH,MAAAA,KAAC,CAACO,kBAAkB,CAACJ,IAAI,CAAC,EAAE;QAE3EC,MAAM,GAAGJ,MAAAA,KAAC,CAACQ,mBAAmB,CAC5BR,MAAAA,KAAC,CAACS,oBAAoB,CAAC,GAAG,EAAEN,IAAI,EAAEJ,SAAS,CAC7C,CAAC;IACH,CAAC,MAAM,IAAIC,MAAAA,KAAC,CAACU,qBAAqB,CAACP,IAAI,CAAC,EAAE;QAExCC,MAAM,GAAGJ,MAAAA,KAAC,CAACW,mBAAmB,CAACR,IAAI,CAACS,IAAI,EAAE;YACxCZ,MAAAA,KAAC,CAACa,kBAAkB,CAACV,IAAI,CAACW,YAAY,CAAC,CAAC,CAAC,CAACC,EAAE,EAAEhB,SAAS,CAAC;SACzD,CAAC;IACJ;IACA,IAAIT,QAAQ,GAAGD,aAAa,CAAC;QAC3B2B,sBAAsB,EAAErB,KAAK,CAACG,qBAAqB,CAAC,kBAAkB,CAAC;QACvEmB,0BAA0B,EAAEtB,KAAK,CAACG,qBAAqB,CACrD,0BACF,CAAC;QACDoB,kBAAkB,EAAEvB,KAAK,CAACG,qBAAqB,CAAC,eAAe,CAAC;QAChEqB,YAAY,EAAExB,KAAK,CAACG,qBAAqB,CAAC,UAAU,CAAC;QACrDsB,YAAY,EAAE3B,gBAAgB;QAC9B4B,MAAM,EAAE3B,IAAI,CAAC4B,KAAK;QAClBC,QAAQ,EAAEvB,MAAAA,KAAC,CAACwB,SAAS,CAAC3B,OAAO;IAC/B,CAAC,CAAC;IAIFP,QAAQ,GAAGA,QAAQ,CAACmC,IAAI,CAACA,IAAqB;IAE9C,MAAMC,eAAe,GAAG1B,MAAAA,KAAC,CAAC2B,kBAAkB,CAAC/B,MAAM,CAAC;IACpD,MAAMgC,OAAO,GAAItC,QAAQ,CAAC,CAAC,CAAC,CAAoBuC,KAAK,CAACJ,IAAI;IAC1D,MAAMK,IAAI,GAAGF,OAAO,CAAC,CAAC,CAAmB;IAEzC,IAAIF,eAAe,EAAE;QACnBE,OAAO,CAAC,CAAC,CAAC,GAAG5B,MAAAA,KAAC,CAAC+B,gBAAgB,CAACnC,MAAM,CAACoC,KAAK,EAAEF,IAAI,CAAC;IACrD;IAEA,OAAO;QACLG,aAAa,EAAEP,eAAe;QAC9BhC,IAAI,EAAEJ,QAAQ;QACdc,MAAM;QACN0B;IACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 6854, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6859, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-async-generator-functions/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport remapAsyncToGenerator from \"@babel/helper-remap-async-to-generator\";\nimport type { NodePath, Visitor, PluginPass } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport rewriteForAwait from \"./for-await.ts\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const yieldStarVisitor = visitors.environmentVisitor<PluginPass>({\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    YieldExpression({ node }, state) {\n      if (!node.delegate) return;\n      const asyncIter = t.callExpression(state.addHelper(\"asyncIterator\"), [\n        node.argument,\n      ]);\n      node.argument = t.callExpression(\n        state.addHelper(\"asyncGeneratorDelegate\"),\n        process.env.BABEL_8_BREAKING\n          ? [asyncIter]\n          : [asyncIter, state.addHelper(\"awaitAsyncGenerator\")],\n      );\n    },\n  });\n\n  const forAwaitVisitor = visitors.environmentVisitor<PluginPass>({\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    ForOfStatement(path: NodePath<t.ForOfStatement>, { file }) {\n      const { node } = path;\n      if (!node.await) return;\n\n      const build = rewriteForAwait(path, {\n        getAsyncIterator: file.addHelper(\"asyncIterator\"),\n      });\n\n      const { declar, loop } = build;\n      const block = loop.body as t.BlockStatement;\n\n      // ensure that it's a block so we can take all its statements\n      path.ensureBlock();\n\n      // add the value declaration to the new loop body\n      if (declar) {\n        block.body.push(declar);\n        if (path.node.body.body.length) {\n          block.body.push(t.blockStatement(path.node.body.body));\n        }\n      } else {\n        block.body.push(...path.node.body.body);\n      }\n\n      t.inherits(loop, node);\n      t.inherits(loop.body, node.body);\n\n      const p = build.replaceParent ? path.parentPath : path;\n      p.replaceWithMultiple(build.node);\n\n      // TODO: Avoid crawl\n      p.scope.parent.crawl();\n    },\n  });\n\n  const visitor: Visitor<PluginPass> = {\n    Function(path, state) {\n      if (!path.node.async) return;\n\n      path.traverse(forAwaitVisitor, state);\n\n      if (!path.node.generator) return;\n\n      path.traverse(yieldStarVisitor, state);\n\n      path.setData(\n        \"@babel/plugin-transform-async-generator-functions/async_generator_function\",\n        true,\n      );\n\n      // We don't need to pass the noNewArrows assumption, since\n      // async generators are never arrow functions.\n      remapAsyncToGenerator(path, {\n        wrapAsync: state.addHelper(\"wrapAsyncGenerator\"),\n        wrapAwait: state.addHelper(\"awaitAsyncGenerator\"),\n      });\n    },\n  };\n\n  return {\n    name: \"transform-async-generator-functions\",\n\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"asyncGenerators\"),\n\n    visitor: {\n      Program(path, state) {\n        // We need to traverse the ast here (instead of just vising Function\n        // in the top level visitor) because for-await needs to run before the\n        // async-to-generator plugin. This is because for-await is transpiled\n        // using \"await\" expressions, which are then converted to \"yield\".\n        //\n        // This is bad for performance, but plugin ordering will allow as to\n        // directly visit Function in the top level visitor.\n        path.traverse(visitor, state);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperRemapAsyncToGenerator","_core","_traverse","_forAwait","_default","exports","default","declare","api","assertVersion","yieldStarVisitor","visitors","environmentVisitor","ArrowFunctionExpression","path","skip","YieldExpression","node","state","delegate","asyncIter","t","callExpression","addHelper","argument","forAwaitVisitor","ForOfStatement","file","await","build","rewriteForAwait","getAsyncIterator","declar","loop","block","body","ensureBlock","push","length","blockStatement","inherits","p","replaceParent","parentPath","replaceWithMultiple","scope","parent","crawl","visitor","Function","async","traverse","generator","setData","remapAsyncToGenerator","wrapAsync","wrapAwait","name","manipulateOptions","_","parser","plugins","Program"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6937, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6942, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-async-to-generator/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport remapAsyncToGenerator from \"@babel/helper-remap-async-to-generator\";\nimport { addNamed } from \"@babel/helper-module-imports\";\nimport { types as t } from \"@babel/core\";\n\nexport interface Options {\n  method?: string;\n  module?: string;\n}\n\ntype State = {\n  methodWrapper?: t.Identifier | t.SequenceExpression;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { method, module } = options;\n  // Todo(BABEL 8): Consider default it to false\n  const noNewArrows = api.assumption(\"noNewArrows\") ?? true;\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? false;\n\n  if (method && module) {\n    return {\n      name: \"transform-async-to-generator\",\n\n      visitor: {\n        Function(path, state) {\n          if (!path.node.async || path.node.generator) return;\n\n          let wrapAsync = state.methodWrapper;\n          if (wrapAsync) {\n            wrapAsync = t.cloneNode(wrapAsync);\n          } else {\n            wrapAsync = state.methodWrapper = addNamed(path, method, module);\n          }\n\n          remapAsyncToGenerator(\n            path,\n            { wrapAsync },\n            noNewArrows,\n            ignoreFunctionLength,\n          );\n        },\n      },\n    };\n  }\n\n  return {\n    name: \"transform-async-to-generator\",\n\n    visitor: {\n      Function(path, state) {\n        if (!path.node.async || path.node.generator) return;\n\n        remapAsyncToGenerator(\n          path,\n          { wrapAsync: state.addHelper(\"asyncToGenerator\") },\n          noNewArrows,\n          ignoreFunctionLength,\n        );\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperRemapAsyncToGenerator","_helperModuleImports","_core","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","method","module","noNewArrows","assumption","ignoreFunctionLength","name","visitor","Function","path","state","node","async","generator","wrapAsync","methodWrapper","t","cloneNode","addNamed","remapAsyncToGenerator","addHelper"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,4BAAA,GAAAD,OAAA;AACA,IAAAE,oBAAA,GAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AAAyC,IAAAI,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAW1B,CAAA,GAAAC,mBAAAA,OAAO,EAAQ,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAAA,IAAAC,eAAA,EAAAC,gBAAA;IACvDH,GAAG,CAACI,aAAa,CAAA,sCAAoB,CAAC;IAEtC,MAAM,EAAEC,MAAM,EAAEC,MAAAA,EAAQ,GAAGL,OAAO;IAElC,MAAMM,WAAW,GAAA,CAAAL,eAAA,GAAGF,GAAG,CAACQ,UAAU,CAAC,aAAa,CAAC,KAAA,OAAAN,eAAA,GAAI,IAAI;IACzD,MAAMO,oBAAoB,GAAA,CAAAN,gBAAA,GAAGH,GAAG,CAACQ,UAAU,CAAC,sBAAsB,CAAC,KAAA,OAAAL,gBAAA,GAAI,KAAK;IAE5E,IAAIE,MAAM,IAAIC,MAAM,EAAE;QACpB,OAAO;YACLI,IAAI,EAAE,8BAA8B;YAEpCC,OAAO,EAAE;gBACPC,QAAQA,EAACC,IAAI,EAAEC,KAAK,EAAE;oBACpB,IAAI,CAACD,IAAI,CAACE,IAAI,CAACC,KAAK,IAAIH,IAAI,CAACE,IAAI,CAACE,SAAS,EAAE;oBAE7C,IAAIC,SAAS,GAAGJ,KAAK,CAACK,aAAa;oBACnC,IAAID,SAAS,EAAE;wBACbA,SAAS,GAAGE,MAAAA,KAAC,CAACC,SAAS,CAACH,SAAS,CAAC;oBACpC,CAAC,MAAM;wBACLA,SAAS,GAAGJ,KAAK,CAACK,aAAa,GAAG,CAAA,GAAAG,qBAAAA,QAAQ,EAACT,IAAI,EAAER,MAAM,EAAEC,MAAM,CAAC;oBAClE;oBAEA,CAAA,GAAAiB,6BAAAA,OAAqB,EACnBV,IAAI,EACJ;wBAAEK;oBAAU,CAAC,EACbX,WAAW,EACXE,oBACF,CAAC;gBACH;YACF;QACF,CAAC;IACH;IAEA,OAAO;QACLC,IAAI,EAAE,8BAA8B;QAEpCC,OAAO,EAAE;YACPC,QAAQA,EAACC,IAAI,EAAEC,KAAK,EAAE;gBACpB,IAAI,CAACD,IAAI,CAACE,IAAI,CAACC,KAAK,IAAIH,IAAI,CAACE,IAAI,CAACE,SAAS,EAAE;gBAE7C,CAAA,GAAAM,6BAAAA,OAAqB,EACnBV,IAAI,EACJ;oBAAEK,SAAS,EAAEJ,KAAK,CAACU,SAAS,CAAC,kBAAkB;gBAAE,CAAC,EAClDjB,WAAW,EACXE,oBACF,CAAC;YACH;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 6988, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6993, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-arrow-functions/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  spec?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const noNewArrows = api.assumption(\"noNewArrows\") ?? !options.spec;\n\n  return {\n    name: \"transform-arrow-functions\",\n\n    visitor: {\n      ArrowFunctionExpression(path) {\n        // In some conversion cases, it may have already been converted to a function while this callback\n        // was queued up.\n        if (!path.isArrowFunctionExpression()) return;\n\n        if (process.env.BABEL_8_BREAKING) {\n          path.arrowFunctionToExpression({\n            // While other utils may be fine inserting other arrows to make more transforms possible,\n            // the arrow transform itself absolutely cannot insert new arrow functions.\n            allowInsertArrow: false,\n            noNewArrows,\n          });\n        } else {\n          path.arrowFunctionToExpression({\n            allowInsertArrow: false,\n            noNewArrows,\n\n            // This is only needed for backward compat with @babel/traverse <7.13.0\n            // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n            specCompliant: !noNewArrows,\n          });\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","options","_api$assumption","assertVersion","noNewArrows","assumption","spec","name","visitor","ArrowFunctionExpression","path","isArrowFunctionExpression","arrowFunctionToExpression","allowInsertArrow","specCompliant"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMtC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAAA,IAAAC,eAAA;IAChDF,GAAG,CAACG,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAMC,WAAW,GAAA,CAAAF,eAAA,GAAGF,GAAG,CAACK,UAAU,CAAC,aAAa,CAAC,KAAA,OAAAH,eAAA,GAAI,CAACD,OAAO,CAACK,IAAI;IAElE,OAAO;QACLC,IAAI,EAAE,2BAA2B;QAEjCC,OAAO,EAAE;YACPC,uBAAuBA,EAACC,IAAI,EAAE;gBAG5B,IAAI,CAACA,IAAI,CAACC,yBAAyB,CAAC,CAAC,EAAE;gBAShC;oBACLD,IAAI,CAACE,yBAAyB,CAAC;wBAC7BC,gBAAgB,EAAE,KAAK;wBACvBT,WAAW;wBAIXU,aAAa,EAAE,CAACV;oBAClB,CAAC,CAAC;gBACJ;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 7019, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7024, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-block-scoped-functions/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  function transformStatementList(\n    parentPath: NodePath,\n    paths: NodePath<t.Statement>[],\n  ) {\n    const isInStrictMode = parentPath.isInStrictMode();\n\n    for (const path of paths) {\n      if (!path.isFunctionDeclaration()) continue;\n\n      if (\n        process.env.BABEL_8_BREAKING &&\n        !isInStrictMode &&\n        !(\n          path.node.async ||\n          path.node.generator ||\n          path.getData(\n            \"@babel/plugin-transform-async-generator-functions/async_generator_function\",\n          )\n        )\n      ) {\n        continue;\n      }\n\n      const func = path.node;\n      const declar = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(func.id, t.toExpression(func)),\n      ]);\n\n      // hoist it up above everything else\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      declar._blockHoist = 2;\n\n      // todo: name this\n      func.id = null;\n\n      path.replaceWith(declar);\n    }\n  }\n\n  return {\n    name: \"transform-block-scoped-functions\",\n\n    visitor: {\n      BlockStatement(path) {\n        const { node, parent } = path;\n        if (\n          t.isFunction(parent, { body: node }) ||\n          t.isExportDeclaration(parent)\n        ) {\n          return;\n        }\n\n        transformStatementList(path, path.get(\"body\"));\n      },\n\n      SwitchCase(path) {\n        transformStatementList(path, path.get(\"consequent\"));\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","transformStatementList","parentPath","paths","isInStrictMode","path","isFunctionDeclaration","func","node","declar","t","variableDeclaration","variableDeclarator","id","toExpression","_blockHoist","replaceWith","name","visitor","BlockStatement","parent","isFunction","body","isExportDeclaration","get","SwitchCase"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAwD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEzC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,SAASC,sBAAsBA,CAC7BC,UAAoB,EACpBC,KAA8B,EAC9B;QACA,MAAMC,cAAc,GAAGF,UAAU,CAACE,cAAc,CAAC,CAAC;QAElD,KAAK,MAAMC,IAAI,IAAIF,KAAK,CAAE;YACxB,IAAI,CAACE,IAAI,CAACC,qBAAqB,CAAC,CAAC,EAAE;;YAgBnC,MAAMC,IAAI,GAAGF,IAAI,CAACG,IAAI;YACtB,MAAMC,MAAM,GAAGC,MAAAA,KAAC,CAACC,mBAAmB,CAAC,KAAK,EAAE;gBAC1CD,MAAAA,KAAC,CAACE,kBAAkB,CAACL,IAAI,CAACM,EAAE,EAAEH,MAAAA,KAAC,CAACI,YAAY,CAACP,IAAI,CAAC,CAAC;aACpD,CAAC;YAIFE,MAAM,CAACM,WAAW,GAAG,CAAC;YAGtBR,IAAI,CAACM,EAAE,GAAG,IAAI;YAEdR,IAAI,CAACW,WAAW,CAACP,MAAM,CAAC;QAC1B;IACF;IAEA,OAAO;QACLQ,IAAI,EAAE,kCAAkC;QAExCC,OAAO,EAAE;YACPC,cAAcA,EAACd,IAAI,EAAE;gBACnB,MAAM,EAAEG,IAAI,EAAEY,MAAAA,EAAQ,GAAGf,IAAI;gBAC7B,IACEK,MAAAA,KAAC,CAACW,UAAU,CAACD,MAAM,EAAE;oBAAEE,IAAI,EAAEd;gBAAK,CAAC,CAAC,IACpCE,MAAAA,KAAC,CAACa,mBAAmB,CAACH,MAAM,CAAC,EAC7B;oBACA;gBACF;gBAEAnB,sBAAsB,CAACI,IAAI,EAAEA,IAAI,CAACmB,GAAG,CAAC,MAAM,CAAC,CAAC;YAChD,CAAC;YAEDC,UAAUA,EAACpB,IAAI,EAAE;gBACfJ,sBAAsB,CAACI,IAAI,EAAEA,IAAI,CAACmB,GAAG,CAAC,YAAY,CAAC,CAAC;YACtD;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 7065, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7070, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-block-scoping/src/loop.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/core\";\n\ninterface LoopBodyBindingsState {\n  blockScoped: Scope.Binding[];\n}\n\nconst collectLoopBodyBindingsVisitor: Visitor<LoopBodyBindingsState> = {\n  \"Expression|Declaration|Loop\"(path) {\n    path.skip();\n  },\n  Scope(path, state) {\n    if (path.isFunctionParent()) path.skip();\n\n    const { bindings } = path.scope;\n    for (const name of Object.keys(bindings)) {\n      const binding = bindings[name];\n      if (\n        binding.kind === \"let\" ||\n        binding.kind === \"const\" ||\n        binding.kind === \"hoisted\"\n      ) {\n        state.blockScoped.push(binding);\n      }\n    }\n  },\n};\n\nexport function getLoopBodyBindings(loopPath: NodePath<t.Loop>) {\n  const state: LoopBodyBindingsState = { blockScoped: [] };\n  loopPath.traverse(collectLoopBodyBindingsVisitor, state);\n  return state.blockScoped;\n}\n\nexport function getUsageInBody(\n  binding: Scope.Binding,\n  loopPath: NodePath<t.Loop>,\n) {\n  // UpdateExpressions are counted both as a reference and a mutation,\n  // so we need to de-duplicate them.\n  const seen = new WeakSet<t.Node>();\n\n  let capturedInClosure = false;\n\n  const constantViolations = filterMap(binding.constantViolations, path => {\n    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);\n    if (!inBody) return null;\n    capturedInClosure ||= inClosure;\n\n    const id = path.isUpdateExpression()\n      ? path.get(\"argument\")\n      : path.isAssignmentExpression()\n        ? path.get(\"left\")\n        : null;\n    if (id) seen.add(id.node);\n    return id as NodePath<t.Identifier> | null;\n  });\n\n  const references = filterMap(binding.referencePaths, path => {\n    if (seen.has(path.node)) return null;\n\n    const { inBody, inClosure } = relativeLoopLocation(path, loopPath);\n    if (!inBody) return null;\n    capturedInClosure ||= inClosure;\n\n    return path as NodePath<t.Identifier>;\n  });\n\n  return {\n    capturedInClosure,\n    hasConstantViolations: constantViolations.length > 0,\n    usages: references.concat(constantViolations),\n  };\n}\n\nfunction relativeLoopLocation(path: NodePath, loopPath: NodePath<t.Loop>) {\n  const bodyPath = loopPath.get(\"body\");\n  let inClosure = false;\n\n  for (let currPath = path; currPath; currPath = currPath.parentPath) {\n    if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {\n      inClosure = true;\n    }\n    if (currPath === bodyPath) {\n      return { inBody: true, inClosure };\n    } else if (currPath === loopPath) {\n      return { inBody: false, inClosure };\n    }\n  }\n\n  throw new Error(\n    \"Internal Babel error: path is not in loop. Please report this as a bug.\",\n  );\n}\n\ninterface CompletionsAndVarsState {\n  breaksContinues: NodePath<t.BreakStatement | t.ContinueStatement>[];\n  returns: NodePath<t.ReturnStatement>[];\n  labelsStack: string[];\n  labellessContinueTargets: number;\n  labellessBreakTargets: number;\n\n  vars: NodePath<t.VariableDeclaration>[];\n  loopNode: t.Loop;\n}\n\nconst collectCompletionsAndVarsVisitor: Visitor<CompletionsAndVarsState> = {\n  Function(path) {\n    path.skip();\n  },\n  LabeledStatement: {\n    enter({ node }, state) {\n      state.labelsStack.push(node.label.name);\n    },\n    exit({ node }, state) {\n      const popped = state.labelsStack.pop();\n      if (popped !== node.label.name) {\n        throw new Error(\"Assertion failure. Please report this bug to Babel.\");\n      }\n    },\n  },\n  Loop: {\n    enter(_, state) {\n      state.labellessContinueTargets++;\n      state.labellessBreakTargets++;\n    },\n    exit(_, state) {\n      state.labellessContinueTargets--;\n      state.labellessBreakTargets--;\n    },\n  },\n  SwitchStatement: {\n    enter(_, state) {\n      state.labellessBreakTargets++;\n    },\n    exit(_, state) {\n      state.labellessBreakTargets--;\n    },\n  },\n  \"BreakStatement|ContinueStatement\"(\n    path: NodePath<t.BreakStatement | t.ContinueStatement>,\n    state,\n  ) {\n    const { label } = path.node;\n    if (label) {\n      if (state.labelsStack.includes(label.name)) return;\n    } else if (\n      path.isBreakStatement()\n        ? state.labellessBreakTargets > 0\n        : state.labellessContinueTargets > 0\n    ) {\n      return;\n    }\n    state.breaksContinues.push(path);\n  },\n  ReturnStatement(path, state) {\n    state.returns.push(path);\n  },\n  VariableDeclaration(path, state) {\n    if (path.parent === state.loopNode && isVarInLoopHead(path)) return;\n    if (path.node.kind === \"var\") state.vars.push(path);\n  },\n};\n\nexport function wrapLoopBody(\n  loopPath: NodePath<t.Loop>,\n  captured: string[],\n  updatedBindingsUsages: Map<string, NodePath<t.Identifier>[]>,\n) {\n  const loopNode = loopPath.node;\n  const state: CompletionsAndVarsState = {\n    breaksContinues: [],\n    returns: [],\n    labelsStack: [],\n    labellessBreakTargets: 0,\n    labellessContinueTargets: 0,\n    vars: [],\n    loopNode,\n  };\n  loopPath.traverse(collectCompletionsAndVarsVisitor, state);\n\n  const callArgs = [];\n  const closureParams = [];\n  const updater = [];\n  for (const [name, updatedUsage] of updatedBindingsUsages) {\n    callArgs.push(t.identifier(name));\n\n    const innerName = loopPath.scope.generateUid(name);\n    closureParams.push(t.identifier(innerName));\n    updater.push(\n      t.assignmentExpression(\"=\", t.identifier(name), t.identifier(innerName)),\n    );\n    for (const path of updatedUsage) path.replaceWith(t.identifier(innerName));\n  }\n  for (const name of captured) {\n    if (updatedBindingsUsages.has(name)) continue; // already injected\n    callArgs.push(t.identifier(name));\n    closureParams.push(t.identifier(name));\n  }\n\n  const id = loopPath.scope.generateUid(\"loop\");\n  const fn = t.functionExpression(\n    null,\n    closureParams,\n    t.toBlock(loopNode.body),\n  );\n  let call: t.Expression = t.callExpression(t.identifier(id), callArgs);\n\n  const fnParent = loopPath.findParent(p => p.isFunction());\n  if (fnParent) {\n    const { async, generator } = fnParent.node as t.Function;\n    fn.async = async;\n    fn.generator = generator;\n    if (generator) call = t.yieldExpression(call, true);\n    else if (async) call = t.awaitExpression(call);\n  }\n\n  const updaterNode =\n    updater.length > 0\n      ? t.expressionStatement(t.sequenceExpression(updater))\n      : null;\n  if (updaterNode) fn.body.body.push(updaterNode);\n\n  // NOTE: Calling .insertBefore on the loop path might cause the\n  // loop to be moved in the AST. For example, in\n  //   if (true) for (let x of y) ...\n  // .insertBefore will replace the loop with a block:\n  //   if (true) { var _loop = ...; for (let x of y) ... }\n  // All subsequent operations in this function on the loop node\n  // must not assume that loopPath still represents the loop.\n  // TODO: Consider using a function declaration\n  const [varPath] = loopPath.insertBefore(\n    t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(id), fn)]),\n  ) as [NodePath<t.VariableDeclaration>];\n\n  const bodyStmts: t.Statement[] = [];\n\n  const varNames: string[] = [];\n  for (const varPath of state.vars) {\n    const assign = [];\n    for (const decl of varPath.node.declarations) {\n      varNames.push(...Object.keys(t.getBindingIdentifiers(decl.id)));\n      if (decl.init) {\n        assign.push(t.assignmentExpression(\"=\", decl.id, decl.init));\n      } else if (t.isForXStatement(varPath.parent, { left: varPath.node })) {\n        assign.push(decl.id as t.Identifier);\n      }\n    }\n    if (assign.length > 0) {\n      const replacement: t.Node =\n        assign.length === 1 ? assign[0] : t.sequenceExpression(assign);\n      varPath.replaceWith(replacement);\n    } else {\n      varPath.remove();\n    }\n  }\n  if (varNames.length) {\n    varPath.pushContainer(\n      \"declarations\",\n      varNames.map(name => t.variableDeclarator(t.identifier(name))),\n    );\n  }\n\n  const labelNum = state.breaksContinues.length;\n  const returnNum = state.returns.length;\n  if (labelNum + returnNum === 0) {\n    bodyStmts.push(t.expressionStatement(call));\n  } else if (labelNum === 1 && returnNum === 0) {\n    for (const path of state.breaksContinues) {\n      const { node } = path;\n      const { type, label } = node;\n      let name = type === \"BreakStatement\" ? \"break\" : \"continue\";\n      if (label) name += \" \" + label.name;\n      path.replaceWith(\n        t.addComment(\n          t.returnStatement(t.numericLiteral(1)),\n          \"trailing\",\n          \" \" + name,\n          true,\n        ),\n      );\n      if (updaterNode) path.insertBefore(t.cloneNode(updaterNode));\n\n      bodyStmts.push(\n        template.statement.ast`\n        if (${call}) ${node}\n      `,\n      );\n    }\n  } else {\n    const completionId = loopPath.scope.generateUid(\"ret\");\n\n    if (varPath.isVariableDeclaration()) {\n      varPath.pushContainer(\"declarations\", [\n        t.variableDeclarator(t.identifier(completionId)),\n      ]);\n      bodyStmts.push(\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.identifier(completionId), call),\n        ),\n      );\n    } else {\n      bodyStmts.push(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(t.identifier(completionId), call),\n        ]),\n      );\n    }\n\n    const injected: string[] = [];\n    for (const path of state.breaksContinues) {\n      const { node } = path;\n      const { type, label } = node;\n      let name = type === \"BreakStatement\" ? \"break\" : \"continue\";\n      if (label) name += \" \" + label.name;\n\n      let i = injected.indexOf(name);\n      const hasInjected = i !== -1;\n      if (!hasInjected) {\n        injected.push(name);\n        i = injected.length - 1;\n      }\n\n      path.replaceWith(\n        t.addComment(\n          t.returnStatement(t.numericLiteral(i)),\n          \"trailing\",\n          \" \" + name,\n          true,\n        ),\n      );\n      if (updaterNode) path.insertBefore(t.cloneNode(updaterNode));\n\n      if (hasInjected) continue;\n\n      bodyStmts.push(\n        template.statement.ast`\n        if (${t.identifier(completionId)} === ${t.numericLiteral(i)}) ${node}\n      `,\n      );\n    }\n\n    if (returnNum) {\n      for (const path of state.returns) {\n        const arg = path.node.argument || path.scope.buildUndefinedNode();\n        path.replaceWith(\n          template.statement.ast`\n          return { v: ${arg} };\n        `,\n        );\n      }\n\n      bodyStmts.push(\n        template.statement.ast`\n          if (${t.identifier(completionId)}) return ${t.identifier(\n            completionId,\n          )}.v;\n        `,\n      );\n    }\n  }\n\n  loopNode.body = t.blockStatement(bodyStmts);\n\n  return varPath;\n}\n\nexport function isVarInLoopHead(path: NodePath<t.VariableDeclaration>) {\n  if (t.isForStatement(path.parent)) return path.key === \"init\";\n  if (t.isForXStatement(path.parent)) return path.key === \"left\";\n  return false;\n}\n\nfunction filterMap<T, U extends object>(list: T[], fn: (item: T) => U | null) {\n  const result: U[] = [];\n  for (const item of list) {\n    const mapped = fn(item);\n    if (mapped) result.push(mapped);\n  }\n  return result;\n}\n"],"names":["_core","require","collectLoopBodyBindingsVisitor","Expression|Declaration|Loop","path","skip","Scope","state","isFunctionParent","bindings","scope","name","Object","keys","binding","kind","blockScoped","push","getLoopBodyBindings","loopPath","traverse","getUsageInBody","seen","WeakSet","capturedInClosure","constantViolations","filterMap","inBody","inClosure","relativeLoopLocation","id","isUpdateExpression","get","isAssignmentExpression","add","node","references","referencePaths","has","hasConstantViolations","length","usages","concat","bodyPath","currPath","parentPath","isFunction","isClass","isMethod","Error","collectCompletionsAndVarsVisitor","Function","LabeledStatement","enter","labelsStack","label","exit","popped","pop","Loop","_","labellessContinueTargets","labellessBreakTargets","SwitchStatement","BreakStatement|ContinueStatement","includes","isBreakStatement","breaksContinues","ReturnStatement","returns","VariableDeclaration","parent","loopNode","isVarInLoopHead","vars","wrapLoopBody","captured","updatedBindingsUsages","callArgs","closureParams","updater","updatedUsage","t","identifier","innerName","generateUid","assignmentExpression","replaceWith","fn","functionExpression","toBlock","body","call","callExpression","fnParent","findParent","p","async","generator","yieldExpression","awaitExpression","updaterNode","expressionStatement","sequenceExpression","varPath","insertBefore","variableDeclaration","variableDeclarator","bodyStmts","varNames","assign","decl","declarations","getBindingIdentifiers","init","isForXStatement","left","replacement","remove","pushContainer","map","labelNum","returnNum","type","addComment","returnStatement","numericLiteral","cloneNode","template","statement","ast","completionId","isVariableDeclaration","injected","i","indexOf","hasInjected","arg","argument","buildUndefinedNode","blockStatement","isForStatement","key","list","result","item","mapped"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7343, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-block-scoping/src/validation.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { Scope, NodePath, PluginPass } from \"@babel/core\";\n\nexport function validateUsage(\n  path: NodePath<t.VariableDeclaration>,\n  state: PluginPass,\n  tdzEnabled: boolean,\n) {\n  const dynamicTDZNames = [];\n\n  for (const name of Object.keys(path.getBindingIdentifiers())) {\n    const binding = path.scope.getBinding(name);\n    // binding may be null. ref: https://github.com/babel/babel/issues/15300\n    if (!binding) continue;\n    if (tdzEnabled) {\n      if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);\n    }\n    if (path.node.kind === \"const\") {\n      disallowConstantViolations(name, binding, state);\n    }\n  }\n\n  return dynamicTDZNames;\n}\n\nfunction disallowConstantViolations(\n  name: string,\n  binding: Scope.Binding,\n  state: PluginPass,\n) {\n  for (const violation of binding.constantViolations) {\n    const readOnlyError = state.addHelper(\"readOnlyError\");\n    const throwNode = t.callExpression(readOnlyError, [t.stringLiteral(name)]);\n\n    if (violation.isAssignmentExpression()) {\n      const { operator, left, right } = violation.node;\n      if (operator === \"=\") {\n        const exprs = [right];\n        exprs.push(throwNode);\n        violation.replaceWith(t.sequenceExpression(exprs));\n      } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n        violation.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error todo: give a better type to operator\n            operator.slice(0, -1),\n            left,\n            t.sequenceExpression([right, throwNode]),\n          ),\n        );\n      } else {\n        violation.replaceWith(\n          t.sequenceExpression([\n            t.binaryExpression(\n              // @ts-expect-error todo: give a better type to operator\n              operator.slice(0, -1),\n              left,\n              right,\n            ),\n            throwNode,\n          ]),\n        );\n      }\n    } else if (violation.isUpdateExpression()) {\n      violation.replaceWith(\n        t.sequenceExpression([\n          t.unaryExpression(\"+\", violation.get(\"argument\").node),\n          throwNode,\n        ]),\n      );\n    } else if (violation.isForXStatement()) {\n      violation.ensureBlock();\n      violation\n        .get(\"left\")\n        .replaceWith(\n          t.variableDeclaration(\"var\", [\n            t.variableDeclarator(violation.scope.generateUidIdentifier(name)),\n          ]),\n        );\n      (violation.node.body as t.BlockStatement).body.unshift(\n        t.expressionStatement(throwNode),\n      );\n    }\n  }\n}\n\nfunction getTDZStatus(refPath: NodePath, bindingPath: NodePath) {\n  const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);\n\n  if (executionStatus === \"before\") {\n    return \"outside\";\n  } else if (executionStatus === \"after\") {\n    return \"inside\";\n  } else {\n    return \"maybe\";\n  }\n}\n\nconst skipTDZChecks = new WeakSet();\n\nfunction buildTDZAssert(\n  status: \"maybe\" | \"inside\",\n  node: t.Identifier | t.JSXIdentifier,\n  state: PluginPass,\n) {\n  if (status === \"maybe\") {\n    const clone = t.cloneNode(node);\n    skipTDZChecks.add(clone);\n    return t.callExpression(state.addHelper(\"temporalRef\"), [\n      // @ts-expect-error Fixme: we may need to handle JSXIdentifier\n      clone,\n      t.stringLiteral(node.name),\n    ]);\n  } else {\n    return t.callExpression(state.addHelper(\"tdz\"), [\n      t.stringLiteral(node.name),\n    ]);\n  }\n}\n\ntype TDZReplacement = { status: \"maybe\" | \"inside\"; node: t.Expression };\nfunction getTDZReplacement(\n  path: NodePath<t.Identifier | t.JSXIdentifier>,\n  state: PluginPass,\n): TDZReplacement | undefined;\nfunction getTDZReplacement(\n  path: NodePath,\n  state: PluginPass,\n  id: t.Identifier | t.JSXIdentifier,\n): TDZReplacement | undefined;\nfunction getTDZReplacement(\n  path: NodePath,\n  state: PluginPass,\n  id: t.Identifier | t.JSXIdentifier = path.node as any,\n): TDZReplacement | undefined {\n  if (skipTDZChecks.has(id)) return;\n  skipTDZChecks.add(id);\n\n  const bindingPath = path.scope.getBinding(id.name)?.path;\n\n  if (!bindingPath || bindingPath.isFunctionDeclaration()) return;\n\n  const status = getTDZStatus(path, bindingPath);\n  if (status === \"outside\") return;\n\n  if (status === \"maybe\") {\n    // add tdzThis to parent variable declarator so it's exploded\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    bindingPath.parent._tdzThis = true;\n  }\n\n  return { status, node: buildTDZAssert(status, id, state) };\n}\n\nfunction injectTDZChecks(binding: Scope.Binding, state: PluginPass) {\n  const allUsages = new Set(binding.referencePaths);\n  binding.constantViolations.forEach(allUsages.add, allUsages);\n\n  let dynamicTdz = false;\n\n  for (const path of binding.constantViolations) {\n    const { node } = path;\n    if (skipTDZChecks.has(node)) continue;\n    skipTDZChecks.add(node);\n\n    if (path.isUpdateExpression()) {\n      // arg is an identifier referencing the current binding\n      const arg = path.get(\"argument\") as NodePath<t.Identifier>;\n\n      const replacement = getTDZReplacement(path, state, arg.node);\n      if (!replacement) continue;\n\n      if (replacement.status === \"maybe\") {\n        dynamicTdz = true;\n        path.insertBefore(replacement.node);\n      } else {\n        path.replaceWith(replacement.node);\n      }\n    } else if (path.isAssignmentExpression()) {\n      const nodes = [];\n      const ids = process.env.BABEL_8_BREAKING\n        ? path.getAssignmentIdentifiers()\n        : path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        const replacement = getTDZReplacement(path, state, ids[name]);\n        if (replacement) {\n          nodes.push(t.expressionStatement(replacement.node));\n          if (replacement.status === \"inside\") break;\n          if (replacement.status === \"maybe\") dynamicTdz = true;\n        }\n      }\n\n      if (nodes.length > 0) path.insertBefore(nodes);\n    }\n  }\n\n  for (const path of binding.referencePaths as NodePath<t.Identifier>[]) {\n    if (path.parentPath.isUpdateExpression()) continue;\n    // It will be handled after transforming the loop\n    if (path.parentPath.isFor({ left: path.node })) continue;\n\n    const replacement = getTDZReplacement(path, state);\n    if (!replacement) continue;\n    if (replacement.status === \"maybe\") dynamicTdz = true;\n\n    path.replaceWith(replacement.node);\n  }\n\n  return dynamicTdz;\n}\n"],"names":["_core","require","validateUsage","path","state","tdzEnabled","dynamicTDZNames","name","Object","keys","getBindingIdentifiers","binding","scope","getBinding","injectTDZChecks","push","node","kind","disallowConstantViolations","violation","constantViolations","readOnlyError","addHelper","throwNode","t","callExpression","stringLiteral","isAssignmentExpression","operator","left","right","exprs","replaceWith","sequenceExpression","includes","logicalExpression","slice","binaryExpression","isUpdateExpression","unaryExpression","get","isForXStatement","ensureBlock","variableDeclaration","variableDeclarator","generateUidIdentifier","body","unshift","expressionStatement","getTDZStatus","refPath","bindingPath","executionStatus","_guessExecutionStatusRelativeTo","skipTDZChecks","WeakSet","buildTDZAssert","status","clone","cloneNode","add","getTDZReplacement","id","_path$scope$getBindin","has","isFunctionDeclaration","parent","_tdzThis","allUsages","Set","referencePaths","forEach","dynamicTdz","arg","replacement","insertBefore","nodes","ids","length","parentPath","isFor"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7496, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-block-scoping/src/annex-B_3_3.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/core\";\n\n// Whenever a function declaration in a nested block scope\n// doesn't conflict with a block-scoped binding from an outer\n// scope, we transform it to a variable declaration.\n//\n// This implements the Annex B.3.3 behavior.\n//\n// TODO(Babel 8): Figure out how this should interact with\n// the transform-block-scoped functions plugin (it feels\n// wrong to handle this transform here), and what we want\n// to do with Annex B behavior in general.\n\n// To avoid confusing block-scoped variables transformed to\n// var with original vars, this transformation happens in two\n// different places:\n//   1. For functions that \"conflict\" with var-variables, in\n//      the VariableDeclaration visitor.\n//   2. For functions that don't conflict with any variable,\n//      in the FunctionDeclaration visitor.\n\nexport const annexB33FunctionsVisitor: Visitor = {\n  VariableDeclaration(path) {\n    if (isStrict(path)) return;\n    if (path.node.kind !== \"var\") return;\n\n    const varScope =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    varScope.path.traverse(functionsToVarVisitor, {\n      names: Object.keys(path.getBindingIdentifiers()),\n    });\n  },\n  ...(process.env.BABEL_8_BREAKING\n    ? {}\n    : {\n        // NOTE: These two visitors target the same nodes as the\n        // block-scoped-functions plugin\n        BlockStatement(path) {\n          if (isStrict(path)) return;\n          if (t.isFunction(path.parent, { body: path.node })) return;\n          transformStatementList(path.get(\"body\"));\n        },\n        SwitchCase(path) {\n          if (isStrict(path)) return;\n          transformStatementList(path.get(\"consequent\"));\n        },\n      }),\n};\n\nfunction transformStatementList(paths: NodePath<t.Statement>[]) {\n  outer: for (const path of paths) {\n    if (!path.isFunctionDeclaration()) continue;\n    // Annex B.3.3 only applies to plain functions.\n    if (path.node.async || path.node.generator) return;\n\n    const { scope } = path.parentPath;\n    if (isVarScope(scope)) return;\n\n    const { name } = path.node.id;\n    let currScope = scope;\n    do {\n      if (currScope.parent.hasOwnBinding(name)) continue outer;\n      currScope = currScope.parent;\n    } while (!isVarScope(currScope));\n\n    maybeTransformBlockScopedFunction(path);\n  }\n}\n\nfunction maybeTransformBlockScopedFunction(\n  path: NodePath<t.FunctionDeclaration>,\n) {\n  const {\n    node,\n    parentPath: { scope },\n  } = path;\n\n  const { id } = node;\n  scope.removeOwnBinding(id.name);\n  node.id = null;\n\n  const varNode = t.variableDeclaration(\"var\", [\n    t.variableDeclarator(id, t.toExpression(node)),\n  ]);\n  // @ts-expect-error undocumented property\n  varNode._blockHoist = 2;\n\n  const [varPath] = path.replaceWith(varNode);\n  scope.registerDeclaration(varPath);\n}\n\nconst functionsToVarVisitor: Visitor<{ names: string[] }> = {\n  Scope(path, { names }) {\n    for (const name of names) {\n      const binding = path.scope.getOwnBinding(name);\n      if (binding && binding.kind === \"hoisted\") {\n        maybeTransformBlockScopedFunction(\n          binding.path as NodePath<t.FunctionDeclaration>,\n        );\n      }\n    }\n  },\n  \"Expression|Declaration\"(path) {\n    path.skip();\n  },\n};\n\nexport function isVarScope(scope: Scope) {\n  return scope.path.isFunctionParent() || scope.path.isProgram();\n}\n\nfunction isStrict(path: NodePath) {\n  return !!path.find(({ node }) => {\n    if (t.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (t.isClass(node)) {\n      return true;\n    } else if (!t.isBlockStatement(node)) {\n      return false;\n    }\n\n    return node.directives?.some(\n      directive => directive.value.value === \"use strict\",\n    );\n  });\n}\n"],"names":["_core","require","annexB33FunctionsVisitor","exports","Object","assign","VariableDeclaration","path","isStrict","node","kind","varScope","scope","getFunctionParent","getProgramParent","traverse","functionsToVarVisitor","names","keys","getBindingIdentifiers","BlockStatement","t","isFunction","parent","body","transformStatementList","get","SwitchCase","paths","outer","isFunctionDeclaration","async","generator","parentPath","isVarScope","name","id","currScope","hasOwnBinding","maybeTransformBlockScopedFunction","removeOwnBinding","varNode","variableDeclaration","variableDeclarator","toExpression","_blockHoist","varPath","replaceWith","registerDeclaration","Scope","binding","getOwnBinding","Expression|Declaration","skip","isFunctionParent","isProgram","find","_node$directives","sourceType","isClass","isBlockStatement","directives","some","directive","value"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7581, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7586, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-block-scoping/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Scope, Visitor, PluginPass } from \"@babel/core\";\nimport { types as t, traverse } from \"@babel/core\";\n\nimport {\n  getLoopBodyBindings,\n  getUsageInBody,\n  isVarInLoopHead,\n  wrapLoopBody,\n} from \"./loop.ts\";\nimport { validateUsage } from \"./validation.ts\";\nimport { annexB33FunctionsVisitor, isVarScope } from \"./annex-B_3_3.ts\";\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: traverse.visitors.merge<PluginPass>([\n      // TODO: Consider adding an option to control Annex B behavior.\n      annexB33FunctionsVisitor,\n      {\n        Loop(path: NodePath<t.Loop>, state) {\n          const isForStatement = path.isForStatement();\n          const headPath = isForStatement\n            ? path.get(\"init\")\n            : path.isForXStatement()\n              ? path.get(\"left\")\n              : null;\n\n          let needsBodyWrap = false;\n          const markNeedsBodyWrap = () => {\n            if (throwIfClosureRequired) {\n              throw path.buildCodeFrameError(\n                \"Compiling let/const in this block would add a closure \" +\n                  \"(throwIfClosureRequired).\",\n              );\n            }\n            needsBodyWrap = true;\n          };\n\n          const body = path.get(\"body\");\n          let bodyScope: Scope | null;\n          if (body.isBlockStatement()) {\n            bodyScope = body.scope;\n          }\n          const bindings = getLoopBodyBindings(path);\n          for (const binding of bindings) {\n            const { capturedInClosure } = getUsageInBody(binding, path);\n            if (capturedInClosure) markNeedsBodyWrap();\n          }\n\n          const captured: string[] = [];\n          const updatedBindingsUsages: Map<string, NodePath<t.Identifier>[]> =\n            new Map();\n\n          if (headPath && isBlockScoped(headPath.node)) {\n            const names = Object.keys(headPath.getBindingIdentifiers());\n            const headScope = headPath.scope;\n\n            for (let name of names) {\n              if (bodyScope?.hasOwnBinding(name)) continue; // shadowed\n\n              let binding = headScope.getOwnBinding(name);\n              if (!binding) {\n                headScope.crawl();\n                binding = headScope.getOwnBinding(name);\n              }\n              const { usages, capturedInClosure, hasConstantViolations } =\n                getUsageInBody(binding, path);\n\n              if (\n                headScope.parent.hasBinding(name) ||\n                headScope.parent.hasGlobal(name)\n              ) {\n                // If the binding is not captured, there is no need\n                // of adding it to the closure param. However, rename\n                // it if it shadows an outer binding, because the\n                // closure will be moved to an outer level.\n                const newName = headScope.generateUid(name);\n                headScope.rename(name, newName);\n                name = newName;\n              }\n\n              if (capturedInClosure) {\n                markNeedsBodyWrap();\n                captured.push(name);\n              }\n\n              if (isForStatement && hasConstantViolations) {\n                updatedBindingsUsages.set(name, usages);\n              }\n            }\n          }\n\n          if (needsBodyWrap) {\n            const varPath = wrapLoopBody(path, captured, updatedBindingsUsages);\n\n            if (headPath?.isVariableDeclaration()) {\n              // If we wrap the loop body, we transform the var\n              // declaration in the loop head now, to avoid\n              // invalid references that break other plugins:\n              //\n              //  for (let head of x) {\n              //    let i = head;\n              //    setTimeout(() => i);\n              //  }\n              //\n              // would become\n              //\n              //  function _loop() {\n              //    let i = head;\n              //    setTimeout(() => i);\n              //  }\n              //  for (let head of x) _loop();\n              //\n              // which references `head` in a scope where it's not visible.\n              transformBlockScopedVariable(headPath, state, tdzEnabled);\n            }\n\n            varPath.get(\"declarations.0.init\").unwrapFunctionEnvironment();\n          }\n        },\n\n        VariableDeclaration(path, state) {\n          transformBlockScopedVariable(path, state, tdzEnabled);\n        },\n\n        // Class declarations are block-scoped: if there is\n        // a class declaration in a nested block that conflicts\n        // with an outer block-scoped binding, rename it.\n        // TODO: Should this be moved to the classes plugin?\n        ClassDeclaration(path) {\n          const { id } = path.node;\n          if (!id) return;\n\n          const { scope } = path.parentPath;\n          if (\n            !isVarScope(scope) &&\n            scope.parent.hasBinding(id.name, { noUids: true })\n          ) {\n            path.scope.rename(id.name);\n          }\n        },\n      },\n    ]),\n  };\n});\n\nconst conflictingFunctionsVisitor: Visitor<{ names: string[] }> = {\n  Scope(path, { names }) {\n    for (const name of names) {\n      const binding = path.scope.getOwnBinding(name);\n      if (binding && binding.kind === \"hoisted\") {\n        path.scope.rename(name);\n      }\n    }\n  },\n  \"Expression|Declaration\"(path) {\n    path.skip();\n  },\n};\n\nfunction transformBlockScopedVariable(\n  path: NodePath<t.VariableDeclaration>,\n  state: PluginPass,\n  tdzEnabled: boolean,\n) {\n  if (!isBlockScoped(path.node)) return;\n\n  const dynamicTDZNames = validateUsage(path, state, tdzEnabled);\n\n  path.node.kind = \"var\";\n\n  const bindingNames = Object.keys(path.getBindingIdentifiers());\n  for (const name of bindingNames) {\n    const binding = path.scope.getOwnBinding(name);\n    if (!binding) continue;\n    binding.kind = \"var\";\n  }\n\n  if (\n    (isInLoop(path) && !isVarInLoopHead(path)) ||\n    dynamicTDZNames.length > 0\n  ) {\n    for (const decl of path.node.declarations) {\n      // We explicitly add `void 0` to cases like\n      //  for (;;) { let a; }\n      // to make sure that `a` doesn't keep the value from\n      // the previous iteration.\n      decl.init ??= path.scope.buildUndefinedNode();\n    }\n  }\n\n  const blockScope = path.scope;\n  const varScope =\n    blockScope.getFunctionParent() || blockScope.getProgramParent();\n\n  if (varScope !== blockScope) {\n    for (const name of bindingNames) {\n      let newName = name;\n      if (\n        // We pass `noUids` true because, if `name` was a generated\n        // UID, it has been used to declare the current variable in\n        // a nested scope and thus we don't need to assume that it\n        // may be declared (but not registered yet) in an upper one.\n        blockScope.parent.hasBinding(name, { noUids: true }) ||\n        blockScope.parent.hasGlobal(name)\n      ) {\n        newName = blockScope.generateUid(name);\n        blockScope.rename(name, newName);\n      }\n\n      blockScope.moveBindingTo(newName, varScope);\n    }\n  }\n\n  blockScope.path.traverse(conflictingFunctionsVisitor, {\n    names: bindingNames,\n  });\n\n  for (const name of dynamicTDZNames) {\n    path.scope.push({\n      id: t.identifier(name),\n      init: state.addHelper(\"temporalUndefined\"),\n    });\n  }\n}\n\nfunction isLetOrConst(kind: string): kind is \"let\" | \"const\" {\n  return kind === \"let\" || kind === \"const\";\n}\n\nfunction isInLoop(path: NodePath<t.Node>): boolean {\n  if (!path.parentPath) return false;\n  if (path.parentPath.isLoop()) return true;\n  if (path.parentPath.isFunctionParent()) return false;\n  return isInLoop(path.parentPath);\n}\n\nfunction isBlockScoped(node: t.Node): node is t.VariableDeclaration {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (\n    // @ts-expect-error Fixme: document symbol properties\n    node[t.BLOCK_SCOPED_SYMBOL]\n  ) {\n    return true;\n  }\n\n  if (!isLetOrConst(node.kind) && node.kind !== \"using\") {\n    return false;\n  }\n\n  return true;\n}\n"],"names":["_helperPluginUtils","require","_core","_loop","_validation","_annexB_3_","_default","exports","default","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","traverse","visitors","merge","annexB33FunctionsVisitor","Loop","path","state","isForStatement","headPath","get","isForXStatement","needsBodyWrap","markNeedsBodyWrap","buildCodeFrameError","body","bodyScope","isBlockStatement","scope","bindings","getLoopBodyBindings","binding","capturedInClosure","getUsageInBody","captured","updatedBindingsUsages","Map","isBlockScoped","node","names","Object","keys","getBindingIdentifiers","headScope","_bodyScope","hasOwnBinding","getOwnBinding","crawl","usages","hasConstantViolations","parent","hasBinding","hasGlobal","newName","generateUid","rename","push","set","varPath","wrapLoopBody","isVariableDeclaration","transformBlockScopedVariable","unwrapFunctionEnvironment","VariableDeclaration","ClassDeclaration","id","parentPath","isVarScope","noUids","conflictingFunctionsVisitor","Scope","kind","Expression|Declaration","skip","dynamicTDZNames","validateUsage","bindingNames","isInLoop","isVarInLoopHead","length","decl","declarations","_decl$init","init","buildUndefinedNode","blockScope","varScope","getFunctionParent","getProgramParent","moveBindingTo","t","identifier","addHelper","isLetOrConst","isLoop","isFunctionParent","BLOCK_SCOPED_SYMBOL"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7755, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 7760, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-member-expression-to-functions/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-member-expression-to-functions/src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-transform-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util.ts\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.Identifier }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.Identifier, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      // object must be a conditional expression because the optional private access in object has been transformed\n      const object = callee.node.object as t.ConditionalExpression;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (\n        container !==\n        // @ts-expect-error listKey must be a valid parent node key\n        parentNode[listKey]\n      ) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (rootParentPath.isUpdateExpression({ argument: node })) {\n        throw member.buildCodeFrameError(`can't handle update expression`);\n      }\n      const isAssignment = rootParentPath.isAssignmentExpression({\n        left: endPath.node,\n      });\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingNode = startingOptional.isOptionalMemberExpression()\n        ? startingOptional.node.object\n        : startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else if (\n        (process.env.BABEL_8_BREAKING || this.delete) &&\n        parentPath.isUnaryExpression({ operator: \"delete\" })\n      ) {\n        parentPath.replaceWith(this.delete(member));\n      } else if (parentPath.isAssignmentExpression()) {\n        // `a?.#b = c` to `(a == null ? void 0 : a.#b = c)`\n        handleAssignment(this, member, parentPath);\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\n            \"=\",\n            context,\n            // object must not be Super when `context` is an identifier\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n            object as t.Expression,\n          );\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation || isAssignment) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\n            \"=\",\n            // When base needs memoised, the baseRef must be an identifier\n            cloneNode(baseRef as t.Identifier),\n            cloneNode(startingNode),\n          )\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (ref = _get(MEMBER), ref2 = ref++, ref)), ref2\n    // ++MEMBER   ->   _set(MEMBER, (ref = _get(MEMBER), ++ref))\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: ref });\n\n      const seq: t.Expression[] = [\n        // ref = _get(MEMBER)\n        assignmentExpression(\"=\", cloneNode(ref), this.get(member)),\n      ];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n\n        // (ref = _get(MEMBER), ++ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref2 });\n\n        seq.push(\n          assignmentExpression(\n            \"=\",\n            cloneNode(ref2),\n            updateExpression(operator, cloneNode(ref), prefix),\n          ),\n          cloneNode(ref),\n        );\n\n        // (ref = _get(MEMBER), ref2 = ref++, ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref2)]),\n        );\n\n        return;\n      }\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      handleAssignment(this, member, parentPath);\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unnecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // delete MEMBER -> _delete(MEMBER)\n    if (\n      (process.env.BABEL_8_BREAKING || this.delete) &&\n      parentPath.isUnaryExpression({ operator: \"delete\" })\n    ) {\n      parentPath.replaceWith(this.delete(member));\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nfunction handleAssignment(\n  state: HandlerState,\n  member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  parentPath: NodePath<t.AssignmentExpression>,\n) {\n  if (state.simpleSet) {\n    member.replaceWith(state.simpleSet(member));\n    return;\n  }\n\n  const { operator, right: value } = parentPath.node;\n\n  if (operator === \"=\") {\n    parentPath.replaceWith(state.set(member, value));\n  } else {\n    const operatorTrunc = operator.slice(0, -1);\n    if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The first access (the get) should do the memo\n      // assignment.\n      state.memoise(member, 1);\n      parentPath.replaceWith(\n        logicalExpression(\n          operatorTrunc as t.LogicalExpression[\"operator\"],\n          state.get(member),\n          state.set(member, value),\n        ),\n      );\n    } else {\n      // Here, the second access (the set) is evaluated first.\n      state.memoise(member, 2);\n      parentPath.replaceWith(\n        state.set(\n          member,\n          binaryExpression(\n            operatorTrunc as t.BinaryExpression[\"operator\"],\n            state.get(member),\n            value,\n          ),\n        ),\n      );\n    }\n  }\n}\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n  delete(this: HandlerState<State> & State, member: Member): t.Expression;\n}\n\nexport interface HandlerState<State = object> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll?: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState extends object>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"],"names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","updateExpression","_t","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","set","toNonOptional","base","property","computed","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","isPattern","willEndPathCastToBoolean","rootParentPath","argument","buildCodeFrameError","isAssignment","isAssignmentExpression","left","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","delete","handleAssignment","regular","current","endParentPath","replacementPath","baseMemoised","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","seq","ref2","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","state","operatorTrunc","slice","includes","memberExpressionToFunctions","visitor","traverse","Object","assign","memoiser"],"mappings":"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","ignoreList":[0,1]}},
    {"offset": {"line": 8111, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8116, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-optimise-call-expression/src/index.ts"],"sourcesContent":["import {\n  callExpression,\n  identifier,\n  isIdentifier,\n  isSpreadElement,\n  memberExpression,\n  optionalCallExpression,\n  optionalMemberExpression,\n} from \"@babel/types\";\nimport type {\n  CallExpression,\n  Expression,\n  OptionalCallExpression,\n} from \"@babel/types\";\n\n/**\n * A helper function that generates a new call expression with given thisNode.\n It will also optimize `(...arguments)` to `.apply(arguments)`\n *\n * @export\n * @param {Expression} callee The callee of call expression\n * @param {Expression} thisNode The desired this of call expression\n * @param {Readonly<CallExpression[\"arguments\"]>} args The arguments of call expression\n * @param {boolean} optional Whether the call expression is optional\n * @returns {CallExpression | OptionalCallExpression} The generated new call expression\n */\nexport default function optimiseCallExpression(\n  callee: Expression,\n  thisNode: Expression,\n  args: Readonly<CallExpression[\"arguments\"]>,\n  optional: boolean,\n): CallExpression | OptionalCallExpression {\n  if (\n    args.length === 1 &&\n    isSpreadElement(args[0]) &&\n    isIdentifier(args[0].argument, { name: \"arguments\" })\n  ) {\n    // a.b?.(...arguments);\n    if (optional) {\n      return optionalCallExpression(\n        optionalMemberExpression(callee, identifier(\"apply\"), false, true),\n        [thisNode, args[0].argument],\n        false,\n      );\n    }\n    // a.b(...arguments);\n    return callExpression(memberExpression(callee, identifier(\"apply\")), [\n      thisNode,\n      args[0].argument,\n    ]);\n  } else {\n    // a.b?.(arg1, arg2)\n    if (optional) {\n      return optionalCallExpression(\n        optionalMemberExpression(callee, identifier(\"call\"), false, true),\n        [thisNode, ...args],\n        false,\n      );\n    }\n    // a.b(arg1, arg2)\n    return callExpression(memberExpression(callee, identifier(\"call\")), [\n      thisNode,\n      ...args,\n    ]);\n  }\n}\n"],"names":["_t","require","callExpression","identifier","isIdentifier","isSpreadElement","memberExpression","optionalCallExpression","optionalMemberExpression","optimiseCallExpression","callee","thisNode","args","optional","length","argument","name"],"mappings":";;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAQsB,MAAA,EAPpBC,cAAc,EACdC,UAAU,EACVC,YAAY,EACZC,eAAe,EACfC,gBAAgB,EAChBC,sBAAsB,EACtBC,wBAAAA,EAAwB,GAAAR,EAAA;AAmBX,SAASS,sBAAsBA,CAC5CC,MAAkB,EAClBC,QAAoB,EACpBC,IAA2C,EAC3CC,QAAiB,EACwB;IACzC,IACED,IAAI,CAACE,MAAM,KAAK,CAAC,IACjBT,eAAe,CAACO,IAAI,CAAC,CAAC,CAAC,CAAC,IACxBR,YAAY,CAACQ,IAAI,CAAC,CAAC,CAAC,CAACG,QAAQ,EAAE;QAAEC,IAAI,EAAE;IAAY,CAAC,CAAC,EACrD;QAEA,IAAIH,QAAQ,EAAE;YACZ,OAAON,sBAAsB,CAC3BC,wBAAwB,CAACE,MAAM,EAAEP,UAAU,CAAC,OAAO,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EAClE;gBAACQ,QAAQ;gBAAEC,IAAI,CAAC,CAAC,CAAC,CAACG,QAAQ;aAAC,EAC5B,KACF,CAAC;QACH;QAEA,OAAOb,cAAc,CAACI,gBAAgB,CAACI,MAAM,EAAEP,UAAU,CAAC,OAAO,CAAC,CAAC,EAAE;YACnEQ,QAAQ;YACRC,IAAI,CAAC,CAAC,CAAC,CAACG,QAAQ;SACjB,CAAC;IACJ,CAAC,MAAM;QAEL,IAAIF,QAAQ,EAAE;YACZ,OAAON,sBAAsB,CAC3BC,wBAAwB,CAACE,MAAM,EAAEP,UAAU,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,EACjE;gBAACQ,QAAQ,EAAE;mBAAGC,IAAI;aAAC,EACnB,KACF,CAAC;QACH;QAEA,OAAOV,cAAc,CAACI,gBAAgB,CAACI,MAAM,EAAEP,UAAU,CAAC,MAAM,CAAC,CAAC,EAAE;YAClEQ,QAAQ,EACR;eAAGC,IAAI;SACR,CAAC;IACJ;AACF","ignoreList":[0]}},
    {"offset": {"line": 8150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8155, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-replace-supers/src/index.ts"],"sourcesContent":["import type { File, NodePath, Scope } from \"@babel/core\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type { HandlerState } from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { template, types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  identifier,\n  memberExpression,\n  sequenceExpression,\n  stringLiteral,\n  thisExpression,\n} = t;\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.environmentVisitor = visitors.environmentVisitor({});\n  // eslint-disable-next-line no-restricted-globals\n  exports.skipAllButComputedKey = function skipAllButComputedKey(\n    path: NodePath<t.Method | t.ClassProperty>,\n  ) {\n    path.skip();\n    if (path.node.computed) {\n      path.context.maybeQueue(path.get(\"key\"));\n    }\n  };\n}\n\nconst visitor = visitors.environmentVisitor<\n  HandlerState<ReplaceState> & ReplaceState\n>({\n  Super(path, state) {\n    const { node, parentPath } = path;\n    if (!parentPath.isMemberExpression({ object: node })) return;\n    state.handle(parentPath);\n  },\n});\n\nconst unshadowSuperBindingVisitor = visitors.environmentVisitor<{\n  refName: string;\n}>({\n  Scopable(path, { refName }) {\n    // https://github.com/Zzzen/babel/pull/1#pullrequestreview-564833183\n    const binding = path.scope.getOwnBinding(refName);\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  },\n});\n\ntype SharedState = {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: () => t.Identifier;\n  getSuperRef: () => t.Identifier;\n  // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n  boundGet: HandlerState[\"get\"];\n};\n\ntype Handler = HandlerState<SharedState> & SharedState;\ntype SuperMember = NodePath<\n  t.MemberExpression & {\n    object: t.Super;\n    property: Exclude<t.MemberExpression[\"property\"], t.PrivateName>;\n  }\n>;\n\nconst enum Flags {\n  Prototype = 0b1,\n  Call = 0b10,\n}\n\ninterface SpecHandler\n  extends Pick<\n    Handler,\n    | \"memoise\"\n    | \"get\"\n    | \"set\"\n    | \"destructureSet\"\n    | \"call\"\n    | \"optionalCall\"\n    | \"delete\"\n  > {\n  _get?(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n  ): t.CallExpression;\n  _call?(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n    optional: boolean,\n  ): t.CallExpression | t.OptionalCallExpression;\n  _getPrototypeOfExpression(this: Handler & SpecHandler): t.CallExpression;\n  prop(this: Handler & SpecHandler, superMember: SuperMember): t.Expression;\n}\n\nconst specHandlers: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  /**\n   * Creates an expression which result is the proto of objectRef.\n   *\n   * @example <caption>isStatic === true</caption>\n   *\n   *   helpers.getPrototypeOf(CLASS)\n   *\n   * @example <caption>isStatic === false</caption>\n   *\n   *   helpers.getPrototypeOf(CLASS.prototype)\n   */\n  _getPrototypeOfExpression(this: Handler & SpecHandler) {\n    const objectRef = cloneNode(this.getObjectRef());\n    const targetRef =\n      this.isStatic || this.isPrivateMethod\n        ? objectRef\n        : memberExpression(objectRef, identifier(\"prototype\"));\n\n    return callExpression(this.file.addHelper(\"getPrototypeOf\"), [targetRef]);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    const objectRef = cloneNode(this.getObjectRef());\n    return callExpression(this.file.addHelper(\"superPropGet\"), [\n      this.isDerivedConstructor\n        ? sequenceExpression([thisExpression(), objectRef])\n        : objectRef,\n      this.prop(superMember),\n      thisExpression(),\n      ...(this.isStatic || this.isPrivateMethod\n        ? []\n        : [t.numericLiteral(Flags.Prototype)]),\n    ]);\n  },\n\n  _call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n    optional: boolean,\n  ): t.CallExpression | t.OptionalCallExpression {\n    const objectRef = cloneNode(this.getObjectRef());\n    let argsNode: t.ArrayExpression | t.Identifier;\n    if (\n      args.length === 1 &&\n      t.isSpreadElement(args[0]) &&\n      (t.isIdentifier(args[0].argument) ||\n        t.isArrayExpression(args[0].argument))\n    ) {\n      argsNode = args[0].argument;\n    } else {\n      argsNode = t.arrayExpression(args as t.Expression[]);\n    }\n\n    const call = t.callExpression(this.file.addHelper(\"superPropGet\"), [\n      this.isDerivedConstructor\n        ? sequenceExpression([thisExpression(), objectRef])\n        : objectRef,\n      this.prop(superMember),\n      thisExpression(),\n      t.numericLiteral(\n        Flags.Call |\n          (this.isStatic || this.isPrivateMethod ? 0 : Flags.Prototype),\n      ),\n    ]);\n    if (optional) {\n      return t.optionalCallExpression(call, [argsNode], true);\n    }\n    return callExpression(call, [argsNode]);\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const objectRef = cloneNode(this.getObjectRef());\n\n    return callExpression(this.file.addHelper(\"superPropSet\"), [\n      this.isDerivedConstructor\n        ? sequenceExpression([thisExpression(), objectRef])\n        : objectRef,\n      this.prop(superMember),\n      value,\n      thisExpression(),\n      t.numericLiteral(superMember.isInStrictMode() ? 1 : 0),\n      ...(this.isStatic || this.isPrivateMethod ? [] : [t.numericLiteral(1)]),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return this._call(superMember, args, false);\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return this._call(superMember, args, true);\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst specHandlers_old: SpecHandler = {\n  memoise(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    count: number,\n  ) {\n    const { scope, node } = superMember;\n    const { computed, property } = node;\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(this: Handler & SpecHandler, superMember: SuperMember) {\n    const { computed, property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return cloneNode(property);\n    }\n\n    return stringLiteral((property as t.Identifier).name);\n  },\n\n  /**\n   * Creates an expression which result is the proto of objectRef.\n   *\n   * @example <caption>isStatic === true</caption>\n   *\n   *   helpers.getPrototypeOf(CLASS)\n   *\n   * @example <caption>isStatic === false</caption>\n   *\n   *   helpers.getPrototypeOf(CLASS.prototype)\n   */\n  _getPrototypeOfExpression(this: Handler & SpecHandler) {\n    const objectRef = cloneNode(this.getObjectRef());\n    const targetRef =\n      this.isStatic || this.isPrivateMethod\n        ? objectRef\n        : memberExpression(objectRef, identifier(\"prototype\"));\n\n    return callExpression(this.file.addHelper(\"getPrototypeOf\"), [targetRef]);\n  },\n\n  get(this: Handler & SpecHandler, superMember: SuperMember) {\n    return this._get(superMember);\n  },\n\n  _get(this: Handler & SpecHandler, superMember: SuperMember) {\n    const proto = this._getPrototypeOfExpression();\n    return callExpression(this.file.addHelper(\"get\"), [\n      this.isDerivedConstructor\n        ? sequenceExpression([thisExpression(), proto])\n        : proto,\n      this.prop(superMember),\n      thisExpression(),\n    ]);\n  },\n\n  set(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const proto = this._getPrototypeOfExpression();\n\n    return callExpression(this.file.addHelper(\"set\"), [\n      this.isDerivedConstructor\n        ? sequenceExpression([thisExpression(), proto])\n        : proto,\n      this.prop(superMember),\n      value,\n      thisExpression(),\n      t.booleanLiteral(superMember.isInStrictMode()),\n    ]);\n  },\n\n  destructureSet(this: Handler & SpecHandler, superMember: SuperMember) {\n    throw superMember.buildCodeFrameError(\n      `Destructuring to a super field is not supported yet.`,\n    );\n  },\n\n  call(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this._get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & SpecHandler,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(\n      this._get(superMember),\n      cloneNode(thisExpression()),\n      args,\n      true,\n    );\n  },\n\n  delete(this: Handler & SpecHandler, superMember: SuperMember) {\n    if (superMember.node.computed) {\n      return sequenceExpression([\n        callExpression(this.file.addHelper(\"toPropertyKey\"), [\n          cloneNode(superMember.node.property),\n        ]),\n        template.expression.ast`\n          function () { throw new ReferenceError(\"'delete super[expr]' is invalid\"); }()\n        `,\n      ]);\n    } else {\n      return template.expression.ast`\n        function () { throw new ReferenceError(\"'delete super.prop' is invalid\"); }()\n      `;\n    }\n  },\n};\n\nconst looseHandlers = {\n  ...specHandlers,\n\n  prop(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { property } = superMember.node;\n    if (this.memoiser.has(property)) {\n      return cloneNode(this.memoiser.get(property));\n    }\n\n    return cloneNode(property);\n  },\n\n  get(this: Handler & typeof specHandlers, superMember: SuperMember) {\n    const { isStatic, getSuperRef } = this;\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    let object;\n    if (isStatic) {\n      object =\n        getSuperRef() ??\n        memberExpression(identifier(\"Function\"), identifier(\"prototype\"));\n    } else {\n      object = memberExpression(\n        getSuperRef() ?? identifier(\"Object\"),\n        identifier(\"prototype\"),\n      );\n    }\n\n    return memberExpression(object, prop, computed);\n  },\n\n  set(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    value: t.Expression,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return assignmentExpression(\n      \"=\",\n      memberExpression(thisExpression(), prop, computed),\n      value,\n    );\n  },\n\n  destructureSet(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n  ) {\n    const { computed } = superMember.node;\n    const prop = this.prop(superMember);\n\n    return memberExpression(thisExpression(), prop, computed);\n  },\n\n  call(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, false);\n  },\n\n  optionalCall(\n    this: Handler & typeof specHandlers,\n    superMember: SuperMember,\n    args: t.CallExpression[\"arguments\"],\n  ) {\n    return optimiseCall(this.get(superMember), thisExpression(), args, true);\n  },\n};\n\ntype ReplaceSupersOptionsBase = {\n  methodPath: NodePath<\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ObjectMethod\n    | t.ClassPrivateMethod\n    | t.ClassPrivateProperty\n    | t.StaticBlock\n  >;\n  constantSuper?: boolean;\n  file: File;\n  // objectRef might have been shadowed in child scopes,\n  // in that case, we need to rename related variables.\n  refToPreserve?: t.Identifier;\n};\n\ntype ReplaceSupersOptions = ReplaceSupersOptionsBase &\n  (\n    | { objectRef?: undefined; getObjectRef: () => t.Node }\n    | { objectRef: t.Node; getObjectRef?: undefined }\n  ) &\n  (\n    | { superRef?: undefined; getSuperRef: () => t.Node }\n    | { superRef: t.Node; getSuperRef?: undefined }\n  );\n\ninterface ReplaceState {\n  file: File;\n  scope: Scope;\n  isDerivedConstructor: boolean;\n  isStatic: boolean;\n  isPrivateMethod: boolean;\n  getObjectRef: ReplaceSupers[\"getObjectRef\"];\n  getSuperRef: ReplaceSupers[\"getSuperRef\"];\n}\n\nexport default class ReplaceSupers {\n  constructor(opts: ReplaceSupersOptions) {\n    const path = opts.methodPath;\n\n    this.methodPath = path;\n    this.isDerivedConstructor =\n      path.isClassMethod({ kind: \"constructor\" }) && !!opts.superRef;\n    this.isStatic =\n      path.isObjectMethod() ||\n      // @ts-expect-error static is not in ClassPrivateMethod\n      path.node.static ||\n      path.isStaticBlock?.();\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n\n    this.file = opts.file;\n    this.constantSuper = process.env.BABEL_8_BREAKING\n      ? opts.constantSuper\n      : // Fallback to isLoose for backward compatibility\n        opts.constantSuper ?? (opts as any).isLoose;\n    this.opts = opts;\n  }\n\n  declare file: File;\n  declare isDerivedConstructor: boolean;\n  declare constantSuper: boolean;\n  declare isPrivateMethod: boolean;\n  declare isStatic: boolean;\n  declare methodPath: NodePath;\n  declare opts: ReplaceSupersOptions;\n\n  getObjectRef() {\n    return cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) {\n      return cloneNode(this.opts.getSuperRef());\n    }\n  }\n\n  replace() {\n    const { methodPath } = this;\n    // https://github.com/babel/babel/issues/11994\n    if (this.opts.refToPreserve) {\n      methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name,\n      });\n    }\n\n    const handler = this.constantSuper\n      ? looseHandlers\n      : process.env.BABEL_8_BREAKING ||\n          this.file.availableHelper(\"superPropSet\")\n        ? specHandlers\n        : specHandlers_old;\n\n    // todo: this should have been handled by the environmentVisitor,\n    // consider add visitSelf support for the path.traverse\n    // @ts-expect-error: Refine typings in packages/babel-traverse/src/types.ts\n    // shouldSkip is accepted in traverseNode\n    visitor.shouldSkip = (path: NodePath) => {\n      if (path.parentPath === methodPath) {\n        if (path.parentKey === \"decorators\" || path.parentKey === \"key\") {\n          return true;\n        }\n      }\n    };\n\n    memberExpressionToFunctions<ReplaceState>(methodPath, visitor, {\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this),\n      // we dont need boundGet here, but memberExpressionToFunctions handler needs it.\n      boundGet: handler.get,\n      ...handler,\n    });\n  }\n}\n"],"names":["_helperMemberExpressionToFunctions","require","_helperOptimiseCallExpression","_core","_traverse","assignmentExpression","callExpression","cloneNode","identifier","memberExpression","sequenceExpression","stringLiteral","thisExpression","t","exports","environmentVisitor","visitors","skipAllButComputedKey","path","skip","node","computed","context","maybeQueue","get","visitor","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","_getPrototypeOfExpression","objectRef","getObjectRef","targetRef","isStatic","isPrivateMethod","file","addHelper","isDerivedConstructor","numericLiteral","_call","args","optional","argsNode","length","isSpreadElement","isIdentifier","argument","isArrayExpression","arrayExpression","call","optionalCallExpression","value","isInStrictMode","destructureSet","buildCodeFrameError","optionalCall","delete","template","expression","ast","specHandlers_old","_get","proto","booleanLiteral","optimiseCall","looseHandlers","Object","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","isMethod","constantSuper","isLoose","replace","refToPreserve","traverse","handler","availableHelper","shouldSkip","parentKey","memberExpressionToFunctions","bind","boundGet","default"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 8475, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8480, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-classes/src/inline-callSuper-helpers.ts"],"sourcesContent":["import { template, types as t, type File } from \"@babel/core\";\n\nconst helper = template.statement`\n  function CALL_SUPER(\n    _this,\n    derived,\n    args,\n  ) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Boolean object.\n        return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}),);\n      } catch (e) {\n        return false;\n      }\n    }\n\n    // Super\n    derived = GET_PROTOTYPE_OF(derived);\n    return POSSIBLE_CONSTRUCTOR_RETURN(\n      _this,\n      isNativeReflectConstruct()\n        ? // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n          Reflect.construct(\n            derived,\n            args || [],\n            GET_PROTOTYPE_OF(_this).constructor,\n          )\n        : derived.apply(_this, args),\n    );\n  }\n`;\n\nconst helperIDs = new WeakMap();\n\nexport default function addCallSuperHelper(file: File) {\n  if (helperIDs.has(file)) {\n    // TODO: Only use t.cloneNode in Babel 8\n    // t.cloneNode isn't supported in every version\n    return (t.cloneNode || t.clone)(helperIDs.get(file));\n  }\n\n  try {\n    return file.addHelper(\"callSuper\");\n  } catch {\n    // old Babel doesn't support the helper.\n  }\n\n  const id = file.scope.generateUidIdentifier(\"callSuper\");\n  helperIDs.set(file, id);\n\n  const fn = helper({\n    CALL_SUPER: id,\n    GET_PROTOTYPE_OF: file.addHelper(\"getPrototypeOf\"),\n    POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper(\"possibleConstructorReturn\"),\n  });\n\n  file.path.unshiftContainer(\"body\", [fn]);\n  file.scope.registerDeclaration(file.path.get(\"body.0\"));\n\n  return t.cloneNode(id);\n}\n"],"names":["_core","require","helper","template","statement","helperIDs","WeakMap","addCallSuperHelper","file","has","t","cloneNode","clone","get","addHelper","_unused","id","scope","generateUidIdentifier","set","fn","CALL_SUPER","GET_PROTOTYPE_OF","POSSIBLE_CONSTRUCTOR_RETURN","path","unshiftContainer","registerDeclaration"],"mappings":";;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,MAAMC,MAAM,GAAGC,MAAAA,QAAQ,CAACC,SAAS,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CjC,CAAC;AAED,MAAMC,SAAS,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEhB,SAASC,kBAAkBA,CAACC,IAAU,EAAE;IACrD,IAAIH,SAAS,CAACI,GAAG,CAACD,IAAI,CAAC,EAAE;QAGvB,OAAO,CAACE,MAAAA,KAAC,CAACC,SAAS,IAAID,MAAAA,KAAC,CAACE,KAAK,EAAEP,SAAS,CAACQ,GAAG,CAACL,IAAI,CAAC,CAAC;IACtD;IAEA,IAAI;QACF,OAAOA,IAAI,CAACM,SAAS,CAAC,WAAW,CAAC;IACpC,CAAC,CAAC,OAAAC,OAAA,EAAM,CAER;IAEA,MAAMC,EAAE,GAAGR,IAAI,CAACS,KAAK,CAACC,qBAAqB,CAAC,WAAW,CAAC;IACxDb,SAAS,CAACc,GAAG,CAACX,IAAI,EAAEQ,EAAE,CAAC;IAEvB,MAAMI,EAAE,GAAGlB,MAAM,CAAC;QAChBmB,UAAU,EAAEL,EAAE;QACdM,gBAAgB,EAAEd,IAAI,CAACM,SAAS,CAAC,gBAAgB,CAAC;QAClDS,2BAA2B,EAAEf,IAAI,CAACM,SAAS,CAAC,2BAA2B;IACzE,CAAC,CAAC;IAEFN,IAAI,CAACgB,IAAI,CAACC,gBAAgB,CAAC,MAAM,EAAE;QAACL,EAAE;KAAC,CAAC;IACxCZ,IAAI,CAACS,KAAK,CAACS,mBAAmB,CAAClB,IAAI,CAACgB,IAAI,CAACX,GAAG,CAAC,QAAQ,CAAC,CAAC;IAEvD,OAAOH,MAAAA,KAAC,CAACC,SAAS,CAACK,EAAE,CAAC;AACxB","ignoreList":[0]}},
    {"offset": {"line": 8552, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 8557, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-classes/src/transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, File } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport { template, types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCallSuperHelper from \"./inline-callSuper-helpers.ts\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = visitors.environmentVisitor({\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    },\n  });\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is one\n   */\n  function maybeCreateConstructor() {\n    const classBodyPath = classState.path.get(\"body\");\n    for (const path of classBodyPath.get(\"body\")) {\n      if (path.isClassMethod({ kind: \"constructor\" })) return;\n    }\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classBodyPath.unshiftContainer(\n      \"body\",\n      t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n    );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty() || path.isClassPrivateProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          visitors.environmentVisitor({\n            ReturnStatement(path) {\n              if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                superReturns.push(path);\n              }\n            },\n          }),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.ensureFunctionName ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          }\n          path.ensureFunctionName(supportUnicodeId);\n          let wrapped;\n          if (node !== path.node) {\n            wrapped = path.node;\n            // The node has been wrapped. Reset it to the original once, but store the wrapper.\n            path.replaceWith(node);\n          }\n\n          pushMethod(node, wrapped);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.returnStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      const args: t.Expression[] = [\n        t.thisExpression(),\n        t.cloneNode(classState.classRef),\n      ];\n      if (bareSuperNode.arguments?.length) {\n        const bareSuperNodeArguments = bareSuperNode.arguments as (\n          | t.Expression\n          | t.SpreadElement\n        )[];\n\n        /**\n         * test262/test/language/expressions/super/call-spread-err-sngl-err-itr-get-get.js\n         *\n         * var iter = {};\n         * Object.defineProperty(iter, Symbol.iterator, {\n         *   get: function() {\n         *     throw new Test262Error();\n         *   }\n         * })\n         * super(...iter);\n         */\n\n        if (\n          bareSuperNodeArguments.length === 1 &&\n          t.isSpreadElement(bareSuperNodeArguments[0]) &&\n          t.isIdentifier(bareSuperNodeArguments[0].argument, {\n            name: \"arguments\",\n          })\n        ) {\n          args.push(bareSuperNodeArguments[0].argument);\n        } else {\n          args.push(t.arrayExpression(bareSuperNodeArguments));\n        }\n      }\n      call = t.callExpression(addCallSuperHelper(classState.file), args);\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    const constructorBody = path.get(\"body\");\n\n    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      maxGuaranteedSuperBeforeIndex++;\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    const buildAssertThisInitialized = function () {\n      return t.callExpression(\n        classState.file.addHelper(\"assertThisInitialized\"),\n        [thisRef()],\n      );\n    };\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      visitors.environmentVisitor({\n        Super(path) {\n          const { node, parentPath } = path;\n          if (parentPath.isCallExpression({ callee: node })) {\n            bareSupers.unshift(parentPath);\n          }\n        },\n      }),\n    );\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (maxGuaranteedSuperBeforeIndex >= 0) {\n        let lastParentPath: NodePath;\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === constructorBody) {\n            maxGuaranteedSuperBeforeIndex = Math.min(\n              maxGuaranteedSuperBeforeIndex,\n              lastParentPath.key as number,\n            );\n            return true;\n          }\n\n          const { type } = parentPath;\n          switch (type) {\n            case \"ExpressionStatement\":\n            case \"SequenceExpression\":\n            case \"AssignmentExpression\":\n            case \"BinaryExpression\":\n            case \"MemberExpression\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"VariableDeclarator\":\n            case \"VariableDeclaration\":\n            case \"BlockStatement\":\n            case \"ArrayExpression\":\n            case \"ObjectExpression\":\n            case \"ObjectProperty\":\n            case \"TemplateLiteral\":\n              lastParentPath = parentPath;\n              return false;\n            default:\n              if (\n                (type === \"LogicalExpression\" &&\n                  parentPath.node.left === lastParentPath.node) ||\n                (parentPath.isConditional() &&\n                  parentPath.node.test === lastParentPath.node) ||\n                (type === \"OptionalCallExpression\" &&\n                  parentPath.node.callee === lastParentPath.node) ||\n                (type === \"OptionalMemberExpression\" &&\n                  parentPath.node.object === lastParentPath.node)\n              ) {\n                lastParentPath = parentPath;\n                return false;\n              }\n          }\n\n          maxGuaranteedSuperBeforeIndex = -1;\n          return true;\n        });\n      }\n    }\n\n    const guaranteedCalls = new Set<NodePath>();\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      let thisIndex: number;\n      thisPath.find(function (parentPath) {\n        if (parentPath.parentPath === constructorBody) {\n          thisIndex = parentPath.key as number;\n          return true;\n        }\n      });\n\n      let exprPath: NodePath = thisPath.parentPath.isSequenceExpression()\n        ? thisPath.parentPath\n        : thisPath;\n      if (\n        exprPath.listKey === \"arguments\" &&\n        (exprPath.parentPath.isCallExpression() ||\n          exprPath.parentPath.isOptionalCallExpression())\n      ) {\n        exprPath = exprPath.parentPath;\n      } else {\n        exprPath = null;\n      }\n\n      if (\n        (maxGuaranteedSuperBeforeIndex !== -1 &&\n          thisIndex > maxGuaranteedSuperBeforeIndex) ||\n        guaranteedCalls.has(exprPath)\n      ) {\n        thisPath.replaceWith(thisRef());\n      } else {\n        if (exprPath) {\n          guaranteedCalls.add(exprPath);\n        }\n        thisPath.replaceWith(buildAssertThisInitialized());\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = buildAssertThisInitialized();\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    const guaranteedSuperBeforeFinish =\n      maxGuaranteedSuperBeforeIndex !== -1 &&\n      maxGuaranteedSuperBeforeIndex < bodyPaths.length;\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish\n            ? thisRef()\n            : buildAssertThisInitialized(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, wrapped?: t.Expression) {\n    if (node.kind === \"method\") {\n      if (processMethod(node)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n    methods.hasComputed = !t.isStringLiteral(key);\n\n    const fn: t.Expression = wrapped ?? t.toExpression(node);\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      const func: t.Expression = t.functionExpression(\n        // @ts-expect-error We actually set and id through .ensureFunctionName\n        node.id,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere else\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    classState.pushedInherits = true;\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constants only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = body.length === 0;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? classState.construct.body.directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(classState.construct);\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    if (!classState.pushedCreateClass) {\n      body.push(\n        t.returnStatement(\n          classState.isLoose\n            ? t.cloneNode(classState.classRef)\n            : createClassHelper([t.cloneNode(classState.classRef)]),\n        ),\n      );\n    }\n\n    body.unshift(classState.construct);\n\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"],"names":["_helperReplaceSupers","require","_core","_traverse","_helperAnnotateAsPure","_inlineCallSuperHelpers","buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","visitors","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","classBodyPath","get","isClassMethod","kind","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","isClassPrivateProperty","buildCodeFrameError","decorators","isConstructor","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","traverse","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","wrapped","replaceWith","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","returnStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","_bareSuperNode$argume","bareSuperNodeArguments","addCallSuperHelper","parentPath","isExpressionStatement","container","assignmentExpression","maxGuaranteedSuperBeforeIndex","ref","generateDeclaredUidIdentifier","buildAssertThisInitialized","bareSupers","Super","isCallExpression","lastParentPath","find","Math","min","type","left","isConditional","test","object","guaranteedCalls","Set","thisPath","isMemberExpression","thisIndex","exprPath","isSequenceExpression","listKey","isOptionalCallExpression","has","add","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","guaranteedSuperBeforeFinish","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","isStringLiteral","fn","toExpression","descriptor","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","id","generator","async","expr","expressionStatement","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","annotateAsPure","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 9098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9103, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-classes/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { types as t } from \"@babel/core\";\nimport globals from \"globals\";\nimport transformClass from \"./transformClass.ts\";\n\nconst getBuiltinClasses = (category: keyof typeof globals) =>\n  Object.keys(globals[category]).filter(name => /^[A-Z]/.test(name));\n\nconst builtinClasses = new Set([\n  ...getBuiltinClasses(\"builtin\"),\n  ...getBuiltinClasses(\"browser\"),\n]);\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { loose = false } = options;\n\n  const setClassMethods = api.assumption(\"setClassMethods\") ?? loose;\n  const constantSuper = api.assumption(\"constantSuper\") ?? loose;\n  const superIsCallableConstructor =\n    api.assumption(\"superIsCallableConstructor\") ?? loose;\n  const noClassCalls = api.assumption(\"noClassCalls\") ?? loose;\n  const supportUnicodeId = !isRequired(\n    \"transform-unicode-escapes\",\n    api.targets(),\n  );\n\n  // todo: investigate traversal requeueing\n  const VISITED = new WeakSet();\n\n  return {\n    name: \"transform-classes\",\n\n    visitor: {\n      ExportDefaultDeclaration(path) {\n        if (!path.get(\"declaration\").isClassDeclaration()) return;\n        if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n          // polyfill when being run by an older Babel version\n          path.splitExportDeclaration ??=\n            // eslint-disable-next-line no-restricted-globals\n            require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n        }\n        path.splitExportDeclaration();\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n\n        const ref = node.id\n          ? t.cloneNode(node.id)\n          : path.scope.generateUidIdentifier(\"class\");\n\n        path.replaceWith(\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(ref, t.toExpression(node)),\n          ]),\n        );\n      },\n\n      ClassExpression(path, state) {\n        const { node } = path;\n        if (VISITED.has(node)) return;\n\n        if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n          // polyfill when being run by an older Babel version\n          path.ensureFunctionName ??=\n            // eslint-disable-next-line no-restricted-globals\n            require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n        }\n        const replacement = path.ensureFunctionName(supportUnicodeId);\n        if (replacement && replacement.node !== node) return;\n\n        VISITED.add(node);\n\n        const [replacedPath] = path.replaceWith(\n          transformClass(\n            path,\n            state.file,\n            builtinClasses,\n            loose,\n            {\n              setClassMethods,\n              constantSuper,\n              superIsCallableConstructor,\n              noClassCalls,\n            },\n            supportUnicodeId,\n          ),\n        );\n\n        if (replacedPath.isCallExpression()) {\n          annotateAsPure(replacedPath);\n          const callee = replacedPath.get(\"callee\");\n          if (callee.isArrowFunctionExpression()) {\n            // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n            callee.arrowFunctionToExpression();\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperCompilationTargets","_helperAnnotateAsPure","_core","_globals","_transformClass","getBuiltinClasses","category","Object","keys","globals","filter","name","test","builtinClasses","Set","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","_api$assumption3","_api$assumption4","assertVersion","loose","setClassMethods","assumption","constantSuper","superIsCallableConstructor","noClassCalls","supportUnicodeId","isRequired","targets","VISITED","WeakSet","visitor","ExportDefaultDeclaration","path","get","isClassDeclaration","_path$splitExportDecl","splitExportDeclaration","NodePath","prototype","ClassDeclaration","node","ref","id","t","cloneNode","scope","generateUidIdentifier","replaceWith","variableDeclaration","variableDeclarator","toExpression","ClassExpression","state","has","_path$ensureFunctionN","ensureFunctionName","replacement","add","replacedPath","transformClass","file","isCallExpression","annotateAsPure","callee","isArrowFunctionExpression","arrowFunctionToExpression"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,yBAAA,GAAAD,OAAA;AACA,IAAAE,qBAAA,GAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AACA,IAAAI,QAAA,GAAAJ,OAAA;AACA,IAAAK,eAAA,GAAAL,OAAA;AAEA,MAAMM,iBAAiB,IAAIC,QAA8B,GACvDC,MAAM,CAACC,IAAI,CAACC,QAAO,CAACH,QAAQ,CAAC,CAAC,CAACI,MAAM,EAACC,IAAI,GAAI,QAAQ,CAACC,IAAI,CAACD,IAAI,CAAC,CAAC;AAEpE,MAAME,cAAc,GAAG,IAAIC,GAAG,CAAC,CAC7B;OAAGT,iBAAiB,CAAC,SAAS,CAAC,EAC/B;OAAGA,iBAAiB,CAAC,SAAS,CAAC;CAChC,CAAC;AAAC,IAAAU,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMY,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAAA,IAAAC,eAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA;IAChDL,GAAG,CAACM,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAM,EAAEC,KAAK,GAAG,KAAA,EAAO,GAAGN,OAAO;IAEjC,MAAMO,eAAe,GAAA,CAAAN,eAAA,GAAGF,GAAG,CAACS,UAAU,CAAC,iBAAiB,CAAC,KAAA,OAAAP,eAAA,GAAIK,KAAK;IAClE,MAAMG,aAAa,GAAA,CAAAP,gBAAA,GAAGH,GAAG,CAACS,UAAU,CAAC,eAAe,CAAC,KAAA,OAAAN,gBAAA,GAAII,KAAK;IAC9D,MAAMI,0BAA0B,GAAA,CAAAP,gBAAA,GAC9BJ,GAAG,CAACS,UAAU,CAAC,4BAA4B,CAAC,KAAA,OAAAL,gBAAA,GAAIG,KAAK;IACvD,MAAMK,YAAY,GAAA,CAAAP,gBAAA,GAAGL,GAAG,CAACS,UAAU,CAAC,cAAc,CAAC,KAAA,OAAAJ,gBAAA,GAAIE,KAAK;IAC5D,MAAMM,gBAAgB,GAAG,CAAC,CAAA,GAAAC,0BAAAA,UAAU,EAClC,2BAA2B,EAC3Bd,GAAG,CAACe,OAAO,CAAC,CACd,CAAC;IAGD,MAAMC,OAAO,GAAG,IAAIC,OAAO,CAAC,CAAC;IAE7B,OAAO;QACLzB,IAAI,EAAE,mBAAmB;QAEzB0B,OAAO,EAAE;YACPC,wBAAwBA,EAACC,IAAI,EAAE;gBAC7B,IAAI,CAACA,IAAI,CAACC,GAAG,CAAC,aAAa,CAAC,CAACC,kBAAkB,CAAC,CAAC,EAAE;gBACc;oBAAA,IAAAC,qBAAA;oBAE/D,CAAAA,qBAAA,GAAAH,IAAI,CAACI,sBAAsB,KAAA,OAAAD,qBAAA,GAA3BH,IAAI,CAACI,sBAAsB,GAEzB5C,OAAO,CAAC,iBAAiB,CAAC,6EAAC6C,QAAQ,CAACC,SAAS,CAACF,sBAAsB;gBACxE;gBACAJ,IAAI,CAACI,sBAAsB,CAAC,CAAC;YAC/B,CAAC;YAEDG,gBAAgBA,EAACP,IAAI,EAAE;gBACrB,MAAM,EAAEQ,IAAAA,EAAM,GAAGR,IAAI;gBAErB,MAAMS,GAAG,GAAGD,IAAI,CAACE,EAAE,GACfC,MAAAA,KAAC,CAACC,SAAS,CAACJ,IAAI,CAACE,EAAE,CAAC,GACpBV,IAAI,CAACa,KAAK,CAACC,qBAAqB,CAAC,OAAO,CAAC;gBAE7Cd,IAAI,CAACe,WAAW,CACdJ,MAAAA,KAAC,CAACK,mBAAmB,CAAC,KAAK,EAAE;oBAC3BL,MAAAA,KAAC,CAACM,kBAAkB,CAACR,GAAG,EAAEE,MAAAA,KAAC,CAACO,YAAY,CAACV,IAAI,CAAC,CAAC;iBAChD,CACH,CAAC;YACH,CAAC;YAEDW,eAAeA,EAACnB,IAAI,EAAEoB,KAAK,EAAE;gBAC3B,MAAM,EAAEZ,IAAAA,EAAM,GAAGR,IAAI;gBACrB,IAAIJ,OAAO,CAACyB,GAAG,CAACb,IAAI,CAAC,EAAE;gBAE0C;oBAAA,IAAAc,qBAAA;oBAE/D,CAAAA,qBAAA,GAAAtB,IAAI,CAACuB,kBAAkB,KAAA,OAAAD,qBAAA,GAAvBtB,IAAI,CAACuB,kBAAkB,GAErB/D,OAAO,CAAC,iBAAiB,CAAC,6EAAC6C,QAAQ,CAACC,SAAS,CAACiB,kBAAkB;gBACpE;gBACA,MAAMC,WAAW,GAAGxB,IAAI,CAACuB,kBAAkB,CAAC9B,gBAAgB,CAAC;gBAC7D,IAAI+B,WAAW,IAAIA,WAAW,CAAChB,IAAI,KAAKA,IAAI,EAAE;gBAE9CZ,OAAO,CAAC6B,GAAG,CAACjB,IAAI,CAAC;gBAEjB,MAAM,CAACkB,YAAY,CAAC,GAAG1B,IAAI,CAACe,WAAW,CACrC,CAAA,GAAAY,gBAAAA,OAAc,EACZ3B,IAAI,EACJoB,KAAK,CAACQ,IAAI,EACVtD,cAAc,EACda,KAAK,EACL;oBACEC,eAAe;oBACfE,aAAa;oBACbC,0BAA0B;oBAC1BC;gBACF,CAAC,EACDC,gBACF,CACF,CAAC;gBAED,IAAIiC,YAAY,CAACG,gBAAgB,CAAC,CAAC,EAAE;oBACnC,CAAA,GAAAC,sBAAAA,OAAc,EAACJ,YAAY,CAAC;oBAC5B,MAAMK,MAAM,GAAGL,YAAY,CAACzB,GAAG,CAAC,QAAQ,CAAC;oBACzC,IAAI8B,MAAM,CAACC,yBAAyB,CAAC,CAAC,EAAE;wBAEtCD,MAAM,CAACE,yBAAyB,CAAC,CAAC;oBACpC;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 9174, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9179, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-skip-transparent-expression-wrappers/src/index.ts"],"sourcesContent":["import {\n  isParenthesizedExpression,\n  isTSAsExpression,\n  isTSNonNullExpression,\n  isTSSatisfiesExpression,\n  isTSTypeAssertion,\n  isTypeCastExpression,\n} from \"@babel/types\";\n\nimport type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport type TransparentExprWrapper =\n  | t.TSAsExpression\n  | t.TSSatisfiesExpression\n  | t.TSTypeAssertion\n  | t.TSNonNullExpression\n  | t.TypeCastExpression\n  | t.ParenthesizedExpression;\n\n// A transparent expression wrapper is an AST node that most plugins will wish\n// to skip, as its presence does not affect the behaviour of the code. This\n// includes expressions used for types, and extra parenthesis. For example, in\n// (a as any)(), this helper can be used to skip the TSAsExpression when\n// determining the callee.\nexport function isTransparentExprWrapper(\n  node: t.Node,\n): node is TransparentExprWrapper {\n  return (\n    isTSAsExpression(node) ||\n    isTSSatisfiesExpression(node) ||\n    isTSTypeAssertion(node) ||\n    isTSNonNullExpression(node) ||\n    isTypeCastExpression(node) ||\n    isParenthesizedExpression(node)\n  );\n}\n\nexport function skipTransparentExprWrappers(\n  path: NodePath<t.Expression>,\n): NodePath<t.Expression> {\n  while (isTransparentExprWrapper(path.node)) {\n    path = path.get(\"expression\");\n  }\n  return path;\n}\n\nexport function skipTransparentExprWrapperNodes(\n  node: t.Expression | t.Super,\n): t.Expression | t.Super {\n  while (isTransparentExprWrapper(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n"],"names":["_t","require","isParenthesizedExpression","isTSAsExpression","isTSNonNullExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTypeCastExpression","isTransparentExprWrapper","node","skipTransparentExprWrappers","path","get","skipTransparentExprWrapperNodes","expression"],"mappings":";;;;;;;AAAA,IAAAA,EAAA,GAAAC,OAAA;AAOsB,MAAA,EANpBC,yBAAyB,EACzBC,gBAAgB,EAChBC,qBAAqB,EACrBC,uBAAuB,EACvBC,iBAAiB,EACjBC,oBAAAA,EAAoB,GAAAP,EAAA;AAmBf,SAASQ,wBAAwBA,CACtCC,IAAY,EACoB;IAChC,OACEN,gBAAgB,CAACM,IAAI,CAAC,IACtBJ,uBAAuB,CAACI,IAAI,CAAC,IAC7BH,iBAAiB,CAACG,IAAI,CAAC,IACvBL,qBAAqB,CAACK,IAAI,CAAC,IAC3BF,oBAAoB,CAACE,IAAI,CAAC,IAC1BP,yBAAyB,CAACO,IAAI,CAAC;AAEnC;AAEO,SAASC,2BAA2BA,CACzCC,IAA4B,EACJ;IACxB,MAAOH,wBAAwB,CAACG,IAAI,CAACF,IAAI,CAAC,CAAE;QAC1CE,IAAI,GAAGA,IAAI,CAACC,GAAG,CAAC,YAAY,CAAC;IAC/B;IACA,OAAOD,IAAI;AACb;AAEO,SAASE,+BAA+BA,CAC7CJ,IAA4B,EACJ;IACxB,MAAOD,wBAAwB,CAACC,IAAI,CAAC,CAAE;QACrCA,IAAI,GAAGA,IAAI,CAACK,UAAU;IACxB;IACA,OAAOL,IAAI;AACb","ignoreList":[0]}},
    {"offset": {"line": 9203, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9208, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-class-properties/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\n\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  createClassFeaturePlugin,\n  FEATURES,\n} from \"@babel/helper-create-class-features-plugin\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return createClassFeaturePlugin({\n    name: \"transform-class-properties\",\n\n    api,\n    feature: FEATURES.fields,\n    loose: options.loose,\n\n    manipulateOptions(opts, parserOpts) {\n      if (!process.env.BABEL_8_BREAKING) {\n        // @ts-ignore(Babel 7 vs Babel 8) These plugins have been removed\n        parserOpts.plugins.push(\"classProperties\", \"classPrivateProperties\");\n      }\n    },\n  });\n});\n"],"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","_default","exports","default","declare","api","options","assertVersion","createClassFeaturePlugin","name","feature","FEATURES","fields","loose","manipulateOptions","opts","parserOpts","plugins","push"],"mappings":";;;;;AAEA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,gCAAA,GAAAD,OAAA;AAGoD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMrC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAChDD,GAAG,CAACE,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO,CAAA,GAAAC,iCAAAA,wBAAwB,EAAC;QAC9BC,IAAI,EAAE,4BAA4B;QAElCJ,GAAG;QACHK,OAAO,EAAEC,iCAAAA,QAAQ,CAACC,MAAM;QACxBC,KAAK,EAAEP,OAAO,CAACO,KAAK;QAEpBC,iBAAiBA,EAACC,IAAI,EAAEC,UAAU,EAAE;YACC;gBAEjCA,UAAU,CAACC,OAAO,CAACC,IAAI,CAAC,iBAAiB,EAAE,wBAAwB,CAAC;YACtE;QACF;IACF,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 9229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9234, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-class-static-block/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { Scope } from \"@babel/core\";\n\nimport {\n  enableFeature,\n  FEATURES,\n} from \"@babel/helper-create-class-features-plugin\";\n\n/**\n * Generate a uid that is not in `denyList`\n *\n * @param {Scope} scope\n * @param {Set<string>} denyList a deny list that the generated uid should avoid\n * @returns\n */\nfunction generateUid(scope: Scope, denyList: Set<string>) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n  do {\n    uid = `_${name}`;\n    if (i > 1) uid += i;\n    i++;\n  } while (denyList.has(uid));\n  return uid;\n}\n\nexport default declare(({ types: t, template, assertVersion }) => {\n  assertVersion(REQUIRED_VERSION(\"^7.12.0\"));\n\n  return {\n    name: \"transform-class-static-block\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"classStaticBlock\"),\n\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.staticBlocks, /* loose */ false);\n    },\n\n    visitor: {\n      // Run on ClassBody and not on class so that if @babel/helper-create-class-features-plugin\n      // is enabled it can generate optimized output without passing from the intermediate\n      // private fields representation.\n      ClassBody(classBody) {\n        const { scope } = classBody;\n        const privateNames = new Set<string>();\n        const body = classBody.get(\"body\");\n        for (const path of body) {\n          if (path.isPrivate()) {\n            privateNames.add(path.get(\"key.id\").node.name);\n          }\n        }\n        for (const path of body) {\n          if (!path.isStaticBlock()) continue;\n          const staticBlockPrivateId = generateUid(scope, privateNames);\n          privateNames.add(staticBlockPrivateId);\n          const staticBlockRef = t.privateName(\n            t.identifier(staticBlockPrivateId),\n          );\n\n          let replacement;\n          const blockBody = path.node.body;\n          // We special-case the single expression case to avoid the iife, since\n          // it's common.\n          if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n            replacement = t.inheritsComments(\n              blockBody[0].expression,\n              blockBody[0],\n            );\n          } else {\n            replacement = template.expression.ast`(() => { ${blockBody} })()`;\n          }\n\n          path.replaceWith(\n            t.classPrivateProperty(\n              staticBlockRef,\n              replacement,\n              [],\n              /* static */ true,\n            ),\n          );\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","generateUid","scope","denyList","name","uid","i","has","_default","exports","default","declare","types","t","template","assertVersion","manipulateOptions","_","parser","plugins","push","pre","enableFeature","file","FEATURES","staticBlocks","visitor","ClassBody","classBody","privateNames","Set","body","get","path","isPrivate","add","node","isStaticBlock","staticBlockPrivateId","staticBlockRef","privateName","identifier","replacement","blockBody","length","isExpressionStatement","inheritsComments","expression","ast","replaceWith","classPrivateProperty"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAGA,IAAAC,gCAAA,GAAAD,OAAA;AAYA,SAASE,WAAWA,CAACC,KAAY,EAAEC,QAAqB,EAAE;IACxD,MAAMC,IAAI,GAAG,EAAE;IACf,IAAIC,GAAG;IACP,IAAIC,CAAC,GAAG,CAAC;IACT,GAAG;QACDD,GAAG,GAAG,CAAA,CAAA,EAAID,IAAI,EAAE;QAChB,IAAIE,CAAC,GAAG,CAAC,EAAED,GAAG,IAAIC,CAAC;QACnBA,CAAC,EAAE;IACL,CAAC,OAAQH,QAAQ,CAACI,GAAG,CAACF,GAAG,CAAC,CAAA;IAC1B,OAAOA,GAAG;AACZ;AAAC,IAAAG,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEc,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAAC,EAAEC,KAAK,EAAEC,CAAC,EAAEC,QAAQ,EAAEC,aAAAA,EAAe,KAAK;IAChEA,aAAa,CAAA,qCAA4B,CAAC;IAE1C,OAAO;QACLX,IAAI,EAAE,8BAA8B;QACpCY,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,kBAAkB,CAAC;QAE1DC,GAAGA,CAAA,EAAG;YAGJ,CAAA,GAAAC,iCAAAA,aAAa,EAAC,IAAI,CAACC,IAAI,EAAEC,iCAAAA,QAAQ,CAACC,YAAY,EAAc,KAAK,CAAC;QACpE,CAAC;QAEDC,OAAO,EAAE;YAIPC,SAASA,EAACC,SAAS,EAAE;gBACnB,MAAM,EAAE1B,KAAAA,EAAO,GAAG0B,SAAS;gBAC3B,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAS,CAAC;gBACtC,MAAMC,IAAI,GAAGH,SAAS,CAACI,GAAG,CAAC,MAAM,CAAC;gBAClC,KAAK,MAAMC,IAAI,IAAIF,IAAI,CAAE;oBACvB,IAAIE,IAAI,CAACC,SAAS,CAAC,CAAC,EAAE;wBACpBL,YAAY,CAACM,GAAG,CAACF,IAAI,CAACD,GAAG,CAAC,QAAQ,CAAC,CAACI,IAAI,CAAChC,IAAI,CAAC;oBAChD;gBACF;gBACA,KAAK,MAAM6B,IAAI,IAAIF,IAAI,CAAE;oBACvB,IAAI,CAACE,IAAI,CAACI,aAAa,CAAC,CAAC,EAAE;oBAC3B,MAAMC,oBAAoB,GAAGrC,WAAW,CAACC,KAAK,EAAE2B,YAAY,CAAC;oBAC7DA,YAAY,CAACM,GAAG,CAACG,oBAAoB,CAAC;oBACtC,MAAMC,cAAc,GAAG1B,CAAC,CAAC2B,WAAW,CAClC3B,CAAC,CAAC4B,UAAU,CAACH,oBAAoB,CACnC,CAAC;oBAED,IAAII,WAAW;oBACf,MAAMC,SAAS,GAAGV,IAAI,CAACG,IAAI,CAACL,IAAI;oBAGhC,IAAIY,SAAS,CAACC,MAAM,KAAK,CAAC,IAAI/B,CAAC,CAACgC,qBAAqB,CAACF,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;wBACnED,WAAW,GAAG7B,CAAC,CAACiC,gBAAgB,CAC9BH,SAAS,CAAC,CAAC,CAAC,CAACI,UAAU,EACvBJ,SAAS,CAAC,CAAC,CACb,CAAC;oBACH,CAAC,MAAM;wBACLD,WAAW,GAAG5B,QAAQ,CAACiC,UAAU,CAACC,GAAG,CAAA,SAAA,EAAYL,SAAS,CAAA,KAAA,CAAO;oBACnE;oBAEAV,IAAI,CAACgB,WAAW,CACdpC,CAAC,CAACqC,oBAAoB,CACpBX,cAAc,EACdG,WAAW,EACX,EAAE,EACW,IACf,CACF,CAAC;gBACH;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 9288, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9293, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-computed-properties/src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginPass, Scope } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport template from \"@babel/template\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\ntype PropertyInfo = {\n  scope: Scope;\n  objId: t.Identifier;\n  body: t.Statement[];\n  computedProps: t.ObjectMember[];\n  initPropExpression: t.ObjectExpression;\n  state: PluginPass;\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var DefineAccessorHelper = template.expression.ast`\n    function (type, obj, key, fn) {\n      var desc = { configurable: true, enumerable: true };\n      desc[type] = fn;\n      return Object.defineProperty(obj, key, desc);\n    }\n  `;\n  // @ts-expect-error undocumented _compact node property\n  DefineAccessorHelper._compact = true;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setComputedProperties =\n    api.assumption(\"setComputedProperties\") ?? options.loose;\n\n  const pushComputedProps = setComputedProperties\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  function buildDefineAccessor(\n    state: PluginPass,\n    obj: t.Expression,\n    prop: t.ObjectMethod,\n  ) {\n    const type = prop.kind as \"get\" | \"set\";\n    const key =\n      !prop.computed && t.isIdentifier(prop.key)\n        ? t.stringLiteral(prop.key.name)\n        : prop.key;\n    const fn = getValue(prop);\n    if (process.env.BABEL_8_BREAKING) {\n      return t.callExpression(state.addHelper(\"defineAccessor\"), [\n        t.stringLiteral(type),\n        obj,\n        key,\n        fn,\n      ]);\n    } else {\n      let helper: t.Identifier;\n      if (state.availableHelper(\"defineAccessor\")) {\n        helper = state.addHelper(\"defineAccessor\");\n      } else {\n        // Fallback for @babel/helpers <= 7.20.6, manually add helper function\n        const file = state.file;\n        helper = file.get(\"fallbackDefineAccessorHelper\");\n        if (!helper) {\n          const id = file.scope.generateUidIdentifier(\"defineAccessor\");\n          file.scope.push({\n            id,\n            init: DefineAccessorHelper,\n          });\n          file.set(\"fallbackDefineAccessorHelper\", (helper = id));\n        }\n        helper = t.cloneNode(helper);\n      }\n\n      return t.callExpression(helper, [t.stringLiteral(type), obj, key, fn]);\n    }\n  }\n\n  /**\n   * Get value of an object member under object expression.\n   * Returns a function expression if prop is a ObjectMethod.\n   *\n   * @param {t.ObjectMember} prop\n   * @returns t.Expression\n   */\n  function getValue(prop: t.ObjectMember) {\n    if (t.isObjectProperty(prop)) {\n      return prop.value as t.Expression;\n    } else if (t.isObjectMethod(prop)) {\n      return t.functionExpression(\n        null,\n        prop.params,\n        prop.body,\n        prop.generator,\n        prop.async,\n      );\n    }\n  }\n\n  function pushAssign(\n    objId: t.Identifier,\n    prop: t.ObjectMember,\n    body: t.Statement[],\n  ) {\n    body.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          t.memberExpression(\n            t.cloneNode(objId),\n            prop.key,\n            prop.computed || t.isLiteral(prop.key),\n          ),\n          getValue(prop),\n        ),\n      ),\n    );\n  }\n\n  function pushComputedPropsLoose(info: PropertyInfo) {\n    const { computedProps, state, initPropExpression, objId, body } = info;\n\n    for (const prop of computedProps) {\n      if (\n        t.isObjectMethod(prop) &&\n        (prop.kind === \"get\" || prop.kind === \"set\")\n      ) {\n        if (computedProps.length === 1) {\n          return buildDefineAccessor(state, initPropExpression, prop);\n        } else {\n          body.push(\n            t.expressionStatement(\n              buildDefineAccessor(state, t.cloneNode(objId), prop),\n            ),\n          );\n        }\n      } else {\n        pushAssign(t.cloneNode(objId), prop, body);\n      }\n    }\n  }\n\n  function pushComputedPropsSpec(info: PropertyInfo) {\n    const { objId, body, computedProps, state } = info;\n\n    // To prevent too deep AST structures in case of large objects\n    const CHUNK_LENGTH_CAP = 10;\n\n    let currentChunk: t.ObjectMember[] = null;\n    const computedPropsChunks: Array<t.ObjectMember[]> = [];\n    for (const prop of computedProps) {\n      if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {\n        currentChunk = [];\n        computedPropsChunks.push(currentChunk);\n      }\n      currentChunk.push(prop);\n    }\n\n    for (const chunk of computedPropsChunks) {\n      const single = computedPropsChunks.length === 1;\n      let node: t.Expression = single\n        ? info.initPropExpression\n        : t.cloneNode(objId);\n      for (const prop of chunk) {\n        if (\n          t.isObjectMethod(prop) &&\n          (prop.kind === \"get\" || prop.kind === \"set\")\n        ) {\n          node = buildDefineAccessor(info.state, node, prop);\n        } else {\n          node = t.callExpression(state.addHelper(\"defineProperty\"), [\n            node,\n            // PrivateName must not be in ObjectExpression\n            t.toComputedKey(prop) as t.Expression,\n            // the value of ObjectProperty in ObjectExpression must be an expression\n            getValue(prop),\n          ]);\n        }\n      }\n      if (single) return node;\n      body.push(t.expressionStatement(node));\n    }\n  }\n\n  return {\n    name: \"transform-computed-properties\",\n\n    visitor: {\n      ObjectExpression: {\n        exit(path, state) {\n          const { node, parent, scope } = path;\n          let hasComputed = false;\n          for (const prop of node.properties) {\n            // @ts-expect-error SpreadElement must not have computed property\n            hasComputed = prop.computed === true;\n            if (hasComputed) break;\n          }\n          if (!hasComputed) return;\n\n          // put all getters/setters into the first object expression as well as all initialisers up\n          // to the first computed property\n\n          const initProps: t.ObjectMember[] = [];\n          const computedProps: t.ObjectMember[] = [];\n          let foundComputed = false;\n\n          for (const prop of node.properties) {\n            if (t.isSpreadElement(prop)) {\n              continue;\n            }\n            if (prop.computed) {\n              foundComputed = true;\n            }\n\n            if (foundComputed) {\n              computedProps.push(prop);\n            } else {\n              initProps.push(prop);\n            }\n          }\n\n          const objId = scope.generateUidIdentifierBasedOnNode(parent);\n          const initPropExpression = t.objectExpression(initProps);\n          const body = [];\n\n          body.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(objId, initPropExpression),\n            ]),\n          );\n\n          const single = pushComputedProps({\n            scope,\n            objId,\n            body,\n            computedProps,\n            initPropExpression,\n            state,\n          });\n\n          if (single) {\n            path.replaceWith(single);\n          } else {\n            if (setComputedProperties) {\n              body.push(t.expressionStatement(t.cloneNode(objId)));\n            }\n            path.replaceWithMultiple(body);\n          }\n        },\n      },\n    },\n  };\n});\n"],"names":["_core","require","_helperPluginUtils","_template","DefineAccessorHelper","template","expression","ast","_compact","_default","exports","default","declare","api","options","_api$assumption","assertVersion","setComputedProperties","assumption","loose","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","buildDefineAccessor","state","obj","prop","type","kind","key","computed","t","isIdentifier","stringLiteral","name","fn","getValue","helper","availableHelper","addHelper","file","get","id","scope","generateUidIdentifier","push","init","set","cloneNode","callExpression","isObjectProperty","value","isObjectMethod","functionExpression","params","body","generator","async","pushAssign","objId","expressionStatement","assignmentExpression","memberExpression","isLiteral","info","computedProps","initPropExpression","length","CHUNK_LENGTH_CAP","currentChunk","computedPropsChunks","chunk","single","node","toComputedKey","visitor","ObjectExpression","exit","path","parent","hasComputed","properties","initProps","foundComputed","isSpreadElement","generateUidIdentifierBasedOnNode","objectExpression","variableDeclaration","variableDeclarator","replaceWith","replaceWithMultiple"],"mappings":";;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,kBAAA,GAAAD,OAAA;AACA,IAAAE,SAAA,GAAAF,OAAA;AAemC;IAEjC,IAAIG,oBAAoB,GAAGC,UAAAA,OAAQ,CAACC,UAAU,CAACC,GAAG,CAAA;;;;;;EAMpD,CAAG;IAEDH,oBAAoB,CAACI,QAAQ,GAAG,IAAI;AACtC,CAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEc,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAAA,IAAAC,eAAA;IAChDF,GAAG,CAACG,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAMC,qBAAqB,GAAA,CAAAF,eAAA,GACzBF,GAAG,CAACK,UAAU,CAAC,uBAAuB,CAAC,KAAA,OAAAH,eAAA,GAAID,OAAO,CAACK,KAAK;IAE1D,MAAMC,iBAAiB,GAAGH,qBAAqB,GAC3CI,sBAAsB,GACtBC,qBAAqB;IAEzB,SAASC,mBAAmBA,CAC1BC,KAAiB,EACjBC,GAAiB,EACjBC,IAAoB,EACpB;QACA,MAAMC,IAAI,GAAGD,IAAI,CAACE,IAAqB;QACvC,MAAMC,GAAG,GACP,CAACH,IAAI,CAACI,QAAQ,IAAIC,MAAAA,KAAC,CAACC,YAAY,CAACN,IAAI,CAACG,GAAG,CAAC,GACtCE,MAAAA,KAAC,CAACE,aAAa,CAACP,IAAI,CAACG,GAAG,CAACK,IAAI,CAAC,GAC9BR,IAAI,CAACG,GAAG;QACd,MAAMM,EAAE,GAAGC,QAAQ,CAACV,IAAI,CAAC;QAQlB;YACL,IAAIW,MAAoB;YACxB,IAAIb,KAAK,CAACc,eAAe,CAAC,gBAAgB,CAAC,EAAE;gBAC3CD,MAAM,GAAGb,KAAK,CAACe,SAAS,CAAC,gBAAgB,CAAC;YAC5C,CAAC,MAAM;gBAEL,MAAMC,IAAI,GAAGhB,KAAK,CAACgB,IAAI;gBACvBH,MAAM,GAAGG,IAAI,CAACC,GAAG,CAAC,8BAA8B,CAAC;gBACjD,IAAI,CAACJ,MAAM,EAAE;oBACX,MAAMK,EAAE,GAAGF,IAAI,CAACG,KAAK,CAACC,qBAAqB,CAAC,gBAAgB,CAAC;oBAC7DJ,IAAI,CAACG,KAAK,CAACE,IAAI,CAAC;wBACdH,EAAE;wBACFI,IAAI,EAAE1C;oBACR,CAAC,CAAC;oBACFoC,IAAI,CAACO,GAAG,CAAC,8BAA8B,EAAGV,MAAM,GAAGK,EAAG,CAAC;gBACzD;gBACAL,MAAM,GAAGN,MAAAA,KAAC,CAACiB,SAAS,CAACX,MAAM,CAAC;YAC9B;YAEA,OAAON,MAAAA,KAAC,CAACkB,cAAc,CAACZ,MAAM,EAAE;gBAACN,MAAAA,KAAC,CAACE,aAAa,CAACN,IAAI,CAAC;gBAAEF,GAAG;gBAAEI,GAAG;gBAAEM,EAAE;aAAC,CAAC;QACxE;IACF;IASA,SAASC,QAAQA,CAACV,IAAoB,EAAE;QACtC,IAAIK,MAAAA,KAAC,CAACmB,gBAAgB,CAACxB,IAAI,CAAC,EAAE;YAC5B,OAAOA,IAAI,CAACyB,KAAK;QACnB,CAAC,MAAM,IAAIpB,MAAAA,KAAC,CAACqB,cAAc,CAAC1B,IAAI,CAAC,EAAE;YACjC,OAAOK,MAAAA,KAAC,CAACsB,kBAAkB,CACzB,IAAI,EACJ3B,IAAI,CAAC4B,MAAM,EACX5B,IAAI,CAAC6B,IAAI,EACT7B,IAAI,CAAC8B,SAAS,EACd9B,IAAI,CAAC+B,KACP,CAAC;QACH;IACF;IAEA,SAASC,UAAUA,CACjBC,KAAmB,EACnBjC,IAAoB,EACpB6B,IAAmB,EACnB;QACAA,IAAI,CAACV,IAAI,CACPd,MAAAA,KAAC,CAAC6B,mBAAmB,CACnB7B,MAAAA,KAAC,CAAC8B,oBAAoB,CACpB,GAAG,EACH9B,MAAAA,KAAC,CAAC+B,gBAAgB,CAChB/B,MAAAA,KAAC,CAACiB,SAAS,CAACW,KAAK,CAAC,EAClBjC,IAAI,CAACG,GAAG,EACRH,IAAI,CAACI,QAAQ,IAAIC,MAAAA,KAAC,CAACgC,SAAS,CAACrC,IAAI,CAACG,GAAG,CACvC,CAAC,EACDO,QAAQ,CAACV,IAAI,CACf,CACF,CACF,CAAC;IACH;IAEA,SAASL,sBAAsBA,CAAC2C,IAAkB,EAAE;QAClD,MAAM,EAAEC,aAAa,EAAEzC,KAAK,EAAE0C,kBAAkB,EAAEP,KAAK,EAAEJ,IAAAA,EAAM,GAAGS,IAAI;QAEtE,KAAK,MAAMtC,IAAI,IAAIuC,aAAa,CAAE;YAChC,IACElC,MAAAA,KAAC,CAACqB,cAAc,CAAC1B,IAAI,CAAC,IAAA,CACrBA,IAAI,CAACE,IAAI,KAAK,KAAK,IAAIF,IAAI,CAACE,IAAI,KAAK,KAAK,CAAC,EAC5C;gBACA,IAAIqC,aAAa,CAACE,MAAM,KAAK,CAAC,EAAE;oBAC9B,OAAO5C,mBAAmB,CAACC,KAAK,EAAE0C,kBAAkB,EAAExC,IAAI,CAAC;gBAC7D,CAAC,MAAM;oBACL6B,IAAI,CAACV,IAAI,CACPd,MAAAA,KAAC,CAAC6B,mBAAmB,CACnBrC,mBAAmB,CAACC,KAAK,EAAEO,MAAAA,KAAC,CAACiB,SAAS,CAACW,KAAK,CAAC,EAAEjC,IAAI,CACrD,CACF,CAAC;gBACH;YACF,CAAC,MAAM;gBACLgC,UAAU,CAAC3B,MAAAA,KAAC,CAACiB,SAAS,CAACW,KAAK,CAAC,EAAEjC,IAAI,EAAE6B,IAAI,CAAC;YAC5C;QACF;IACF;IAEA,SAASjC,qBAAqBA,CAAC0C,IAAkB,EAAE;QACjD,MAAM,EAAEL,KAAK,EAAEJ,IAAI,EAAEU,aAAa,EAAEzC,KAAAA,EAAO,GAAGwC,IAAI;QAGlD,MAAMI,gBAAgB,GAAG,EAAE;QAE3B,IAAIC,YAA8B,GAAG,IAAI;QACzC,MAAMC,mBAA4C,GAAG,EAAE;QACvD,KAAK,MAAM5C,IAAI,IAAIuC,aAAa,CAAE;YAChC,IAAI,CAACI,YAAY,IAAIA,YAAY,CAACF,MAAM,KAAKC,gBAAgB,EAAE;gBAC7DC,YAAY,GAAG,EAAE;gBACjBC,mBAAmB,CAACzB,IAAI,CAACwB,YAAY,CAAC;YACxC;YACAA,YAAY,CAACxB,IAAI,CAACnB,IAAI,CAAC;QACzB;QAEA,KAAK,MAAM6C,KAAK,IAAID,mBAAmB,CAAE;YACvC,MAAME,MAAM,GAAGF,mBAAmB,CAACH,MAAM,KAAK,CAAC;YAC/C,IAAIM,IAAkB,GAAGD,MAAM,GAC3BR,IAAI,CAACE,kBAAkB,GACvBnC,MAAAA,KAAC,CAACiB,SAAS,CAACW,KAAK,CAAC;YACtB,KAAK,MAAMjC,IAAI,IAAI6C,KAAK,CAAE;gBACxB,IACExC,MAAAA,KAAC,CAACqB,cAAc,CAAC1B,IAAI,CAAC,IAAA,CACrBA,IAAI,CAACE,IAAI,KAAK,KAAK,IAAIF,IAAI,CAACE,IAAI,KAAK,KAAK,CAAC,EAC5C;oBACA6C,IAAI,GAAGlD,mBAAmB,CAACyC,IAAI,CAACxC,KAAK,EAAEiD,IAAI,EAAE/C,IAAI,CAAC;gBACpD,CAAC,MAAM;oBACL+C,IAAI,GAAG1C,MAAAA,KAAC,CAACkB,cAAc,CAACzB,KAAK,CAACe,SAAS,CAAC,gBAAgB,CAAC,EAAE;wBACzDkC,IAAI;wBAEJ1C,MAAAA,KAAC,CAAC2C,aAAa,CAAChD,IAAI,CAAC;wBAErBU,QAAQ,CAACV,IAAI,CAAC;qBACf,CAAC;gBACJ;YACF;YACA,IAAI8C,MAAM,EAAE,OAAOC,IAAI;YACvBlB,IAAI,CAACV,IAAI,CAACd,MAAAA,KAAC,CAAC6B,mBAAmB,CAACa,IAAI,CAAC,CAAC;QACxC;IACF;IAEA,OAAO;QACLvC,IAAI,EAAE,+BAA+B;QAErCyC,OAAO,EAAE;YACPC,gBAAgB,EAAE;gBAChBC,IAAIA,EAACC,IAAI,EAAEtD,KAAK,EAAE;oBAChB,MAAM,EAAEiD,IAAI,EAAEM,MAAM,EAAEpC,KAAAA,EAAO,GAAGmC,IAAI;oBACpC,IAAIE,WAAW,GAAG,KAAK;oBACvB,KAAK,MAAMtD,IAAI,IAAI+C,IAAI,CAACQ,UAAU,CAAE;wBAElCD,WAAW,GAAGtD,IAAI,CAACI,QAAQ,KAAK,IAAI;wBACpC,IAAIkD,WAAW,EAAE;oBACnB;oBACA,IAAI,CAACA,WAAW,EAAE;oBAKlB,MAAME,SAA2B,GAAG,EAAE;oBACtC,MAAMjB,aAA+B,GAAG,EAAE;oBAC1C,IAAIkB,aAAa,GAAG,KAAK;oBAEzB,KAAK,MAAMzD,IAAI,IAAI+C,IAAI,CAACQ,UAAU,CAAE;wBAClC,IAAIlD,MAAAA,KAAC,CAACqD,eAAe,CAAC1D,IAAI,CAAC,EAAE;4BAC3B;wBACF;wBACA,IAAIA,IAAI,CAACI,QAAQ,EAAE;4BACjBqD,aAAa,GAAG,IAAI;wBACtB;wBAEA,IAAIA,aAAa,EAAE;4BACjBlB,aAAa,CAACpB,IAAI,CAACnB,IAAI,CAAC;wBAC1B,CAAC,MAAM;4BACLwD,SAAS,CAACrC,IAAI,CAACnB,IAAI,CAAC;wBACtB;oBACF;oBAEA,MAAMiC,KAAK,GAAGhB,KAAK,CAAC0C,gCAAgC,CAACN,MAAM,CAAC;oBAC5D,MAAMb,kBAAkB,GAAGnC,MAAAA,KAAC,CAACuD,gBAAgB,CAACJ,SAAS,CAAC;oBACxD,MAAM3B,IAAI,GAAG,EAAE;oBAEfA,IAAI,CAACV,IAAI,CACPd,MAAAA,KAAC,CAACwD,mBAAmB,CAAC,KAAK,EAAE;wBAC3BxD,MAAAA,KAAC,CAACyD,kBAAkB,CAAC7B,KAAK,EAAEO,kBAAkB,CAAC;qBAChD,CACH,CAAC;oBAED,MAAMM,MAAM,GAAGpD,iBAAiB,CAAC;wBAC/BuB,KAAK;wBACLgB,KAAK;wBACLJ,IAAI;wBACJU,aAAa;wBACbC,kBAAkB;wBAClB1C;oBACF,CAAC,CAAC;oBAEF,IAAIgD,MAAM,EAAE;wBACVM,IAAI,CAACW,WAAW,CAACjB,MAAM,CAAC;oBAC1B,CAAC,MAAM;wBACL,IAAIvD,qBAAqB,EAAE;4BACzBsC,IAAI,CAACV,IAAI,CAACd,MAAAA,KAAC,CAAC6B,mBAAmB,CAAC7B,MAAAA,KAAC,CAACiB,SAAS,CAACW,KAAK,CAAC,CAAC,CAAC;wBACtD;wBACAmB,IAAI,CAACY,mBAAmB,CAACnC,IAAI,CAAC;oBAChC;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 9453, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 9458, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-destructuring/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-destructuring/src/index.ts"],"sourcesContent":["import { types as t, template } from \"@babel/core\";\nimport type { File, Scope, NodePath } from \"@babel/core\";\n\nfunction isPureVoid(node: t.Node) {\n  return (\n    t.isUnaryExpression(node) &&\n    node.operator === \"void\" &&\n    t.isPureish(node.argument)\n  );\n}\n\nexport function unshiftForXStatementBody(\n  statementPath: NodePath<t.ForXStatement>,\n  newStatements: t.Statement[],\n) {\n  statementPath.ensureBlock();\n  const { scope, node } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(\n    name => scope.hasBinding(name),\n  );\n\n  if (hasShadowedBlockScopedBindings) {\n    // handle shadowed variables referenced in computed keys:\n    // var a = 0;for (const { #x: x, [a++]: y } of z) { const a = 1; }\n    node.body = t.blockStatement([...newStatements, node.body]);\n  } else {\n    (node.body as t.BlockStatement).body.unshift(...newStatements);\n  }\n}\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasArrayRest(pattern: t.ArrayPattern) {\n  return pattern.elements.some(elem => t.isRestElement(elem));\n}\n\n/**\n * Test if an ObjectPattern's properties contain any RestElements.\n */\n\nfunction hasObjectRest(pattern: t.ObjectPattern) {\n  return pattern.properties.some(prop => t.isRestElement(prop));\n}\n\ninterface UnpackableArrayExpression extends t.ArrayExpression {\n  elements: (null | t.Expression)[];\n}\n\nconst STOP_TRAVERSAL = {};\n\ninterface ArrayUnpackVisitorState {\n  deopt: boolean;\n  bindings: Record<string, t.Identifier>;\n}\n\n// NOTE: This visitor is meant to be used via t.traverse\nconst arrayUnpackVisitor = (\n  node: t.Node,\n  ancestors: t.TraversalAncestors,\n  state: ArrayUnpackVisitorState,\n) => {\n  if (!ancestors.length) {\n    // Top-level node: this is the array literal.\n    return;\n  }\n\n  if (\n    t.isIdentifier(node) &&\n    t.isReferenced(node, ancestors[ancestors.length - 1].node) &&\n    state.bindings[node.name]\n  ) {\n    state.deopt = true;\n    // eslint-disable-next-line @typescript-eslint/only-throw-error\n    throw STOP_TRAVERSAL;\n  }\n};\n\nexport type DestructuringTransformerNode =\n  | t.VariableDeclaration\n  | t.ExpressionStatement\n  | t.ReturnStatement;\n\ninterface DestructuringTransformerOption {\n  blockHoist?: number;\n  operator?: t.AssignmentExpression[\"operator\"];\n  nodes?: DestructuringTransformerNode[];\n  kind?: t.VariableDeclaration[\"kind\"];\n  scope: Scope;\n  arrayLikeIsIterable: boolean;\n  iterableIsArray: boolean;\n  objectRestNoSymbols: boolean;\n  useBuiltIns: boolean;\n  addHelper: File[\"addHelper\"];\n}\nexport class DestructuringTransformer {\n  private blockHoist: number;\n  private operator: t.AssignmentExpression[\"operator\"];\n  arrayRefSet: Set<string>;\n  private nodes: DestructuringTransformerNode[];\n  private scope: Scope;\n  private kind: t.VariableDeclaration[\"kind\"];\n  private iterableIsArray: boolean;\n  private arrayLikeIsIterable: boolean;\n  private objectRestNoSymbols: boolean;\n  private useBuiltIns: boolean;\n  private addHelper: File[\"addHelper\"];\n  constructor(opts: DestructuringTransformerOption) {\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(\n    id: t.AssignmentExpression[\"left\"],\n    init: t.Expression,\n  ) {\n    let op = this.operator;\n    if (t.isMemberExpression(id) || t.isOptionalMemberExpression(id)) op = \"=\";\n\n    let node: t.ExpressionStatement | t.VariableDeclaration;\n\n    if (op) {\n      node = t.expressionStatement(\n        t.assignmentExpression(\n          op,\n          id,\n          t.cloneNode(init) || this.scope.buildUndefinedNode(),\n        ),\n      );\n    } else {\n      let nodeInit: t.Expression;\n\n      if ((this.kind === \"const\" || this.kind === \"using\") && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = t.cloneNode(init);\n      }\n\n      node = t.variableDeclaration(this.kind, [\n        t.variableDeclarator(\n          id as t.Identifier | t.ArrayPattern | t.ObjectPattern,\n          nodeInit,\n        ),\n      ]);\n    }\n\n    //@ts-expect-error(todo): document block hoist property\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  }\n\n  buildVariableDeclaration(id: t.Identifier, init: t.Expression) {\n    const declar = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),\n    ]);\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id: t.LVal, _init: t.Expression | null) {\n    const init = t.cloneNode(_init);\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(\n        this.buildVariableAssignment(\n          id as t.AssignmentExpression[\"left\"],\n          init,\n        ),\n      );\n    }\n  }\n\n  toArray(node: t.Expression, count?: false | number) {\n    if (\n      this.iterableIsArray ||\n      (t.isIdentifier(node) && this.arrayRefSet.has(node.name))\n    ) {\n      return node;\n    } else {\n      const { scope, arrayLikeIsIterable } = this;\n\n      if (t.isIdentifier(node)) {\n        const binding = scope.getBinding(node.name);\n        if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n\n      if (t.isArrayExpression(node)) {\n        return node;\n      }\n\n      if (t.isIdentifier(node, { name: \"arguments\" })) {\n        return template.expression.ast`\n          Array.prototype.slice.call(${node})\n        `;\n      }\n\n      let helperName;\n      const args = [node];\n      if (typeof count === \"number\") {\n        args.push(t.numericLiteral(count));\n\n        // Used in array-rest to create an array from a subset of an iterable.\n        helperName = \"slicedToArray\";\n        // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n      } else {\n        // Used in array-rest to create an array\n        helperName = \"toArray\";\n      }\n\n      if (arrayLikeIsIterable) {\n        args.unshift(scope.path.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n\n      return t.callExpression(scope.path.hub.addHelper(helperName), args);\n    }\n  }\n\n  pushAssignmentPattern(\n    { left, right }: t.AssignmentPattern,\n    valueRef: t.Expression | null,\n  ) {\n    // handle array init with void 0. This also happens when\n    // the value was originally a hole.\n    // const [x = 42] = [void 0,];\n    // -> const x = 42;\n    if (isPureVoid(valueRef)) {\n      this.push(left, right);\n      return;\n    }\n\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n    const tempConditional = t.conditionalExpression(\n      t.binaryExpression(\n        \"===\",\n        t.cloneNode(tempId),\n        this.scope.buildUndefinedNode(),\n      ),\n      right,\n      t.cloneNode(tempId),\n    );\n\n    if (t.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (\n        this.kind === \"const\" ||\n        this.kind === \"let\" ||\n        this.kind === \"using\"\n      ) {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n\n        node = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(tempId), tempConditional),\n        );\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(\n    pattern: t.ObjectPattern,\n    objRef: t.Expression,\n    spreadProp: t.RestElement,\n    spreadPropIndex: number,\n  ) {\n    const value = buildObjectExcludingKeys(\n      pattern.properties.slice(0, spreadPropIndex) as t.ObjectProperty[],\n      objRef,\n      this.scope,\n      name => this.addHelper(name),\n      this.objectRestNoSymbols,\n      this.useBuiltIns,\n    );\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop: t.ObjectProperty, propRef: t.Expression) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    const pattern = prop.value as t.AssignmentExpression[\"left\"];\n    const objRef = t.memberExpression(\n      t.cloneNode(propRef),\n      prop.key,\n      prop.computed,\n    );\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern: t.ObjectPattern, objRef: t.Expression) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(\n            this.addHelper(\"objectDestructuringEmpty\"),\n            isPureVoid(objRef) ? [] : [objRef],\n          ),\n        ),\n      );\n      return;\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    // Replace impure computed key expressions if we have a rest parameter\n    if (hasObjectRest(pattern)) {\n      let copiedPattern: t.ObjectPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (t.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(\n            //@ts-expect-error PrivateName has been handled by destructuring-private\n            this.buildVariableDeclaration(name, key),\n          );\n          if (!copiedPattern) {\n            copiedPattern = pattern = {\n              ...pattern,\n              properties: pattern.properties.slice(),\n            };\n          }\n          copiedPattern.properties[i] = {\n            ...prop,\n            key: name,\n          };\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (t.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: t.Expression,\n  ): arr is UnpackableArrayExpression {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements won't be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (\n      pattern.elements.length < arr.elements.length &&\n      !hasArrayRest(pattern)\n    ) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n\n      // deopt call expressions as they might change values of LHS variables\n      if (t.isCallExpression(elem)) return false;\n\n      // deopt on member expressions as they may be getter/setters and have side-effects\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    const bindings = t.getBindingIdentifiers(pattern);\n    const state: ArrayUnpackVisitorState = { deopt: false, bindings };\n\n    try {\n      t.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: UnpackableArrayExpression,\n  ) {\n    const holeToUndefined = (el: t.Expression) =>\n      el ?? this.scope.buildUndefinedNode();\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(\n          elem.argument,\n          t.arrayExpression(arr.elements.slice(i).map(holeToUndefined)),\n        );\n      } else {\n        this.push(elem, holeToUndefined(arr.elements[i]));\n      }\n    }\n  }\n\n  pushArrayPattern(pattern: t.ArrayPattern, arrayRef: t.Expression | null) {\n    if (arrayRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(this.addHelper(\"objectDestructuringEmpty\"), []),\n        ),\n      );\n      return;\n    }\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that won't be evaluated\n    //\n    // eg: let [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      this.pushUnpackedArrayPattern(pattern, arrayRef);\n      return;\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    const toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      let elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = t.callExpression(\n          t.memberExpression(elemRef, t.identifier(\"slice\")),\n          [t.numericLiteral(i)],\n        );\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern: t.LVal, ref: t.Expression) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, t.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  }\n}\n\ninterface ExcludingKey {\n  key: t.Expression | t.PrivateName;\n  computed: boolean;\n}\n\nexport function buildObjectExcludingKeys<T extends ExcludingKey>(\n  excludedKeys: T[],\n  objRef: t.Expression,\n  scope: Scope,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): t.CallExpression {\n  // get all the keys that appear in this object before the current spread\n\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      keys.push(t.stringLiteral(key.name));\n    } else if (t.isTemplateLiteral(key)) {\n      keys.push(t.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (t.isLiteral(key)) {\n      // @ts-expect-error todo(flow->ts) NullLiteral\n      keys.push(t.stringLiteral(String(key.value)));\n    } else if (t.isPrivateName(key)) {\n      // private key is not enumerable\n    } else {\n      keys.push(t.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : addHelper(\"extends\");\n    value = t.callExpression(extendsHelper, [\n      t.objectExpression([]),\n      t.sequenceExpression([\n        t.callExpression(addHelper(\"objectDestructuringEmpty\"), [\n          t.cloneNode(objRef),\n        ]),\n        t.cloneNode(objRef),\n      ]),\n    ]);\n  } else {\n    let keyExpression: t.Expression = t.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = t.callExpression(\n        t.memberExpression(keyExpression, t.identifier(\"map\")),\n        [addHelper(\"toPropertyKey\")],\n      );\n    } else if (!hasTemplateLiteral && !t.isProgram(scope.block)) {\n      // Hoist definition of excluded keys, so that it's not created each time.\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\",\n      });\n\n      keyExpression = t.cloneNode(id);\n    }\n\n    value = t.callExpression(\n      addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`),\n      [t.cloneNode(objRef), keyExpression],\n    );\n  }\n  return value;\n}\n\nexport function convertVariableDeclaration(\n  path: NodePath<t.VariableDeclaration>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n\n    const patternId = declar.init;\n    const pattern = declar.id;\n\n    const destructuring: DestructuringTransformer =\n      new DestructuringTransformer({\n        // @ts-expect-error(todo): avoid internal properties access\n        blockHoist: node._blockHoist,\n        nodes: nodes,\n        scope: scope,\n        kind: node.kind,\n        iterableIsArray,\n        arrayLikeIsIterable,\n        useBuiltIns,\n        objectRestNoSymbols,\n        addHelper,\n      });\n\n    if (t.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        // we aren't the last declarator so let's just make the\n        // last transformed node inherit from us\n        t.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(\n        t.inherits(\n          destructuring.buildVariableAssignment(pattern, patternId),\n          declar,\n        ),\n      );\n    }\n  }\n\n  let tail: t.VariableDeclaration | null = null;\n  let nodesOut = [];\n  for (const node of nodes) {\n    if (t.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        // Create a single compound declarations\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        // Make sure the original node kind is used for each compound declaration\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    // Propagate the original declaration node's location\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(node);\n  }\n\n  if (\n    nodesOut.length === 2 &&\n    t.isVariableDeclaration(nodesOut[0]) &&\n    t.isExpressionStatement(nodesOut[1]) &&\n    t.isCallExpression(nodesOut[1].expression) &&\n    nodesOut[0].declarations.length === 1\n  ) {\n    // This can only happen when we generate this code:\n    //    var _ref = DESTRUCTURED_VALUE;\n    //     babelHelpers.objectDestructuringEmpty(_ref);\n    // Since pushing those two statements to the for loop .init will require an IIFE,\n    // we can optimize them to\n    //     babelHelpers.objectDestructuringEmpty(DESTRUCTURED_VALUE);\n    const expr = nodesOut[1].expression;\n    expr.arguments = [nodesOut[0].declarations[0].init];\n    nodesOut = [expr];\n  } else {\n    // We must keep nodes all are expressions or statements, so `replaceWithMultiple` can work.\n    if (\n      t.isForStatement(path.parent, { init: node }) &&\n      !nodesOut.some(v => t.isVariableDeclaration(v))\n    ) {\n      for (let i = 0; i < nodesOut.length; i++) {\n        const node: t.Node = nodesOut[i];\n        if (t.isExpressionStatement(node)) {\n          nodesOut[i] = node.expression;\n        }\n      }\n    }\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\n\nexport function convertAssignmentExpression(\n  path: NodePath<t.AssignmentExpression & { left: t.Pattern }>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope, parentPath } = path;\n\n  const nodes: DestructuringTransformerNode[] = [];\n\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper,\n  });\n\n  let ref: t.Identifier | void;\n  if (\n    (!parentPath.isExpressionStatement() &&\n      !parentPath.isSequenceExpression()) ||\n    path.isCompletionRecord()\n  ) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n    nodes.push(\n      t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]),\n    );\n\n    if (t.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(t.blockStatement([]));\n      nodes.push(t.returnStatement(t.cloneNode(ref)));\n    } else {\n      nodes.push(t.expressionStatement(t.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\nimport {\n  DestructuringTransformer,\n  convertVariableDeclaration,\n  convertAssignmentExpression,\n  unshiftForXStatementBody,\n  type DestructuringTransformerNode,\n} from \"./util.ts\";\nexport { buildObjectExcludingKeys, unshiftForXStatementBody } from \"./util.ts\";\n\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node: t.VariableDeclaration) {\n  for (const declar of node.declarations) {\n    if (t.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n  useBuiltIns?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { useBuiltIns = false } = options;\n\n  const iterableIsArray =\n    api.assumption(\"iterableIsArray\") ?? options.loose ?? false;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\") ?? false;\n  const objectRestNoSymbols =\n    api.assumption(\"objectRestNoSymbols\") ?? options.loose ?? false;\n\n  return {\n    name: \"transform-destructuring\",\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const statementBody = (path.node.body as t.BlockStatement).body;\n          const nodes = [];\n          // todo: the completion of a for statement can only be observed from\n          // a do block (or eval that we don't support),\n          // but the new do-expression proposal plans to ban iteration ends in the\n          // do block, maybe we can get rid of this\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        const pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [\n          t.variableDeclarator(key, null),\n        ]);\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n\n        destructuring.init(pattern, key);\n\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n\n      CatchClause({ node, scope }) {\n        const pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n\n      AssignmentExpression(path, state) {\n        if (!t.isPattern(path.node.left)) return;\n        convertAssignmentExpression(\n          path as NodePath<t.AssignmentExpression & { left: t.Pattern }>,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n\n      VariableDeclaration(path, state) {\n        const { node, parent } = path;\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n    },\n  };\n});\n"],"names":["isPureVoid","node","t","isUnaryExpression","operator","isPureish","argument","unshiftForXStatementBody","statementPath","newStatements","ensureBlock","scope","bodyScopeBindings","get","bindings","hasShadowedBlockScopedBindings","Object","keys","some","name","hasBinding","body","blockStatement","unshift","hasArrayRest","pattern","elements","elem","isRestElement","hasObjectRest","properties","prop","STOP_TRAVERSAL","arrayUnpackVisitor","ancestors","state","length","isIdentifier","isReferenced","deopt","DestructuringTransformer","constructor","opts","blockHoist","arrayRefSet","nodes","kind","iterableIsArray","arrayLikeIsIterable","objectRestNoSymbols","useBuiltIns","addHelper","Set","getExtendsHelper","memberExpression","identifier","buildVariableAssignment","id","init","op","isMemberExpression","isOptionalMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","nodeInit","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","declar","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","has","binding","getBinding","constant","path","isGenericType","isArrayExpression","template","expression","ast","helperName","args","numericLiteral","hub","callExpression","left","right","valueRef","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","isPattern","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","value","buildObjectExcludingKeys","slice","pushObjectProperty","propRef","isLiteral","key","computed","isStatic","temp","copiedPattern","i","isPure","assign","canUnpackArrayPattern","arr","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","holeToUndefined","el","arrayExpression","map","arrayRef","add","elemRef","ref","memo","maybeGenerateMemoised","excludedKeys","allLiteral","hasTemplateLiteral","stringLiteral","isTemplateLiteral","String","isPrivateName","extendsHelper","objectExpression","sequenceExpression","keyExpression","isProgram","block","programScope","getProgramParent","convertVariableDeclaration","nodeKind","nodeLoc","loc","declarations","destructuring","inherits","tail","nodesOut","isVariableDeclaration","isExpressionStatement","expr","arguments","isForStatement","parent","v","replaceWith","replaceWithMultiple","crawl","convertAssignmentExpression","parentPath","isSequenceExpression","isCompletionRecord","isArrowFunctionExpression","returnStatement","variableDeclarationHasPattern","declare","api","options","_ref","_api$assumption","_ref2","_options$allowArrayLi","_ref3","_api$assumption2","assertVersion","assumption","loose","allowArrayLike","visitor","ExportNamedDeclaration","declaration","specifiers","getOuterBindingIdentifiers","exportSpecifier","insertAfter","exportNamedDeclaration","ForXStatement","statementBody","CatchClause","param","AssignmentExpression","VariableDeclaration","isForXStatement","container"],"mappings":"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","ignoreList":[0,1]}},
    {"offset": {"line": 10044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10049, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-regexp-features-plugin/src/features.ts"],"sourcesContent":["export const FEATURES = Object.freeze({\n  unicodeFlag: 1 << 0,\n  dotAllFlag: 1 << 1,\n  unicodePropertyEscape: 1 << 2,\n  namedCaptureGroups: 1 << 3,\n  // Not used, for backward compatibility with syntax-unicode-sets-regex\n  unicodeSetsFlag_syntax: 1 << 4,\n  unicodeSetsFlag: 1 << 5,\n  duplicateNamedCaptureGroups: 1 << 6,\n  modifiers: 1 << 7,\n});\n\n// We can't use a symbol because this needs to always be the same, even if\n// this package isn't deduped by npm. e.g.\n//  - node_modules/\n//    - @babel/plugin-regexp-features\n//    - @babel/plugin-transform-unicode-property-regex\n//      - node_modules\n//        - @babel-plugin-regexp-features\nexport const featuresKey = \"@babel/plugin-regexp-features/featuresKey\";\nexport const runtimeKey = \"@babel/plugin-regexp-features/runtimeKey\";\n\ntype FeatureType = (typeof FEATURES)[keyof typeof FEATURES];\n\nexport function enableFeature(features: number, feature: FeatureType): number {\n  return features | feature;\n}\n\nexport function hasFeature(features: number, feature: FeatureType) {\n  return !!(features & feature);\n}\n"],"names":["FEATURES","exports","Object","freeze","unicodeFlag","dotAllFlag","unicodePropertyEscape","namedCaptureGroups","unicodeSetsFlag_syntax","unicodeSetsFlag","duplicateNamedCaptureGroups","modifiers","featuresKey","runtimeKey","enableFeature","features","feature","hasFeature"],"mappings":";;;;;;;;;AAAO,MAAMA,QAAQ,GAAAC,OAAA,CAAAD,QAAA,GAAGE,MAAM,CAACC,MAAM,CAAC;IACpCC,WAAW,EAAE,CAAC,IAAI,CAAC;IACnBC,UAAU,EAAE,CAAC,IAAI,CAAC;IAClBC,qBAAqB,EAAE,CAAC,IAAI,CAAC;IAC7BC,kBAAkB,EAAE,CAAC,IAAI,CAAC;IAE1BC,sBAAsB,EAAE,CAAC,IAAI,CAAC;IAC9BC,eAAe,EAAE,CAAC,IAAI,CAAC;IACvBC,2BAA2B,EAAE,CAAC,IAAI,CAAC;IACnCC,SAAS,EAAE,CAAC,IAAI;AAClB,CAAC,CAAC;AASK,MAAMC,WAAW,GAAAX,OAAA,CAAAW,WAAA,GAAG,2CAA2C;AAC/D,MAAMC,UAAU,GAAAZ,OAAA,CAAAY,UAAA,GAAG,0CAA0C;AAI7D,SAASC,aAAaA,CAACC,QAAgB,EAAEC,OAAoB,EAAU;IAC5E,OAAOD,QAAQ,GAAGC,OAAO;AAC3B;AAEO,SAASC,UAAUA,CAACF,QAAgB,EAAEC,OAAoB,EAAE;IACjE,OAAO,CAAC,CAAA,CAAED,QAAQ,GAAGC,OAAO,CAAC;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 10076, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10081, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-regexp-features-plugin/src/util.ts"],"sourcesContent":["import type { types as t } from \"@babel/core\";\nimport { FEATURES, hasFeature } from \"./features.ts\";\n\nimport type { RegexpuOptions } from \"regexpu-core\";\n\nexport function generateRegexpuOptions(\n  pattern: string,\n  toTransform: number,\n): RegexpuOptions {\n  const feat = (name: keyof typeof FEATURES) => {\n    return hasFeature(toTransform, FEATURES[name]) ? \"transform\" : false;\n  };\n\n  const featDuplicateNamedGroups = (): \"transform\" | false => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n\n    // This can return false positive, for example for /\\(?<a>\\)/.\n    // However, it's such a rare occurrence that it's ok to compile\n    // the regexp even if we only need to compile regexps with\n    // duplicate named capturing groups.\n    const regex = /\\(\\?<([^>]+)>/g;\n    const seen = new Set();\n    for (let match; (match = regex.exec(pattern)); seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n    return false;\n  };\n\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag: feat(\"unicodeSetsFlag\"),\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {},\n    modifiers: feat(\"modifiers\"),\n  };\n}\n\nexport function canSkipRegexpu(\n  node: t.RegExpLiteral,\n  options: RegexpuOptions,\n): boolean {\n  const { flags, pattern } = node;\n\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n    if (\n      options.unicodePropertyEscapes === \"transform\" &&\n      /\\\\p\\{/i.test(pattern)\n    ) {\n      return false;\n    }\n  }\n\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n\n  if (options.modifiers === \"transform\" && /\\(\\?[\\w-]+:/.test(pattern)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function transformFlags(regexpuOptions: RegexpuOptions, flags: string) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n  return flags;\n}\n"],"names":["_features","require","generateRegexpuOptions","pattern","toTransform","feat","name","hasFeature","FEATURES","featDuplicateNamedGroups","regex","seen","Set","match","exec","add","has","unicodeFlag","unicodeSetsFlag","dotAllFlag","unicodePropertyEscapes","namedGroups","onNamedGroup","modifiers","canSkipRegexpu","node","options","flags","includes","test","transformFlags","regexpuOptions","replace"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10151, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-regexp-features-plugin/src/index.ts"],"sourcesContent":["import rewritePattern from \"regexpu-core\";\nimport { types as t, type PluginObject, type NodePath } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport semver from \"semver\";\n\nimport {\n  featuresKey,\n  FEATURES,\n  enableFeature,\n  runtimeKey,\n  hasFeature,\n} from \"./features.ts\";\nimport {\n  generateRegexpuOptions,\n  canSkipRegexpu,\n  transformFlags,\n} from \"./util.ts\";\n\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nexport interface Options {\n  name: string;\n  feature: keyof typeof FEATURES;\n  options?: {\n    useUnicodeFlag?: boolean;\n    runtime?: boolean;\n  };\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n}\n\nexport function createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {},\n  manipulateOptions = () => {},\n}: Options): PluginObject {\n  return {\n    name,\n\n    manipulateOptions,\n\n    pre() {\n      const { file } = this;\n      const features = file.get(featuresKey) ?? 0;\n      let newFeatures = enableFeature(features, FEATURES[feature]);\n\n      const { useUnicodeFlag, runtime } = options;\n      if (useUnicodeFlag === false) {\n        newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);\n      }\n      if (newFeatures !== features) {\n        file.set(featuresKey, newFeatures);\n      }\n\n      if (runtime !== undefined) {\n        if (\n          file.has(runtimeKey) &&\n          file.get(runtimeKey) !== runtime &&\n          (process.env.BABEL_8_BREAKING ||\n            // This check. Is necessary because in Babel 7 we allow multiple\n            // copies of transform-named-capturing-groups-regex with\n            // conflicting 'runtime' options.\n            hasFeature(newFeatures, FEATURES.duplicateNamedCaptureGroups))\n        ) {\n          throw new Error(\n            `The 'runtime' option must be the same for ` +\n              `'@babel/plugin-transform-named-capturing-groups-regex' and ` +\n              `'@babel/plugin-transform-duplicate-named-capturing-groups-regex'.`,\n          );\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          file.set(runtimeKey, runtime);\n        } else if (\n          // This check. Is necessary because in Babel 7 we allow multiple\n          // copies of transform-named-capturing-groups-regex with\n          // conflicting 'runtime' options.\n          feature === \"namedCaptureGroups\"\n        ) {\n          if (!runtime || !file.has(runtimeKey)) file.set(runtimeKey, runtime);\n        } else {\n          file.set(runtimeKey, runtime);\n        }\n      }\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // Until 7.21.4, we used to encode the version as a number.\n        // If file.get(versionKey) is a number, it has thus been\n        // set by an older version of this plugin.\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, PACKAGE_JSON.version);\n          return;\n        }\n      }\n      if (\n        !file.get(versionKey) ||\n        semver.lt(file.get(versionKey), PACKAGE_JSON.version)\n      ) {\n        file.set(versionKey, PACKAGE_JSON.version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        const { node } = path;\n        const { file } = this;\n        const features = file.get(featuresKey);\n        const runtime = file.get(runtimeKey) ?? true;\n\n        const regexpuOptions = generateRegexpuOptions(node.pattern, features);\n        if (canSkipRegexpu(node, regexpuOptions)) {\n          return;\n        }\n\n        const namedCaptureGroups: Record<string, number | number[]> = {\n          __proto__: null,\n        };\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n\n        let newFlags;\n        if (regexpuOptions.modifiers === \"transform\") {\n          regexpuOptions.onNewFlags = flags => {\n            newFlags = flags;\n          };\n        }\n\n        node.pattern = rewritePattern(node.pattern, node.flags, regexpuOptions);\n\n        if (\n          regexpuOptions.namedGroups === \"transform\" &&\n          Object.keys(namedCaptureGroups).length > 0 &&\n          runtime &&\n          !isRegExpTest(path)\n        ) {\n          const call = t.callExpression(this.addHelper(\"wrapRegExp\"), [\n            node,\n            t.valueToNode(namedCaptureGroups),\n          ]);\n          annotateAsPure(call);\n\n          path.replaceWith(call);\n        }\n\n        node.flags = transformFlags(regexpuOptions, newFlags ?? node.flags);\n      },\n    },\n  };\n}\n\nfunction isRegExpTest(path: NodePath<t.RegExpLiteral>) {\n  return (\n    path.parentPath.isMemberExpression({\n      object: path.node,\n      computed: false,\n    }) && path.parentPath.get(\"property\").isIdentifier({ name: \"test\" })\n  );\n}\n"],"names":["_regexpuCore","require","_core","_helperAnnotateAsPure","_semver","_features","_util","versionKey","createRegExpFeaturePlugin","name","feature","options","manipulateOptions","pre","_file$get","file","features","get","featuresKey","newFeatures","enableFeature","FEATURES","useUnicodeFlag","runtime","unicodeFlag","set","undefined","has","runtimeKey","hasFeature","duplicateNamedCaptureGroups","Error","semver","lt","visitor","RegExpLiteral","path","_file$get2","_newFlags","node","regexpuOptions","generateRegexpuOptions","pattern","canSkipRegexpu","namedCaptureGroups","__proto__","namedGroups","onNamedGroup","index","prev","Array","isArray","push","newFlags","modifiers","onNewFlags","flags","rewritePattern","Object","keys","length","isRegExpTest","call","t","callExpression","addHelper","valueToNode","annotateAsPure","replaceWith","transformFlags","parentPath","isMemberExpression","object","computed","isIdentifier"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10256, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10261, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-dotall-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-dotall-regex\",\n    feature: \"dotAllFlag\",\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","assertVersion","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,wBAAwB;QAC9BC,OAAO,EAAE;IACX,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10275, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10280, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-duplicate-keys/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nfunction getName(\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n) {\n  if (t.isIdentifier(key)) {\n    return key.name;\n  }\n  return key.value.toString();\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-duplicate-keys\",\n\n    visitor: {\n      ObjectExpression(path) {\n        const { node } = path;\n        const plainProps = node.properties.filter(\n          prop => !t.isSpreadElement(prop) && !prop.computed,\n        ) as (t.ObjectMethod | t.ObjectProperty)[];\n\n        // A property is a duplicate key if:\n        // * the property is a data property, and is preceded by a data,\n        //   getter, or setter property of the same name.\n        // * the property is a getter property, and is preceded by a data or\n        //   getter property of the same name.\n        // * the property is a setter property, and is preceded by a data or\n        //   setter property of the same name.\n\n        const alreadySeenData = Object.create(null);\n        const alreadySeenGetters = Object.create(null);\n        const alreadySeenSetters = Object.create(null);\n\n        for (const prop of plainProps) {\n          const name = getName(\n            // prop must be non-computed\n            prop.key as\n              | t.Identifier\n              | t.StringLiteral\n              | t.NumericLiteral\n              | t.BigIntLiteral,\n          );\n          let isDuplicate = false;\n          // @ts-expect-error prop.kind is not defined in ObjectProperty\n          switch (prop.kind) {\n            case \"get\":\n              if (alreadySeenData[name] || alreadySeenGetters[name]) {\n                isDuplicate = true;\n              }\n              alreadySeenGetters[name] = true;\n              break;\n            case \"set\":\n              if (alreadySeenData[name] || alreadySeenSetters[name]) {\n                isDuplicate = true;\n              }\n              alreadySeenSetters[name] = true;\n              break;\n            default:\n              if (\n                alreadySeenData[name] ||\n                alreadySeenGetters[name] ||\n                alreadySeenSetters[name]\n              ) {\n                isDuplicate = true;\n              }\n              alreadySeenData[name] = true;\n          }\n\n          if (isDuplicate) {\n            // Rely on the computed properties transform to split the property\n            // assignment out of the object literal.\n            prop.computed = true;\n            prop.key = t.stringLiteral(name);\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","getName","key","t","isIdentifier","name","value","toString","_default","exports","default","declare","api","assertVersion","visitor","ObjectExpression","path","node","plainProps","properties","filter","prop","isSpreadElement","computed","alreadySeenData","Object","create","alreadySeenGetters","alreadySeenSetters","isDuplicate","kind","stringLiteral"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAEA,SAASE,OAAOA,CACdC,GAAwE,EACxE;IACA,IAAIC,MAAAA,KAAC,CAACC,YAAY,CAACF,GAAG,CAAC,EAAE;QACvB,OAAOA,GAAG,CAACG,IAAI;IACjB;IACA,OAAOH,GAAG,CAACI,KAAK,CAACC,QAAQ,CAAC,CAAC;AAC7B;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEc,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLR,IAAI,EAAE,0BAA0B;QAEhCS,OAAO,EAAE;YACPC,gBAAgBA,EAACC,IAAI,EAAE;gBACrB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI;gBACrB,MAAME,UAAU,GAAGD,IAAI,CAACE,UAAU,CAACC,MAAM,EACvCC,IAAI,GAAI,CAAClB,MAAAA,KAAC,CAACmB,eAAe,CAACD,IAAI,CAAC,IAAI,CAACA,IAAI,CAACE,QAC5C,CAA0C;gBAU1C,MAAMC,eAAe,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;gBAC3C,MAAMC,kBAAkB,GAAGF,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;gBAC9C,MAAME,kBAAkB,GAAGH,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;gBAE9C,KAAK,MAAML,IAAI,IAAIH,UAAU,CAAE;oBAC7B,MAAMb,IAAI,GAAGJ,OAAO,CAElBoB,IAAI,CAACnB,GAKP,CAAC;oBACD,IAAI2B,WAAW,GAAG,KAAK;oBAEvB,OAAQR,IAAI,CAACS,IAAI;wBACf,KAAK,KAAK;4BACR,IAAIN,eAAe,CAACnB,IAAI,CAAC,IAAIsB,kBAAkB,CAACtB,IAAI,CAAC,EAAE;gCACrDwB,WAAW,GAAG,IAAI;4BACpB;4BACAF,kBAAkB,CAACtB,IAAI,CAAC,GAAG,IAAI;4BAC/B;wBACF,KAAK,KAAK;4BACR,IAAImB,eAAe,CAACnB,IAAI,CAAC,IAAIuB,kBAAkB,CAACvB,IAAI,CAAC,EAAE;gCACrDwB,WAAW,GAAG,IAAI;4BACpB;4BACAD,kBAAkB,CAACvB,IAAI,CAAC,GAAG,IAAI;4BAC/B;wBACF;4BACE,IACEmB,eAAe,CAACnB,IAAI,CAAC,IACrBsB,kBAAkB,CAACtB,IAAI,CAAC,IACxBuB,kBAAkB,CAACvB,IAAI,CAAC,EACxB;gCACAwB,WAAW,GAAG,IAAI;4BACpB;4BACAL,eAAe,CAACnB,IAAI,CAAC,GAAG,IAAI;oBAChC;oBAEA,IAAIwB,WAAW,EAAE;wBAGfR,IAAI,CAACE,QAAQ,GAAG,IAAI;wBACpBF,IAAI,CAACnB,GAAG,GAAGC,MAAAA,KAAC,CAAC4B,aAAa,CAAC1B,IAAI,CAAC;oBAClC;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10340, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-duplicate-named-capturing-groups-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  runtime?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.19.0\"));\n\n  const { runtime } = options;\n  if (runtime !== undefined && typeof runtime !== \"boolean\") {\n    throw new Error(\"The 'runtime' option must be boolean\");\n  }\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-duplicate-named-capturing-groups-regex\",\n    feature: \"duplicateNamedCaptureGroups\",\n    options: { runtime },\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","options","assertVersion","runtime","undefined","Error","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMtC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAChDD,GAAG,CAACE,aAAa,CAAA,qCAA4B,CAAC;IAE9C,MAAM,EAAEC,OAAAA,EAAS,GAAGF,OAAO;IAC3B,IAAIE,OAAO,KAAKC,SAAS,IAAI,OAAOD,OAAO,KAAK,SAAS,EAAE;QACzD,MAAM,IAAIE,KAAK,CAAC,sCAAsC,CAAC;IACzD;IAEA,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,kDAAkD;QACxDC,OAAO,EAAE,6BAA6B;QACtCP,OAAO,EAAE;YAAEE;QAAQ;IACrB,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10366, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-dynamic-import/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nconst SUPPORTED_MODULES = new Set([\"commonjs\", \"amd\", \"systemjs\"]);\n\nconst MODULES_NOT_FOUND = `\\\n@babel/plugin-transform-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n`;\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-dynamic-import\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"dynamicImport\"),\n\n    pre() {\n      // We keep using the old name, for compatibility with older\n      // version of the CommonJS transform.\n      this.file.set(\n        \"@babel/plugin-proposal-dynamic-import\",\n        PACKAGE_JSON.version,\n      );\n    },\n\n    visitor: {\n      Program() {\n        const modules = this.file.get(\"@babel/plugin-transform-modules-*\");\n\n        if (!SUPPORTED_MODULES.has(modules)) {\n          throw new Error(MODULES_NOT_FOUND);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","SUPPORTED_MODULES","Set","MODULES_NOT_FOUND","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","_","parser","plugins","push","pre","file","set","visitor","Program","modules","get","has","Error"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAEA,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,CAAC;IAAC,UAAU;IAAE,KAAK;IAAE,UAAU;CAAC,CAAC;AAElE,MAAMC,iBAAiB,GAAG,CAAA;;;;;;;;;;;AAW1B,CAAC;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEa,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,0BAA0B;QAChCC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,eAAe,CAAC;QAEvDC,GAAGA,CAAA,EAAG;YAGJ,IAAI,CAACC,IAAI,CAACC,GAAG,CACX,uCAAuC,EAAA,QAEzC,CAAC;QACH,CAAC;QAEDC,OAAO,EAAE;YACPC,OAAOA,CAAA,EAAG;gBACR,MAAMC,OAAO,GAAG,IAAI,CAACJ,IAAI,CAACK,GAAG,CAAC,mCAAmC,CAAC;gBAElE,IAAI,CAACrB,iBAAiB,CAACsB,GAAG,CAACF,OAAO,CAAC,EAAE;oBACnC,MAAM,IAAIG,KAAK,CAACrB,iBAAiB,CAAC;gBACpC;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10407, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10412, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-exponentiation-operator/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, Scope } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { types: t, template } = api;\n\n  function build(left: t.Expression, right: t.Expression) {\n    return t.callExpression(\n      t.memberExpression(t.identifier(\"Math\"), t.identifier(\"pow\")),\n      [left, right],\n    );\n  }\n\n  function maybeMemoize<T extends t.Expression | t.Super>(\n    node: T,\n    scope: Scope,\n  ) {\n    if (scope.isStatic(node)) {\n      return { assign: node, ref: t.cloneNode(node) };\n    }\n\n    if (scope.path.isPattern()) {\n      // We cannot inject a temp var in function arguments.\n      return null;\n    }\n\n    const id = scope.generateUidIdentifierBasedOnNode(node);\n    scope.push({ id });\n    return {\n      assign: t.assignmentExpression(\n        \"=\",\n        t.cloneNode(id),\n        // This is not t.Super, because otherwise the .isStatic check above\n        // would have returned true.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        node as t.Expression,\n      ),\n      ref: t.cloneNode(id),\n    };\n  }\n\n  return {\n    name: \"transform-exponentiation-operator\",\n\n    visitor: {\n      AssignmentExpression(path) {\n        const { node, scope } = path;\n        if (node.operator !== \"**=\") return;\n\n        if (t.isMemberExpression(node.left)) {\n          let member1: t.Expression;\n          let member2: t.Expression;\n\n          const object = maybeMemoize(node.left.object, scope);\n          if (!object) {\n            // We need to inject a temp var, but we are in function parameters\n            // and thus cannot. Wrap the expression in an IIFE. It will be\n            // eventually requeued and transformed.\n            path.replaceWith(template.expression.ast`(() => ${path.node})()`);\n            return;\n          }\n\n          const { property, computed } = node.left;\n\n          if (computed) {\n            const prop = maybeMemoize(property as t.Expression, scope);\n            member1 = t.memberExpression(object.assign, prop.assign, true);\n            member2 = t.memberExpression(object.ref, prop.ref, true);\n          } else {\n            member1 = t.memberExpression(object.assign, property, false);\n            member2 = t.memberExpression(\n              object.ref,\n              t.cloneNode(property),\n              false,\n            );\n          }\n\n          path.replaceWith(\n            t.assignmentExpression(\"=\", member1, build(member2, node.right)),\n          );\n        } else {\n          path.replaceWith(\n            t.assignmentExpression(\n              \"=\",\n              node.left,\n              build(\n                // todo: it could be a t.AsExpression\n                t.cloneNode(node.left) as t.Identifier,\n                node.right,\n              ),\n            ),\n          );\n        }\n      },\n\n      BinaryExpression(path) {\n        const { node } = path;\n        if (node.operator === \"**\") {\n          path.replaceWith(\n            build(\n              // left can be PrivateName only if operator is `\"in\"`\n              node.left as t.Expression,\n              node.right,\n            ),\n          );\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","types","t","template","build","left","right","callExpression","memberExpression","identifier","maybeMemoize","node","scope","isStatic","assign","ref","cloneNode","path","isPattern","id","generateUidIdentifierBasedOnNode","push","assignmentExpression","name","visitor","AssignmentExpression","operator","isMemberExpression","member1","member2","object","replaceWith","expression","ast","property","computed","prop","BinaryExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10483, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10488, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-export-namespace-from/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-export-namespace-from\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"exportNamespaceFrom\"),\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const { node, scope } = path;\n        const { specifiers } = node;\n\n        const index = t.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;\n        if (!t.isExportNamespaceSpecifier(specifiers[index])) return;\n\n        const nodes = [];\n\n        if (index === 1) {\n          nodes.push(\n            t.exportNamedDeclaration(null, [specifiers.shift()], node.source),\n          );\n        }\n\n        const specifier = specifiers.shift();\n        const { exported } = specifier;\n        const uid = scope.generateUidIdentifier(\n          // @ts-expect-error Identifier ?? StringLiteral\n          exported.name ?? exported.value,\n        );\n\n        nodes.push(\n          t.importDeclaration(\n            [t.importNamespaceSpecifier(uid)],\n            t.cloneNode(node.source),\n          ),\n          t.exportNamedDeclaration(null, [\n            t.exportSpecifier(t.cloneNode(uid), exported),\n          ]),\n        );\n\n        if (node.specifiers.length >= 1) {\n          nodes.push(node);\n        }\n\n        const [importDeclaration] = path.replaceWithMultiple(nodes);\n        path.scope.registerDeclaration(importDeclaration);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","_","parser","plugins","push","visitor","ExportNamedDeclaration","path","_exported$name","node","scope","specifiers","index","t","isExportDefaultSpecifier","isExportNamespaceSpecifier","nodes","exportNamedDeclaration","shift","source","specifier","exported","uid","generateUidIdentifier","value","importDeclaration","importNamespaceSpecifier","cloneNode","exportSpecifier","length","replaceWithMultiple","registerDeclaration"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,iCAAiC;QACvCC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,qBAAqB,CAAC;QAE7DC,OAAO,EAAE;YACPC,sBAAsBA,EAACC,IAAI,EAAE;gBAAA,IAAAC,cAAA;gBAC3B,MAAM,EAAEC,IAAI,EAAEC,KAAAA,EAAO,GAAGH,IAAI;gBAC5B,MAAM,EAAEI,UAAAA,EAAY,GAAGF,IAAI;gBAE3B,MAAMG,KAAK,GAAGC,MAAAA,KAAC,CAACC,wBAAwB,CAACH,UAAU,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;gBAC/D,IAAI,CAACE,MAAAA,KAAC,CAACE,0BAA0B,CAACJ,UAAU,CAACC,KAAK,CAAC,CAAC,EAAE;gBAEtD,MAAMI,KAAK,GAAG,EAAE;gBAEhB,IAAIJ,KAAK,KAAK,CAAC,EAAE;oBACfI,KAAK,CAACZ,IAAI,CACRS,MAAAA,KAAC,CAACI,sBAAsB,CAAC,IAAI,EAAE;wBAACN,UAAU,CAACO,KAAK,CAAC,CAAC;qBAAC,EAAET,IAAI,CAACU,MAAM,CAClE,CAAC;gBACH;gBAEA,MAAMC,SAAS,GAAGT,UAAU,CAACO,KAAK,CAAC,CAAC;gBACpC,MAAM,EAAEG,QAAAA,EAAU,GAAGD,SAAS;gBAC9B,MAAME,GAAG,GAAGZ,KAAK,CAACa,qBAAqB,CAAA,CAAAf,cAAA,GAErCa,QAAQ,CAACtB,IAAI,KAAA,OAAAS,cAAA,GAAIa,QAAQ,CAACG,KAC5B,CAAC;gBAEDR,KAAK,CAACZ,IAAI,CACRS,MAAAA,KAAC,CAACY,iBAAiB,CACjB;oBAACZ,MAAAA,KAAC,CAACa,wBAAwB,CAACJ,GAAG,CAAC;iBAAC,EACjCT,MAAAA,KAAC,CAACc,SAAS,CAAClB,IAAI,CAACU,MAAM,CACzB,CAAC,EACDN,MAAAA,KAAC,CAACI,sBAAsB,CAAC,IAAI,EAAE;oBAC7BJ,MAAAA,KAAC,CAACe,eAAe,CAACf,MAAAA,KAAC,CAACc,SAAS,CAACL,GAAG,CAAC,EAAED,QAAQ,CAAC;iBAC9C,CACH,CAAC;gBAED,IAAIZ,IAAI,CAACE,UAAU,CAACkB,MAAM,IAAI,CAAC,EAAE;oBAC/Bb,KAAK,CAACZ,IAAI,CAACK,IAAI,CAAC;gBAClB;gBAEA,MAAM,CAACgB,iBAAiB,CAAC,GAAGlB,IAAI,CAACuB,mBAAmB,CAACd,KAAK,CAAC;gBAC3DT,IAAI,CAACG,KAAK,CAACqB,mBAAmB,CAACN,iBAAiB,CAAC;YACnD;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10535, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-for-of/src/no-helper-implementation.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { PluginPass, NodePath } from \"@babel/core\";\n\n// This is the legacy implementation, which inlines all the code.\n// It must be kept for compatibility reasons.\n// TODO(Babel 8): Remove this file.\n\nexport default function transformWithoutHelper(\n  loose: boolean | void,\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const pushComputedProps = loose\n    ? pushComputedPropsLoose\n    : pushComputedPropsSpec;\n\n  const { node } = path;\n  const build = pushComputedProps(path, state);\n  const declar = build.declar;\n  const loop = build.loop;\n  const block = loop.body as t.BlockStatement;\n\n  // ensure that it's a block so we can take all its statements\n  path.ensureBlock();\n\n  // add the value declaration to the new loop body\n  if (declar) {\n    block.body.push(declar);\n  }\n\n  // push the rest of the original loop body onto our new body\n  block.body.push(...(node.body as t.BlockStatement).body);\n\n  t.inherits(loop, node);\n  t.inherits(loop.body, node.body);\n\n  if (build.replaceParent) {\n    path.parentPath.replaceWithMultiple(build.node);\n    path.remove();\n  } else {\n    path.replaceWithMultiple(build.node);\n  }\n}\n\nconst buildForOfLoose = template.statement(`\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n`);\n\nconst buildForOf = template.statements(`\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n`);\n\nfunction pushComputedPropsLoose(\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const { node, scope, parent } = path;\n  const { left } = node;\n  let declar, id, intermediate;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    id = left;\n    intermediate = null;\n  } else if (t.isVariableDeclaration(left)) {\n    // for (let i of test)\n    id = scope.generateUidIdentifier(\"ref\");\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, t.identifier(id.name)),\n    ]);\n    intermediate = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.identifier(id.name)),\n    ]);\n  } else {\n    throw state.buildCodeFrameError(\n      left,\n      `Unknown node type ${left.type} in ForStatement`,\n    );\n  }\n\n  const iteratorKey = scope.generateUidIdentifier(\"iterator\");\n  const isArrayKey = scope.generateUidIdentifier(\"isArray\");\n\n  const loop = buildForOfLoose({\n    LOOP_OBJECT: iteratorKey,\n    IS_ARRAY: isArrayKey,\n    OBJECT: node.right,\n    INDEX: scope.generateUidIdentifier(\"i\"),\n    ID: id,\n    INTERMEDIATE: intermediate,\n  }) as t.ForStatement;\n\n  //\n  const isLabeledParent = t.isLabeledStatement(parent);\n  let labeled;\n\n  if (isLabeledParent) {\n    labeled = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    declar: declar,\n    node: labeled || loop,\n    loop: loop,\n  };\n}\n\nfunction pushComputedPropsSpec(\n  path: NodePath<t.ForOfStatement>,\n  state: PluginPass,\n) {\n  const { node, scope, parent } = path;\n  const left = node.left;\n  let declar;\n\n  const stepKey = scope.generateUid(\"step\");\n  const stepValue = t.memberExpression(\n    t.identifier(stepKey),\n    t.identifier(\"value\"),\n  );\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    declar = t.expressionStatement(\n      t.assignmentExpression(\"=\", left, stepValue),\n    );\n  } else if (t.isVariableDeclaration(left)) {\n    // for (let i of test)\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, stepValue),\n    ]);\n  } else {\n    throw state.buildCodeFrameError(\n      left,\n      `Unknown node type ${left.type} in ForStatement`,\n    );\n  }\n\n  const template = buildForOf({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_COMPLETION: scope.generateUidIdentifier(\n      \"iteratorNormalCompletion\",\n    ),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    STEP_KEY: t.identifier(stepKey),\n    OBJECT: node.right,\n  });\n\n  const isLabeledParent = t.isLabeledStatement(parent);\n\n  const tryBody = (template[3] as t.TryStatement).block.body;\n  const loop = tryBody[0] as t.ForStatement;\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  //\n\n  return {\n    replaceParent: isLabeledParent,\n    declar: declar,\n    loop: loop,\n    node: template,\n  };\n}\n"],"names":["_core","require","transformWithoutHelper","loose","path","state","pushComputedProps","pushComputedPropsLoose","pushComputedPropsSpec","node","build","declar","loop","block","body","ensureBlock","push","t","inherits","replaceParent","parentPath","replaceWithMultiple","remove","buildForOfLoose","template","statement","buildForOf","statements","scope","parent","left","id","intermediate","isIdentifier","isPattern","isMemberExpression","isVariableDeclaration","generateUidIdentifier","variableDeclaration","kind","variableDeclarator","declarations","identifier","name","buildCodeFrameError","type","iteratorKey","isArrayKey","LOOP_OBJECT","IS_ARRAY","OBJECT","right","INDEX","ID","INTERMEDIATE","isLabeledParent","isLabeledStatement","labeled","labeledStatement","label","stepKey","generateUid","stepValue","memberExpression","expressionStatement","assignmentExpression","ITERATOR_HAD_ERROR_KEY","ITERATOR_COMPLETION","ITERATOR_ERROR_KEY","ITERATOR_KEY","STEP_KEY","tryBody"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10684, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-for-of/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t, type NodePath } from \"@babel/core\";\n\nimport transformWithoutHelper from \"./no-helper-implementation.ts\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  assumeArray?: boolean;\n  loose?: boolean;\n}\n\nfunction buildLoopBody(\n  path: NodePath<t.ForXStatement>,\n  declar: t.Statement,\n  newBody?: t.Statement | t.Expression,\n) {\n  let block;\n  const bodyPath = path.get(\"body\");\n  const body = newBody ?? bodyPath.node;\n  if (\n    t.isBlockStatement(body) &&\n    Object.keys(path.getBindingIdentifiers()).some(id =>\n      bodyPath.scope.hasOwnBinding(id),\n    )\n  ) {\n    block = t.blockStatement([declar, body]);\n  } else {\n    block = t.toBlock(body);\n    block.body.unshift(declar);\n  }\n  return block;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  {\n    const { assumeArray, allowArrayLike, loose } = options;\n\n    if (loose === true && assumeArray === true) {\n      throw new Error(\n        `The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`,\n      );\n    }\n\n    if (assumeArray === true && allowArrayLike === true) {\n      throw new Error(\n        `The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of`,\n      );\n    }\n\n    if (!process.env.BABEL_8_BREAKING) {\n      // TODO: Remove in Babel 8\n      if (allowArrayLike && /^7\\.\\d\\./.test(api.version)) {\n        throw new Error(\n          `The allowArrayLike is only supported when using @babel/core@^7.10.0`,\n        );\n      }\n    }\n  }\n\n  const iterableIsArray =\n    options.assumeArray ??\n    // Loose mode is not compatible with 'assumeArray', so we shouldn't read\n    // 'iterableIsArray' if 'loose' is true.\n    (!options.loose && api.assumption(\"iterableIsArray\"));\n\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  const skipIteratorClosing =\n    api.assumption(\"skipForOfIteratorClosing\") ?? options.loose;\n\n  if (iterableIsArray && arrayLikeIsIterable) {\n    throw new Error(\n      `The \"iterableIsArray\" and \"arrayLikeIsIterable\" assumptions are not compatible.`,\n    );\n  }\n\n  if (iterableIsArray) {\n    return {\n      name: \"transform-for-of\",\n\n      visitor: {\n        ForOfStatement(path) {\n          const { scope } = path;\n          const { left, await: isAwait } = path.node;\n          if (isAwait) {\n            return;\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n          const right = skipTransparentExprWrapperNodes(\n            path.node.right,\n          ) as t.Expression;\n          const i = scope.generateUidIdentifier(\"i\");\n          let array: t.Identifier | t.ThisExpression =\n            scope.maybeGenerateMemoised(right, true);\n          if (\n            !array &&\n            t.isIdentifier(right) &&\n            path.get(\"body\").scope.hasOwnBinding(right.name)\n          ) {\n            array = scope.generateUidIdentifier(\"arr\");\n          }\n\n          const inits = [t.variableDeclarator(i, t.numericLiteral(0))];\n          if (array) {\n            inits.push(t.variableDeclarator(array, right));\n          } else {\n            array = right as t.Identifier | t.ThisExpression;\n          }\n\n          const item = t.memberExpression(\n            t.cloneNode(array),\n            t.cloneNode(i),\n            true,\n          );\n          let assignment;\n          if (t.isVariableDeclaration(left)) {\n            assignment = left;\n            assignment.declarations[0].init = item;\n          } else {\n            assignment = t.expressionStatement(\n              t.assignmentExpression(\"=\", left, item),\n            );\n          }\n\n          path.replaceWith(\n            t.forStatement(\n              t.variableDeclaration(\"let\", inits),\n              t.binaryExpression(\n                \"<\",\n                t.cloneNode(i),\n                t.memberExpression(t.cloneNode(array), t.identifier(\"length\")),\n              ),\n              t.updateExpression(\"++\", t.cloneNode(i)),\n              buildLoopBody(path, assignment),\n            ),\n          );\n        },\n      },\n    };\n  }\n\n  const buildForOfArray = template`\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  `;\n\n  const buildForOfNoIteratorClosing = template.statements`\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  `;\n\n  const buildForOf = template.statements`\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  `;\n\n  const builder = skipIteratorClosing\n    ? {\n        build: buildForOfNoIteratorClosing,\n        helper: \"createForOfIteratorHelperLoose\",\n        getContainer: (nodes: t.Statement[]): [t.ForStatement] =>\n          nodes as [t.ForStatement],\n      }\n    : {\n        build: buildForOf,\n        helper: \"createForOfIteratorHelper\",\n        getContainer: (nodes: t.Statement[]): [t.ForStatement] =>\n          (nodes[1] as t.TryStatement).block.body as [t.ForStatement],\n      };\n\n  function _ForOfStatementArray(path: NodePath<t.ForOfStatement>) {\n    const { node, scope } = path;\n\n    const right = scope.generateUidIdentifierBasedOnNode(node.right, \"arr\");\n    const iterationKey = scope.generateUidIdentifier(\"i\");\n\n    const loop = buildForOfArray({\n      BODY: node.body,\n      KEY: iterationKey,\n      NAME: right,\n      ARR: node.right,\n    }) as t.For;\n\n    t.inherits(loop, node);\n\n    const iterationValue = t.memberExpression(\n      t.cloneNode(right),\n      t.cloneNode(iterationKey),\n      true,\n    );\n\n    let declar;\n    const left = node.left;\n    if (t.isVariableDeclaration(left)) {\n      left.declarations[0].init = iterationValue;\n      declar = left;\n    } else {\n      declar = t.expressionStatement(\n        t.assignmentExpression(\"=\", left, iterationValue),\n      );\n    }\n\n    loop.body = buildLoopBody(path, declar, loop.body);\n\n    return loop;\n  }\n\n  return {\n    name: \"transform-for-of\",\n    visitor: {\n      ForOfStatement(path, state) {\n        const right = path.get(\"right\");\n        if (\n          right.isArrayExpression() ||\n          (process.env.BABEL_8_BREAKING\n            ? right.isGenericType(\"Array\")\n            : right.isGenericType(\"Array\") ||\n              t.isArrayTypeAnnotation(right.getTypeAnnotation()))\n        ) {\n          path.replaceWith(_ForOfStatementArray(path));\n          return;\n        }\n\n        if (!process.env.BABEL_8_BREAKING) {\n          if (!state.availableHelper(builder.helper)) {\n            // Babel <7.9.0 doesn't support this helper\n            transformWithoutHelper(skipIteratorClosing, path, state);\n            return;\n          }\n        }\n\n        const { node, parent, scope } = path;\n        const left = node.left;\n        let declar;\n\n        const stepKey = scope.generateUid(\"step\");\n        const stepValue = t.memberExpression(\n          t.identifier(stepKey),\n          t.identifier(\"value\"),\n        );\n\n        if (t.isVariableDeclaration(left)) {\n          // for (let i of test)\n          declar = t.variableDeclaration(left.kind, [\n            t.variableDeclarator(left.declarations[0].id, stepValue),\n          ]);\n        } else {\n          // for (i of test), for ({ i } of test)\n          declar = t.expressionStatement(\n            t.assignmentExpression(\"=\", left, stepValue),\n          );\n        }\n\n        const nodes = builder.build({\n          CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),\n          ITERATOR_HELPER: scope.generateUidIdentifier(\"iterator\"),\n          ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable\n            ? t.booleanLiteral(true)\n            : null,\n          STEP_KEY: t.identifier(stepKey),\n          OBJECT: node.right,\n          BODY: buildLoopBody(path, declar),\n        });\n        const container = builder.getContainer(nodes);\n\n        t.inherits(container[0], node);\n        t.inherits(container[0].body, node.body);\n\n        if (t.isLabeledStatement(parent)) {\n          // @ts-expect-error replacing node types\n          container[0] = t.labeledStatement(parent.label, container[0]);\n\n          path.parentPath.replaceWithMultiple(nodes);\n\n          // The parent has been replaced, prevent Babel from traversing a detached path\n          path.skip();\n        } else {\n          path.replaceWithMultiple(nodes);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_noHelperImplementation","_helperSkipTransparentExpressionWrappers","buildLoopBody","path","declar","newBody","block","bodyPath","get","body","node","t","isBlockStatement","Object","keys","getBindingIdentifiers","some","id","scope","hasOwnBinding","blockStatement","toBlock","unshift","_default","exports","default","declare","api","options","_options$assumeArray","_options$allowArrayLi","_api$assumption","assertVersion","assumeArray","allowArrayLike","loose","Error","test","version","iterableIsArray","assumption","arrayLikeIsIterable","skipIteratorClosing","name","visitor","ForOfStatement","left","await","isAwait","right","skipTransparentExprWrapperNodes","i","generateUidIdentifier","array","maybeGenerateMemoised","isIdentifier","inits","variableDeclarator","numericLiteral","push","item","memberExpression","cloneNode","assignment","isVariableDeclaration","declarations","init","expressionStatement","assignmentExpression","replaceWith","forStatement","variableDeclaration","binaryExpression","identifier","updateExpression","buildForOfArray","template","buildForOfNoIteratorClosing","statements","buildForOf","builder","build","helper","getContainer","nodes","_ForOfStatementArray","generateUidIdentifierBasedOnNode","iterationKey","loop","BODY","KEY","NAME","ARR","inherits","iterationValue","state","isArrayExpression","isGenericType","isArrayTypeAnnotation","getTypeAnnotation","availableHelper","transformWithoutHelper","parent","stepKey","generateUid","stepValue","kind","CREATE_ITERATOR_HELPER","addHelper","ITERATOR_HELPER","ARRAY_LIKE_IS_ITERABLE","booleanLiteral","STEP_KEY","OBJECT","container","isLabeledStatement","labeledStatement","label","parentPath","replaceWithMultiple","skip"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10866, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10871, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-function-name/src/index.ts"],"sourcesContent":["import { isRequired } from \"@babel/helper-compilation-targets\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const supportUnicodeId = !isRequired(\n    \"transform-unicode-escapes\",\n    api.targets(),\n  );\n\n  return {\n    name: \"transform-function-name\",\n\n    visitor: {\n      FunctionExpression: {\n        exit(path) {\n          if (path.key !== \"value\" && !path.parentPath.isObjectProperty()) {\n            if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n              // polyfill when being run by an older Babel version\n              path.ensureFunctionName ??=\n                // eslint-disable-next-line no-restricted-globals\n                require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n            }\n            path.ensureFunctionName(supportUnicodeId);\n          }\n        },\n      },\n\n      ObjectProperty(path) {\n        const value = path.get(\"value\");\n        if (value.isFunction()) {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            value.ensureFunctionName ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          }\n          // @ts-expect-error Fixme: should check ArrowFunctionExpression\n          value.ensureFunctionName(supportUnicodeId);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperCompilationTargets","require","_helperPluginUtils","_default","exports","default","declare","api","assertVersion","supportUnicodeId","isRequired","targets","name","visitor","FunctionExpression","exit","path","key","parentPath","isObjectProperty","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","ObjectProperty","value","get","isFunction","_value$ensureFunction"],"mappings":";;;;;AAAA,IAAAA,yBAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IACtC,MAAMC,gBAAgB,GAAG,CAAC,CAAA,GAAAC,0BAAAA,UAAU,EAClC,2BAA2B,EAC3BH,GAAG,CAACI,OAAO,CAAC,CACd,CAAC;IAED,OAAO;QACLC,IAAI,EAAE,yBAAyB;QAE/BC,OAAO,EAAE;YACPC,kBAAkB,EAAE;gBAClBC,IAAIA,EAACC,IAAI,EAAE;oBACT,IAAIA,IAAI,CAACC,GAAG,KAAK,OAAO,IAAI,CAACD,IAAI,CAACE,UAAU,CAACC,gBAAgB,CAAC,CAAC,EAAE;wBACE;4BAAA,IAAAC,qBAAA;4BAE/D,CAAAA,qBAAA,GAAAJ,IAAI,CAACK,kBAAkB,KAAA,OAAAD,qBAAA,GAAvBJ,IAAI,CAACK,kBAAkB,GAErBpB,OAAO,CAAC,iBAAiB,CAAC,6EAACqB,QAAQ,CAACC,SAAS,CAACF,kBAAkB;wBACpE;wBACAL,IAAI,CAACK,kBAAkB,CAACZ,gBAAgB,CAAC;oBAC3C;gBACF;YACF,CAAC;YAEDe,cAAcA,EAACR,IAAI,EAAE;gBACnB,MAAMS,KAAK,GAAGT,IAAI,CAACU,GAAG,CAAC,OAAO,CAAC;gBAC/B,IAAID,KAAK,CAACE,UAAU,CAAC,CAAC,EAAE;oBAC2C;wBAAA,IAAAC,qBAAA;wBAE/D,CAAAA,qBAAA,GAAAH,KAAK,CAACJ,kBAAkB,KAAA,OAAAO,qBAAA,GAAxBH,KAAK,CAACJ,kBAAkB,GAEtBpB,OAAO,CAAC,iBAAiB,CAAC,6EAACqB,QAAQ,CAACC,SAAS,CAACF,kBAAkB;oBACpE;oBAEAI,KAAK,CAACJ,kBAAkB,CAACZ,gBAAgB,CAAC;gBAC5C;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10908, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10913, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-json-strings/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const regex = /(\\\\*)([\\u2028\\u2029])/g;\n  function replace(match: string, escapes: string, separator: string) {\n    // If there's an odd number, that means the separator itself was escaped.\n    // \"\\X\" escapes X.\n    // \"\\\\X\" escapes the backslash, so X is unescaped.\n    const isEscaped = escapes.length % 2 === 1;\n    if (isEscaped) return match;\n\n    return `${escapes}\\\\u${separator.charCodeAt(0).toString(16)}`;\n  }\n\n  return {\n    name: \"transform-json-strings\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"jsonStrings\"),\n\n    visitor: {\n      \"DirectiveLiteral|StringLiteral\"({\n        node,\n      }: NodePath<t.DirectiveLiteral | t.StringLiteral>) {\n        const { extra } = node;\n        if (!extra?.raw) return;\n\n        extra.raw = (extra.raw as string).replace(regex, replace);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","regex","replace","match","escapes","separator","isEscaped","length","charCodeAt","toString","name","manipulateOptions","_","parser","plugins","push","visitor","DirectiveLiteral|StringLiteral","node","extra","raw"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAGtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IACtC,MAAMC,KAAK,GAAG,wBAAwB;IACtC,SAASC,OAAOA,CAACC,KAAa,EAAEC,OAAe,EAAEC,SAAiB,EAAE;QAIlE,MAAMC,SAAS,GAAGF,OAAO,CAACG,MAAM,GAAG,CAAC,KAAK,CAAC;QAC1C,IAAID,SAAS,EAAE,OAAOH,KAAK;QAE3B,OAAO,GAAGC,OAAO,CAAA,GAAA,EAAMC,SAAS,CAACG,UAAU,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,EAAE;IAC/D;IAEA,OAAO;QACLC,IAAI,EAAE,wBAAwB;QAC9BC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,aAAa,CAAC;QAErDC,OAAO,EAAE;YACP,gCAAgCC,EAAC,EAC/BC,IAAAA,EAC+C,EAAE;gBACjD,MAAM,EAAEC,KAAAA,EAAO,GAAGD,IAAI;gBACtB,IAAI,CAAA,CAACC,KAAK,IAAA,QAALA,KAAK,CAAEC,GAAG,GAAE;gBAEjBD,KAAK,CAACC,GAAG,GAAID,KAAK,CAACC,GAAG,CAAYlB,OAAO,CAACD,KAAK,EAAEC,OAAO,CAAC;YAC3D;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10939, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10944, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-literals/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-literals\",\n\n    visitor: {\n      NumericLiteral({ node }) {\n        // number octal like 0b10 or 0o70\n        // @ts-expect-error Add node.extra typings\n        if (node.extra && /^0[ob]/i.test(node.extra.raw)) {\n          node.extra = undefined;\n        }\n      },\n\n      StringLiteral({ node }) {\n        // unicode escape\n        // @ts-expect-error Add node.extra typings\n        if (node.extra && /\\\\u/i.test(node.extra.raw)) {\n          node.extra = undefined;\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","name","visitor","NumericLiteral","node","extra","test","raw","undefined","StringLiteral"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,oBAAoB;QAE1BC,OAAO,EAAE;YACPC,cAAcA,EAAC,EAAEC,IAAAA,EAAM,EAAE;gBAGvB,IAAIA,IAAI,CAACC,KAAK,IAAI,SAAS,CAACC,IAAI,CAACF,IAAI,CAACC,KAAK,CAACE,GAAG,CAAC,EAAE;oBAChDH,IAAI,CAACC,KAAK,GAAGG,SAAS;gBACxB;YACF,CAAC;YAEDC,aAAaA,EAAC,EAAEL,IAAAA,EAAM,EAAE;gBAGtB,IAAIA,IAAI,CAACC,KAAK,IAAI,MAAM,CAACC,IAAI,CAACF,IAAI,CAACC,KAAK,CAACE,GAAG,CAAC,EAAE;oBAC7CH,IAAI,CAACC,KAAK,GAAGG,SAAS;gBACxB;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 10968, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 10973, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-logical-assignment-operators/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-logical-assignment-operators\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"logicalAssignment\"),\n\n    visitor: {\n      AssignmentExpression(path) {\n        const { node, scope } = path;\n        const { operator, left, right } = node;\n        const operatorTrunc = operator.slice(0, -1);\n        if (!t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          return;\n        }\n\n        const lhs = t.cloneNode(left) as t.Identifier | t.MemberExpression;\n        if (t.isMemberExpression(left)) {\n          const { object, property, computed } = left;\n          const memo = scope.maybeGenerateMemoised(object);\n          if (memo) {\n            left.object = memo;\n            (lhs as t.MemberExpression).object = t.assignmentExpression(\n              \"=\",\n              t.cloneNode(memo),\n              // object must not be Super when `memo` is an identifier\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n              object as t.Expression,\n            );\n          }\n\n          if (computed) {\n            const memo = scope.maybeGenerateMemoised(property);\n            if (memo) {\n              left.property = memo;\n              (lhs as t.MemberExpression).property = t.assignmentExpression(\n                \"=\",\n                t.cloneNode(memo),\n                // @ts-expect-error todo(flow->ts): property can be t.PrivateName\n                property,\n              );\n            }\n          }\n        }\n\n        path.replaceWith(\n          t.logicalExpression(\n            // @ts-expect-error operatorTrunc has been tested by t.LOGICAL_OPERATORS\n            operatorTrunc,\n            lhs,\n            t.assignmentExpression(\"=\", left, right),\n          ),\n        );\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","_","parser","plugins","push","visitor","AssignmentExpression","path","node","scope","operator","left","right","operatorTrunc","slice","t","LOGICAL_OPERATORS","includes","lhs","cloneNode","isMemberExpression","object","property","computed","memo","maybeGenerateMemoised","assignmentExpression","replaceWith","logicalExpression"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,wCAAwC;QAC9CC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,mBAAmB,CAAC;QAE3DC,OAAO,EAAE;YACPC,oBAAoBA,EAACC,IAAI,EAAE;gBACzB,MAAM,EAAEC,IAAI,EAAEC,KAAAA,EAAO,GAAGF,IAAI;gBAC5B,MAAM,EAAEG,QAAQ,EAAEC,IAAI,EAAEC,KAAAA,EAAO,GAAGJ,IAAI;gBACtC,MAAMK,aAAa,GAAGH,QAAQ,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBAC3C,IAAI,CAACC,MAAAA,KAAC,CAACC,iBAAiB,CAACC,QAAQ,CAACJ,aAAa,CAAC,EAAE;oBAChD;gBACF;gBAEA,MAAMK,GAAG,GAAGH,MAAAA,KAAC,CAACI,SAAS,CAACR,IAAI,CAAsC;gBAClE,IAAII,MAAAA,KAAC,CAACK,kBAAkB,CAACT,IAAI,CAAC,EAAE;oBAC9B,MAAM,EAAEU,MAAM,EAAEC,QAAQ,EAAEC,QAAAA,EAAU,GAAGZ,IAAI;oBAC3C,MAAMa,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACJ,MAAM,CAAC;oBAChD,IAAIG,IAAI,EAAE;wBACRb,IAAI,CAACU,MAAM,GAAGG,IAAI;wBACjBN,GAAG,CAAwBG,MAAM,GAAGN,MAAAA,KAAC,CAACW,oBAAoB,CACzD,GAAG,EACHX,MAAAA,KAAC,CAACI,SAAS,CAACK,IAAI,CAAC,EAGjBH,MACF,CAAC;oBACH;oBAEA,IAAIE,QAAQ,EAAE;wBACZ,MAAMC,IAAI,GAAGf,KAAK,CAACgB,qBAAqB,CAACH,QAAQ,CAAC;wBAClD,IAAIE,IAAI,EAAE;4BACRb,IAAI,CAACW,QAAQ,GAAGE,IAAI;4BACnBN,GAAG,CAAwBI,QAAQ,GAAGP,MAAAA,KAAC,CAACW,oBAAoB,CAC3D,GAAG,EACHX,MAAAA,KAAC,CAACI,SAAS,CAACK,IAAI,CAAC,EAEjBF,QACF,CAAC;wBACH;oBACF;gBACF;gBAEAf,IAAI,CAACoB,WAAW,CACdZ,MAAAA,KAAC,CAACa,iBAAiB,CAEjBf,aAAa,EACbK,GAAG,EACHH,MAAAA,KAAC,CAACW,oBAAoB,CAAC,GAAG,EAAEf,IAAI,EAAEC,KAAK,CACzC,CACF,CAAC;YACH;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 11014, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11019, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-member-expression-literals/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-member-expression-literals\",\n\n    visitor: {\n      MemberExpression: {\n        exit({ node }) {\n          const prop = node.property;\n          if (\n            !node.computed &&\n            t.isIdentifier(prop) &&\n            !t.isValidES3Identifier(prop.name)\n          ) {\n            // foo.default -> foo[\"default\"]\n            node.property = t.stringLiteral(prop.name);\n            node.computed = true;\n          }\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","MemberExpression","exit","node","prop","property","computed","t","isIdentifier","isValidES3Identifier","stringLiteral"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,sCAAsC;QAE5CC,OAAO,EAAE;YACPC,gBAAgB,EAAE;gBAChBC,IAAIA,EAAC,EAAEC,IAAAA,EAAM,EAAE;oBACb,MAAMC,IAAI,GAAGD,IAAI,CAACE,QAAQ;oBAC1B,IACE,CAACF,IAAI,CAACG,QAAQ,IACdC,MAAAA,KAAC,CAACC,YAAY,CAACJ,IAAI,CAAC,IACpB,CAACG,MAAAA,KAAC,CAACE,oBAAoB,CAACL,IAAI,CAACL,IAAI,CAAC,EAClC;wBAEAI,IAAI,CAACE,QAAQ,GAAGE,MAAAA,KAAC,CAACG,aAAa,CAACN,IAAI,CAACL,IAAI,CAAC;wBAC1CI,IAAI,CAACG,QAAQ,GAAG,IAAI;oBACtB;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 11043, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11048, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-amd/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  buildDynamicImport,\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport type { NodePath, PluginPass } from \"@babel/core\";\n\nconst buildWrapper = template.statement(`\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n`);\n\nconst buildAnonymousWrapper = template.statement(`\n  define([\"require\"], function(REQUIRE) {\n  })\n`);\n\nfunction injectWrapper(\n  path: NodePath<t.Program>,\n  wrapper: t.ExpressionStatement,\n) {\n  const { body, directives } = path.node;\n  path.node.directives = [];\n  path.node.body = [];\n  const amdFactoryCall = path\n    .pushContainer(\"body\", wrapper)[0]\n    .get(\"expression\") as NodePath<t.CallExpression>;\n  const amdFactoryCallArgs = amdFactoryCall.get(\"arguments\");\n  const amdFactory = (\n    amdFactoryCallArgs[\n      amdFactoryCallArgs.length - 1\n    ] as NodePath<t.FunctionExpression>\n  ).get(\"body\");\n  amdFactory.pushContainer(\"directives\", directives);\n  amdFactory.pushContainer(\"body\", body);\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\ntype State = {\n  requireId?: t.Identifier;\n  resolveId?: t.Identifier;\n  rejectId?: t.Identifier;\n};\n\nexport default declare<State>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } =\n    options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  return {\n    name: \"transform-modules-amd\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"amd\");\n    },\n\n    visitor: {\n      [\"CallExpression\" +\n        (api.types.importExpression ? \"|ImportExpression\" : \"\")](\n        this: State & PluginPass,\n        path: NodePath<t.CallExpression | t.ImportExpression>,\n        state: State,\n      ) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (path.isCallExpression() && !path.get(\"callee\").isImport()) return;\n\n        let { requireId, resolveId, rejectId } = state;\n        if (!requireId) {\n          requireId = path.scope.generateUidIdentifier(\"require\");\n          state.requireId = requireId;\n        }\n        if (!resolveId || !rejectId) {\n          resolveId = path.scope.generateUidIdentifier(\"resolve\");\n          rejectId = path.scope.generateUidIdentifier(\"reject\");\n          state.resolveId = resolveId;\n          state.rejectId = rejectId;\n        }\n\n        let result: t.Node = t.identifier(\"imported\");\n        if (!noInterop) {\n          result = wrapInterop(this.file.path, result, \"namespace\");\n        }\n\n        path.replaceWith(\n          buildDynamicImport(\n            path.node,\n            false,\n            false,\n            specifier => template.expression.ast`\n              new Promise((${resolveId}, ${rejectId}) =>\n                ${requireId}(\n                  [${specifier}],\n                  imported => ${t.cloneNode(resolveId)}(${result}),\n                  ${t.cloneNode(rejectId)}\n                )\n              )\n            `,\n          ),\n        );\n      },\n      Program: {\n        exit(path, { requireId }) {\n          if (!isModule(path)) {\n            if (requireId) {\n              injectWrapper(\n                path,\n                buildAnonymousWrapper({\n                  REQUIRE: t.cloneNode(requireId),\n                }) as t.ExpressionStatement,\n              );\n            }\n            return;\n          }\n\n          const amdArgs = [];\n          const importNames = [];\n          if (requireId) {\n            amdArgs.push(t.stringLiteral(\"require\"));\n            importNames.push(t.cloneNode(requireId));\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              enumerableModuleMeta,\n              constantReexports,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              importInterop,\n              noInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                header.loc = metadata.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          injectWrapper(\n            path,\n            buildWrapper({\n              MODULE_NAME: moduleName,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              IMPORT_NAMES: importNames,\n            }) as t.ExpressionStatement,\n          );\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperModuleTransforms","_core","buildWrapper","template","statement","buildAnonymousWrapper","injectWrapper","path","wrapper","body","directives","node","amdFactoryCall","pushContainer","get","amdFactoryCallArgs","amdFactory","length","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","allowTopLevelThis","strict","strictMode","importInterop","noInterop","constantReexports","assumption","loose","enumerableModuleMeta","name","pre","file","set","visitor","types","importExpression","state","has","isCallExpression","isImport","requireId","resolveId","rejectId","scope","generateUidIdentifier","result","t","identifier","wrapInterop","replaceWith","buildDynamicImport","specifier","expression","ast","cloneNode","Program","exit","isModule","REQUIRE","amdArgs","importNames","push","stringLiteral","moduleName","getModuleName","opts","meta","headers","rewriteModuleStatementsAndPrepareHeader","filename","hasExports","exportName","source","metadata","isSideEffectImport","interop","header","expressionStatement","assignmentExpression","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","IMPORT_NAMES"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11176, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-commonjs/src/dynamic-import.ts"],"sourcesContent":["// Heavily inspired by\n// https://github.com/airbnb/babel-plugin-dynamic-import-node/blob/master/src/utils.js\n\nimport type { File, NodePath } from \"@babel/core\";\nimport { types as t, template } from \"@babel/core\";\nimport { buildDynamicImport } from \"@babel/helper-module-transforms\";\n\nconst requireNoInterop = (source: t.Expression) =>\n  template.expression.ast`require(${source})`;\n\nconst requireInterop = (source: t.Expression, file: File) =>\n  t.callExpression(file.addHelper(\"interopRequireWildcard\"), [\n    requireNoInterop(source),\n  ]);\n\nexport function transformDynamicImport(\n  path: NodePath<t.CallExpression | t.ImportExpression>,\n  noInterop: boolean,\n  file: File,\n) {\n  const buildRequire = noInterop ? requireNoInterop : requireInterop;\n\n  path.replaceWith(\n    buildDynamicImport(path.node, true, false, specifier =>\n      buildRequire(specifier, file),\n    ),\n  );\n}\n"],"names":["_core","require","_helperModuleTransforms","requireNoInterop","source","template","expression","ast","requireInterop","file","t","callExpression","addHelper","transformDynamicImport","path","noInterop","buildRequire","replaceWith","buildDynamicImport","node","specifier"],"mappings":";;;;;AAIA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,uBAAA,GAAAD,OAAA;AAEA,MAAME,gBAAgB,IAAIC,MAAoB,GAC5CC,MAAAA,QAAQ,CAACC,UAAU,CAACC,GAAG,CAAA,QAAA,EAAWH,MAAM,CAAA,CAAA,CAAG;AAE7C,MAAMI,cAAc,GAAGA,CAACJ,MAAoB,EAAEK,IAAU,GACtDC,MAAAA,KAAC,CAACC,cAAc,CAACF,IAAI,CAACG,SAAS,CAAC,wBAAwB,CAAC,EAAE;QACzDT,gBAAgB,CAACC,MAAM,CAAC;KACzB,CAAC;AAEG,SAASS,sBAAsBA,CACpCC,IAAqD,EACrDC,SAAkB,EAClBN,IAAU,EACV;IACA,MAAMO,YAAY,GAAGD,SAAS,GAAGZ,gBAAgB,GAAGK,cAAc;IAElEM,IAAI,CAACG,WAAW,CACd,CAAA,GAAAC,wBAAAA,kBAAkB,EAACJ,IAAI,CAACK,IAAI,EAAE,IAAI,EAAE,KAAK,GAAEC,SAAS,GAClDJ,YAAY,CAACI,SAAS,EAAEX,IAAI,CAC9B,CACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 11191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11196, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-commonjs/src/lazy.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport { isSideEffectImport } from \"@babel/helper-module-transforms\";\nimport type { CommonJSHook } from \"./hooks.ts\";\n\ntype Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport const lazyImportsHook = (lazy: Lazy): CommonJSHook => ({\n  name: `${PACKAGE_JSON.name}/lazy`,\n  version: PACKAGE_JSON.version,\n  getWrapperPayload(source, metadata) {\n    if (isSideEffectImport(metadata) || metadata.reexportAll) {\n      return null;\n    }\n    if (lazy === true) {\n      // 'true' means that local relative files are eagerly loaded and\n      // dependency modules are loaded lazily.\n      return source.includes(\".\") ? null : \"lazy/function\";\n    }\n    if (Array.isArray(lazy)) {\n      return !lazy.includes(source) ? null : \"lazy/function\";\n    }\n    if (typeof lazy === \"function\") {\n      return lazy(source) ? \"lazy/function\" : null;\n    }\n  },\n  buildRequireWrapper(name, init, payload, referenced) {\n    if (payload === \"lazy/function\") {\n      if (!referenced) return false;\n      return template.statement.ast`\n        function ${name}() {\n          const data = ${init};\n          ${name} = function(){ return data; };\n          return data;\n        }\n      `;\n    }\n  },\n  wrapReference(ref, payload) {\n    if (payload === \"lazy/function\") return t.callExpression(ref, []);\n  },\n});\n"],"names":["_core","require","_helperModuleTransforms","lazyImportsHook","lazy","name","version","getWrapperPayload","source","metadata","isSideEffectImport","reexportAll","includes","Array","isArray","buildRequireWrapper","init","payload","referenced","template","statement","ast","wrapReference","ref","t","callExpression","exports"],"mappings":";;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,uBAAA,GAAAD,OAAA;AAKO,MAAME,eAAe,IAAIC,IAAU,GAAA,CAAoB;QAC5DC,IAAI,EAAE,GAAA,2CAAA,KAAA,CAA2B;QACjCC,OAAO,EAAA,QAAsB;QAC7BC,iBAAiBA,EAACC,MAAM,EAAEC,QAAQ,EAAE;YAClC,IAAI,CAAA,GAAAC,wBAAAA,kBAAkB,EAACD,QAAQ,CAAC,IAAIA,QAAQ,CAACE,WAAW,EAAE;gBACxD,OAAO,IAAI;YACb;YACA,IAAIP,IAAI,KAAK,IAAI,EAAE;gBAGjB,OAAOI,MAAM,CAACI,QAAQ,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,eAAe;YACtD;YACA,IAAIC,KAAK,CAACC,OAAO,CAACV,IAAI,CAAC,EAAE;gBACvB,OAAO,CAACA,IAAI,CAACQ,QAAQ,CAACJ,MAAM,CAAC,GAAG,IAAI,GAAG,eAAe;YACxD;YACA,IAAI,OAAOJ,IAAI,KAAK,UAAU,EAAE;gBAC9B,OAAOA,IAAI,CAACI,MAAM,CAAC,GAAG,eAAe,GAAG,IAAI;YAC9C;QACF,CAAC;QACDO,mBAAmBA,EAACV,IAAI,EAAEW,IAAI,EAAEC,OAAO,EAAEC,UAAU,EAAE;YACnD,IAAID,OAAO,KAAK,eAAe,EAAE;gBAC/B,IAAI,CAACC,UAAU,EAAE,OAAO,KAAK;gBAC7B,OAAOC,MAAAA,QAAQ,CAACC,SAAS,CAACC,GAAG,CAAA;iBACnC,EAAmBhB,IAAI,CAAA;uBACvB,EAAyBW,IAAI,CAAA;UAC7B,EAAYX,IAAI,CAAA;;;MAGhB,CAAO;YACH;QACF,CAAC;QACDiB,aAAaA,EAACC,GAAG,EAAEN,OAAO,EAAE;YAC1B,IAAIA,OAAO,KAAK,eAAe,EAAE,OAAOO,MAAAA,KAAC,CAACC,cAAc,CAACF,GAAG,EAAE,EAAE,CAAC;QACnE;IACF,CAAC,CAAC;AAACG,OAAA,CAAAvB,eAAA,GAAAA,eAAA","ignoreList":[0]}},
    {"offset": {"line": 11237, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11242, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-commonjs/src/hooks.ts"],"sourcesContent":["import type { types as t, File } from \"@babel/core\";\nimport type { isSideEffectImport } from \"@babel/helper-module-transforms\";\n\nconst commonJSHooksKey =\n  \"@babel/plugin-transform-modules-commonjs/customWrapperPlugin\";\n\ntype SourceMetadata = Parameters<typeof isSideEffectImport>[0];\n\n// A hook exposes a set of function that can customize how `require()` calls and\n// references to the imported bindings are handled. These functions can either\n// return a result, or return `null` to delegate to the next hook.\nexport interface CommonJSHook {\n  name: string;\n  version: string;\n  wrapReference?(ref: t.Expression, payload: unknown): t.CallExpression | null;\n  // Optionally wrap a `require` call. If this function returns `false`, the\n  // `require` call is removed from the generated code.\n  buildRequireWrapper?(\n    name: string,\n    init: t.Expression,\n    payload: unknown,\n    referenced: boolean,\n  ): t.Statement | false | null;\n  getWrapperPayload?(\n    source: string,\n    metadata: SourceMetadata,\n    importNodes: t.Node[],\n  ): string | null;\n}\n\nexport function defineCommonJSHook(file: File, hook: CommonJSHook) {\n  let hooks = file.get(commonJSHooksKey);\n  if (!hooks) file.set(commonJSHooksKey, (hooks = []));\n  hooks.push(hook);\n}\n\nfunction findMap<T, U>(arr: T[] | null, cb: (el: T) => U): U | null {\n  if (arr) {\n    for (const el of arr) {\n      const res = cb(el);\n      if (res != null) return res;\n    }\n  }\n}\n\nexport function makeInvokers(\n  file: File,\n): Pick<\n  CommonJSHook,\n  \"wrapReference\" | \"getWrapperPayload\" | \"buildRequireWrapper\"\n> {\n  const hooks: CommonJSHook[] | null = file.get(commonJSHooksKey);\n\n  return {\n    getWrapperPayload(...args) {\n      return findMap(hooks, hook => hook.getWrapperPayload?.(...args));\n    },\n    wrapReference(...args) {\n      return findMap(hooks, hook => hook.wrapReference?.(...args));\n    },\n    buildRequireWrapper(...args) {\n      return findMap(hooks, hook => hook.buildRequireWrapper?.(...args));\n    },\n  };\n}\n"],"names":["commonJSHooksKey","defineCommonJSHook","file","hook","hooks","get","set","push","findMap","arr","cb","el","res","makeInvokers","getWrapperPayload","args","wrapReference","buildRequireWrapper"],"mappings":";;;;;;AAGA,MAAMA,gBAAgB,GACpB,8DAA8D;AA0BzD,SAASC,kBAAkBA,CAACC,IAAU,EAAEC,IAAkB,EAAE;IACjE,IAAIC,KAAK,GAAGF,IAAI,CAACG,GAAG,CAACL,gBAAgB,CAAC;IACtC,IAAI,CAACI,KAAK,EAAEF,IAAI,CAACI,GAAG,CAACN,gBAAgB,EAAGI,KAAK,GAAG,EAAG,CAAC;IACpDA,KAAK,CAACG,IAAI,CAACJ,IAAI,CAAC;AAClB;AAEA,SAASK,OAAOA,CAAOC,GAAe,EAAEC,EAAgB,EAAY;IAClE,IAAID,GAAG,EAAE;QACP,KAAK,MAAME,EAAE,IAAIF,GAAG,CAAE;YACpB,MAAMG,GAAG,GAAGF,EAAE,CAACC,EAAE,CAAC;YAClB,IAAIC,GAAG,IAAI,IAAI,EAAE,OAAOA,GAAG;QAC7B;IACF;AACF;AAEO,SAASC,YAAYA,CAC1BX,IAAU,EAIV;IACA,MAAME,KAA4B,GAAGF,IAAI,CAACG,GAAG,CAACL,gBAAgB,CAAC;IAE/D,OAAO;QACLc,iBAAiBA,EAAC,GAAGC,IAAI,EAAE;YACzB,OAAOP,OAAO,CAACJ,KAAK,GAAED,IAAI,GAAIA,IAAI,CAACW,iBAAiB,IAAA,OAAA,KAAA,IAAtBX,IAAI,CAACW,iBAAiB,CAAG,GAAGC,IAAI,CAAC,CAAC;QAClE,CAAC;QACDC,aAAaA,EAAC,GAAGD,IAAI,EAAE;YACrB,OAAOP,OAAO,CAACJ,KAAK,GAAED,IAAI,GAAIA,IAAI,CAACa,aAAa,IAAA,OAAA,KAAA,IAAlBb,IAAI,CAACa,aAAa,CAAG,GAAGD,IAAI,CAAC,CAAC;QAC9D,CAAC;QACDE,mBAAmBA,EAAC,GAAGF,IAAI,EAAE;YAC3B,OAAOP,OAAO,CAACJ,KAAK,GAAED,IAAI,GAAIA,IAAI,CAACc,mBAAmB,IAAA,OAAA,KAAA,IAAxBd,IAAI,CAACc,mBAAmB,CAAG,GAAGF,IAAI,CAAC,CAAC;QACpE;IACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 11276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11281, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-commonjs/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginPass, Visitor, Scope, NodePath } from \"@babel/core\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\n\nimport { transformDynamicImport } from \"./dynamic-import.ts\";\nimport { lazyImportsHook } from \"./lazy.ts\";\n\nimport { defineCommonJSHook, makeInvokers } from \"./hooks.ts\";\nexport { defineCommonJSHook };\n\nexport interface Options extends PluginOptions {\n  allowCommonJSExports?: boolean;\n  allowTopLevelThis?: boolean;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  lazy?: RewriteModuleStatementsAndPrepareHeaderOptions[\"lazy\"];\n  loose?: boolean;\n  mjsStrictNamespace?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n  strictNamespace?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    // 'true' for imports to strictly have .default, instead of having\n    // destructuring-like behavior for their properties. This matches the behavior\n    // of the initial Node.js (v12) behavior when importing a CommonJS without\n    // the __esMoule property.\n    // .strictNamespace is for non-mjs files, mjsStrictNamespace if for mjs files.\n    strictNamespace = false,\n    mjsStrictNamespace = strictNamespace,\n\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop,\n    importInterop,\n    lazy = false,\n    // Defaulting to 'true' for now. May change before 7.x major.\n    allowCommonJSExports = true,\n    loose = false,\n  } = options;\n\n  const constantReexports = api.assumption(\"constantReexports\") ?? loose;\n  const enumerableModuleMeta = api.assumption(\"enumerableModuleMeta\") ?? loose;\n  const noIncompleteNsImportDetection =\n    api.assumption(\"noIncompleteNsImportDetection\") ?? false;\n\n  if (\n    typeof lazy !== \"boolean\" &&\n    typeof lazy !== \"function\" &&\n    (!Array.isArray(lazy) || !lazy.every(item => typeof item === \"string\"))\n  ) {\n    throw new Error(`.lazy must be a boolean, array of strings, or a function`);\n  }\n\n  if (typeof strictNamespace !== \"boolean\") {\n    throw new Error(`.strictNamespace must be a boolean, or undefined`);\n  }\n  if (typeof mjsStrictNamespace !== \"boolean\") {\n    throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);\n  }\n\n  const getAssertion = (localName: string) => template.expression.ast`\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"${localName}\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  `;\n\n  const moduleExportsVisitor: Visitor<{ scope: Scope }> = {\n    ReferencedIdentifier(path) {\n      const localName = path.node.name;\n      if (localName !== \"module\" && localName !== \"exports\") return;\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = this.scope.getBinding(localName);\n\n      if (\n        // redeclared in this scope\n        rootBinding !== localBinding ||\n        (path.parentPath.isObjectProperty({ value: path.node }) &&\n          path.parentPath.parentPath.isObjectPattern()) ||\n        path.parentPath.isAssignmentExpression({ left: path.node }) ||\n        path.isAssignmentExpression({ left: path.node })\n      ) {\n        return;\n      }\n\n      path.replaceWith(getAssertion(localName));\n    },\n\n    UpdateExpression(path) {\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (localName !== \"module\" && localName !== \"exports\") return;\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = this.scope.getBinding(localName);\n\n      // redeclared in this scope\n      if (rootBinding !== localBinding) return;\n\n      path.replaceWith(\n        t.assignmentExpression(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n          (path.node.operator[0] + \"=\") as t.AssignmentExpression[\"operator\"],\n          arg.node,\n          getAssertion(localName),\n        ),\n      );\n    },\n\n    AssignmentExpression(path) {\n      const left = path.get(\"left\");\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n        if (localName !== \"module\" && localName !== \"exports\") return;\n\n        const localBinding = path.scope.getBinding(localName);\n        const rootBinding = this.scope.getBinding(localName);\n\n        // redeclared in this scope\n        if (rootBinding !== localBinding) return;\n\n        const right = path.get(\"right\");\n        right.replaceWith(\n          t.sequenceExpression([right.node, getAssertion(localName)]),\n        );\n      } else if (left.isPattern()) {\n        const ids = left.getOuterBindingIdentifiers();\n        const localName = Object.keys(ids).find(localName => {\n          if (localName !== \"module\" && localName !== \"exports\") return false;\n\n          return (\n            this.scope.getBinding(localName) ===\n            path.scope.getBinding(localName)\n          );\n        });\n\n        if (localName) {\n          const right = path.get(\"right\");\n          right.replaceWith(\n            t.sequenceExpression([right.node, getAssertion(localName)]),\n          );\n        }\n      }\n    },\n  };\n\n  return {\n    name: \"transform-modules-commonjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"commonjs\");\n\n      if (lazy) defineCommonJSHook(this.file, lazyImportsHook(lazy));\n    },\n\n    visitor: {\n      [\"CallExpression\" +\n        (api.types.importExpression ? \"|ImportExpression\" : \"\")](\n        this: PluginPass,\n        path: NodePath<t.CallExpression | t.ImportExpression>,\n      ) {\n        if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) return;\n        if (path.isCallExpression() && !t.isImport(path.node.callee)) return;\n\n        let { scope } = path;\n        do {\n          scope.rename(\"require\");\n        } while ((scope = scope.parent));\n\n        transformDynamicImport(path, noInterop, this.file);\n      },\n\n      Program: {\n        exit(path, state) {\n          if (!isModule(path)) return;\n\n          // Rename the bindings auto-injected into the scope so there is no\n          // risk of conflict between the bindings.\n          path.scope.rename(\"exports\");\n          path.scope.rename(\"module\");\n          path.scope.rename(\"require\");\n          path.scope.rename(\"__filename\");\n          path.scope.rename(\"__dirname\");\n\n          // Rewrite references to 'module' and 'exports' to throw exceptions.\n          // These objects are specific to CommonJS and are not available in\n          // real ES6 implementations.\n          if (!allowCommonJSExports) {\n            path.traverse(moduleExportsVisitor, {\n              scope: path.scope,\n            });\n          }\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          const hooks = makeInvokers(this.file);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              exportName: \"exports\",\n              constantReexports,\n              enumerableModuleMeta,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              noInterop,\n              importInterop,\n              wrapReference: hooks.wrapReference,\n              getWrapperPayload: hooks.getWrapperPayload,\n              esNamespaceOnly:\n                typeof state.filename === \"string\" &&\n                /\\.mjs$/.test(state.filename)\n                  ? mjsStrictNamespace\n                  : strictNamespace,\n              noIncompleteNsImportDetection,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          for (const [source, metadata] of meta.source) {\n            const loadExpr = t.callExpression(t.identifier(\"require\"), [\n              t.stringLiteral(source),\n            ]);\n\n            let header: t.Statement;\n            if (isSideEffectImport(metadata)) {\n              if (lazy && metadata.wrap === \"function\") {\n                throw new Error(\"Assertion failure\");\n              }\n\n              header = t.expressionStatement(loadExpr);\n            } else {\n              const init =\n                wrapInterop(path, loadExpr, metadata.interop) || loadExpr;\n\n              if (metadata.wrap) {\n                const res = hooks.buildRequireWrapper(\n                  metadata.name,\n                  init,\n                  metadata.wrap,\n                  metadata.referenced,\n                );\n                if (res === false) continue;\n                else header = res;\n              }\n              header ??= template.statement.ast`\n                var ${metadata.name} = ${init};\n              `;\n            }\n            header.loc = metadata.loc;\n\n            headers.push(header);\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n                hooks.wrapReference,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n          path.get(\"body\").forEach(path => {\n            if (!headers.includes(path.node)) return;\n            if (path.isVariableDeclaration()) {\n              path.scope.registerDeclaration(path);\n            }\n          });\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperModuleTransforms","_core","_dynamicImport","_lazy","_hooks","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","_api$assumption3","assertVersion","strictNamespace","mjsStrictNamespace","allowTopLevelThis","strict","strictMode","noInterop","importInterop","lazy","allowCommonJSExports","loose","constantReexports","assumption","enumerableModuleMeta","noIncompleteNsImportDetection","Array","isArray","every","item","Error","getAssertion","localName","template","expression","ast","moduleExportsVisitor","ReferencedIdentifier","path","node","name","localBinding","scope","getBinding","rootBinding","parentPath","isObjectProperty","value","isObjectPattern","isAssignmentExpression","left","replaceWith","UpdateExpression","arg","get","isIdentifier","t","assignmentExpression","operator","AssignmentExpression","right","sequenceExpression","isPattern","ids","getOuterBindingIdentifiers","Object","keys","find","pre","file","set","defineCommonJSHook","lazyImportsHook","visitor","types","importExpression","has","isCallExpression","isImport","callee","rename","parent","transformDynamicImport","Program","exit","state","isModule","traverse","moduleName","getModuleName","opts","stringLiteral","hooks","makeInvokers","meta","headers","rewriteModuleStatementsAndPrepareHeader","exportName","wrapReference","getWrapperPayload","esNamespaceOnly","filename","test","source","metadata","loadExpr","callExpression","identifier","header","isSideEffectImport","wrap","expressionStatement","_header","init","wrapInterop","interop","res","buildRequireWrapper","referenced","statement","loc","push","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","forEach","includes","isVariableDeclaration","registerDeclaration"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11469, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-systemjs/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t } from \"@babel/core\";\nimport type { PluginPass, NodePath, Scope, Visitor } from \"@babel/core\";\nimport {\n  buildDynamicImport,\n  getModuleName,\n  rewriteThis,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\n\nconst buildTemplate = template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\n\nconst buildExportAll = template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\n\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-transform-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-transform-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\n//todo: use getExportSpecifierName in `helper-module-transforms` when this library is refactored to NodePath usage.\n\nexport function getExportSpecifierName(\n  node: t.Node,\n  stringSpecifiers: Set<string>,\n): string {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`,\n    );\n  }\n}\n\ntype PluginState = {\n  contextIdent: string;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n};\n\ntype ModuleMetadata = {\n  key: string;\n  imports: any[];\n  exports: any[];\n};\n\nfunction constructExportCall(\n  path: NodePath<t.Program>,\n  exportIdent: t.Identifier,\n  exportNames: string[],\n  exportValues: t.Expression[],\n  exportStarTarget: t.Identifier | null,\n  stringSpecifiers: Set<string>,\n) {\n  const statements = [];\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [\n            t.stringLiteral(exportNames[0]),\n            exportValues[0],\n          ]),\n        ),\n      );\n    } else {\n      const objectProperties = [];\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(\n          t.objectProperty(\n            stringSpecifiers.has(exportName)\n              ? t.stringLiteral(exportName)\n              : t.identifier(exportName),\n            exportValue,\n          ),\n        );\n      }\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [t.objectExpression(objectProperties)]),\n        ),\n      );\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n\n    statements.push(\n      t.variableDeclaration(\"var\", [\n        t.variableDeclarator(t.identifier(exportObj), t.objectExpression([])),\n      ]),\n    );\n\n    statements.push(\n      buildExportAll({\n        KEY: path.scope.generateUidIdentifier(\"key\"),\n        EXPORT_OBJ: t.identifier(exportObj),\n        TARGET: exportStarTarget,\n      }),\n    );\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n\n      statements.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(\n              t.identifier(exportObj),\n              t.identifier(exportName),\n            ),\n            exportValue,\n          ),\n        ),\n      );\n    }\n\n    statements.push(\n      t.expressionStatement(\n        t.callExpression(exportIdent, [t.identifier(exportObj)]),\n      ),\n    );\n  }\n  return statements;\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  systemGlobal?: string;\n}\n\ntype ReassignmentVisitorState = {\n  scope: Scope;\n  exports: any;\n  buildCall: (name: string, value: t.Expression) => t.ExpressionStatement;\n};\n\nexport default declare<PluginState>((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { systemGlobal = \"System\", allowTopLevelThis = false } = options;\n  const reassignmentVisited = new WeakSet();\n\n  const reassignmentVisitor: Visitor<ReassignmentVisitorState> = {\n    \"AssignmentExpression|UpdateExpression\"(\n      path: NodePath<t.AssignmentExpression | t.UpdateExpression>,\n    ) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n\n      const arg = path.isAssignmentExpression()\n        ? path.get(\"left\")\n        : path.get(\"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs: t.SequenceExpression[\"expressions\"] = [path.node];\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n          for (const exportedName of exportedNames) {\n            exprs.push(\n              this.buildCall(exportedName, t.identifier(name)).expression,\n            );\n          }\n        }\n        path.replaceWith(t.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n\n      const name = arg.node.name;\n\n      // redeclared in this scope\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n\n      let node: t.Expression = path.node;\n\n      // if it is a non-prefix update expression (x++ etc)\n      // then we must replace with the expression (_export('x', x + 1), x++)\n      // in order to ensure the same update expression value\n      const isPostUpdateExpression = t.isUpdateExpression(node, {\n        prefix: false,\n      });\n      if (isPostUpdateExpression) {\n        node = t.binaryExpression(\n          // @ts-expect-error The operator of a post-update expression must be \"++\" | \"--\"\n          node.operator[0],\n          t.unaryExpression(\n            \"+\",\n            t.cloneNode(\n              // @ts-expect-error node is UpdateExpression\n              node.argument,\n            ),\n          ),\n          t.numericLiteral(1),\n        );\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = t.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    },\n  };\n\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      [\"CallExpression\" +\n        (api.types.importExpression ? \"|ImportExpression\" : \"\")](\n        this: PluginPass & PluginState,\n        path: NodePath<t.CallExpression | t.ImportExpression>,\n        state: PluginState,\n      ) {\n        if (path.isCallExpression() && !t.isImport(path.node.callee)) return;\n        if (path.isCallExpression()) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            if (process.env.BABEL_8_BREAKING) {\n              throw new Error(MISSING_PLUGIN_ERROR);\n            } else {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n        } else {\n          // when createImportExpressions is true, we require the dynamic import transform\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            throw new Error(MISSING_PLUGIN_ERROR);\n          }\n        }\n        path.replaceWith(\n          buildDynamicImport(path.node, false, true, specifier =>\n            t.callExpression(\n              t.memberExpression(\n                t.identifier(state.contextIdent),\n                t.identifier(\"import\"),\n              ),\n              [specifier],\n            ),\n          ),\n        );\n      },\n\n      MetaProperty(path, state: PluginState) {\n        if (\n          path.node.meta.name === \"import\" &&\n          path.node.property.name === \"meta\"\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"meta\"),\n            ),\n          );\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (\n          path.node.name === \"__moduleName\" &&\n          !path.scope.hasBinding(\"__moduleName\")\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"id\"),\n            ),\n          );\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n          if (!allowTopLevelThis) {\n            rewriteThis(path);\n          }\n        },\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const { contextIdent, stringSpecifiers } = state;\n\n          const exportMap: Record<string, string[]> = Object.create(null);\n          const modules: ModuleMetadata[] = [];\n\n          const beforeBody = [];\n          const setters: t.Expression[] = [];\n          const sources: t.StringLiteral[] = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key: string, val: string) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(\n            source: string,\n            key: \"imports\" | \"exports\",\n            specifiers: t.ModuleSpecifier[] | t.ExportAllDeclaration,\n          ) {\n            let module: ModuleMetadata;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n            if (!module) {\n              modules.push(\n                (module = { key: source, imports: [], exports: [] }),\n              );\n            }\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name: string, val: t.Expression) {\n            return t.expressionStatement(\n              t.callExpression(t.identifier(exportIdent), [\n                t.stringLiteral(name),\n                val,\n              ]),\n            );\n          }\n\n          const exportNames = [];\n          const exportValues: t.Expression[] = [];\n\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(t.cloneNode(path.node.id));\n              path.replaceWith(\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(path.node.id),\n                    t.toExpression(path.node),\n                  ),\n                ),\n              );\n            } else if (path.isVariableDeclaration()) {\n              // Convert top-level variable declarations to \"var\",\n              // because they must be hoisted\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(t.identifier(name));\n              }\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n              if (t.isClassDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (t.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                }\n                removedPaths.push(path);\n              } else {\n                // @ts-expect-error TSDeclareFunction is not expected here\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n\n              if (declar) {\n                path.replaceWith(declar);\n\n                if (t.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(t.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (t.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(declar.id));\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(declar.id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                  addExportName(name, name);\n                } else {\n                  if (t.isVariableDeclaration(declar)) {\n                    // Convert top-level variable declarations to \"var\",\n                    // because they must be hoisted\n                    declar.kind = \"var\";\n                  }\n                  for (const name of Object.keys(\n                    t.getBindingIdentifiers(declar),\n                  )) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n                if (specifiers?.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      // @ts-expect-error This isn't an \"export ... from\" declaration\n                      // because path.node.source is falsy, so the local specifier exists.\n                      const { local, exported } = specifier;\n\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(\n                        exported,\n                        stringSpecifiers,\n                      );\n                      // hoisted function export\n                      if (\n                        binding &&\n                        t.isFunctionDeclaration(binding.path.node)\n                      ) {\n                        exportNames.push(exportedName);\n                        exportValues.push(t.cloneNode(local));\n                      }\n                      // only globals also exported this way\n                      else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n                      addExportName(local.name, exportedName);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (t.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.identifier(target),\n                    ),\n                  ),\n                );\n              } else if (t.isImportDefaultSpecifier(specifier)) {\n                specifier = t.importSpecifier(\n                  specifier.local,\n                  t.identifier(\"default\"),\n                );\n              }\n\n              if (t.isImportSpecifier(specifier)) {\n                const { imported } = specifier;\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.memberExpression(\n                        t.identifier(target),\n                        specifier.imported,\n                        /* computed */ imported.type === \"StringLiteral\",\n                      ),\n                    ),\n                  ),\n                );\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (t.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (t.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(\n                    node.exported,\n                    stringSpecifiers,\n                  );\n                  exportNames.push(exportedName);\n                  exportValues.push(\n                    t.memberExpression(\n                      t.identifier(target),\n                      node.local,\n                      t.isStringLiteral(node.local),\n                    ),\n                  );\n                } else {\n                  // todo\n                }\n              }\n\n              setterBody.push(\n                ...constructExportCall(\n                  path,\n                  t.identifier(exportIdent),\n                  exportNames,\n                  exportValues,\n                  hasExportStar ? t.identifier(target) : null,\n                  stringSpecifiers,\n                ),\n              );\n            }\n\n            sources.push(t.stringLiteral(specifiers.key));\n            setters.push(\n              t.functionExpression(\n                null,\n                [t.identifier(target)],\n                t.blockStatement(setterBody),\n              ),\n            );\n          });\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.scope.hoistVariables ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").Scope.prototype.hoistVariables;\n          }\n\n          path.scope.hoistVariables((id, hasInit) => {\n            variableIds.push(id);\n            if (!hasInit && id.name in exportMap) {\n              for (const exported of exportMap[id.name]) {\n                exportNames.push(exported);\n                exportValues.push(t.buildUndefinedNode());\n              }\n            }\n          });\n\n          if (variableIds.length) {\n            beforeBody.unshift(\n              t.variableDeclaration(\n                \"var\",\n                variableIds.map(id => t.variableDeclarator(id)),\n              ),\n            );\n          }\n\n          if (exportNames.length) {\n            beforeBody.push(\n              ...constructExportCall(\n                path,\n                t.identifier(exportIdent),\n                exportNames,\n                exportValues,\n                null,\n                stringSpecifiers,\n              ),\n            );\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope,\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n            Function(path) {\n              path.skip();\n            },\n            // @ts-expect-error - todo: add noScope to type definitions\n            noScope: true,\n          });\n\n          path.node.body = [\n            buildTemplate({\n              SYSTEM_REGISTER: t.memberExpression(\n                t.identifier(systemGlobal),\n                t.identifier(\"register\"),\n              ),\n              BEFORE_BODY: beforeBody,\n              MODULE_NAME: moduleName,\n              SETTERS: t.arrayExpression(setters),\n              EXECUTE: t.functionExpression(\n                null,\n                [],\n                t.blockStatement(path.node.body),\n                false,\n                hasTLA,\n              ),\n              SOURCES: t.arrayExpression(sources),\n              EXPORT_IDENTIFIER: t.identifier(exportIdent),\n              CONTEXT_IDENTIFIER: t.identifier(contextIdent),\n            }),\n          ];\n          path.requeue(path.get(\"body.0\"));\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_helperModuleTransforms","_helperValidatorIdentifier","buildTemplate","template","statement","buildExportAll","MISSING_PLUGIN_WARNING","MISSING_PLUGIN_ERROR","getExportSpecifierName","node","stringSpecifiers","type","name","stringValue","value","isIdentifierName","add","Error","constructExportCall","path","exportIdent","exportNames","exportValues","exportStarTarget","statements","length","push","t","expressionStatement","callExpression","stringLiteral","objectProperties","i","exportName","exportValue","objectProperty","has","identifier","objectExpression","exportObj","scope","generateUid","variableDeclaration","variableDeclarator","KEY","generateUidIdentifier","EXPORT_OBJ","TARGET","assignmentExpression","memberExpression","_default","exports","default","declare","api","options","assertVersion","systemGlobal","allowTopLevelThis","reassignmentVisited","WeakSet","reassignmentVisitor","AssignmentExpression|UpdateExpression","arg","isAssignmentExpression","get","isObjectPattern","isArrayPattern","exprs","Object","keys","getBindingIdentifiers","getBinding","exportedNames","exportedName","buildCall","expression","replaceWith","sequenceExpression","isIdentifier","isPostUpdateExpression","isUpdateExpression","prefix","binaryExpression","operator","unaryExpression","cloneNode","argument","numericLiteral","pre","file","set","visitor","types","importExpression","state","isCallExpression","isImport","callee","console","warn","buildDynamicImport","specifier","contextIdent","MetaProperty","meta","property","ReferencedIdentifier","hasBinding","Program","enter","Set","rewriteThis","exit","exportMap","create","modules","beforeBody","setters","sources","variableIds","removedPaths","addExportName","key","val","pushModule","source","specifiers","module","forEach","m","imports","concat","buildExportCall","body","isFunctionDeclaration","isClassDeclaration","id","toExpression","isVariableDeclaration","kind","isImportDeclaration","removeBinding","remove","isExportAllDeclaration","isExportDefaultDeclaration","declar","declaration","buildUndefinedNode","isExportNamedDeclaration","isFunction","isClass","nodes","local","exported","binding","replaceWithMultiple","setterBody","target","isImportNamespaceSpecifier","isImportDefaultSpecifier","importSpecifier","isImportSpecifier","imported","hasExportStar","isExportSpecifier","isStringLiteral","functionExpression","blockStatement","moduleName","getModuleName","opts","_path$scope","_path$scope$hoistVari","hoistVariables","Scope","prototype","hasInit","unshift","map","traverse","hasTLA","AwaitExpression","stop","Function","skip","noScope","SYSTEM_REGISTER","BEFORE_BODY","MODULE_NAME","SETTERS","arrayExpression","EXECUTE","SOURCES","EXPORT_IDENTIFIER","CONTEXT_IDENTIFIER","requeue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11884, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 11889, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-modules-umd/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { basename, extname } from \"path\";\nimport {\n  isModule,\n  rewriteModuleStatementsAndPrepareHeader,\n  type RewriteModuleStatementsAndPrepareHeaderOptions,\n  hasExports,\n  isSideEffectImport,\n  buildNamespaceInitStatements,\n  ensureStatementsHoisted,\n  wrapInterop,\n  getModuleName,\n} from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { types as t, template, type NodePath } from \"@babel/core\";\n\nconst buildPrerequisiteAssignment = template(`\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n`);\n// Note: we avoid comparing typeof results with \"object\" or \"symbol\" otherwise\n// they will be processed by `transform-typeof-symbol`, which in return could\n// cause typeof helper used before declaration\nconst buildWrapper = template(`\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n`);\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  exactGlobals?: boolean;\n  globals?: Record<string, string>;\n  importInterop?: RewriteModuleStatementsAndPrepareHeaderOptions[\"importInterop\"];\n  loose?: boolean;\n  noInterop?: boolean;\n  strict?: boolean;\n  strictMode?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    globals,\n    exactGlobals,\n    allowTopLevelThis,\n    strict,\n    strictMode,\n    noInterop,\n    importInterop,\n  } = options;\n\n  const constantReexports =\n    api.assumption(\"constantReexports\") ?? options.loose;\n  const enumerableModuleMeta =\n    api.assumption(\"enumerableModuleMeta\") ?? options.loose;\n\n  /**\n   * Build the assignment statements that initialize the UMD global.\n   */\n  function buildBrowserInit(\n    browserGlobals: Record<string, string>,\n    exactGlobals: boolean,\n    filename: string,\n    moduleName: t.StringLiteral | void,\n  ) {\n    const moduleNameOrBasename = moduleName\n      ? moduleName.value\n      : basename(filename, extname(filename));\n    let globalToAssign = t.memberExpression(\n      t.identifier(\"global\"),\n      t.identifier(t.toIdentifier(moduleNameOrBasename)),\n    );\n    let initAssignments = [];\n\n    if (exactGlobals) {\n      const globalName = browserGlobals[moduleNameOrBasename];\n\n      if (globalName) {\n        initAssignments = [];\n\n        const members = globalName.split(\".\");\n        globalToAssign = members.slice(1).reduce(\n          (accum, curr) => {\n            initAssignments.push(\n              buildPrerequisiteAssignment({\n                GLOBAL_REFERENCE: t.cloneNode(accum),\n              }),\n            );\n            return t.memberExpression(accum, t.identifier(curr));\n          },\n          t.memberExpression(t.identifier(\"global\"), t.identifier(members[0])),\n        );\n      }\n    }\n\n    initAssignments.push(\n      t.expressionStatement(\n        t.assignmentExpression(\n          \"=\",\n          globalToAssign,\n          t.memberExpression(t.identifier(\"mod\"), t.identifier(\"exports\")),\n        ),\n      ),\n    );\n\n    return initAssignments;\n  }\n\n  /**\n   * Build the member expression that reads from a global for a given source.\n   */\n  function buildBrowserArg(\n    browserGlobals: Record<string, string>,\n    exactGlobals: boolean,\n    source: string,\n  ) {\n    let memberExpression: t.MemberExpression;\n    if (exactGlobals) {\n      const globalRef = browserGlobals[source];\n      if (globalRef) {\n        memberExpression = globalRef\n          .split(\".\")\n          .reduce(\n            (accum: t.Identifier | t.MemberExpression, curr) =>\n              t.memberExpression(accum, t.identifier(curr)),\n            t.identifier(\"global\"),\n          ) as t.MemberExpression;\n      } else {\n        memberExpression = t.memberExpression(\n          t.identifier(\"global\"),\n          t.identifier(t.toIdentifier(source)),\n        );\n      }\n    } else {\n      const requireName = basename(source, extname(source));\n      const globalName = browserGlobals[requireName] || requireName;\n      memberExpression = t.memberExpression(\n        t.identifier(\"global\"),\n        t.identifier(t.toIdentifier(globalName)),\n      );\n    }\n    return memberExpression;\n  }\n\n  return {\n    name: \"transform-modules-umd\",\n\n    visitor: {\n      Program: {\n        exit(path) {\n          if (!isModule(path)) return;\n\n          const browserGlobals = globals || {};\n\n          const moduleName = getModuleName(this.file.opts, options);\n          let moduleNameLiteral: void | t.StringLiteral;\n          if (moduleName) moduleNameLiteral = t.stringLiteral(moduleName);\n\n          const { meta, headers } = rewriteModuleStatementsAndPrepareHeader(\n            path,\n            {\n              constantReexports,\n              enumerableModuleMeta,\n              strict,\n              strictMode,\n              allowTopLevelThis,\n              noInterop,\n              importInterop,\n              filename: this.file.opts.filename,\n            },\n          );\n\n          const amdArgs = [];\n          const commonjsArgs = [];\n          const browserArgs = [];\n          const importNames = [];\n\n          if (hasExports(meta)) {\n            amdArgs.push(t.stringLiteral(\"exports\"));\n            commonjsArgs.push(t.identifier(\"exports\"));\n            browserArgs.push(\n              t.memberExpression(t.identifier(\"mod\"), t.identifier(\"exports\")),\n            );\n            importNames.push(t.identifier(meta.exportName));\n          }\n\n          for (const [source, metadata] of meta.source) {\n            amdArgs.push(t.stringLiteral(source));\n            commonjsArgs.push(\n              t.callExpression(t.identifier(\"require\"), [\n                t.stringLiteral(source),\n              ]),\n            );\n            browserArgs.push(\n              buildBrowserArg(browserGlobals, exactGlobals, source),\n            );\n            importNames.push(t.identifier(metadata.name));\n\n            if (!isSideEffectImport(metadata)) {\n              const interop = wrapInterop(\n                path,\n                t.identifier(metadata.name),\n                metadata.interop,\n              );\n              if (interop) {\n                const header = t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.identifier(metadata.name),\n                    interop,\n                  ),\n                );\n                // @ts-expect-error todo(flow->ts)\n                header.loc = meta.loc;\n                headers.push(header);\n              }\n            }\n\n            headers.push(\n              ...buildNamespaceInitStatements(\n                meta,\n                metadata,\n                constantReexports,\n              ),\n            );\n          }\n\n          ensureStatementsHoisted(headers);\n          path.unshiftContainer(\"body\", headers);\n\n          const { body, directives } = path.node;\n          path.node.directives = [];\n          path.node.body = [];\n          const umdWrapper = path.pushContainer(\"body\", [\n            buildWrapper({\n              //todo: buildWrapper does not handle void moduleNameLiteral\n              MODULE_NAME: moduleNameLiteral,\n\n              AMD_ARGUMENTS: t.arrayExpression(amdArgs),\n              COMMONJS_ARGUMENTS: commonjsArgs,\n              BROWSER_ARGUMENTS: browserArgs,\n              IMPORT_NAMES: importNames,\n\n              GLOBAL_TO_ASSIGN: buildBrowserInit(\n                browserGlobals,\n                exactGlobals,\n                this.filename || \"unknown\",\n                moduleNameLiteral,\n              ),\n            }) as t.Statement,\n          ])[0] as NodePath<t.ExpressionStatement>;\n          const umdFactory = (\n            umdWrapper.get(\"expression.arguments\")[1] as NodePath<t.Function>\n          ).get(\"body\") as NodePath<t.BlockStatement>;\n          umdFactory.pushContainer(\"directives\", directives);\n          umdFactory.pushContainer(\"body\", body);\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_path","_helperModuleTransforms","_core","buildPrerequisiteAssignment","template","buildWrapper","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","globals","exactGlobals","allowTopLevelThis","strict","strictMode","noInterop","importInterop","constantReexports","assumption","loose","enumerableModuleMeta","buildBrowserInit","browserGlobals","filename","moduleName","moduleNameOrBasename","value","basename","extname","globalToAssign","t","memberExpression","identifier","toIdentifier","initAssignments","globalName","members","split","slice","reduce","accum","curr","push","GLOBAL_REFERENCE","cloneNode","expressionStatement","assignmentExpression","buildBrowserArg","source","globalRef","requireName","name","visitor","Program","exit","path","isModule","getModuleName","file","opts","moduleNameLiteral","stringLiteral","meta","headers","rewriteModuleStatementsAndPrepareHeader","amdArgs","commonjsArgs","browserArgs","importNames","hasExports","exportName","metadata","callExpression","isSideEffectImport","interop","wrapInterop","header","loc","buildNamespaceInitStatements","ensureStatementsHoisted","unshiftContainer","body","directives","node","umdWrapper","pushContainer","MODULE_NAME","AMD_ARGUMENTS","arrayExpression","COMMONJS_ARGUMENTS","BROWSER_ARGUMENTS","IMPORT_NAMES","GLOBAL_TO_ASSIGN","umdFactory","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12032, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12037, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-named-capturing-groups-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  runtime?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  const { runtime } = options;\n  if (runtime !== undefined && typeof runtime !== \"boolean\") {\n    throw new Error(\"The 'runtime' option must be boolean\");\n  }\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-named-capturing-groups-regex\",\n    feature: \"namedCaptureGroups\",\n    options: { runtime },\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","options","runtime","undefined","Error","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMtC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAChD,MAAM,EAAEC,OAAAA,EAAS,GAAGD,OAAO;IAC3B,IAAIC,OAAO,KAAKC,SAAS,IAAI,OAAOD,OAAO,KAAK,SAAS,EAAE;QACzD,MAAM,IAAIE,KAAK,CAAC,sCAAsC,CAAC;IACzD;IAEA,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,wCAAwC;QAC9CC,OAAO,EAAE,oBAAoB;QAC7BN,OAAO,EAAE;YAAEC;QAAQ;IACrB,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 12057, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12062, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-new-target/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-new-target\",\n\n    visitor: {\n      MetaProperty(path) {\n        const meta = path.get(\"meta\");\n        const property = path.get(\"property\");\n        const { scope } = path;\n\n        if (\n          meta.isIdentifier({ name: \"new\" }) &&\n          property.isIdentifier({ name: \"target\" })\n        ) {\n          const func = path.findParent(path => {\n            if (path.isClass()) return true;\n            if (path.isFunction() && !path.isArrowFunctionExpression()) {\n              if (path.isClassMethod({ kind: \"constructor\" })) {\n                return false;\n              }\n\n              return true;\n            }\n            return false;\n          }) as NodePath<\n            | t.FunctionDeclaration\n            | t.FunctionExpression\n            | t.Class\n            | t.ClassMethod\n            | t.ClassPrivateMethod\n          >;\n\n          if (!func) {\n            throw path.buildCodeFrameError(\n              \"new.target must be under a (non-arrow) function or a class.\",\n            );\n          }\n\n          const { node } = func;\n          if (t.isMethod(node)) {\n            path.replaceWith(scope.buildUndefinedNode());\n            return;\n          }\n\n          const constructor = t.memberExpression(\n            t.thisExpression(),\n            t.identifier(\"constructor\"),\n          );\n\n          if (func.isClass()) {\n            path.replaceWith(constructor);\n            return;\n          }\n\n          if (!node.id) {\n            node.id = scope.generateUidIdentifier(\"target\");\n          } else {\n            // packages/babel-helper-create-class-features-plugin/src/fields.ts#L192 unshadow\n            let scope = path.scope;\n            const name = node.id.name;\n            while (scope !== func.parentPath.scope) {\n              if (\n                scope.hasOwnBinding(name) &&\n                !scope.bindingIdentifierEquals(name, node.id)\n              ) {\n                scope.rename(name);\n              }\n              scope = scope.parent;\n            }\n          }\n\n          path.replaceWith(\n            t.conditionalExpression(\n              t.binaryExpression(\n                \"instanceof\",\n                t.thisExpression(),\n                t.cloneNode(node.id),\n              ),\n              constructor,\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","MetaProperty","path","meta","get","property","scope","isIdentifier","func","findParent","isClass","isFunction","isArrowFunctionExpression","isClassMethod","kind","buildCodeFrameError","node","t","isMethod","replaceWith","buildUndefinedNode","constructor","memberExpression","thisExpression","identifier","id","generateUidIdentifier","parentPath","hasOwnBinding","bindingIdentifierEquals","rename","parent","conditionalExpression","binaryExpression","cloneNode"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12131, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-nullish-coalescing-operator/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, template } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, { loose = false }: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n\n  return {\n    name: \"transform-nullish-coalescing-operator\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"nullishCoalescingOperator\"),\n\n    visitor: {\n      LogicalExpression(path) {\n        const { node, scope } = path;\n        if (node.operator !== \"??\") {\n          return;\n        }\n\n        let ref;\n        let assignment;\n        // skip creating extra reference when `left` is static\n        if (scope.isStatic(node.left)) {\n          ref = node.left;\n          assignment = t.cloneNode(node.left);\n        } else if (scope.path.isPattern()) {\n          // Replace `function (a, x = a.b ?? c) {}` to `function (a, x = (() => a.b ?? c)() ){}`\n          // so the temporary variable can be injected in correct scope\n          path.replaceWith(template.statement.ast`(() => ${path.node})()`);\n          // The injected nullish expression will be queued and eventually transformed when visited\n          return;\n        } else {\n          ref = scope.generateUidIdentifierBasedOnNode(node.left);\n          scope.push({ id: t.cloneNode(ref) });\n          assignment = t.assignmentExpression(\"=\", ref, node.left);\n        }\n\n        path.replaceWith(\n          t.conditionalExpression(\n            // We cannot use `!= null` in spec mode because\n            // `document.all == null` and `document.all` is not \"nullish\".\n            noDocumentAll\n              ? t.binaryExpression(\"!=\", assignment, t.nullLiteral())\n              : t.logicalExpression(\n                  \"&&\",\n                  t.binaryExpression(\"!==\", assignment, t.nullLiteral()),\n                  t.binaryExpression(\n                    \"!==\",\n                    t.cloneNode(ref),\n                    scope.buildUndefinedNode(),\n                  ),\n                ),\n            t.cloneNode(ref),\n            node.right,\n          ),\n        );\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","loose","_api$assumption","assertVersion","noDocumentAll","assumption","name","manipulateOptions","_","parser","plugins","push","visitor","LogicalExpression","path","node","scope","operator","ref","assignment","isStatic","left","t","cloneNode","isPattern","replaceWith","template","statement","ast","generateUidIdentifierBasedOnNode","id","assignmentExpression","conditionalExpression","binaryExpression","nullLiteral","logicalExpression","buildUndefinedNode","right"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAmD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMpC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAE,EAAEC,KAAK,GAAG,KAAA,EAAgB,KAAK;IAAA,IAAAC,eAAA;IAC1DF,GAAG,CAACG,aAAa,CAAA,sCAAoB,CAAC;IACtC,MAAMC,aAAa,GAAA,CAAAF,eAAA,GAAGF,GAAG,CAACK,UAAU,CAAC,eAAe,CAAC,KAAA,OAAAH,eAAA,GAAID,KAAK;IAE9D,OAAO;QACLK,IAAI,EAAE,uCAAuC;QAC7CC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,2BAA2B,CAAC;QAEnEC,OAAO,EAAE;YACPC,iBAAiBA,EAACC,IAAI,EAAE;gBACtB,MAAM,EAAEC,IAAI,EAAEC,KAAAA,EAAO,GAAGF,IAAI;gBAC5B,IAAIC,IAAI,CAACE,QAAQ,KAAK,IAAI,EAAE;oBAC1B;gBACF;gBAEA,IAAIC,GAAG;gBACP,IAAIC,UAAU;gBAEd,IAAIH,KAAK,CAACI,QAAQ,CAACL,IAAI,CAACM,IAAI,CAAC,EAAE;oBAC7BH,GAAG,GAAGH,IAAI,CAACM,IAAI;oBACfF,UAAU,GAAGG,MAAAA,KAAC,CAACC,SAAS,CAACR,IAAI,CAACM,IAAI,CAAC;gBACrC,CAAC,MAAM,IAAIL,KAAK,CAACF,IAAI,CAACU,SAAS,CAAC,CAAC,EAAE;oBAGjCV,IAAI,CAACW,WAAW,CAACC,MAAAA,QAAQ,CAACC,SAAS,CAACC,GAAG,CAAA,OAAA,EAAUd,IAAI,CAACC,IAAI,CAAA,GAAA,CAAK,CAAC;oBAEhE;gBACF,CAAC,MAAM;oBACLG,GAAG,GAAGF,KAAK,CAACa,gCAAgC,CAACd,IAAI,CAACM,IAAI,CAAC;oBACvDL,KAAK,CAACL,IAAI,CAAC;wBAAEmB,EAAE,EAAER,MAAAA,KAAC,CAACC,SAAS,CAACL,GAAG;oBAAE,CAAC,CAAC;oBACpCC,UAAU,GAAGG,MAAAA,KAAC,CAACS,oBAAoB,CAAC,GAAG,EAAEb,GAAG,EAAEH,IAAI,CAACM,IAAI,CAAC;gBAC1D;gBAEAP,IAAI,CAACW,WAAW,CACdH,MAAAA,KAAC,CAACU,qBAAqB,CAGrB5B,aAAa,GACTkB,MAAAA,KAAC,CAACW,gBAAgB,CAAC,IAAI,EAAEd,UAAU,EAAEG,MAAAA,KAAC,CAACY,WAAW,CAAC,CAAC,CAAC,GACrDZ,MAAAA,KAAC,CAACa,iBAAiB,CACjB,IAAI,EACJb,MAAAA,KAAC,CAACW,gBAAgB,CAAC,KAAK,EAAEd,UAAU,EAAEG,MAAAA,KAAC,CAACY,WAAW,CAAC,CAAC,CAAC,EACtDZ,MAAAA,KAAC,CAACW,gBAAgB,CAChB,KAAK,EACLX,MAAAA,KAAC,CAACC,SAAS,CAACL,GAAG,CAAC,EAChBF,KAAK,CAACoB,kBAAkB,CAAC,CAC3B,CACF,CAAC,EACLd,MAAAA,KAAC,CAACC,SAAS,CAACL,GAAG,CAAC,EAChBH,IAAI,CAACsB,KACP,CACF,CAAC;YACH;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 12171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12176, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-numeric-separator/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, types as t } from \"@babel/core\";\n\n/**\n * Given a bigIntLiteral or NumericLiteral, remove numeric\n * separator `_` from its raw representation\n *\n * @param {NodePath<BigIntLiteral | NumericLiteral>} { node }: A Babel AST node path\n */\nfunction remover({ node }: NodePath<t.BigIntLiteral | t.NumericLiteral>) {\n  const { extra } = node;\n  // @ts-expect-error todo(flow->ts)\n  if (extra?.raw?.includes(\"_\")) {\n    // @ts-expect-error todo(flow->ts)\n    extra.raw = extra.raw.replace(/_/g, \"\");\n  }\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-numeric-separator\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"numericSeparator\"),\n\n    visitor: {\n      NumericLiteral: remover,\n      BigIntLiteral: remover,\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","remover","node","_extra$raw","extra","raw","includes","replace","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","_","parser","plugins","push","visitor","NumericLiteral","BigIntLiteral"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AASA,SAASC,OAAOA,CAAC,EAAEC,IAAAA,EAAoD,EAAE;IAAA,IAAAC,UAAA;IACvE,MAAM,EAAEC,KAAAA,EAAO,GAAGF,IAAI;IAEtB,IAAIE,KAAK,IAAA,QAAA,CAAAD,UAAA,GAALC,KAAK,CAAEC,GAAG,KAAA,QAAVF,UAAA,CAAYG,QAAQ,CAAC,GAAG,CAAC,EAAE;QAE7BF,KAAK,CAACC,GAAG,GAAGD,KAAK,CAACC,GAAG,CAACE,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IACzC;AACF;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEc,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,6BAA6B;QACnCC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,kBAAkB,CAAC;QAE1DC,OAAO,EAAE;YACPC,cAAc,EAAEpB,OAAO;YACvBqB,aAAa,EAAErB;QACjB;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 12200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12205, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-parameters/src/shadow-utils.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/core\";\n\ntype State = {\n  needsOuterBinding: boolean;\n  scope: Scope;\n};\n\nexport const iifeVisitor: Visitor<State> = {\n  \"ReferencedIdentifier|BindingIdentifier\"(\n    path: NodePath<t.Identifier>,\n    state,\n  ) {\n    const { scope, node } = path;\n    const { name } = node;\n\n    if (\n      name === \"eval\" ||\n      (scope.getBinding(name) === state.scope.parent.getBinding(name) &&\n        state.scope.hasOwnBinding(name))\n    ) {\n      state.needsOuterBinding = true;\n      path.stop();\n    }\n  },\n  // type annotations don't use or introduce \"real\" bindings\n  \"TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration\":\n    (path: NodePath) => path.skip(),\n};\n\nexport function collectShadowedParamsNames(\n  param: NodePath<t.Function[\"params\"][number]>,\n  functionScope: Scope,\n  shadowedParams: Set<string>,\n) {\n  for (const name of Object.keys(param.getBindingIdentifiers())) {\n    const constantViolations = functionScope.bindings[name]?.constantViolations;\n    if (constantViolations) {\n      for (const redeclarator of constantViolations) {\n        const node = redeclarator.node;\n        // If a constant violation is a var or a function declaration,\n        // we first check to see if it's a var without an init.\n        // If so, we remove that declarator.\n        // Otherwise, we have to wrap it in an IIFE.\n        switch (node.type) {\n          case \"VariableDeclarator\": {\n            if (node.init === null) {\n              const declaration = redeclarator.parentPath;\n              // The following uninitialized var declarators should not be removed\n              // for (var x in {})\n              // for (var x;;)\n              if (\n                !declaration.parentPath.isFor() ||\n                declaration.parentPath.get(\"body\") === declaration\n              ) {\n                redeclarator.remove();\n                break;\n              }\n            }\n\n            shadowedParams.add(name);\n            break;\n          }\n          case \"FunctionDeclaration\":\n            shadowedParams.add(name);\n            break;\n        }\n      }\n    }\n  }\n}\n\nexport function buildScopeIIFE(\n  shadowedParams: Set<string>,\n  body: t.BlockStatement,\n) {\n  const args = [];\n  const params = [];\n\n  for (const name of shadowedParams) {\n    // We create them twice; the other option is to use t.cloneNode\n    args.push(t.identifier(name));\n    params.push(t.identifier(name));\n  }\n\n  return t.returnStatement(\n    t.callExpression(t.arrowFunctionExpression(params, body), args),\n  );\n}\n"],"names":["_core","require","iifeVisitor","exports","ReferencedIdentifier|BindingIdentifier","path","state","scope","node","name","getBinding","parent","hasOwnBinding","needsOuterBinding","stop","skip","collectShadowedParamsNames","param","functionScope","shadowedParams","Object","keys","getBindingIdentifiers","_functionScope$bindin","constantViolations","bindings","redeclarator","type","init","declaration","parentPath","isFor","get","remove","add","buildScopeIIFE","body","args","params","push","t","identifier","returnStatement","callExpression","arrowFunctionExpression"],"mappings":";;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAQO,MAAMC,WAA2B,GAAAC,OAAA,CAAAD,WAAA,GAAG;IACzC,wCAAwCE,EACtCC,IAA4B,EAC5BC,KAAK,EACL;QACA,MAAM,EAAEC,KAAK,EAAEC,IAAAA,EAAM,GAAGH,IAAI;QAC5B,MAAM,EAAEI,IAAAA,EAAM,GAAGD,IAAI;QAErB,IACEC,IAAI,KAAK,MAAM,IACdF,KAAK,CAACG,UAAU,CAACD,IAAI,CAAC,KAAKH,KAAK,CAACC,KAAK,CAACI,MAAM,CAACD,UAAU,CAACD,IAAI,CAAC,IAC7DH,KAAK,CAACC,KAAK,CAACK,aAAa,CAACH,IAAI,CAAE,EAClC;YACAH,KAAK,CAACO,iBAAiB,GAAG,IAAI;YAC9BR,IAAI,CAACS,IAAI,CAAC,CAAC;QACb;IACF,CAAC;IAED,qFAAqF,GAClFT,IAAc,GAAKA,IAAI,CAACU,IAAI,CAAC;AAClC,CAAC;AAEM,SAASC,0BAA0BA,CACxCC,KAA6C,EAC7CC,aAAoB,EACpBC,cAA2B,EAC3B;IACA,KAAK,MAAMV,IAAI,IAAIW,MAAM,CAACC,IAAI,CAACJ,KAAK,CAACK,qBAAqB,CAAC,CAAC,CAAC,CAAE;QAAA,IAAAC,qBAAA;QAC7D,MAAMC,kBAAkB,GAAA,CAAAD,qBAAA,GAAGL,aAAa,CAACO,QAAQ,CAAChB,IAAI,CAAC,KAAA,OAAA,KAAA,IAA5Bc,qBAAA,CAA8BC,kBAAkB;QAC3E,IAAIA,kBAAkB,EAAE;YACtB,KAAK,MAAME,YAAY,IAAIF,kBAAkB,CAAE;gBAC7C,MAAMhB,IAAI,GAAGkB,YAAY,CAAClB,IAAI;gBAK9B,OAAQA,IAAI,CAACmB,IAAI;oBACf,KAAK,oBAAoB;wBAAE;4BACzB,IAAInB,IAAI,CAACoB,IAAI,KAAK,IAAI,EAAE;gCACtB,MAAMC,WAAW,GAAGH,YAAY,CAACI,UAAU;gCAI3C,IACE,CAACD,WAAW,CAACC,UAAU,CAACC,KAAK,CAAC,CAAC,IAC/BF,WAAW,CAACC,UAAU,CAACE,GAAG,CAAC,MAAM,CAAC,KAAKH,WAAW,EAClD;oCACAH,YAAY,CAACO,MAAM,CAAC,CAAC;oCACrB;gCACF;4BACF;4BAEAd,cAAc,CAACe,GAAG,CAACzB,IAAI,CAAC;4BACxB;wBACF;oBACA,KAAK,qBAAqB;wBACxBU,cAAc,CAACe,GAAG,CAACzB,IAAI,CAAC;wBACxB;gBACJ;YACF;QACF;IACF;AACF;AAEO,SAAS0B,cAAcA,CAC5BhB,cAA2B,EAC3BiB,IAAsB,EACtB;IACA,MAAMC,IAAI,GAAG,EAAE;IACf,MAAMC,MAAM,GAAG,EAAE;IAEjB,KAAK,MAAM7B,IAAI,IAAIU,cAAc,CAAE;QAEjCkB,IAAI,CAACE,IAAI,CAACC,MAAAA,KAAC,CAACC,UAAU,CAAChC,IAAI,CAAC,CAAC;QAC7B6B,MAAM,CAACC,IAAI,CAACC,MAAAA,KAAC,CAACC,UAAU,CAAChC,IAAI,CAAC,CAAC;IACjC;IAEA,OAAO+B,MAAAA,KAAC,CAACE,eAAe,CACtBF,MAAAA,KAAC,CAACG,cAAc,CAACH,MAAAA,KAAC,CAACI,uBAAuB,CAACN,MAAM,EAAEF,IAAI,CAAC,EAAEC,IAAI,CAChE,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 12261, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12266, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-parameters/src/params.ts"],"sourcesContent":["import { template, types as t, type NodePath } from \"@babel/core\";\n\nimport {\n  iifeVisitor,\n  collectShadowedParamsNames,\n  buildScopeIIFE,\n} from \"./shadow-utils.ts\";\n\nconst buildDefaultParam = template.statement(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\n\nconst buildLooseDefaultParam = template.statement(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\n\nconst buildLooseDestructuredDefaultParam = template.statement(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\n\nconst buildSafeArgumentsAccess = template.statement(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\n\n// last 2 parameters are optional -- they are used by transform-object-rest-spread/src/index.js\nexport default function convertFunctionParams(\n  path: NodePath<t.Function>,\n  ignoreFunctionLength: boolean | void,\n  shouldTransformParam?: (index: number) => boolean,\n  replaceRestElement?: (\n    path: NodePath<t.Function>,\n    paramPath: NodePath<t.Function[\"params\"][number]>,\n    transformedRestNodes: t.Statement[],\n  ) => void,\n) {\n  const params = path.get(\"params\");\n\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n\n  const { node, scope } = path;\n\n  const body = [];\n  const shadowedParams = new Set<string>();\n\n  for (const param of params) {\n    collectShadowedParamsNames(param, scope, shadowedParams);\n  }\n\n  const state = {\n    needsOuterBinding: false,\n    scope,\n  };\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n    const transformedRestNodes: t.Statement[] = [];\n    if (replaceRestElement) {\n      replaceRestElement(path, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n    if (\n      paramIsAssignmentPattern &&\n      (ignoreFunctionLength || t.isMethod(node, { kind: \"set\" }))\n    ) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(\n          buildLooseDefaultParam({\n            ASSIGNMENT_IDENTIFIER: t.cloneNode(left.node),\n            DEFAULT_VALUE: right.node,\n            UNDEFINED: undefinedNode,\n          }),\n        );\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(\n          buildLooseDestructuredDefaultParam({\n            ASSIGNMENT_IDENTIFIER: left.node,\n            DEFAULT_VALUE: right.node,\n            PARAMETER_NAME: t.cloneNode(paramName),\n            UNDEFINED: undefinedNode,\n          }),\n        );\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: t.numericLiteral(i),\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([\n        param.node,\n        t.numericLiteral(i),\n      ]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n      uid.typeAnnotation = param.node.typeAnnotation;\n\n      const defNode = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(param.node, uid),\n      ]);\n      body.push(defNode);\n\n      param.replaceWith(t.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  // we need to cut off all trailing parameters\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  // ensure it's a block, useful for arrow functions\n  path.ensureBlock();\n  const path2 = path as NodePath<typeof path.node & { body: t.BlockStatement }>;\n\n  const { async, generator } = node;\n  if (generator || state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push(buildScopeIIFE(shadowedParams, path2.node.body));\n\n    path.set(\"body\", t.blockStatement(body as t.Statement[]));\n\n    // We inject an arrow and then transform it to a normal function, to be\n    // sure that we correctly handle this and arguments.\n    const bodyPath = path2.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\n      \"argument.callee\",\n    ) as NodePath<t.ArrowFunctionExpression>;\n\n    // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n    arrowPath.arrowFunctionToExpression();\n\n    arrowPath.node.generator = generator;\n    arrowPath.node.async = async;\n\n    node.generator = false;\n    node.async = false;\n    if (async) {\n      // If the default value of a parameter throws, it must reject asynchronously.\n      path2.node.body = template.statement.ast`{\n        try {\n          ${path2.node.body.body}\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }` as t.BlockStatement;\n    }\n  } else {\n    path2.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}\n"],"names":["_core","require","_shadowUtils","buildDefaultParam","template","statement","buildLooseDefaultParam","buildLooseDestructuredDefaultParam","buildSafeArgumentsAccess","convertFunctionParams","path","ignoreFunctionLength","shouldTransformParam","replaceRestElement","params","get","isSimpleParameterList","every","param","isIdentifier","node","scope","body","shadowedParams","Set","collectShadowedParamsNames","state","needsOuterBinding","size","traverse","iifeVisitor","firstOptionalIndex","i","length","transformedRestNodes","paramIsAssignmentPattern","isAssignmentPattern","t","isMethod","kind","left","right","undefinedNode","buildUndefinedNode","push","ASSIGNMENT_IDENTIFIER","cloneNode","DEFAULT_VALUE","UNDEFINED","replaceWith","isObjectPattern","isArrayPattern","paramName","generateUidIdentifier","PARAMETER_NAME","defNode","VARIABLE_NAME","ARGUMENT_KEY","numericLiteral","uid","typeAnnotation","variableDeclaration","variableDeclarator","transformedNode","slice","ensureBlock","path2","async","generator","buildScopeIIFE","set","blockStatement","bodyPath","arrowPath","arrowFunctionToExpression","ast","unshiftContainer"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12406, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12411, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-parameters/src/rest.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/core\";\n\nimport {\n  iifeVisitor,\n  collectShadowedParamsNames,\n  buildScopeIIFE,\n} from \"./shadow-utils.ts\";\n\nconst buildRest = template.statement(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\n\nconst restIndex = template.expression(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\n\nconst restIndexImpure = template.expression(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\n\nconst restLength = template.expression(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(\n  path: NodePath<t.Identifier | t.JSXIdentifier>,\n  state: State,\n) {\n  if (path.node.name === state.name) {\n    // Check rest parameter is not shadowed by a binding in another scope.\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\ntype Candidate = {\n  cause: \"argSpread\" | \"indexGetter\" | \"lengthGetter\";\n  path: NodePath<t.Identifier | t.JSXIdentifier>;\n};\n\ntype State = {\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  offset: number;\n\n  argumentsNode: t.Identifier;\n  outerBinding: t.Identifier;\n\n  // candidate member expressions we could optimise if there are no other references\n  candidates: Candidate[];\n\n  // local rest binding name\n  name: string;\n\n  /*\n  It may be possible to optimize the output code in certain ways, such as\n  not generating code to initialize an array (perhaps substituting direct\n  references to arguments[i] or arguments.length for reads of the\n  corresponding rest parameter property) or positioning the initialization\n  code so that it may not have to execute depending on runtime conditions.\n\n  This property tracks eligibility for optimization. \"deopted\" means give up\n  and don't perform optimization. For example, when any of rest's elements /\n  properties is assigned to at the top level, or referenced at all in a\n  nested function.\n  */\n  deopted: boolean;\n  noOptimise?: boolean;\n};\n\nconst memberExpressionOptimisationVisitor: Visitor<State> = {\n  Scope(path, state) {\n    // check if this scope has a local binding that will shadow the rest parameter\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path: NodePath<t.Flow>) {\n    // Do not skip TypeCastExpressions as the contain valid non flow code\n    if (path.isTypeCastExpression()) return;\n    // don't touch reference in type annotations\n    path.skip();\n  },\n\n  Function(path, state) {\n    // Detect whether any reference to rest is contained in nested functions to\n    // determine if deopt is necessary.\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n\n    // Skip because optimizing references to rest would refer to the `arguments`\n    // of the nested function.\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const { node } = path;\n\n    // we can't guarantee the purity of arguments\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    // is this a referenced identifier and is it referencing the rest parameter?\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const { parentPath } = path;\n\n      // Is this identifier the right hand side of a default parameter?\n      if (\n        parentPath.listKey === \"params\" &&\n        (parentPath.key as number) < state.offset\n      ) {\n        return;\n      }\n\n      // ex: `args[0]`\n      // ex: `args.whatever`\n      if (parentPath.isMemberExpression({ object: node })) {\n        const grandparentPath = parentPath.parentPath;\n\n        const argsOptEligible =\n          !state.deopted &&\n          !(\n            // ex: `args[0] = \"whatever\"`\n            (\n              (grandparentPath.isAssignmentExpression() &&\n                parentPath.node === grandparentPath.node.left) ||\n              // ex: `[args[0]] = [\"whatever\"]`\n              grandparentPath.isLVal() ||\n              // ex: `for (rest[0] in this)`\n              // ex: `for (rest[0] of this)`\n              grandparentPath.isForXStatement() ||\n              // ex: `++args[0]`\n              // ex: `args[0]--`\n              grandparentPath.isUpdateExpression() ||\n              // ex: `delete args[0]`\n              grandparentPath.isUnaryExpression({ operator: \"delete\" }) ||\n              // ex: `args[0]()`\n              // ex: `new args[0]()`\n              // ex: `new args[0]`\n              ((grandparentPath.isCallExpression() ||\n                grandparentPath.isNewExpression()) &&\n                parentPath.node === grandparentPath.node.callee)\n            )\n          );\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            // if we know that this member expression is referencing a number then\n            // we can safely optimise it\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({ cause: \"indexGetter\", path });\n              return;\n            }\n          } else if (\n            // @ts-expect-error .length must not be a private name\n            parentPath.node.property.name === \"length\"\n          ) {\n            // args.length\n            state.candidates.push({ cause: \"lengthGetter\", path });\n            return;\n          }\n        }\n      }\n\n      // we can only do these optimizations if the rest variable would match\n      // the arguments exactly\n      // optimise single spread args in calls\n      // ex: fn(...args)\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({ cause: \"argSpread\", path });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  /**\n   * Deopt on use of a binding identifier with the same name as our rest param.\n   *\n   * See https://github.com/babel/babel/issues/2091\n   */\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  },\n};\n\nfunction getParamsCount(node: t.Function) {\n  let count = node.params.length;\n  // skip the first parameter if it is a TypeScript 'this parameter'\n  if (count > 0 && t.isIdentifier(node.params[0], { name: \"this\" })) {\n    count -= 1;\n  }\n  return count;\n}\n\nfunction hasRest(node: t.Function) {\n  const length = node.params.length;\n  return length > 0 && t.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(\n  path: NodePath<t.Identifier | t.JSXIdentifier>,\n  argsId: t.Identifier,\n  offset: number,\n) {\n  const offsetLiteral = t.numericLiteral(offset);\n  let index;\n  const parent = path.parent as t.MemberExpression;\n\n  if (t.isNumericLiteral(parent.property)) {\n    index = t.numericLiteral(parent.property.value + offset);\n  } else if (offset === 0) {\n    // Avoid unnecessary '+ 0'\n    index = parent.property;\n  } else {\n    index = t.binaryExpression(\n      \"+\",\n      parent.property,\n      t.cloneNode(offsetLiteral),\n    );\n  }\n\n  const { scope, parentPath } = path;\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({ id: temp, kind: \"var\" });\n    parentPath.replaceWith(\n      restIndexImpure({\n        ARGUMENTS: argsId,\n        OFFSET: offsetLiteral,\n        INDEX: index,\n        REF: t.cloneNode(temp),\n      }),\n    );\n  } else {\n    parentPath.replaceWith(\n      restIndex({\n        ARGUMENTS: argsId,\n        OFFSET: offsetLiteral,\n        INDEX: index,\n      }),\n    );\n    const replacedParentPath = parentPath as NodePath<t.ConditionalExpression>;\n\n    // See if we can statically evaluate the first test (i.e. index < offset)\n    // and optimize the AST accordingly.\n    const offsetTestPath = replacedParentPath.get(\n      \"test\",\n    ) as NodePath<t.BinaryExpression>;\n    const valRes = offsetTestPath.get(\"left\").evaluate();\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        replacedParentPath.replaceWith(scope.buildUndefinedNode());\n      } else {\n        offsetTestPath.replaceWith(offsetTestPath.get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(\n  path: NodePath<t.Identifier | t.JSXIdentifier>,\n  argsId: t.Identifier,\n  offset: number,\n) {\n  if (offset) {\n    path.parentPath.replaceWith(\n      restLength({\n        ARGUMENTS: argsId,\n        OFFSET: t.numericLiteral(offset),\n      }),\n    );\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nexport default function convertFunctionRest(path: NodePath<t.Function>) {\n  const { node, scope } = path;\n  if (!hasRest(node)) return false;\n\n  const restPath = path.get(\n    `params.${node.params.length - 1}.argument`,\n  ) as NodePath<t.ArrayPattern | t.ObjectPattern | t.Identifier>;\n\n  if (!restPath.isIdentifier()) {\n    const shadowedParams = new Set<string>();\n    collectShadowedParamsNames(restPath, path.scope, shadowedParams);\n\n    let needsIIFE = shadowedParams.size > 0;\n    if (!needsIIFE) {\n      const state = {\n        needsOuterBinding: false,\n        scope,\n      };\n      restPath.traverse(iifeVisitor, state);\n      needsIIFE = state.needsOuterBinding;\n    }\n\n    if (needsIIFE) {\n      path.ensureBlock();\n      path.set(\n        \"body\",\n        t.blockStatement([\n          buildScopeIIFE(shadowedParams, path.node.body as t.BlockStatement),\n        ]),\n      );\n    }\n  }\n\n  let rest = restPath.node;\n  node.params.pop(); // This returns 'rest'\n\n  if (t.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = t.variableDeclaration(\"let\", [\n      t.variableDeclarator(pattern, rest),\n    ]);\n    path.ensureBlock();\n    (node.body as t.BlockStatement).body.unshift(declar);\n  } else if (rest.name === \"arguments\") {\n    scope.rename(rest.name);\n  }\n\n  const argsId = t.identifier(\"arguments\");\n  const paramsCount = getParamsCount(node);\n\n  // check and optimise for extremely common cases\n  const state: State = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false,\n  };\n\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  // There are only \"shorthand\" references\n  if (!state.deopted && !state.references.length) {\n    for (const { path, cause } of state.candidates) {\n      const clonedArgsId = t.cloneNode(argsId);\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n    return true;\n  }\n\n  state.references.push(...state.candidates.map(({ path }) => path));\n\n  const start = t.numericLiteral(paramsCount);\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n\n  let arrKey, arrLen;\n  if (paramsCount) {\n    // this method has additional params, so we need to subtract\n    // the index of the current argument position from the\n    // position in the array that we want to populate\n    arrKey = t.binaryExpression(\"-\", t.cloneNode(key), t.cloneNode(start));\n\n    // we need to work out the size of the array that we're\n    // going to store all the rest parameters\n    //\n    // we need to add a check to avoid constructing the array\n    // with <0 if there are less arguments than params as it'll\n    // cause an error\n    arrLen = t.conditionalExpression(\n      t.binaryExpression(\">\", t.cloneNode(len), t.cloneNode(start)),\n      t.binaryExpression(\"-\", t.cloneNode(len), t.cloneNode(start)),\n      t.numericLiteral(0),\n    );\n  } else {\n    arrKey = t.identifier(key.name);\n    arrLen = t.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len,\n  });\n\n  if (state.deopted) {\n    (node.body as t.BlockStatement).body.unshift(loop);\n  } else {\n    let target = path\n      .getEarliestCommonAncestorFrom(state.references)\n      .getStatementParent();\n\n    // don't perform the allocation inside a loop\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        // Stop crawling up if this is a function.\n        return path.isFunction();\n      }\n    });\n\n    target.insertBefore(loop);\n  }\n\n  return true;\n}\n"],"names":["_core","require","_shadowUtils","buildRest","template","statement","restIndex","expression","restIndexImpure","restLength","referencesRest","path","state","node","name","scope","bindingIdentifierEquals","outerBinding","memberExpressionOptimisationVisitor","Scope","skip","Flow","isTypeCastExpression","Function","oldNoOptimise","noOptimise","traverse","ReferencedIdentifier","deopted","parentPath","listKey","key","offset","isMemberExpression","object","grandparentPath","argsOptEligible","isAssignmentExpression","left","isLVal","isForXStatement","isUpdateExpression","isUnaryExpression","operator","isCallExpression","isNewExpression","callee","computed","get","isBaseType","candidates","push","cause","property","isSpreadElement","call","arguments","length","references","BindingIdentifier","getParamsCount","count","params","t","isIdentifier","hasRest","isRestElement","optimiseIndexGetter","argsId","offsetLiteral","numericLiteral","index","parent","isNumericLiteral","value","binaryExpression","cloneNode","isPure","temp","generateUidIdentifierBasedOnNode","id","kind","replaceWith","ARGUMENTS","OFFSET","INDEX","REF","replacedParentPath","offsetTestPath","valRes","evaluate","confident","buildUndefinedNode","optimiseLengthGetter","convertFunctionRest","restPath","shadowedParams","Set","collectShadowedParamsNames","needsIIFE","size","needsOuterBinding","iifeVisitor","ensureBlock","set","blockStatement","buildScopeIIFE","body","rest","pop","isPattern","pattern","generateUidIdentifier","declar","variableDeclaration","variableDeclarator","unshift","rename","identifier","paramsCount","argumentsNode","getBindingIdentifier","clonedArgsId","map","start","len","arrKey","arrLen","conditionalExpression","loop","ARRAY_KEY","ARRAY_LEN","START","ARRAY","KEY","LEN","target","getEarliestCommonAncestorFrom","getStatementParent","findParent","isLoop","isFunction","insertBefore"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 12681, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12686, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-parameters/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport convertFunctionParams from \"./params.ts\";\nimport convertFunctionRest from \"./rest.ts\";\nexport { convertFunctionParams };\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const ignoreFunctionLength =\n    api.assumption(\"ignoreFunctionLength\") ?? options.loose;\n  // Todo(BABEL 8): Consider default it to false\n  const noNewArrows = api.assumption(\"noNewArrows\") ?? true;\n\n  return {\n    name: \"transform-parameters\",\n\n    visitor: {\n      Function(path) {\n        if (\n          path.isArrowFunctionExpression() &&\n          path\n            .get(\"params\")\n            .some(param => param.isRestElement() || param.isAssignmentPattern())\n        ) {\n          // default/rest visitors require access to `arguments`, so it cannot be an arrow\n          path.arrowFunctionToExpression({\n            allowInsertArrowWithRest: false,\n            noNewArrows,\n          });\n\n          // In some cases arrowFunctionToExpression replaces the function with a wrapper.\n          // Return early; the wrapped function will be visited later in the AST traversal.\n          if (!path.isFunctionExpression()) return;\n        }\n\n        const convertedRest = convertFunctionRest(path);\n        const convertedParams = convertFunctionParams(\n          path,\n          ignoreFunctionLength,\n        );\n\n        if (convertedRest || convertedParams) {\n          // Manually reprocess this scope to ensure that the moved params are updated.\n          path.scope.crawl();\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_params","_rest","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","ignoreFunctionLength","assumption","loose","noNewArrows","name","visitor","Function","path","isArrowFunctionExpression","get","some","param","isRestElement","isAssignmentPattern","arrowFunctionToExpression","allowInsertArrowWithRest","isFunctionExpression","convertedRest","convertFunctionRest","convertedParams","convertFunctionParams","scope","crawl"],"mappings":";;;;;;;;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAA4C,IAAAG,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAO7B,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAAA,IAAAC,eAAA,EAAAC,gBAAA;IAChDH,GAAG,CAACI,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAMC,oBAAoB,GAAA,CAAAH,eAAA,GACxBF,GAAG,CAACM,UAAU,CAAC,sBAAsB,CAAC,KAAA,OAAAJ,eAAA,GAAID,OAAO,CAACM,KAAK;IAEzD,MAAMC,WAAW,GAAA,CAAAL,gBAAA,GAAGH,GAAG,CAACM,UAAU,CAAC,aAAa,CAAC,KAAA,OAAAH,gBAAA,GAAI,IAAI;IAEzD,OAAO;QACLM,IAAI,EAAE,sBAAsB;QAE5BC,OAAO,EAAE;YACPC,QAAQA,EAACC,IAAI,EAAE;gBACb,IACEA,IAAI,CAACC,yBAAyB,CAAC,CAAC,IAChCD,IAAI,CACDE,GAAG,CAAC,QAAQ,CAAC,CACbC,IAAI,EAACC,KAAK,GAAIA,KAAK,CAACC,aAAa,CAAC,CAAC,IAAID,KAAK,CAACE,mBAAmB,CAAC,CAAC,CAAC,EACtE;oBAEAN,IAAI,CAACO,yBAAyB,CAAC;wBAC7BC,wBAAwB,EAAE,KAAK;wBAC/BZ;oBACF,CAAC,CAAC;oBAIF,IAAI,CAACI,IAAI,CAACS,oBAAoB,CAAC,CAAC,EAAE;gBACpC;gBAEA,MAAMC,aAAa,GAAG,CAAA,GAAAC,MAAAA,OAAmB,EAACX,IAAI,CAAC;gBAC/C,MAAMY,eAAe,GAAG,CAAA,GAAAC,QAAAA,OAAqB,EAC3Cb,IAAI,EACJP,oBACF,CAAC;gBAED,IAAIiB,aAAa,IAAIE,eAAe,EAAE;oBAEpCZ,IAAI,CAACc,KAAK,CAACC,KAAK,CAAC,CAAC;gBACpB;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 12725, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 12730, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-object-rest-spread/src/shouldStoreRHSInTemporaryVariable.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-object-rest-spread/src/compat-data.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-object-rest-spread/src/index.ts"],"sourcesContent":["import type { types as t } from \"@babel/core\";\n\n/**\n * This is a helper function to determine if we should create an intermediate variable\n * such that the RHS of an assignment is not duplicated.\n *\n * See https://github.com/babel/babel/pull/13711#issuecomment-914388382 for discussion\n * on further optimizations.\n */\nexport default function shouldStoreRHSInTemporaryVariable(\n  node: t.LVal,\n): boolean {\n  if (!node) return false;\n  if (node.type === \"ArrayPattern\") {\n    const nonNullElements = node.elements.filter(element => element !== null);\n    if (nonNullElements.length > 1) return true;\n    else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (node.type === \"ObjectPattern\") {\n    const { properties } = node;\n    if (properties.length > 1) return true;\n    else if (properties.length === 0) return false;\n    else {\n      const firstProperty = properties[0];\n      if (firstProperty.type === \"ObjectProperty\") {\n        // the value of the property must be an LVal\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value as t.LVal);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (node.type === \"AssignmentPattern\") {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (node.type === \"RestElement\") {\n    if (node.argument.type === \"Identifier\") return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    // node is Identifier or MemberExpression\n    return false;\n  }\n}\n","export default {\n  \"Object.assign\": {\n    chrome: \"49\",\n    opera: \"36\",\n    edge: \"13\",\n    firefox: \"36\",\n    safari: \"10\",\n    node: \"6\",\n    deno: \"1\",\n    ios: \"10\",\n    samsung: \"5\",\n    opera_mobile: \"36\",\n    electron: \"0.37\",\n  },\n};\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass, NodePath, Scope } from \"@babel/core\";\nimport { convertFunctionParams } from \"@babel/plugin-transform-parameters\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport shouldStoreRHSInTemporaryVariable from \"./shouldStoreRHSInTemporaryVariable.ts\";\nimport compatData from \"./compat-data.ts\";\n\nconst { isAssignmentPattern, isObjectProperty } = t;\n// @babel/types <=7.3.3 counts FOO as referenced in var { x: FOO }.\n// We need to detect this bug to know if \"unused\" means 0 or 1 references.\nif (!process.env.BABEL_8_BREAKING) {\n  const node = t.identifier(\"a\");\n  const property = t.objectProperty(t.identifier(\"key\"), node);\n  const pattern = t.objectPattern([property]);\n\n  // eslint-disable-next-line no-var\n  var ZERO_REFS = t.isReferenced(node, property, pattern) ? 1 : 0;\n}\n\ntype Param = NodePath<t.Function[\"params\"][number]>;\nexport interface Options {\n  useBuiltIns?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const targets = api.targets();\n  const supportsObjectAssign = !isRequired(\"Object.assign\", targets, {\n    compatData,\n  });\n\n  const { useBuiltIns = supportsObjectAssign, loose = false } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? loose;\n  const objectRestNoSymbols = api.assumption(\"objectRestNoSymbols\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n  const setSpreadProperties = api.assumption(\"setSpreadProperties\") ?? loose;\n\n  function getExtendsHelper(\n    file: PluginPass,\n  ): t.MemberExpression | t.Identifier {\n    return useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path: Param) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path: NodePath): boolean {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(\n    path: NodePath,\n    visitor: (path: NodePath<t.RestElement>) => any,\n  ) {\n    path.traverse({\n      Expression(path) {\n        const { parent, key } = path;\n        if (\n          (isAssignmentPattern(parent) && key === \"right\") ||\n          (isObjectProperty(parent) && parent.computed && key === \"key\")\n        ) {\n          path.skip();\n        }\n      },\n      RestElement: visitor,\n    });\n  }\n\n  function hasSpread(node: t.ObjectExpression): boolean {\n    for (const prop of node.properties) {\n      if (t.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // returns an array of all keys of an object, and a status flag indicating if all extracted keys\n  // were converted to stringLiterals or not\n  // e.g. extracts {keys: [\"a\", \"b\", \"3\", ++x], allPrimitives: false }\n  // from ast of {a: \"foo\", b, 3: \"bar\", [++x]: \"baz\"}\n  // `allPrimitives: false` doesn't necessarily mean that there is a non-primitive, but just\n  // that we are not sure.\n  function extractNormalizedKeys(node: t.ObjectPattern) {\n    // RestElement has been removed in createObjectRest\n    const props = node.properties as t.ObjectProperty[];\n    const keys: t.Expression[] = [];\n    let allPrimitives = true;\n    let hasTemplateLiteral = false;\n\n    for (const prop of props) {\n      const { key } = prop;\n      if (t.isIdentifier(key) && !prop.computed) {\n        // since a key {a: 3} is equivalent to {\"a\": 3}, use the latter\n        keys.push(t.stringLiteral(key.name));\n      } else if (t.isTemplateLiteral(key)) {\n        keys.push(t.cloneNode(key));\n        hasTemplateLiteral = true;\n      } else if (t.isLiteral(key)) {\n        keys.push(\n          t.stringLiteral(\n            String(\n              // @ts-expect-error prop.key can not be a NullLiteral\n              key.value,\n            ),\n          ),\n        );\n      } else {\n        // @ts-expect-error private name has been handled by destructuring-private\n        keys.push(t.cloneNode(key));\n\n        if (\n          (t.isMemberExpression(key, { computed: false }) &&\n            t.isIdentifier(key.object, { name: \"Symbol\" })) ||\n          (t.isCallExpression(key) &&\n            t.matchesPattern(key.callee, \"Symbol.for\"))\n        ) {\n          // there all return a primitive\n        } else {\n          allPrimitives = false;\n        }\n      }\n    }\n\n    return { keys, allPrimitives, hasTemplateLiteral };\n  }\n\n  // replaces impure computed keys with new identifiers\n  // and returns variable declarators of these new identifiers\n  function replaceImpureComputedKeys(\n    properties: NodePath<t.ObjectProperty>[],\n    scope: Scope,\n  ) {\n    const impureComputedPropertyDeclarators: t.VariableDeclarator[] = [];\n    for (const propPath of properties) {\n      // PrivateName is handled in destructuring-private plugin\n      const key = propPath.get(\"key\") as NodePath<t.Expression>;\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n        const declarator = t.variableDeclarator(t.identifier(name), key.node);\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(t.identifier(name));\n      }\n    }\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path: NodePath<t.ObjectPattern>): void {\n    const bindings = path.getOuterBindingIdentifierPaths();\n\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (\n        path.scope.getBinding(bindingName).references >\n          (process.env.BABEL_8_BREAKING ? 0 : ZERO_REFS) ||\n        !bindingParentPath.isObjectProperty()\n      ) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n\n  //expects path to an object pattern\n  function createObjectRest(\n    path: NodePath<t.ObjectPattern>,\n    file: PluginPass,\n    objRef: t.Identifier | t.MemberExpression,\n  ): [\n    t.VariableDeclarator[],\n    t.AssignmentExpression[\"left\"],\n    t.CallExpression,\n  ] {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    t.assertRestElement(last.node);\n    const restElement = t.cloneNode(last.node);\n    last.remove();\n\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(\n      path.get(\"properties\") as NodePath<t.ObjectProperty>[],\n      path.scope,\n    );\n    const { keys, allPrimitives, hasTemplateLiteral } = extractNormalizedKeys(\n      path.node,\n    );\n\n    if (keys.length === 0) {\n      return [\n        impureComputedPropertyDeclarators,\n        restElement.argument,\n        t.callExpression(getExtendsHelper(file), [\n          t.objectExpression([]),\n          t.sequenceExpression([\n            t.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [\n              t.cloneNode(objRef),\n            ]),\n            t.cloneNode(objRef),\n          ]),\n        ]),\n      ];\n    }\n\n    let keyExpression;\n    if (!allPrimitives) {\n      // map to toPropertyKey to handle the possible non-string values\n      keyExpression = t.callExpression(\n        t.memberExpression(t.arrayExpression(keys), t.identifier(\"map\")),\n        [file.addHelper(\"toPropertyKey\")],\n      );\n    } else {\n      keyExpression = t.arrayExpression(keys);\n\n      if (!hasTemplateLiteral && !t.isProgram(path.scope.block)) {\n        // Hoist definition of excluded keys, so that it's not created each time.\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\",\n        });\n\n        keyExpression = t.cloneNode(id);\n      }\n    }\n\n    return [\n      impureComputedPropertyDeclarators,\n      restElement.argument,\n      t.callExpression(\n        file.addHelper(\n          `objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`,\n        ),\n        [t.cloneNode(objRef), keyExpression],\n      ),\n    ];\n  }\n\n  function replaceRestElement(\n    parentPath: NodePath<t.Function | t.CatchClause>,\n    paramPath: NodePath<\n      t.Function[\"params\"][number] | t.AssignmentPattern[\"left\"]\n    >,\n    container?: t.VariableDeclaration[],\n  ): void {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(paramPath.node, uid),\n      ]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        (parentPath.get(\"body\") as NodePath<t.BlockStatement>).unshiftContainer(\n          \"body\",\n          declar,\n        );\n      }\n      paramPath.replaceWith(t.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"transform-object-rest-spread\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"objectRestSpread\"),\n\n    visitor: {\n      // function a({ b, ...c }) {}\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set<number>();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        // if true, a parameter exists that has an id in its initializer\n        // that is also an id bound in a rest parameter\n        // example: f({...R}, a = R)\n        let idInRest = false;\n\n        const IdentifierHandler = function (\n          path: NodePath<t.Identifier>,\n          functionScope: Scope,\n        ) {\n          const name = path.node.name;\n          if (\n            path.scope.getBinding(name) === functionScope.getBinding(name) &&\n            idsInRestParams.has(name)\n          ) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i: number;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse(\n                {\n                  \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                  \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler,\n                },\n                path.scope,\n              );\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = (idx: number) =>\n            idx >= i - 1 || paramsWithRestElement.has(idx);\n          convertFunctionParams(\n            path,\n            ignoreFunctionLength,\n            shouldTransformParam,\n            replaceRestElement,\n          );\n        }\n      },\n\n      // adapted from transform-destructuring/src/index.js#pushObjectRest\n      // const { a, ...b } = c;\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          if (\n            // skip single-property case, e.g.\n            // const { ...x } = foo();\n            // since the RHS will not be duplicated\n            shouldStoreRHSInTemporaryVariable(originalPath.node.id) &&\n            !t.isIdentifier(originalPath.node.init)\n          ) {\n            // const { a, ...b } = foo();\n            // to avoid calling foo() twice, as a first step convert it to:\n            // const _foo = foo(),\n            //       { a, ...b } = _foo;\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(\n              originalPath.node.init,\n              \"ref\",\n            );\n            // insert _foo = foo()\n            originalPath.insertBefore(\n              t.variableDeclarator(initRef, originalPath.node.init),\n            );\n            // replace foo() with _foo\n            originalPath.replaceWith(\n              t.variableDeclarator(originalPath.node.id, t.cloneNode(initRef)),\n            );\n\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath: NodePath<t.ObjectProperty>[] = [];\n          let kind;\n\n          path.findParent((path: NodePath): boolean => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(\n            refPropertyPath,\n            path.scope,\n          );\n          refPropertyPath.forEach(prop => {\n            const { node } = prop;\n            ref = t.memberExpression(\n              ref,\n              t.cloneNode(node.key),\n              node.computed || t.isLiteral(node.key),\n            );\n          });\n\n          //@ts-expect-error: findParent can not apply assertions on result shape\n          const objectPatternPath: NodePath<t.ObjectPattern> = path.findParent(\n            path => path.isObjectPattern(),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(\n              objectPatternPath,\n              file,\n              ref as t.MemberExpression,\n            );\n\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          t.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n\n          insertionPath = insertionPath.insertAfter(\n            t.variableDeclarator(argument, callExpression),\n          )[0] as NodePath<t.VariableDeclarator>;\n\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath\n              .findParent(\n                path => path.isObjectProperty() || path.isVariableDeclarator(),\n              )\n              .remove();\n          }\n        });\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      // export var { a, ...b } = c;\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n\n        const hasRest = declaration\n          .get(\"declarations\")\n          .some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(true))) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n\n      // try {} catch ({a, ...b}) {}\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n\n      // ({a, ...b} = c);\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n\n          const refName = path.scope.generateUidBasedOnNode(\n            path.node.right,\n            \"ref\",\n          );\n\n          nodes.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(t.identifier(refName), path.node.right),\n            ]),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(leftPath, file, t.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(\n              t.variableDeclaration(\"var\", impureComputedPropertyDeclarators),\n            );\n          }\n\n          const nodeWithoutSpread = t.cloneNode(path.node);\n          nodeWithoutSpread.right = t.identifier(refName);\n          nodes.push(t.expressionStatement(nodeWithoutSpread));\n          nodes.push(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", argument, callExpression),\n            ),\n          );\n          nodes.push(t.expressionStatement(t.identifier(refName)));\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) {\n          // for ({a, ...b} of []) {}\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const body = path.node.body as t.BlockStatement;\n\n          if (body.body.length === 0 && path.isCompletionRecord()) {\n            body.body.unshift(\n              t.expressionStatement(scope.buildUndefinedNode()),\n            );\n          }\n\n          body.body.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n        } else {\n          // for (var {a, ...b} of []) {}\n          const pattern = left.declarations[0].id;\n\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = t.variableDeclaration(left.kind, [\n            t.variableDeclarator(key, null),\n          ]);\n\n          path.ensureBlock();\n          const body = node.body as t.BlockStatement;\n\n          body.body.unshift(\n            t.variableDeclaration(node.left.kind, [\n              t.variableDeclarator(pattern, t.cloneNode(key)),\n            ]),\n          );\n        }\n      },\n\n      // [{a, ...b}] = c;\n      ArrayPattern(path) {\n        const objectPatterns: t.VariableDeclarator[] = [];\n\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(t.variableDeclarator(objectPattern.node, uid));\n\n          objectPattern.replaceWith(t.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          const statementNode = statementPath.node;\n          const kind =\n            statementNode.type === \"VariableDeclaration\"\n              ? statementNode.kind\n              : \"var\";\n          statementPath.insertAfter(\n            t.variableDeclaration(kind, objectPatterns),\n          );\n        }\n      },\n\n      // var a = { ...b, ...c }\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n\n        let helper: t.Identifier | t.MemberExpression;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          if (process.env.BABEL_8_BREAKING) {\n            helper = file.addHelper(\"objectSpread2\");\n          } else {\n            try {\n              helper = file.addHelper(\"objectSpread2\");\n            } catch {\n              // TODO: This is needed to workaround https://github.com/babel/babel/issues/10187\n              // and https://github.com/babel/babel/issues/10179 for older @babel/core versions\n              // where #10187 isn't fixed.\n              this.file.declarations[\"objectSpread2\"] = null;\n\n              // objectSpread2 has been introduced in v7.5.0\n              // We have to maintain backward compatibility.\n              helper = file.addHelper(\"objectSpread\");\n            }\n          }\n        }\n\n        let exp: t.CallExpression = null;\n        let props: t.ObjectMember[] = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = t.objectExpression(props);\n          props = [];\n\n          if (!exp) {\n            exp = t.callExpression(helper, [obj]);\n            return;\n          }\n\n          // When we can assume that getters are pure and don't depend on\n          // the order of evaluation, we can avoid making multiple calls.\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n\n          exp = t.callExpression(t.cloneNode(helper), [\n            exp,\n            // If we have static props, we need to insert an empty object\n            // because the odd arguments are copied with [[Get]], not\n            // [[GetOwnProperty]]\n            ...(hadProps ? [t.objectExpression([]), obj] : []),\n          ]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (t.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n\n        path.replaceWith(exp);\n      },\n    },\n  };\n});\n"],"names":["shouldStoreRHSInTemporaryVariable","node","type","nonNullElements","elements","filter","element","length","properties","firstProperty","value","left","argument","chrome","opera","edge","firefox","safari","deno","ios","samsung","opera_mobile","electron","isAssignmentPattern","isObjectProperty","t","identifier","property","objectProperty","pattern","objectPattern","ZERO_REFS","isReferenced","declare","api","opts","_api$assumption","_api$assumption2","_api$assumption3","_api$assumption4","assertVersion","targets","supportsObjectAssign","isRequired","compatData","useBuiltIns","loose","Error","ignoreFunctionLength","assumption","objectRestNoSymbols","pureGetters","setSpreadProperties","getExtendsHelper","file","memberExpression","addHelper","hasRestElement","path","foundRestElement","visitRestElements","restElement","stop","hasObjectPatternRestElement","parentPath","isObjectPattern","visitor","traverse","Expression","parent","key","computed","skip","RestElement","hasSpread","prop","isSpreadElement","extractNormalizedKeys","props","keys","allPrimitives","hasTemplateLiteral","isIdentifier","push","stringLiteral","name","isTemplateLiteral","cloneNode","isLiteral","String","isMemberExpression","object","isCallExpression","matchesPattern","callee","replaceImpureComputedKeys","scope","impureComputedPropertyDeclarators","propPath","get","isPure","generateUidBasedOnNode","declarator","variableDeclarator","replaceWith","removeUnusedExcludedKeys","bindings","getOuterBindingIdentifierPaths","Object","forEach","bindingName","bindingParentPath","getBinding","references","remove","createObjectRest","objRef","last","assertRestElement","callExpression","objectExpression","sequenceExpression","keyExpression","arrayExpression","isProgram","block","program","findParent","id","generateUidIdentifier","init","kind","replaceRestElement","paramPath","container","isArrayPattern","i","uid","declar","variableDeclaration","ensureBlock","unshiftContainer","manipulateOptions","_","parser","plugins","Function","params","paramsWithRestElement","Set","idsInRestParams","param","add","getBindingIdentifiers","idInRest","IdentifierHandler","functionScope","has","isReferencedIdentifier","isBindingIdentifier","shouldTransformParam","idx","convertFunctionParams","VariableDeclarator","insertionPath","originalPath","initRef","generateUidIdentifierBasedOnNode","insertBefore","ref","refPropertyPath","unshift","isVariableDeclarator","impureObjRefComputedDeclarators","objectPatternPath","assertIdentifier","insertAfter","registerBinding","ExportNamedDeclaration","declaration","isVariableDeclaration","hasRest","some","specifiers","getOuterBindingIdentifiers","exportSpecifier","exportNamedDeclaration","CatchClause","AssignmentExpression","leftPath","nodes","refName","right","nodeWithoutSpread","expressionStatement","assignmentExpression","replaceWithMultiple","ForXStatement","temp","body","isCompletionRecord","buildUndefinedNode","declarations","ArrayPattern","objectPatterns","statementPath","getStatementParent","statementNode","ObjectExpression","helper","_unused","exp","make","hadProps","obj","arguments"],"mappings":";;;;;;;;AASe,SAASA,iCAAiCA,CACvDC,IAAY,EACH;IACT,IAAI,CAACA,IAAI,EAAE,OAAO,KAAK,CAAA;IACvB,IAAIA,IAAI,CAACC,IAAI,KAAK,cAAc,EAAE;QAChC,MAAMC,eAAe,GAAGF,IAAI,CAACG,QAAQ,CAACC,MAAM,EAACC,OAAO,GAAIA,OAAO,KAAK,IAAI,CAAC,CAAA;QACzE,IAAIH,eAAe,CAACI,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI,CAAC;aACvC,OAAOP,iCAAiC,CAACG,eAAe,CAAC,CAAC,CAAC,CAAC,CAAA;IACnE,CAAC,MAAM,IAAIF,IAAI,CAACC,IAAI,KAAK,eAAe,EAAE;QACxC,MAAM,EAAEM,UAAAA,EAAY,GAAGP,IAAI,CAAA;QAC3B,IAAIO,UAAU,CAACD,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI,CAAC;aAClC,IAAIC,UAAU,CAACD,MAAM,KAAK,CAAC,EAAE,OAAO,KAAK,CAAC;aAC1C;YACH,MAAME,aAAa,GAAGD,UAAU,CAAC,CAAC,CAAC,CAAA;YACnC,IAAIC,aAAa,CAACP,IAAI,KAAK,gBAAgB,EAAE;gBAE3C,OAAOF,iCAAiC,CAACS,aAAa,CAACC,KAAe,CAAC,CAAA;YACzE,CAAC,MAAM;gBACL,OAAOV,iCAAiC,CAACS,aAAa,CAAC,CAAA;YACzD,CAAA;QACF,CAAA;IACF,CAAC,MAAM,IAAIR,IAAI,CAACC,IAAI,KAAK,mBAAmB,EAAE;QAC5C,OAAOF,iCAAiC,CAACC,IAAI,CAACU,IAAI,CAAC,CAAA;IACrD,CAAC,MAAM,IAAIV,IAAI,CAACC,IAAI,KAAK,aAAa,EAAE;QACtC,IAAID,IAAI,CAACW,QAAQ,CAACV,IAAI,KAAK,YAAY,EAAE,OAAO,IAAI,CAAA;QACpD,OAAOF,iCAAiC,CAACC,IAAI,CAACW,QAAQ,CAAC,CAAA;IACzD,CAAC,MAAM;QAEL,OAAO,KAAK,CAAA;IACd,CAAA;AACF;ACvCA,IAAA,aAAe;IACb,eAAe,EAAE;QACfC,MAAM,EAAE,IAAI;QACZC,KAAK,EAAE,IAAI;QACXC,IAAI,EAAE,IAAI;QACVC,OAAO,EAAE,IAAI;QACbC,MAAM,EAAE,IAAI;QACZhB,IAAI,EAAE,GAAG;QACTiB,IAAI,EAAE,GAAG;QACTC,GAAG,EAAE,IAAI;QACTC,OAAO,EAAE,GAAG;QACZC,YAAY,EAAE,IAAI;QAClBC,QAAQ,EAAE,MAAA;IACZ,CAAA;AACF,CAAC;ACND,MAAM,EAAEC,mBAAmB,EAAEC,gBAAAA,EAAkB,GAAGC,KAAAA,KAAC,CAAA;AAGhB;IACjC,MAAMxB,IAAI,GAAGwB,KAAAA,KAAC,CAACC,UAAU,CAAC,GAAG,CAAC,CAAA;IAC9B,MAAMC,QAAQ,GAAGF,KAAAA,KAAC,CAACG,cAAc,CAACH,KAAAA,KAAC,CAACC,UAAU,CAAC,KAAK,CAAC,EAAEzB,IAAI,CAAC,CAAA;IAC5D,MAAM4B,OAAO,GAAGJ,KAAAA,KAAC,CAACK,aAAa,CAAC;QAACH,QAAQ;KAAC,CAAC,CAAA;IAG3C,IAAII,SAAS,GAAGN,KAAAA,KAAC,CAACO,YAAY,CAAC/B,IAAI,EAAE0B,QAAQ,EAAEE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AACjE,CAAA,AAQA,IAAA,QAAeI,kBAAAA,OAAO,CAAC,CAACC,GAAG,EAAEC,IAAa,KAAK;IAAA,IAAAC,eAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,gBAAA,CAAA;IAC7CL,GAAG,CAACM,aAAa,CAAA,sCAAoB,CAAC,CAAA;IAEtC,MAAMC,OAAO,GAAGP,GAAG,CAACO,OAAO,EAAE,CAAA;IAC7B,MAAMC,oBAAoB,GAAG,CAACC,yBAAAA,UAAU,CAAC,eAAe,EAAEF,OAAO,EAAE;QACjEG,UAAAA;IACF,CAAC,CAAC,CAAA;IAEF,MAAM,EAAEC,WAAW,GAAGH,oBAAoB,EAAEI,KAAK,GAAG,KAAA,EAAO,GAAGX,IAAI,CAAA;IAElE,IAAI,OAAOW,KAAK,KAAK,SAAS,EAAE;QAC9B,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC,CAAA;IAC3D,CAAA;IAEA,MAAMC,oBAAoB,GAAA,CAAAZ,eAAA,GAAGF,GAAG,CAACe,UAAU,CAAC,sBAAsB,CAAC,KAAAb,IAAAA,GAAAA,eAAA,GAAIU,KAAK,CAAA;IAC5E,MAAMI,mBAAmB,GAAA,CAAAb,gBAAA,GAAGH,GAAG,CAACe,UAAU,CAAC,qBAAqB,CAAC,KAAAZ,IAAAA,GAAAA,gBAAA,GAAIS,KAAK,CAAA;IAC1E,MAAMK,WAAW,GAAA,CAAAb,gBAAA,GAAGJ,GAAG,CAACe,UAAU,CAAC,aAAa,CAAC,KAAAX,IAAAA,GAAAA,gBAAA,GAAIQ,KAAK,CAAA;IAC1D,MAAMM,mBAAmB,GAAA,CAAAb,gBAAA,GAAGL,GAAG,CAACe,UAAU,CAAC,qBAAqB,CAAC,KAAAV,IAAAA,GAAAA,gBAAA,GAAIO,KAAK,CAAA;IAE1E,SAASO,gBAAgBA,CACvBC,IAAgB,EACmB;QACnC,OAAOT,WAAW,GACdpB,KAAAA,KAAC,CAAC8B,gBAAgB,CAAC9B,KAAAA,KAAC,CAACC,UAAU,CAAC,QAAQ,CAAC,EAAED,KAAAA,KAAC,CAACC,UAAU,CAAC,QAAQ,CAAC,CAAC,GAClE4B,IAAI,CAACE,SAAS,CAAC,SAAS,CAAC,CAAA;IAC/B,CAAA;IAEA,SAASC,cAAcA,CAACC,IAAW,EAAE;QACnC,IAAIC,gBAAgB,GAAG,KAAK,CAAA;QAC5BC,iBAAiB,CAACF,IAAI,GAAEG,WAAW,IAAI;YACrCF,gBAAgB,GAAG,IAAI,CAAA;YACvBE,WAAW,CAACC,IAAI,EAAE,CAAA;QACpB,CAAC,CAAC,CAAA;QACF,OAAOH,gBAAgB,CAAA;IACzB,CAAA;IAEA,SAASI,2BAA2BA,CAACL,IAAc,EAAW;QAC5D,IAAIC,gBAAgB,GAAG,KAAK,CAAA;QAC5BC,iBAAiB,CAACF,IAAI,GAAEG,WAAW,IAAI;YACrC,IAAIA,WAAW,CAACG,UAAU,CAACC,eAAe,EAAE,EAAE;gBAC5CN,gBAAgB,GAAG,IAAI,CAAA;gBACvBE,WAAW,CAACC,IAAI,EAAE,CAAA;YACpB,CAAA;QACF,CAAC,CAAC,CAAA;QACF,OAAOH,gBAAgB,CAAA;IACzB,CAAA;IAEA,SAASC,iBAAiBA,CACxBF,IAAc,EACdQ,OAA+C,EAC/C;QACAR,IAAI,CAACS,QAAQ,CAAC;YACZC,UAAUA,EAACV,IAAI,EAAE;gBACf,MAAM,EAAEW,MAAM,EAAEC,GAAAA,EAAK,GAAGZ,IAAI,CAAA;gBAC5B,IACGnC,mBAAmB,CAAC8C,MAAM,CAAC,IAAIC,GAAG,KAAK,OAAO,IAC9C9C,gBAAgB,CAAC6C,MAAM,CAAC,IAAIA,MAAM,CAACE,QAAQ,IAAID,GAAG,KAAK,KAAM,EAC9D;oBACAZ,IAAI,CAACc,IAAI,EAAE,CAAA;gBACb,CAAA;aACD;YACDC,WAAW,EAAEP,OAAAA;QACf,CAAC,CAAC,CAAA;IACJ,CAAA;IAEA,SAASQ,SAASA,CAACzE,IAAwB,EAAW;QACpD,KAAK,MAAM0E,IAAI,IAAI1E,IAAI,CAACO,UAAU,CAAE;YAClC,IAAIiB,KAAAA,KAAC,CAACmD,eAAe,CAACD,IAAI,CAAC,EAAE;gBAC3B,OAAO,IAAI,CAAA;YACb,CAAA;QACF,CAAA;QACA,OAAO,KAAK,CAAA;IACd,CAAA;IAQA,SAASE,qBAAqBA,CAAC5E,IAAqB,EAAE;QAEpD,MAAM6E,KAAK,GAAG7E,IAAI,CAACO,UAAgC,CAAA;QACnD,MAAMuE,IAAoB,GAAG,EAAE,CAAA;QAC/B,IAAIC,aAAa,GAAG,IAAI,CAAA;QACxB,IAAIC,kBAAkB,GAAG,KAAK,CAAA;QAE9B,KAAK,MAAMN,IAAI,IAAIG,KAAK,CAAE;YACxB,MAAM,EAAER,GAAAA,EAAK,GAAGK,IAAI,CAAA;YACpB,IAAIlD,KAAAA,KAAC,CAACyD,YAAY,CAACZ,GAAG,CAAC,IAAI,CAACK,IAAI,CAACJ,QAAQ,EAAE;gBAEzCQ,IAAI,CAACI,IAAI,CAAC1D,KAAAA,KAAC,CAAC2D,aAAa,CAACd,GAAG,CAACe,IAAI,CAAC,CAAC,CAAA;aACrC,MAAM,IAAI5D,KAAAA,KAAC,CAAC6D,iBAAiB,CAAChB,GAAG,CAAC,EAAE;gBACnCS,IAAI,CAACI,IAAI,CAAC1D,KAAAA,KAAC,CAAC8D,SAAS,CAACjB,GAAG,CAAC,CAAC,CAAA;gBAC3BW,kBAAkB,GAAG,IAAI,CAAA;aAC1B,MAAM,IAAIxD,KAAAA,KAAC,CAAC+D,SAAS,CAAClB,GAAG,CAAC,EAAE;gBAC3BS,IAAI,CAACI,IAAI,CACP1D,KAAAA,KAAC,CAAC2D,aAAa,CACbK,MAAM,CAEJnB,GAAG,CAAC5D,KACN,CACF,CACF,CAAC,CAAA;YACH,CAAC,MAAM;gBAELqE,IAAI,CAACI,IAAI,CAAC1D,KAAAA,KAAC,CAAC8D,SAAS,CAACjB,GAAG,CAAC,CAAC,CAAA;gBAE3B,IACG7C,KAAAA,KAAC,CAACiE,kBAAkB,CAACpB,GAAG,EAAE;oBAAEC,QAAQ,EAAE,KAAA;iBAAO,CAAC,IAC7C9C,KAAAA,KAAC,CAACyD,YAAY,CAACZ,GAAG,CAACqB,MAAM,EAAE;oBAAEN,IAAI,EAAE,QAAA;iBAAU,CAAC,IAC/C5D,KAAAA,KAAC,CAACmE,gBAAgB,CAACtB,GAAG,CAAC,IACtB7C,KAAAA,KAAC,CAACoE,cAAc,CAACvB,GAAG,CAACwB,MAAM,EAAE,YAAY,CAAE,EAC7C,CAED;qBAAM;oBACLd,aAAa,GAAG,KAAK,CAAA;gBACvB,CAAA;YACF,CAAA;QACF,CAAA;QAEA,OAAO;YAAED,IAAI;YAAEC,aAAa;YAAEC,kBAAAA;SAAoB,CAAA;IACpD,CAAA;IAIA,SAASc,yBAAyBA,CAChCvF,UAAwC,EACxCwF,KAAY,EACZ;QACA,MAAMC,iCAAyD,GAAG,EAAE,CAAA;QACpE,KAAK,MAAMC,QAAQ,IAAI1F,UAAU,CAAE;YAEjC,MAAM8D,GAAG,GAAG4B,QAAQ,CAACC,GAAG,CAAC,KAAK,CAA2B,CAAA;YACzD,IAAID,QAAQ,CAACjG,IAAI,CAACsE,QAAQ,IAAI,CAACD,GAAG,CAAC8B,MAAM,EAAE,EAAE;gBAC3C,MAAMf,IAAI,GAAGW,KAAK,CAACK,sBAAsB,CAAC/B,GAAG,CAACrE,IAAI,CAAC,CAAA;gBACnD,MAAMqG,UAAU,GAAG7E,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC9E,KAAAA,KAAC,CAACC,UAAU,CAAC2D,IAAI,CAAC,EAAEf,GAAG,CAACrE,IAAI,CAAC,CAAA;gBACrEgG,iCAAiC,CAACd,IAAI,CAACmB,UAAU,CAAC,CAAA;gBAClDhC,GAAG,CAACkC,WAAW,CAAC/E,KAAAA,KAAC,CAACC,UAAU,CAAC2D,IAAI,CAAC,CAAC,CAAA;YACrC,CAAA;QACF,CAAA;QACA,OAAOY,iCAAiC,CAAA;IAC1C,CAAA;IAEA,SAASQ,wBAAwBA,CAAC/C,IAA+B,EAAQ;QACvE,MAAMgD,QAAQ,GAAGhD,IAAI,CAACiD,8BAA8B,EAAE,CAAA;QAEtDC,MAAM,CAAC7B,IAAI,CAAC2B,QAAQ,CAAC,CAACG,OAAO,EAACC,WAAW,IAAI;YAC3C,MAAMC,iBAAiB,GAAGL,QAAQ,CAACI,WAAW,CAAC,CAAC9C,UAAU,CAAA;YAC1D,IACEN,IAAI,CAACsC,KAAK,CAACgB,UAAU,CAACF,WAAW,CAAC,CAACG,UAAU,GACPlF,SAAU,IAChD,CAACgF,iBAAiB,CAACvF,gBAAgB,EAAE,EACrC;gBACA,OAAA;YACF,CAAA;YACAuF,iBAAiB,CAACG,MAAM,EAAE,CAAA;QAC5B,CAAC,CAAC,CAAA;IACJ,CAAA;IAGA,SAASC,gBAAgBA,CACvBzD,IAA+B,EAC/BJ,IAAgB,EAChB8D,MAAyC,EAKzC;QACA,MAAMtC,KAAK,GAAGpB,IAAI,CAACyC,GAAG,CAAC,YAAY,CAAC,CAAA;QACpC,MAAMkB,IAAI,GAAGvC,KAAK,CAACA,KAAK,CAACvE,MAAM,GAAG,CAAC,CAAC,CAAA;QACpCkB,KAAAA,KAAC,CAAC6F,iBAAiB,CAACD,IAAI,CAACpH,IAAI,CAAC,CAAA;QAC9B,MAAM4D,WAAW,GAAGpC,KAAAA,KAAC,CAAC8D,SAAS,CAAC8B,IAAI,CAACpH,IAAI,CAAC,CAAA;QAC1CoH,IAAI,CAACH,MAAM,EAAE,CAAA;QAEb,MAAMjB,iCAAiC,GAAGF,yBAAyB,CACjErC,IAAI,CAACyC,GAAG,CAAC,YAAY,CAAC,EACtBzC,IAAI,CAACsC,KACP,CAAC,CAAA;QACD,MAAM,EAAEjB,IAAI,EAAEC,aAAa,EAAEC,kBAAAA,EAAoB,GAAGJ,qBAAqB,CACvEnB,IAAI,CAACzD,IACP,CAAC,CAAA;QAED,IAAI8E,IAAI,CAACxE,MAAM,KAAK,CAAC,EAAE;YACrB,OAAO;gBACL0F,iCAAiC;gBACjCpC,WAAW,CAACjD,QAAQ;gBACpBa,KAAAA,KAAC,CAAC8F,cAAc,CAAClE,gBAAgB,CAACC,IAAI,CAAC,EAAE;oBACvC7B,KAAAA,KAAC,CAAC+F,gBAAgB,CAAC,EAAE,CAAC;oBACtB/F,KAAAA,KAAC,CAACgG,kBAAkB,CAAC;wBACnBhG,KAAAA,KAAC,CAAC8F,cAAc,CAACjE,IAAI,CAACE,SAAS,CAAC,0BAA0B,CAAC,EAAE;4BAC3D/B,KAAAA,KAAC,CAAC8D,SAAS,CAAC6B,MAAM,CAAC;yBACpB,CAAC;wBACF3F,KAAAA,KAAC,CAAC8D,SAAS,CAAC6B,MAAM,CAAC;qBACpB,CAAC;iBACH,CAAC;aACH,CAAA;QACH,CAAA;QAEA,IAAIM,aAAa,CAAA;QACjB,IAAI,CAAC1C,aAAa,EAAE;YAElB0C,aAAa,GAAGjG,KAAAA,KAAC,CAAC8F,cAAc,CAC9B9F,KAAAA,KAAC,CAAC8B,gBAAgB,CAAC9B,KAAAA,KAAC,CAACkG,eAAe,CAAC5C,IAAI,CAAC,EAAEtD,KAAAA,KAAC,CAACC,UAAU,CAAC,KAAK,CAAC,CAAC,EAChE;gBAAC4B,IAAI,CAACE,SAAS,CAAC,eAAe,CAAC;aAClC,CAAC,CAAA;QACH,CAAC,MAAM;YACLkE,aAAa,GAAGjG,KAAAA,KAAC,CAACkG,eAAe,CAAC5C,IAAI,CAAC,CAAA;YAEvC,IAAI,CAACE,kBAAkB,IAAI,CAACxD,KAAAA,KAAC,CAACmG,SAAS,CAAClE,IAAI,CAACsC,KAAK,CAAC6B,KAAK,CAAC,EAAE;gBAEzD,MAAMC,OAAO,GAAGpE,IAAI,CAACqE,UAAU,EAACrE,IAAI,GAAIA,IAAI,CAACkE,SAAS,EAAE,CAAC,CAAA;gBACzD,MAAMI,EAAE,GAAGtE,IAAI,CAACsC,KAAK,CAACiC,qBAAqB,CAAC,UAAU,CAAC,CAAA;gBAEvDH,OAAO,CAAC9B,KAAK,CAACb,IAAI,CAAC;oBACjB6C,EAAE;oBACFE,IAAI,EAAER,aAAa;oBACnBS,IAAI,EAAE,OAAA;gBACR,CAAC,CAAC,CAAA;gBAEFT,aAAa,GAAGjG,KAAAA,KAAC,CAAC8D,SAAS,CAACyC,EAAE,CAAC,CAAA;YACjC,CAAA;QACF,CAAA;QAEA,OAAO;YACL/B,iCAAiC;YACjCpC,WAAW,CAACjD,QAAQ;YACpBa,KAAAA,KAAC,CAAC8F,cAAc,CACdjE,IAAI,CAACE,SAAS,CACZ,CAA0BN,uBAAAA,EAAAA,mBAAmB,GAAG,OAAO,GAAG,EAAE,CAAA,CAC9D,CAAC,EACD;gBAACzB,KAAAA,KAAC,CAAC8D,SAAS,CAAC6B,MAAM,CAAC;gBAAEM,aAAa;aACrC,CAAC;SACF,CAAA;IACH,CAAA;IAEA,SAASU,kBAAkBA,CACzBpE,UAAgD,EAChDqE,SAEC,EACDC,SAAmC,EAC7B;QACN,IAAID,SAAS,CAAC9G,mBAAmB,EAAE,EAAE;YACnC6G,kBAAkB,CAACpE,UAAU,EAAEqE,SAAS,CAAClC,GAAG,CAAC,MAAM,CAAC,EAAEmC,SAAS,CAAC,CAAA;YAChE,OAAA;QACF,CAAA;QAEA,IAAID,SAAS,CAACE,cAAc,EAAE,IAAI9E,cAAc,CAAC4E,SAAS,CAAC,EAAE;YAC3D,MAAMjI,QAAQ,GAAGiI,SAAS,CAAClC,GAAG,CAAC,UAAU,CAAC,CAAA;YAE1C,IAAK,IAAIqC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpI,QAAQ,CAACG,MAAM,EAAEiI,CAAC,EAAE,CAAE;gBACxCJ,kBAAkB,CAACpE,UAAU,EAAE5D,QAAQ,CAACoI,CAAC,CAAC,EAAEF,SAAS,CAAC,CAAA;YACxD,CAAA;QACF,CAAA;QAEA,IAAID,SAAS,CAACpE,eAAe,EAAE,IAAIR,cAAc,CAAC4E,SAAS,CAAC,EAAE;YAC5D,MAAMI,GAAG,GAAGzE,UAAU,CAACgC,KAAK,CAACiC,qBAAqB,CAAC,KAAK,CAAC,CAAA;YAEzD,MAAMS,MAAM,GAAGjH,KAAAA,KAAC,CAACkH,mBAAmB,CAAC,KAAK,EAAE;gBAC1ClH,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC8B,SAAS,CAACpI,IAAI,EAAEwI,GAAG,CAAC;aAC1C,CAAC,CAAA;YAEF,IAAIH,SAAS,EAAE;gBACbA,SAAS,CAACnD,IAAI,CAACuD,MAAM,CAAC,CAAA;YACxB,CAAC,MAAM;gBACL1E,UAAU,CAAC4E,WAAW,EAAE,CAAA;gBACvB5E,UAAU,CAACmC,GAAG,CAAC,MAAM,CAAC,CAAgC0C,gBAAgB,CACrE,MAAM,EACNH,MACF,CAAC,CAAA;YACH,CAAA;YACAL,SAAS,CAAC7B,WAAW,CAAC/E,KAAAA,KAAC,CAAC8D,SAAS,CAACkD,GAAG,CAAC,CAAC,CAAA;QACzC,CAAA;IACF,CAAA;IAEA,OAAO;QACLpD,IAAI,EAAE,8BAA8B;QACpCyD,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAAC9D,IAAI,CAAC,kBAAkB,CAAC;QAE1DjB,OAAO,EAAE;YAEPgF,QAAQA,EAACxF,IAAI,EAAE;gBACb,MAAMyF,MAAM,GAAGzF,IAAI,CAACyC,GAAG,CAAC,QAAQ,CAAC,CAAA;gBACjC,MAAMiD,qBAAqB,GAAG,IAAIC,GAAG,EAAU,CAAA;gBAC/C,MAAMC,eAAe,GAAG,IAAID,GAAG,EAAE,CAAA;gBACjC,IAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,MAAM,CAAC5I,MAAM,EAAE,EAAEiI,CAAC,CAAE;oBACtC,MAAMe,KAAK,GAAGJ,MAAM,CAACX,CAAC,CAAC,CAAA;oBACvB,IAAI/E,cAAc,CAAC8F,KAAK,CAAC,EAAE;wBACzBH,qBAAqB,CAACI,GAAG,CAAChB,CAAC,CAAC,CAAA;wBAC5B,KAAK,MAAMnD,IAAI,IAAIuB,MAAM,CAAC7B,IAAI,CAACwE,KAAK,CAACE,qBAAqB,EAAE,CAAC,CAAE;4BAC7DH,eAAe,CAACE,GAAG,CAACnE,IAAI,CAAC,CAAA;wBAC3B,CAAA;oBACF,CAAA;gBACF,CAAA;gBAKA,IAAIqE,QAAQ,GAAG,KAAK,CAAA;gBAEpB,MAAMC,iBAAiB,GAAG,SACxBjG,IAA4B,EAC5BkG,aAAoB,EACpB;oBACA,MAAMvE,IAAI,GAAG3B,IAAI,CAACzD,IAAI,CAACoF,IAAI,CAAA;oBAC3B,IACE3B,IAAI,CAACsC,KAAK,CAACgB,UAAU,CAAC3B,IAAI,CAAC,KAAKuE,aAAa,CAAC5C,UAAU,CAAC3B,IAAI,CAAC,IAC9DiE,eAAe,CAACO,GAAG,CAACxE,IAAI,CAAC,EACzB;wBACAqE,QAAQ,GAAG,IAAI,CAAA;wBACfhG,IAAI,CAACI,IAAI,EAAE,CAAA;oBACb,CAAA;iBACD,CAAA;gBAED,IAAI0E,CAAS,CAAA;gBACb,IAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,MAAM,CAAC5I,MAAM,IAAI,CAACmJ,QAAQ,EAAE,EAAElB,CAAC,CAAE;oBAC/C,MAAMe,KAAK,GAAGJ,MAAM,CAACX,CAAC,CAAC,CAAA;oBACvB,IAAI,CAACY,qBAAqB,CAACS,GAAG,CAACrB,CAAC,CAAC,EAAE;wBACjC,IAAIe,KAAK,CAACO,sBAAsB,EAAE,IAAIP,KAAK,CAACQ,mBAAmB,EAAE,EAAE;4BACjEJ,iBAAiB,CAACJ,KAAK,EAAE7F,IAAI,CAACsC,KAAK,CAAC,CAAA;wBACtC,CAAC,MAAM;4BACLuD,KAAK,CAACpF,QAAQ,CACZ;gCACE,uCAAuC,GAAET,IAAI,GAAIA,IAAI,CAACc,IAAI,EAAE;gCAC5D,wCAAwC,EAAEmF,iBAAAA;4BAC5C,CAAC,EACDjG,IAAI,CAACsC,KACP,CAAC,CAAA;wBACH,CAAA;oBACF,CAAA;gBACF,CAAA;gBAEA,IAAI,CAAC0D,QAAQ,EAAE;oBACb,IAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGW,MAAM,CAAC5I,MAAM,EAAE,EAAEiI,CAAC,CAAE;wBACtC,MAAMe,KAAK,GAAGJ,MAAM,CAACX,CAAC,CAAC,CAAA;wBACvB,IAAIY,qBAAqB,CAACS,GAAG,CAACrB,CAAC,CAAC,EAAE;4BAChCJ,kBAAkB,CAAC1E,IAAI,EAAE6F,KAAK,CAAC,CAAA;wBACjC,CAAA;oBACF,CAAA;gBACF,CAAC,MAAM;oBACL,MAAMS,oBAAoB,IAAIC,GAAW,GACvCA,GAAG,IAAIzB,CAAC,GAAG,CAAC,IAAIY,qBAAqB,CAACS,GAAG,CAACI,GAAG,CAAC,CAAA;oBAChDC,0BAAAA,qBAAqB,CACnBxG,IAAI,EACJV,oBAAoB,EACpBgH,oBAAoB,EACpB5B,kBACF,CAAC,CAAA;gBACH,CAAA;aACD;YAID+B,kBAAkBA,EAACzG,IAAI,EAAEJ,IAAI,EAAE;gBAC7B,IAAI,CAACI,IAAI,CAACyC,GAAG,CAAC,IAAI,CAAC,CAAClC,eAAe,EAAE,EAAE;oBACrC,OAAA;gBACF,CAAA;gBAEA,IAAImG,aAAa,GAAG1G,IAAI,CAAA;gBACxB,MAAM2G,YAAY,GAAG3G,IAAI,CAAA;gBAEzBE,iBAAiB,CAACF,IAAI,CAACyC,GAAG,CAAC,IAAI,CAAC,GAAEzC,IAAI,IAAI;oBACxC,IAAI,CAACA,IAAI,CAACM,UAAU,CAACC,eAAe,EAAE,EAAE;wBAItC,OAAA;oBACF,CAAA;oBAEA,IAIEjE,iCAAiC,CAACqK,YAAY,CAACpK,IAAI,CAAC+H,EAAE,CAAC,IACvD,CAACvG,KAAAA,KAAC,CAACyD,YAAY,CAACmF,YAAY,CAACpK,IAAI,CAACiI,IAAI,CAAC,EACvC;wBAKA,MAAMoC,OAAO,GAAG5G,IAAI,CAACsC,KAAK,CAACuE,gCAAgC,CACzDF,YAAY,CAACpK,IAAI,CAACiI,IAAI,EACtB,KACF,CAAC,CAAA;wBAEDmC,YAAY,CAACG,YAAY,CACvB/I,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC+D,OAAO,EAAED,YAAY,CAACpK,IAAI,CAACiI,IAAI,CACtD,CAAC,CAAA;wBAEDmC,YAAY,CAAC7D,WAAW,CACtB/E,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC8D,YAAY,CAACpK,IAAI,CAAC+H,EAAE,EAAEvG,KAAAA,KAAC,CAAC8D,SAAS,CAAC+E,OAAO,CAAC,CACjE,CAAC,CAAA;wBAED,OAAA;oBACF,CAAA;oBAEA,IAAIG,GAAG,GAAGJ,YAAY,CAACpK,IAAI,CAACiI,IAAI,CAAA;oBAChC,MAAMwC,eAA6C,GAAG,EAAE,CAAA;oBACxD,IAAIvC,IAAI,CAAA;oBAERzE,IAAI,CAACqE,UAAU,EAAErE,IAAc,IAAc;wBAC3C,IAAIA,IAAI,CAAClC,gBAAgB,EAAE,EAAE;4BAC3BkJ,eAAe,CAACC,OAAO,CAACjH,IAAI,CAAC,CAAA;wBAC/B,CAAC,MAAM,IAAIA,IAAI,CAACkH,oBAAoB,EAAE,EAAE;4BACtCzC,IAAI,GAAGzE,IAAI,CAACM,UAAU,CAAC/D,IAAI,CAACkI,IAAI,CAAA;4BAChC,OAAO,IAAI,CAAA;wBACb,CAAA;oBACF,CAAC,CAAC,CAAA;oBAEF,MAAM0C,+BAA+B,GAAG9E,yBAAyB,CAC/D2E,eAAe,EACfhH,IAAI,CAACsC,KACP,CAAC,CAAA;oBACD0E,eAAe,CAAC7D,OAAO,EAAClC,IAAI,IAAI;wBAC9B,MAAM,EAAE1E,IAAAA,EAAM,GAAG0E,IAAI,CAAA;wBACrB8F,GAAG,GAAGhJ,KAAAA,KAAC,CAAC8B,gBAAgB,CACtBkH,GAAG,EACHhJ,KAAAA,KAAC,CAAC8D,SAAS,CAACtF,IAAI,CAACqE,GAAG,CAAC,EACrBrE,IAAI,CAACsE,QAAQ,IAAI9C,KAAAA,KAAC,CAAC+D,SAAS,CAACvF,IAAI,CAACqE,GAAG,CACvC,CAAC,CAAA;oBACH,CAAC,CAAC,CAAA;oBAGF,MAAMwG,iBAA4C,GAAGpH,IAAI,CAACqE,UAAU,EAClErE,IAAI,GAAIA,IAAI,CAACO,eAAe,EAC9B,CAAC,CAAA;oBAED,MAAM,CAACgC,iCAAiC,EAAErF,QAAQ,EAAE2G,cAAc,CAAC,GACjEJ,gBAAgB,CACd2D,iBAAiB,EACjBxH,IAAI,EACJmH,GACF,CAAC,CAAA;oBAEH,IAAItH,WAAW,EAAE;wBACfsD,wBAAwB,CAACqE,iBAAiB,CAAC,CAAA;oBAC7C,CAAA;oBAEArJ,KAAAA,KAAC,CAACsJ,gBAAgB,CAACnK,QAAQ,CAAC,CAAA;oBAE5BwJ,aAAa,CAACI,YAAY,CAACvE,iCAAiC,CAAC,CAAA;oBAE7DmE,aAAa,CAACI,YAAY,CAACK,+BAA+B,CAAC,CAAA;oBAE3DT,aAAa,GAAGA,aAAa,CAACY,WAAW,CACvCvJ,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC3F,QAAQ,EAAE2G,cAAc,CAC/C,CAAC,CAAC,CAAC,CAAmC,CAAA;oBAEtC7D,IAAI,CAACsC,KAAK,CAACiF,eAAe,CAAC9C,IAAI,EAAEiC,aAAa,CAAC,CAAA;oBAE/C,IAAIU,iBAAiB,CAAC7K,IAAI,CAACO,UAAU,CAACD,MAAM,KAAK,CAAC,EAAE;wBAClDuK,iBAAiB,CACd/C,UAAU,EACTrE,IAAI,GAAIA,IAAI,CAAClC,gBAAgB,EAAE,IAAIkC,IAAI,CAACkH,oBAAoB,EAC9D,CAAC,CACA1D,MAAM,EAAE,CAAA;oBACb,CAAA;gBACF,CAAC,CAAC,CAAA;aACH;YAIDgE,sBAAsBA,EAACxH,IAAI,EAAE;gBAC3B,MAAMyH,WAAW,GAAGzH,IAAI,CAACyC,GAAG,CAAC,aAAa,CAAC,CAAA;gBAC3C,IAAI,CAACgF,WAAW,CAACC,qBAAqB,EAAE,EAAE,OAAA;gBAE1C,MAAMC,OAAO,GAAGF,WAAW,CACxBhF,GAAG,CAAC,cAAc,CAAC,CACnBmF,IAAI,EAAC5H,IAAI,GAAIK,2BAA2B,CAACL,IAAI,CAACyC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;gBAC5D,IAAI,CAACkF,OAAO,EAAE,OAAA;gBAEd,MAAME,UAAU,GAAG,EAAE,CAAA;gBAErB,KAAK,MAAMlG,IAAI,IAAIuB,MAAM,CAAC7B,IAAI,CAACrB,IAAI,CAAC8H,0BAA0B,CAAC,IAAI,CAAC,CAAC,CAAE;oBACrED,UAAU,CAACpG,IAAI,CACb1D,KAAAA,KAAC,CAACgK,eAAe,CAAChK,KAAAA,KAAC,CAACC,UAAU,CAAC2D,IAAI,CAAC,EAAE5D,KAAAA,KAAC,CAACC,UAAU,CAAC2D,IAAI,CAAC,CAC1D,CAAC,CAAA;gBACH,CAAA;gBAKA3B,IAAI,CAAC8C,WAAW,CAAC2E,WAAW,CAAClL,IAAI,CAAC,CAAA;gBAClCyD,IAAI,CAACsH,WAAW,CAACvJ,KAAAA,KAAC,CAACiK,sBAAsB,CAAC,IAAI,EAAEH,UAAU,CAAC,CAAC,CAAA;aAC7D;YAGDI,WAAWA,EAACjI,IAAI,EAAE;gBAChB,MAAM2E,SAAS,GAAG3E,IAAI,CAACyC,GAAG,CAAC,OAAO,CAAC,CAAA;gBACnCiC,kBAAkB,CAAC1E,IAAI,EAAE2E,SAAS,CAAC,CAAA;aACpC;YAGDuD,oBAAoBA,EAAClI,IAAI,EAAEJ,IAAI,EAAE;gBAC/B,MAAMuI,QAAQ,GAAGnI,IAAI,CAACyC,GAAG,CAAC,MAAM,CAAC,CAAA;gBACjC,IAAI0F,QAAQ,CAAC5H,eAAe,EAAE,IAAIR,cAAc,CAACoI,QAAQ,CAAC,EAAE;oBAC1D,MAAMC,KAAK,GAAG,EAAE,CAAA;oBAEhB,MAAMC,OAAO,GAAGrI,IAAI,CAACsC,KAAK,CAACK,sBAAsB,CAC/C3C,IAAI,CAACzD,IAAI,CAAC+L,KAAK,EACf,KACF,CAAC,CAAA;oBAEDF,KAAK,CAAC3G,IAAI,CACR1D,KAAAA,KAAC,CAACkH,mBAAmB,CAAC,KAAK,EAAE;wBAC3BlH,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC9E,KAAAA,KAAC,CAACC,UAAU,CAACqK,OAAO,CAAC,EAAErI,IAAI,CAACzD,IAAI,CAAC+L,KAAK,CAAC;qBAC7D,CACH,CAAC,CAAA;oBAED,MAAM,CAAC/F,iCAAiC,EAAErF,QAAQ,EAAE2G,cAAc,CAAC,GACjEJ,gBAAgB,CAAC0E,QAAQ,EAAEvI,IAAI,EAAE7B,KAAAA,KAAC,CAACC,UAAU,CAACqK,OAAO,CAAC,CAAC,CAAA;oBAEzD,IAAI9F,iCAAiC,CAAC1F,MAAM,GAAG,CAAC,EAAE;wBAChDuL,KAAK,CAAC3G,IAAI,CACR1D,KAAAA,KAAC,CAACkH,mBAAmB,CAAC,KAAK,EAAE1C,iCAAiC,CAChE,CAAC,CAAA;oBACH,CAAA;oBAEA,MAAMgG,iBAAiB,GAAGxK,KAAAA,KAAC,CAAC8D,SAAS,CAAC7B,IAAI,CAACzD,IAAI,CAAC,CAAA;oBAChDgM,iBAAiB,CAACD,KAAK,GAAGvK,KAAAA,KAAC,CAACC,UAAU,CAACqK,OAAO,CAAC,CAAA;oBAC/CD,KAAK,CAAC3G,IAAI,CAAC1D,KAAAA,KAAC,CAACyK,mBAAmB,CAACD,iBAAiB,CAAC,CAAC,CAAA;oBACpDH,KAAK,CAAC3G,IAAI,CACR1D,KAAAA,KAAC,CAACyK,mBAAmB,CACnBzK,KAAAA,KAAC,CAAC0K,oBAAoB,CAAC,GAAG,EAAEvL,QAAQ,EAAE2G,cAAc,CACtD,CACF,CAAC,CAAA;oBACDuE,KAAK,CAAC3G,IAAI,CAAC1D,KAAAA,KAAC,CAACyK,mBAAmB,CAACzK,KAAAA,KAAC,CAACC,UAAU,CAACqK,OAAO,CAAC,CAAC,CAAC,CAAA;oBAExDrI,IAAI,CAAC0I,mBAAmB,CAACN,KAAK,CAAC,CAAA;gBACjC,CAAA;aACD;YAGDO,aAAaA,EAAC3I,IAA+B,EAAE;gBAC7C,MAAM,EAAEzD,IAAI,EAAE+F,KAAAA,EAAO,GAAGtC,IAAI,CAAA;gBAC5B,MAAMmI,QAAQ,GAAGnI,IAAI,CAACyC,GAAG,CAAC,MAAM,CAAC,CAAA;gBACjC,MAAMxF,IAAI,GAAGV,IAAI,CAACU,IAAI,CAAA;gBAEtB,IAAI,CAACoD,2BAA2B,CAAC8H,QAAQ,CAAC,EAAE;oBAC1C,OAAA;gBACF,CAAA;gBAEA,IAAI,CAACpK,KAAAA,KAAC,CAAC2J,qBAAqB,CAACzK,IAAI,CAAC,EAAE;oBAElC,MAAM2L,IAAI,GAAGtG,KAAK,CAACiC,qBAAqB,CAAC,KAAK,CAAC,CAAA;oBAE/ChI,IAAI,CAACU,IAAI,GAAGc,KAAAA,KAAC,CAACkH,mBAAmB,CAAC,KAAK,EAAE;wBACvClH,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC+F,IAAI,CAAC;qBAC3B,CAAC,CAAA;oBAEF5I,IAAI,CAACkF,WAAW,EAAE,CAAA;oBAClB,MAAM2D,IAAI,GAAG7I,IAAI,CAACzD,IAAI,CAACsM,IAAwB,CAAA;oBAE/C,IAAIA,IAAI,CAACA,IAAI,CAAChM,MAAM,KAAK,CAAC,IAAImD,IAAI,CAAC8I,kBAAkB,EAAE,EAAE;wBACvDD,IAAI,CAACA,IAAI,CAAC5B,OAAO,CACflJ,KAAAA,KAAC,CAACyK,mBAAmB,CAAClG,KAAK,CAACyG,kBAAkB,EAAE,CAClD,CAAC,CAAA;oBACH,CAAA;oBAEAF,IAAI,CAACA,IAAI,CAAC5B,OAAO,CACflJ,KAAAA,KAAC,CAACyK,mBAAmB,CACnBzK,KAAAA,KAAC,CAAC0K,oBAAoB,CAAC,GAAG,EAAExL,IAAI,EAAEc,KAAAA,KAAC,CAAC8D,SAAS,CAAC+G,IAAI,CAAC,CACrD,CACF,CAAC,CAAA;gBACH,CAAC,MAAM;oBAEL,MAAMzK,OAAO,GAAGlB,IAAI,CAAC+L,YAAY,CAAC,CAAC,CAAC,CAAC1E,EAAE,CAAA;oBAEvC,MAAM1D,GAAG,GAAG0B,KAAK,CAACiC,qBAAqB,CAAC,KAAK,CAAC,CAAA;oBAC9ChI,IAAI,CAACU,IAAI,GAAGc,KAAAA,KAAC,CAACkH,mBAAmB,CAAChI,IAAI,CAACwH,IAAI,EAAE;wBAC3C1G,KAAAA,KAAC,CAAC8E,kBAAkB,CAACjC,GAAG,EAAE,IAAI,CAAC;qBAChC,CAAC,CAAA;oBAEFZ,IAAI,CAACkF,WAAW,EAAE,CAAA;oBAClB,MAAM2D,IAAI,GAAGtM,IAAI,CAACsM,IAAwB,CAAA;oBAE1CA,IAAI,CAACA,IAAI,CAAC5B,OAAO,CACflJ,KAAAA,KAAC,CAACkH,mBAAmB,CAAC1I,IAAI,CAACU,IAAI,CAACwH,IAAI,EAAE;wBACpC1G,KAAAA,KAAC,CAAC8E,kBAAkB,CAAC1E,OAAO,EAAEJ,KAAAA,KAAC,CAAC8D,SAAS,CAACjB,GAAG,CAAC,CAAC;qBAChD,CACH,CAAC,CAAA;gBACH,CAAA;aACD;YAGDqI,YAAYA,EAACjJ,IAAI,EAAE;gBACjB,MAAMkJ,cAAsC,GAAG,EAAE,CAAA;gBAEjDhJ,iBAAiB,CAACF,IAAI,GAAEA,IAAI,IAAI;oBAC9B,IAAI,CAACA,IAAI,CAACM,UAAU,CAACC,eAAe,EAAE,EAAE;wBAItC,OAAA;oBACF,CAAA;oBAEA,MAAMnC,aAAa,GAAG4B,IAAI,CAACM,UAAU,CAAA;oBAErC,MAAMyE,GAAG,GAAG/E,IAAI,CAACsC,KAAK,CAACiC,qBAAqB,CAAC,KAAK,CAAC,CAAA;oBACnD2E,cAAc,CAACzH,IAAI,CAAC1D,KAAAA,KAAC,CAAC8E,kBAAkB,CAACzE,aAAa,CAAC7B,IAAI,EAAEwI,GAAG,CAAC,CAAC,CAAA;oBAElE3G,aAAa,CAAC0E,WAAW,CAAC/E,KAAAA,KAAC,CAAC8D,SAAS,CAACkD,GAAG,CAAC,CAAC,CAAA;oBAC3C/E,IAAI,CAACc,IAAI,EAAE,CAAA;gBACb,CAAC,CAAC,CAAA;gBAEF,IAAIoI,cAAc,CAACrM,MAAM,GAAG,CAAC,EAAE;oBAC7B,MAAMsM,aAAa,GAAGnJ,IAAI,CAACoJ,kBAAkB,EAAE,CAAA;oBAC/C,MAAMC,aAAa,GAAGF,aAAa,CAAC5M,IAAI,CAAA;oBACxC,MAAMkI,IAAI,GACR4E,aAAa,CAAC7M,IAAI,KAAK,qBAAqB,GACxC6M,aAAa,CAAC5E,IAAI,GAClB,KAAK,CAAA;oBACX0E,aAAa,CAAC7B,WAAW,CACvBvJ,KAAAA,KAAC,CAACkH,mBAAmB,CAACR,IAAI,EAAEyE,cAAc,CAC5C,CAAC,CAAA;gBACH,CAAA;aACD;YAGDI,gBAAgBA,EAACtJ,IAAI,EAAEJ,IAAI,EAAE;gBAC3B,IAAI,CAACoB,SAAS,CAAChB,IAAI,CAACzD,IAAI,CAAC,EAAE,OAAA;gBAE3B,IAAIgN,MAAyC,CAAA;gBAC7C,IAAI7J,mBAAmB,EAAE;oBACvB6J,MAAM,GAAG5J,gBAAgB,CAACC,IAAI,CAAC,CAAA;gBACjC,CAAC,MAAM;oBAGE;wBACL,IAAI;4BACF2J,MAAM,GAAG3J,IAAI,CAACE,SAAS,CAAC,eAAe,CAAC,CAAA;yBACzC,CAAC,OAAA0J,OAAA,EAAM;4BAIN,IAAI,CAAC5J,IAAI,CAACoJ,YAAY,CAAC,eAAe,CAAC,GAAG,IAAI,CAAA;4BAI9CO,MAAM,GAAG3J,IAAI,CAACE,SAAS,CAAC,cAAc,CAAC,CAAA;wBACzC,CAAA;oBACF,CAAA;gBACF,CAAA;gBAEA,IAAI2J,GAAqB,GAAG,IAAI,CAAA;gBAChC,IAAIrI,KAAuB,GAAG,EAAE,CAAA;gBAEhC,SAASsI,IAAIA,GAAG;oBACd,MAAMC,QAAQ,GAAGvI,KAAK,CAACvE,MAAM,GAAG,CAAC,CAAA;oBACjC,MAAM+M,GAAG,GAAG7L,KAAAA,KAAC,CAAC+F,gBAAgB,CAAC1C,KAAK,CAAC,CAAA;oBACrCA,KAAK,GAAG,EAAE,CAAA;oBAEV,IAAI,CAACqI,GAAG,EAAE;wBACRA,GAAG,GAAG1L,KAAAA,KAAC,CAAC8F,cAAc,CAAC0F,MAAM,EAAE;4BAACK,GAAG;yBAAC,CAAC,CAAA;wBACrC,OAAA;oBACF,CAAA;oBAIA,IAAInK,WAAW,EAAE;wBACf,IAAIkK,QAAQ,EAAE;4BACZF,GAAG,CAACI,SAAS,CAACpI,IAAI,CAACmI,GAAG,CAAC,CAAA;wBACzB,CAAA;wBACA,OAAA;oBACF,CAAA;oBAEAH,GAAG,GAAG1L,KAAAA,KAAC,CAAC8F,cAAc,CAAC9F,KAAAA,KAAC,CAAC8D,SAAS,CAAC0H,MAAM,CAAC,EAAE;wBAC1CE,GAAG,EAIH;2BAAIE,QAAQ,GAAG;4BAAC5L,KAAAA,KAAC,CAAC+F,gBAAgB,CAAC,EAAE,CAAC;4BAAE8F,GAAG;yBAAC,GAAG,EAAE,CAAC;qBACnD,CAAC,CAAA;gBACJ,CAAA;gBAEA,KAAK,MAAM3I,IAAI,IAAIjB,IAAI,CAACzD,IAAI,CAACO,UAAU,CAAE;oBACvC,IAAIiB,KAAAA,KAAC,CAACmD,eAAe,CAACD,IAAI,CAAC,EAAE;wBAC3ByI,IAAI,EAAE,CAAA;wBACND,GAAG,CAACI,SAAS,CAACpI,IAAI,CAACR,IAAI,CAAC/D,QAAQ,CAAC,CAAA;oBACnC,CAAC,MAAM;wBACLkE,KAAK,CAACK,IAAI,CAACR,IAAI,CAAC,CAAA;oBAClB,CAAA;gBACF,CAAA;gBAEA,IAAIG,KAAK,CAACvE,MAAM,EAAE6M,IAAI,EAAE,CAAA;gBAExB1J,IAAI,CAAC8C,WAAW,CAAC2G,GAAG,CAAC,CAAA;YACvB,CAAA;QACF,CAAA;KACD,CAAA;AACH,CAAC,CAAC","ignoreList":[0,1,2]}},
    {"offset": {"line": 13213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13218, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-object-super/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport { types as t } from \"@babel/core\";\nimport type { File, NodePath } from \"@babel/core\";\n\nfunction replacePropertySuper(\n  path: NodePath<t.ObjectMethod>,\n  getObjectRef: () => t.Identifier,\n  file: File,\n) {\n  // @ts-expect-error todo(flow->ts):\n  const replaceSupers = new ReplaceSupers({\n    getObjectRef: getObjectRef,\n    methodPath: path,\n    file: file,\n  });\n\n  replaceSupers.replace();\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const newLets = new Set<{\n    scopePath: NodePath;\n    id: t.Identifier;\n  }>();\n\n  return {\n    name: \"transform-object-super\",\n\n    visitor: {\n      Loop: {\n        exit(path) {\n          newLets.forEach(v => {\n            if (v.scopePath === path) {\n              path.scope.push({\n                id: v.id,\n                kind: \"let\",\n              });\n              path.scope.crawl();\n              path.requeue();\n              newLets.delete(v);\n            }\n          });\n        },\n      },\n      ObjectExpression(path, state) {\n        let objectRef: t.Identifier;\n        const getObjectRef = () =>\n          (objectRef = objectRef || path.scope.generateUidIdentifier(\"obj\"));\n\n        path.get(\"properties\").forEach(propPath => {\n          if (!propPath.isMethod()) return;\n\n          replacePropertySuper(propPath, getObjectRef, state.file);\n        });\n\n        if (objectRef) {\n          const scopePath = path.findParent(\n            p => p.isFunction() || p.isProgram() || p.isLoop(),\n          );\n          const useLet = scopePath.isLoop();\n          // For transform-block-scoping\n          if (useLet) {\n            newLets.add({ scopePath, id: t.cloneNode(objectRef) });\n          } else {\n            path.scope.push({\n              id: t.cloneNode(objectRef),\n              kind: \"var\",\n            });\n          }\n\n          path.replaceWith(\n            t.assignmentExpression(\"=\", t.cloneNode(objectRef), path.node),\n          );\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperReplaceSupers","_core","replacePropertySuper","path","getObjectRef","file","replaceSupers","ReplaceSupers","methodPath","replace","_default","exports","default","declare","api","assertVersion","newLets","Set","name","visitor","Loop","exit","forEach","v","scopePath","scope","push","id","kind","crawl","requeue","delete","ObjectExpression","state","objectRef","generateUidIdentifier","get","propPath","isMethod","findParent","p","isFunction","isProgram","isLoop","useLet","add","t","cloneNode","replaceWith","assignmentExpression","node"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,oBAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAGA,SAASG,oBAAoBA,CAC3BC,IAA8B,EAC9BC,YAAgC,EAChCC,IAAU,EACV;IAEA,MAAMC,aAAa,GAAG,IAAIC,qBAAAA,OAAa,CAAC;QACtCH,YAAY,EAAEA,YAAY;QAC1BI,UAAU,EAAEL,IAAI;QAChBE,IAAI,EAAEA;IACR,CAAC,CAAC;IAEFC,aAAa,CAACG,OAAO,CAAC,CAAC;AACzB;AAAC,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEc,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IACtC,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAGpB,CAAC;IAEJ,OAAO;QACLC,IAAI,EAAE,wBAAwB;QAE9BC,OAAO,EAAE;YACPC,IAAI,EAAE;gBACJC,IAAIA,EAAClB,IAAI,EAAE;oBACTa,OAAO,CAACM,OAAO,EAACC,CAAC,IAAI;wBACnB,IAAIA,CAAC,CAACC,SAAS,KAAKrB,IAAI,EAAE;4BACxBA,IAAI,CAACsB,KAAK,CAACC,IAAI,CAAC;gCACdC,EAAE,EAAEJ,CAAC,CAACI,EAAE;gCACRC,IAAI,EAAE;4BACR,CAAC,CAAC;4BACFzB,IAAI,CAACsB,KAAK,CAACI,KAAK,CAAC,CAAC;4BAClB1B,IAAI,CAAC2B,OAAO,CAAC,CAAC;4BACdd,OAAO,CAACe,MAAM,CAACR,CAAC,CAAC;wBACnB;oBACF,CAAC,CAAC;gBACJ;YACF,CAAC;YACDS,gBAAgBA,EAAC7B,IAAI,EAAE8B,KAAK,EAAE;gBAC5B,IAAIC,SAAuB;gBAC3B,MAAM9B,YAAY,GAAGA,CAAA,GAClB8B,SAAS,GAAGA,SAAS,IAAI/B,IAAI,CAACsB,KAAK,CAACU,qBAAqB,CAAC,KAAK,CAAE;gBAEpEhC,IAAI,CAACiC,GAAG,CAAC,YAAY,CAAC,CAACd,OAAO,EAACe,QAAQ,IAAI;oBACzC,IAAI,CAACA,QAAQ,CAACC,QAAQ,CAAC,CAAC,EAAE;oBAE1BpC,oBAAoB,CAACmC,QAAQ,EAAEjC,YAAY,EAAE6B,KAAK,CAAC5B,IAAI,CAAC;gBAC1D,CAAC,CAAC;gBAEF,IAAI6B,SAAS,EAAE;oBACb,MAAMV,SAAS,GAAGrB,IAAI,CAACoC,UAAU,EAC/BC,CAAC,GAAIA,CAAC,CAACC,UAAU,CAAC,CAAC,IAAID,CAAC,CAACE,SAAS,CAAC,CAAC,IAAIF,CAAC,CAACG,MAAM,CAAC,CACnD,CAAC;oBACD,MAAMC,MAAM,GAAGpB,SAAS,CAACmB,MAAM,CAAC,CAAC;oBAEjC,IAAIC,MAAM,EAAE;wBACV5B,OAAO,CAAC6B,GAAG,CAAC;4BAAErB,SAAS;4BAAEG,EAAE,EAAEmB,MAAAA,KAAC,CAACC,SAAS,CAACb,SAAS;wBAAE,CAAC,CAAC;oBACxD,CAAC,MAAM;wBACL/B,IAAI,CAACsB,KAAK,CAACC,IAAI,CAAC;4BACdC,EAAE,EAAEmB,MAAAA,KAAC,CAACC,SAAS,CAACb,SAAS,CAAC;4BAC1BN,IAAI,EAAE;wBACR,CAAC,CAAC;oBACJ;oBAEAzB,IAAI,CAAC6C,WAAW,CACdF,MAAAA,KAAC,CAACG,oBAAoB,CAAC,GAAG,EAAEH,MAAAA,KAAC,CAACC,SAAS,CAACb,SAAS,CAAC,EAAE/B,IAAI,CAAC+C,IAAI,CAC/D,CAAC;gBACH;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13287, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-optional-catch-binding/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-optional-catch-binding\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"optionalCatchBinding\"),\n\n    visitor: {\n      CatchClause(path) {\n        if (!path.node.param) {\n          const uid = path.scope.generateUidIdentifier(\"unused\");\n          const paramPath = path.get(\"param\");\n          paramPath.replaceWith(uid);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_default","exports","default","declare","api","assertVersion","name","manipulateOptions","_","parser","plugins","push","visitor","CatchClause","path","node","param","uid","scope","generateUidIdentifier","paramPath","get","replaceWith"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAAqD,IAAAC,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,kCAAkC;QACxCC,iBAAiB,EAEbA,CAACC,CAAC,EAAEC,MAAM,GAAKA,MAAM,CAACC,OAAO,CAACC,IAAI,CAAC,sBAAsB,CAAC;QAE9DC,OAAO,EAAE;YACPC,WAAWA,EAACC,IAAI,EAAE;gBAChB,IAAI,CAACA,IAAI,CAACC,IAAI,CAACC,KAAK,EAAE;oBACpB,MAAMC,GAAG,GAAGH,IAAI,CAACI,KAAK,CAACC,qBAAqB,CAAC,QAAQ,CAAC;oBACtD,MAAMC,SAAS,GAAGN,IAAI,CAACO,GAAG,CAAC,OAAO,CAAC;oBACnCD,SAAS,CAACE,WAAW,CAACL,GAAG,CAAC;gBAC5B;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13309, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13314, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-optional-chaining/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-optional-chaining/src/transform.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-optional-chaining/src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/core\";\nimport { isTransparentExprWrapper } from \"@babel/helper-skip-transparent-expression-wrappers\";\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n * It respects transparent expression wrappers defined in\n * \"@babel/helper-skip-transparent-expression-wrappers\"\n *\n * @example\n * // returns true\n * const nodePathADotB = NodePath(\"if (a.b) {}\").get(\"test\"); // a.b\n * willPathCastToBoolean(nodePathADotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a.b\"))\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n\n/**\n * Return the outermost transparent expression wrapper of a given path,\n * otherwise returns path itself.\n * @example\n * const nodePathADotB = NodePath(\"(a.b as any)\").get(\"expression\"); // a.b\n * // returns NodePath(\"(a.b as any)\")\n * findOutermostTransparentParent(nodePathADotB);\n * @param {NodePath} path\n * @returns {NodePath}\n */\nexport function findOutermostTransparentParent(path: NodePath): NodePath {\n  let maybeWrapped = path;\n  path.findParent(p => {\n    if (!isTransparentExprWrapper(p.node)) return true;\n    maybeWrapped = p;\n  });\n  return maybeWrapped;\n}\n","import { types as t, template, type NodePath } from \"@babel/core\";\nimport {\n  skipTransparentExprWrapperNodes,\n  skipTransparentExprWrappers,\n} from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport {\n  willPathCastToBoolean,\n  findOutermostTransparentParent,\n} from \"./util.ts\";\n\n// TODO(Babel 9): Use .at(-1)\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isSimpleMemberExpression(\n  expression: t.Expression | t.Super,\n): expression is t.Identifier | t.Super | t.MemberExpression {\n  expression = skipTransparentExprWrapperNodes(expression);\n  return (\n    t.isIdentifier(expression) ||\n    t.isSuper(expression) ||\n    (t.isMemberExpression(expression) &&\n      !expression.computed &&\n      isSimpleMemberExpression(expression.object))\n  );\n}\n\n/**\n * Test if a given optional chain `path` needs to be memoized\n * @param {NodePath} path\n * @returns {boolean}\n */\nfunction needsMemoize(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n) {\n  let optionalPath: NodePath = path;\n  const { scope } = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    const childPath = skipTransparentExprWrappers(\n      optionalPath.isOptionalMemberExpression()\n        ? optionalPath.get(\"object\")\n        : optionalPath.get(\"callee\"),\n    );\n    if (node.optional) {\n      return !scope.isStatic(childPath.node);\n    }\n\n    optionalPath = childPath;\n  }\n}\n\nconst NULLISH_CHECK = template.expression(\n  `%%check%% === null || %%ref%% === void 0`,\n);\nconst NULLISH_CHECK_NO_DDA = template.expression(`%%check%% == null`);\nconst NULLISH_CHECK_NEG = template.expression(\n  `%%check%% !== null && %%ref%% !== void 0`,\n);\nconst NULLISH_CHECK_NO_DDA_NEG = template.expression(`%%check%% != null`);\n\ninterface OptionalChainAssumptions {\n  pureGetters: boolean;\n  noDocumentAll: boolean;\n}\n\nexport function transformOptionalChain(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  { pureGetters, noDocumentAll }: OptionalChainAssumptions,\n  replacementPath: NodePath<t.Expression>,\n  ifNullish: t.Expression,\n  wrapLast?: (value: t.Expression) => t.Expression,\n) {\n  const { scope } = path;\n\n  // Replace `function (a, x = a.b?.c) {}` to `function (a, x = (() => a.b?.c)() ){}`\n  // so the temporary variable can be injected in correct scope\n  if (scope.path.isPattern() && needsMemoize(path)) {\n    replacementPath.replaceWith(\n      template.expression.ast`(() => ${replacementPath.node})()`,\n    );\n    // The injected optional chain will be queued and eventually transformed when visited\n    return;\n  }\n\n  const optionals = [];\n\n  let optionalPath = path;\n  while (\n    optionalPath.isOptionalMemberExpression() ||\n    optionalPath.isOptionalCallExpression()\n  ) {\n    const { node } = optionalPath;\n    if (node.optional) {\n      optionals.push(node);\n    }\n    if (optionalPath.isOptionalMemberExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"MemberExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      // @ts-expect-error todo(flow->ts) avoid changing more type\n      optionalPath.node.type = \"CallExpression\";\n      // @ts-expect-error todo(flow->ts)\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    }\n  }\n\n  if (optionals.length === 0) {\n    // Malformed AST: there was an OptionalMemberExpression node\n    // with no actual optional elements.\n    return;\n  }\n\n  const checks = [];\n\n  let tmpVar;\n\n  for (let i = optionals.length - 1; i >= 0; i--) {\n    const node = optionals[i] as unknown as\n      | t.MemberExpression\n      | t.CallExpression;\n\n    const isCall = t.isCallExpression(node);\n\n    const chainWithTypes = isCall\n      ? // V8 intrinsics must not be an optional call\n        (node.callee as t.Expression)\n      : node.object;\n    const chain = skipTransparentExprWrapperNodes(chainWithTypes);\n\n    let ref;\n    let check;\n    if (isCall && t.isIdentifier(chain, { name: \"eval\" })) {\n      check = ref = chain;\n      // `eval?.()` is an indirect eval call transformed to `(0,eval)()`\n      node.callee = t.sequenceExpression([t.numericLiteral(0), ref]);\n    } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {\n      // If we assume getters are pure (avoiding a Function#call) and we are at the call,\n      // we can avoid a needless memoize. We only do this if the callee is a simple member\n      // expression, to avoid multiple calls to nested call expressions.\n      check = ref = node.callee;\n    } else if (scope.isStatic(chain)) {\n      check = ref = chainWithTypes;\n    } else {\n      // We cannot reuse the tmpVar for calls, because we need to\n      // store both the method and the receiver.\n      if (!tmpVar || isCall) {\n        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);\n        scope.push({ id: t.cloneNode(tmpVar) });\n      }\n      ref = tmpVar;\n      check = t.assignmentExpression(\n        \"=\",\n        t.cloneNode(tmpVar),\n        // Here `chainWithTypes` MUST NOT be cloned because it could be\n        // updated when generating the memoised context of a call\n        // expression. It must be an Expression when `ref` is an identifier\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        chainWithTypes as t.Expression,\n      );\n\n      if (isCall) {\n        node.callee = ref;\n      } else {\n        node.object = ref;\n      }\n    }\n\n    // Ensure call expressions have the proper `this`\n    // `foo.bar()` has context `foo`.\n    if (isCall && t.isMemberExpression(chain)) {\n      if (pureGetters && isSimpleMemberExpression(chain)) {\n        // To avoid a Function#call, we can instead re-grab the property from the context object.\n        // `a.?b.?()` translates roughly to `_a.b != null && _a.b()`\n        node.callee = chainWithTypes;\n      } else {\n        // Otherwise, we need to memoize the context object, and change the call into a Function#call.\n        // `a.?b.?()` translates roughly to `(_b = _a.b) != null && _b.call(_a)`\n        const { object } = chain;\n        let context: t.Expression;\n        if (t.isSuper(object)) {\n          context = t.thisExpression();\n        } else {\n          const memoized = scope.maybeGenerateMemoised(object);\n          if (memoized) {\n            context = memoized;\n            chain.object = t.assignmentExpression(\"=\", memoized, object);\n          } else {\n            context = object;\n          }\n        }\n\n        node.arguments.unshift(t.cloneNode(context));\n        // @ts-expect-error node.callee can not be an V8IntrinsicIdentifier: V8 intrinsic is disallowed in optional chain\n        node.callee = t.memberExpression(node.callee, t.identifier(\"call\"));\n      }\n    }\n\n    const data = { check: t.cloneNode(check), ref: t.cloneNode(ref) };\n    // We make `ref` non-enumerable, so that @babel/template doesn't throw\n    // in the noDocumentAll template if it's not used.\n    Object.defineProperty(data, \"ref\", { enumerable: false });\n    checks.push(data);\n  }\n\n  let result = replacementPath.node;\n  if (wrapLast) result = wrapLast(result);\n\n  const ifNullishBoolean = t.isBooleanLiteral(ifNullish);\n  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;\n  const ifNullishVoid =\n    !ifNullishBoolean && t.isUnaryExpression(ifNullish, { operator: \"void\" });\n\n  const isEvaluationValueIgnored =\n    (t.isExpressionStatement(replacementPath.parent) &&\n      !replacementPath.isCompletionRecord()) ||\n    (t.isSequenceExpression(replacementPath.parent) &&\n      last(replacementPath.parent.expressions) !== replacementPath.node);\n\n  // prettier-ignore\n  const tpl = ifNullishFalse\n    ? (noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG)\n    : (noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK);\n  const logicalOp = ifNullishFalse ? \"&&\" : \"||\";\n\n  const check = checks\n    .map(tpl)\n    .reduce((expr, check) => t.logicalExpression(logicalOp, expr, check));\n\n  replacementPath.replaceWith(\n    ifNullishBoolean || (ifNullishVoid && isEvaluationValueIgnored)\n      ? t.logicalExpression(logicalOp, check, result)\n      : t.conditionalExpression(check, ifNullish, result),\n  );\n}\n\nexport function transform(\n  path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n  assumptions: OptionalChainAssumptions,\n) {\n  const { scope } = path;\n\n  // maybeWrapped points to the outermost transparent expression wrapper\n  // or the path itself\n  const maybeWrapped = findOutermostTransparentParent(path);\n  const { parentPath } = maybeWrapped;\n\n  if (parentPath.isUnaryExpression({ operator: \"delete\" })) {\n    transformOptionalChain(\n      path,\n      assumptions,\n      parentPath,\n      t.booleanLiteral(true),\n    );\n  } else {\n    let wrapLast;\n    if (\n      parentPath.isCallExpression({ callee: maybeWrapped.node }) &&\n      // note that the first condition must implies that `path.optional` is `true`,\n      // otherwise the parentPath should be an OptionalCallExpression\n      path.isOptionalMemberExpression()\n    ) {\n      // Ensure (a?.b)() has proper `this`\n      wrapLast = (replacement: t.MemberExpression) => {\n        // `(a?.b)()` to `(a == null ? undefined : a.b.bind(a))()`\n        // object must not be Super as super?.foo is invalid\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        const object = skipTransparentExprWrapperNodes(\n          replacement.object,\n        ) as t.Expression;\n        let baseRef: t.Expression;\n        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {\n          // memoize the context object when getters are not always pure\n          // or the object is not a simple member expression\n          // `(a?.b.c)()` to `(a == null ? undefined : (_a$b = a.b).c.bind(_a$b))()`\n          baseRef = scope.maybeGenerateMemoised(object);\n          if (baseRef) {\n            replacement.object = t.assignmentExpression(\"=\", baseRef, object);\n          }\n        }\n        return t.callExpression(\n          t.memberExpression(replacement, t.identifier(\"bind\")),\n          [t.cloneNode(baseRef ?? object)],\n        );\n      };\n    }\n\n    transformOptionalChain(\n      path,\n      assumptions,\n      path,\n      willPathCastToBoolean(maybeWrapped)\n        ? t.booleanLiteral(false)\n        : scope.buildUndefinedNode(),\n      wrapLast,\n    );\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { transform, transformOptionalChain } from \"./transform.ts\";\nimport type { NodePath, types as t } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { loose = false } = options;\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n\n  return {\n    name: \"transform-optional-chaining\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"optionalChaining\"),\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(\n        path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n      ) {\n        transform(path, { noDocumentAll, pureGetters });\n      },\n    },\n  };\n});\n\nexport { transform, transformOptionalChain };\n"],"names":["willPathCastToBoolean","path","maybeWrapped","findOutermostTransparentParent","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","findParent","p","isTransparentExprWrapper","last","arr","isSimpleMemberExpression","expression","skipTransparentExprWrapperNodes","t","isIdentifier","isSuper","isMemberExpression","computed","object","needsMemoize","optionalPath","scope","isOptionalMemberExpression","isOptionalCallExpression","childPath","skipTransparentExprWrappers","get","optional","isStatic","NULLISH_CHECK","template","NULLISH_CHECK_NO_DDA","NULLISH_CHECK_NEG","NULLISH_CHECK_NO_DDA_NEG","transformOptionalChain","pureGetters","noDocumentAll","replacementPath","ifNullish","wrapLast","isPattern","replaceWith","ast","optionals","push","type","checks","tmpVar","i","isCall","isCallExpression","chainWithTypes","callee","chain","ref","check","name","sequenceExpression","numericLiteral","generateUidIdentifierBasedOnNode","id","cloneNode","assignmentExpression","context","thisExpression","memoized","maybeGenerateMemoised","arguments","unshift","memberExpression","identifier","data","Object","defineProperty","enumerable","result","ifNullishBoolean","isBooleanLiteral","ifNullishFalse","value","ifNullishVoid","isEvaluationValueIgnored","isExpressionStatement","parent","isCompletionRecord","tpl","logicalOp","map","reduce","expr","logicalExpression","conditionalExpression","transform","assumptions","booleanLiteral","replacement","_baseRef","baseRef","callExpression","buildUndefinedNode","declare","api","options","_api$assumption","_api$assumption2","assertVersion","loose","assumption","manipulateOptions","_","parser","plugins","visitor","OptionalCallExpression|OptionalMemberExpression"],"mappings":"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","ignoreList":[0,1,2]}},
    {"offset": {"line": 13531, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13536, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-private-methods/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\n\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  createClassFeaturePlugin,\n  FEATURES,\n} from \"@babel/helper-create-class-features-plugin\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return createClassFeaturePlugin({\n    name: \"transform-private-methods\",\n\n    api,\n    feature: FEATURES.privateMethods,\n    loose: options.loose,\n\n    manipulateOptions(opts, parserOpts) {\n      if (!process.env.BABEL_8_BREAKING) {\n        // @ts-ignore(Babel 7 vs Babel 8) This plugin has been removed\n        parserOpts.plugins.push(\"classPrivateMethods\");\n      }\n    },\n  });\n});\n"],"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","_default","exports","default","declare","api","options","assertVersion","createClassFeaturePlugin","name","feature","FEATURES","privateMethods","loose","manipulateOptions","opts","parserOpts","plugins","push"],"mappings":";;;;;AAEA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,gCAAA,GAAAD,OAAA;AAGoD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMrC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAChDD,GAAG,CAACE,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO,CAAA,GAAAC,iCAAAA,wBAAwB,EAAC;QAC9BC,IAAI,EAAE,2BAA2B;QAEjCJ,GAAG;QACHK,OAAO,EAAEC,iCAAAA,QAAQ,CAACC,cAAc;QAChCC,KAAK,EAAEP,OAAO,CAACO,KAAK;QAEpBC,iBAAiBA,EAACC,IAAI,EAAEC,UAAU,EAAE;YACC;gBAEjCA,UAAU,CAACC,OAAO,CAACC,IAAI,CAAC,qBAAqB,CAAC;YAChD;QACF;IACF,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13562, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-private-property-in-object/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type { NodePath, Scope, types as t } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let constructorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, constructorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<t.Node, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expression: t.Expression,\n      before?: boolean,\n    ) => void,\n  ) {\n    let id = weakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      annotateAsPure(newExpr);\n\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"transform-private-property-in-object\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"privateIn\"),\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const { node } = path;\n        const { file } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n\n        const { name } = node.left.id;\n\n        let privateElement: NodePath<\n          t.ClassPrivateMethod | t.ClassPrivateProperty\n        >;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n\n          privateElement = path.get(\"body.body\").find(\n            ({ node }) =>\n              // fixme: Support class accessor property\n              t.isPrivate(node) && node.key.id.name === name,\n          ) as NodePath<t.ClassPrivateMethod | t.ClassPrivateProperty>;\n\n          return !!privateElement;\n        }) as NodePath<t.Class>;\n\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(\n            template.ast`(() => ${outerClass.node})()` as t.Statement,\n          );\n          // The injected class will be queued and eventually transformed when visited\n          return;\n        }\n\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(\n              template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${buildCheckInRHS(\n                  node.right,\n                  file,\n                )}\n              `,\n            );\n          } else {\n            const id = getWeakSetId(\n              classWeakSets,\n              outerClass,\n              outerClass,\n              outerClass.node.id?.name,\n              injectInitialization,\n            );\n\n            path.replaceWith(\n              template.expression.ast`${id}.has(${buildCheckInRHS(\n                node.right,\n                file,\n              )})`,\n            );\n          }\n        } else {\n          // Private fields might not all be initialized: see the 'halfConstructed'\n          // example at https://v8.dev/features/private-brand-checks.\n\n          const id = getWeakSetId<t.ClassPrivateProperty>(\n            fieldsWeakSets,\n            outerClass,\n            privateElement as NodePath<t.ClassPrivateProperty>,\n            privateElement.node.key.id.name,\n            injectToFieldInit,\n          );\n\n          path.replaceWith(\n            template.expression.ast`${id}.has(${buildCheckInRHS(\n              node.right,\n              file,\n            )})`,\n          );\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","_helperAnnotateAsPure","_default","exports","default","declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","constructorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","injectConstructorInit","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","annotateAsPure","manipulateOptions","_","parser","plugins","push","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right","_outerClass$node$id"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 13674, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13679, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-property-literals/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-property-literals\",\n\n    visitor: {\n      ObjectProperty: {\n        exit({ node }) {\n          const key = node.key;\n          if (\n            !node.computed &&\n            t.isIdentifier(key) &&\n            !t.isValidES3Identifier(key.name)\n          ) {\n            // default: \"bar\" -> \"default\": \"bar\"\n            node.key = t.stringLiteral(key.name);\n          }\n        },\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","ObjectProperty","exit","node","key","computed","t","isIdentifier","isValidES3Identifier","stringLiteral"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,6BAA6B;QAEnCC,OAAO,EAAE;YACPC,cAAc,EAAE;gBACdC,IAAIA,EAAC,EAAEC,IAAAA,EAAM,EAAE;oBACb,MAAMC,GAAG,GAAGD,IAAI,CAACC,GAAG;oBACpB,IACE,CAACD,IAAI,CAACE,QAAQ,IACdC,MAAAA,KAAC,CAACC,YAAY,CAACH,GAAG,CAAC,IACnB,CAACE,MAAAA,KAAC,CAACE,oBAAoB,CAACJ,GAAG,CAACL,IAAI,CAAC,EACjC;wBAEAI,IAAI,CAACC,GAAG,GAAGE,MAAAA,KAAC,CAACG,aAAa,CAACL,GAAG,CAACL,IAAI,CAAC;oBACtC;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13702, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13707, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/runtime/helpers/interopRequireDefault.js"],"sourcesContent":["function _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":[],"mappings":"AAAA,SAAS,uBAAuB,CAAC;IAC/B,OAAO,KAAK,EAAE,UAAU,GAAG,IAAI;QAC7B,WAAW;IACb;AACF;AACA,OAAO,OAAO,GAAG,wBAAwB,OAAO,OAAO,CAAC,UAAU,GAAG,MAAM,OAAO,OAAO,CAAC,UAAU,GAAG,OAAO,OAAO","ignoreList":[0]}},
    {"offset": {"line": 13713, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13718, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-regenerator/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t } from \"@babel/core\";\nimport regeneratorTransform from \"regenerator-transform\";\n\nexport default declare(({ types: t, assertVersion }) => {\n  assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-regenerator\",\n\n    inherits: regeneratorTransform.default,\n\n    visitor: {\n      // We visit CallExpression so that we always transform\n      // regeneratorRuntime.*() before babel-plugin-polyfill-regenerator.\n      CallExpression(path) {\n        if (!process.env.BABEL_8_BREAKING) {\n          if (!this.availableHelper?.(\"regeneratorRuntime\")) {\n            // When using an older @babel/helpers version, fallback\n            // to the old behavior.\n            // TODO: Remove this in Babel 8.\n            return;\n          }\n        }\n\n        const callee = path.get(\"callee\");\n        if (!callee.isMemberExpression()) return;\n\n        const obj = callee.get(\"object\");\n        if (obj.isIdentifier({ name: \"regeneratorRuntime\" })) {\n          const helper = this.addHelper(\"regeneratorRuntime\") as\n            | t.Identifier\n            | t.ArrowFunctionExpression;\n\n          if (!process.env.BABEL_8_BREAKING) {\n            if (\n              // TODO: Remove this in Babel 8, it's necessary to\n              // avoid the IIFE when using older Babel versions.\n              t.isArrowFunctionExpression(helper)\n            ) {\n              obj.replaceWith(helper.body);\n              return;\n            }\n          }\n\n          obj.replaceWith(t.callExpression(helper, []));\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_regeneratorTransform","_default","exports","default","declare","types","t","assertVersion","name","inherits","regeneratorTransform","visitor","CallExpression","path","_this$availableHelper","availableHelper","call","callee","get","isMemberExpression","obj","isIdentifier","helper","addHelper","isArrowFunctionExpression","replaceWith","body","callExpression"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAEA,IAAAC,qBAAA,GAAAD,OAAA;AAAyD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1C,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAAC,EAAEC,KAAK,EAAEC,CAAC,EAAEC,aAAAA,EAAe,KAAK;IACtDA,aAAa,CAAkB,CAAE,CAAC;IAElC,OAAO;QACLC,IAAI,EAAE,uBAAuB;QAE7BC,QAAQ,EAAEC,qBAAoB,CAACP,OAAO;QAEtCQ,OAAO,EAAE;YAGPC,cAAcA,EAACC,IAAI,EAAE;gBACgB;oBAAA,IAAAC,qBAAA;oBACjC,IAAI,CAAA,CAAA,CAAAA,qBAAA,GAAC,IAAI,CAACC,eAAe,KAAA,QAApBD,qBAAA,CAAAE,IAAA,CAAA,IAAI,EAAmB,oBAAoB,CAAC,GAAE;wBAIjD;oBACF;gBACF;gBAEA,MAAMC,MAAM,GAAGJ,IAAI,CAACK,GAAG,CAAC,QAAQ,CAAC;gBACjC,IAAI,CAACD,MAAM,CAACE,kBAAkB,CAAC,CAAC,EAAE;gBAElC,MAAMC,GAAG,GAAGH,MAAM,CAACC,GAAG,CAAC,QAAQ,CAAC;gBAChC,IAAIE,GAAG,CAACC,YAAY,CAAC;oBAAEb,IAAI,EAAE;gBAAqB,CAAC,CAAC,EAAE;oBACpD,MAAMc,MAAM,GAAG,IAAI,CAACC,SAAS,CAAC,oBAAoB,CAErB;oBAEM;wBACjC,IAGEjB,CAAC,CAACkB,yBAAyB,CAACF,MAAM,CAAC,EACnC;4BACAF,GAAG,CAACK,WAAW,CAACH,MAAM,CAACI,IAAI,CAAC;4BAC5B;wBACF;oBACF;oBAEAN,GAAG,CAACK,WAAW,CAACnB,CAAC,CAACqB,cAAc,CAACL,MAAM,EAAE,EAAE,CAAC,CAAC;gBAC/C;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13757, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13762, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-regexp-modifiers/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.19.0\"));\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-regexp-modifiers\",\n    feature: \"modifiers\",\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","assertVersion","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,qCAA4B,CAAC;IAE9C,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,4BAA4B;QAClCC,OAAO,EAAE;IACX,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13776, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13781, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-reserved-words/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-reserved-words\",\n\n    visitor: {\n      \"BindingIdentifier|ReferencedIdentifier\"(path: NodePath<t.Identifier>) {\n        if (!t.isValidES3Identifier(path.node.name)) {\n          path.scope.rename(path.node.name);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","BindingIdentifier|ReferencedIdentifier","path","t","isValidES3Identifier","node","scope","rename"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAwD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEzC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,0BAA0B;QAEhCC,OAAO,EAAE;YACP,wCAAwCC,EAACC,IAA4B,EAAE;gBACrE,IAAI,CAACC,MAAAA,KAAC,CAACC,oBAAoB,CAACF,IAAI,CAACG,IAAI,CAACN,IAAI,CAAC,EAAE;oBAC3CG,IAAI,CAACI,KAAK,CAACC,MAAM,CAACL,IAAI,CAACG,IAAI,CAACN,IAAI,CAAC;gBACnC;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13801, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13806, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-shorthand-properties/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-shorthand-properties\",\n\n    visitor: {\n      ObjectMethod(path) {\n        const { node } = path;\n        if (node.kind === \"method\") {\n          const func = t.functionExpression(\n            null,\n            node.params,\n            node.body,\n            node.generator,\n            node.async,\n          );\n          func.returnType = node.returnType;\n\n          const computedKey = t.toComputedKey(node);\n          if (t.isStringLiteral(computedKey, { value: \"__proto__\" })) {\n            path.replaceWith(t.objectProperty(computedKey, func, true));\n          } else {\n            path.replaceWith(t.objectProperty(node.key, func, node.computed));\n          }\n        }\n      },\n\n      ObjectProperty(path) {\n        const { node } = path;\n        if (node.shorthand) {\n          const computedKey = t.toComputedKey(node);\n          if (t.isStringLiteral(computedKey, { value: \"__proto__\" })) {\n            path.replaceWith(t.objectProperty(computedKey, node.value, true));\n          } else {\n            node.shorthand = false;\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","ObjectMethod","path","node","kind","func","t","functionExpression","params","body","generator","async","returnType","computedKey","toComputedKey","isStringLiteral","value","replaceWith","objectProperty","key","computed","ObjectProperty","shorthand"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,gCAAgC;QAEtCC,OAAO,EAAE;YACPC,YAAYA,EAACC,IAAI,EAAE;gBACjB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI;gBACrB,IAAIC,IAAI,CAACC,IAAI,KAAK,QAAQ,EAAE;oBAC1B,MAAMC,IAAI,GAAGC,MAAAA,KAAC,CAACC,kBAAkB,CAC/B,IAAI,EACJJ,IAAI,CAACK,MAAM,EACXL,IAAI,CAACM,IAAI,EACTN,IAAI,CAACO,SAAS,EACdP,IAAI,CAACQ,KACP,CAAC;oBACDN,IAAI,CAACO,UAAU,GAAGT,IAAI,CAACS,UAAU;oBAEjC,MAAMC,WAAW,GAAGP,MAAAA,KAAC,CAACQ,aAAa,CAACX,IAAI,CAAC;oBACzC,IAAIG,MAAAA,KAAC,CAACS,eAAe,CAACF,WAAW,EAAE;wBAAEG,KAAK,EAAE;oBAAY,CAAC,CAAC,EAAE;wBAC1Dd,IAAI,CAACe,WAAW,CAACX,MAAAA,KAAC,CAACY,cAAc,CAACL,WAAW,EAAER,IAAI,EAAE,IAAI,CAAC,CAAC;oBAC7D,CAAC,MAAM;wBACLH,IAAI,CAACe,WAAW,CAACX,MAAAA,KAAC,CAACY,cAAc,CAACf,IAAI,CAACgB,GAAG,EAAEd,IAAI,EAAEF,IAAI,CAACiB,QAAQ,CAAC,CAAC;oBACnE;gBACF;YACF,CAAC;YAEDC,cAAcA,EAACnB,IAAI,EAAE;gBACnB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI;gBACrB,IAAIC,IAAI,CAACmB,SAAS,EAAE;oBAClB,MAAMT,WAAW,GAAGP,MAAAA,KAAC,CAACQ,aAAa,CAACX,IAAI,CAAC;oBACzC,IAAIG,MAAAA,KAAC,CAACS,eAAe,CAACF,WAAW,EAAE;wBAAEG,KAAK,EAAE;oBAAY,CAAC,CAAC,EAAE;wBAC1Dd,IAAI,CAACe,WAAW,CAACX,MAAAA,KAAC,CAACY,cAAc,CAACL,WAAW,EAAEV,IAAI,CAACa,KAAK,EAAE,IAAI,CAAC,CAAC;oBACnE,CAAC,MAAM;wBACLb,IAAI,CAACmB,SAAS,GAAG,KAAK;oBACxB;gBACF;YACF;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 13849, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 13854, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-spread/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { types as t, template } from \"@babel/core\";\nimport type { File, NodePath, Scope } from \"@babel/core\";\n\ntype ListElement = t.SpreadElement | t.Expression;\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const iterableIsArray = api.assumption(\"iterableIsArray\") ?? options.loose;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(\n    spread: t.SpreadElement,\n    scope: Scope,\n  ): t.Expression {\n    if (\n      iterableIsArray &&\n      !t.isIdentifier(spread.argument, { name: \"arguments\" })\n    ) {\n      return spread.argument;\n    } else {\n      const node = spread.argument;\n\n      if (t.isIdentifier(node)) {\n        const binding = scope.getBinding(node.name);\n        if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n          return node;\n        }\n      }\n\n      if (t.isArrayExpression(node)) {\n        return node;\n      }\n\n      if (t.isIdentifier(node, { name: \"arguments\" })) {\n        return template.expression.ast`\n          Array.prototype.slice.call(${node})\n        `;\n      }\n\n      const args = [node];\n      let helperName = \"toConsumableArray\";\n\n      if (arrayLikeIsIterable) {\n        args.unshift(scope.path.hub.addHelper(helperName));\n        helperName = \"maybeArrayLike\";\n      }\n\n      return t.callExpression(scope.path.hub.addHelper(helperName), args);\n    }\n  }\n\n  function hasHole(spread: t.ArrayExpression): boolean {\n    return spread.elements.includes(null);\n  }\n\n  function hasSpread(nodes: Array<t.Node>): boolean {\n    for (let i = 0; i < nodes.length; i++) {\n      if (t.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function push(_props: Array<ListElement>, nodes: Array<t.Expression>) {\n    if (!_props.length) return _props;\n    nodes.push(t.arrayExpression(_props));\n    return [];\n  }\n\n  function build(\n    props: Array<ListElement>,\n    scope: Scope,\n    file: File,\n  ): t.Expression[] {\n    const nodes: Array<t.Expression> = [];\n    let _props: Array<ListElement> = [];\n\n    for (const prop of props) {\n      if (t.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (t.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = t.callExpression(\n            file.addHelper(\n              process.env.BABEL_8_BREAKING\n                ? \"arrayLikeToArray\"\n                : \"arrayWithoutHoles\",\n            ),\n            [spreadLiteral],\n          );\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n\n    visitor: {\n      ArrayExpression(path): void {\n        const { node, scope } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n\n        // If there is only one element in the ArrayExpression and\n        // the element was transformed (Array.prototype.slice.call or toConsumableArray)\n        // we know that the transformed code already takes care of cloning the array.\n        // So we can simply return that element.\n        if (\n          nodes.length === 1 &&\n          first !== (elements[0] as t.SpreadElement).argument\n        ) {\n          path.replaceWith(first);\n          return;\n        }\n\n        // If the first element is a ArrayExpression we can directly call\n        // concat on it.\n        // `[..].concat(..)`\n        // If not then we have to use `[].concat(arr)` and not `arr.concat`\n        // because `arr` could be extended/modified (e.g. Immutable) and we do not know exactly\n        // what concat would produce.\n        if (!t.isArrayExpression(first)) {\n          first = t.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          ),\n        );\n      },\n      CallExpression(path): void {\n        const { node, scope } = path;\n\n        const args = node.arguments as Array<ListElement>;\n        if (!hasSpread(args)) return;\n        const calleePath = skipTransparentExprWrappers(\n          path.get(\"callee\") as NodePath<t.Expression>,\n        );\n        if (calleePath.isSuper()) {\n          // NOTE: spread and classes have almost the same compat data, so this is very unlikely to happen in practice.\n          throw path.buildCodeFrameError(\n            \"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" +\n              \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n          );\n        }\n        let contextLiteral: t.Expression | t.Super = scope.buildUndefinedNode();\n        node.arguments = [];\n\n        let nodes: t.Expression[];\n        if (\n          args.length === 1 &&\n          t.isIdentifier((args[0] as t.SpreadElement).argument, {\n            name: \"arguments\",\n          })\n        ) {\n          nodes = [(args[0] as t.SpreadElement).argument];\n        } else {\n          nodes = build(args, scope, this.file);\n        }\n\n        const first = nodes.shift();\n        if (nodes.length) {\n          node.arguments.push(\n            t.callExpression(\n              t.memberExpression(first, t.identifier(\"concat\")),\n              nodes,\n            ),\n          );\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = calleePath.node as t.MemberExpression;\n\n        if (t.isMemberExpression(callee)) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n          if (temp) {\n            callee.object = t.assignmentExpression(\n              \"=\",\n              temp,\n              // object must not be Super when `temp` is an identifier\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n              callee.object as t.Expression,\n            );\n            contextLiteral = temp;\n          } else {\n            contextLiteral = t.cloneNode(callee.object);\n          }\n        }\n\n        // We use the original callee here, to preserve any types/parentheses\n        node.callee = t.memberExpression(\n          node.callee as t.Expression,\n          t.identifier(\"apply\"),\n        );\n        if (t.isSuper(contextLiteral)) {\n          contextLiteral = t.thisExpression();\n        }\n\n        node.arguments.unshift(t.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path): void {\n        const { node, scope } = path;\n        if (!hasSpread(node.arguments)) return;\n\n        const nodes = build(\n          node.arguments as Array<ListElement>,\n          scope,\n          this.file,\n        );\n\n        const first = nodes.shift();\n\n        let args: t.Expression;\n        if (nodes.length) {\n          args = t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          );\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(\n          t.callExpression(path.hub.addHelper(\"construct\"), [\n            node.callee as t.Expression,\n            args,\n          ]),\n        );\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_helperSkipTransparentExpressionWrappers","_core","_default","exports","default","declare","api","options","_api$assumption","_options$allowArrayLi","assertVersion","iterableIsArray","assumption","loose","arrayLikeIsIterable","allowArrayLike","getSpreadLiteral","spread","scope","t","isIdentifier","argument","name","node","binding","getBinding","constant","path","isGenericType","isArrayExpression","template","expression","ast","args","helperName","unshift","hub","addHelper","callExpression","hasHole","elements","includes","hasSpread","nodes","i","length","isSpreadElement","push","_props","arrayExpression","build","props","file","prop","spreadLiteral","visitor","ArrayExpression","first","replaceWith","shift","memberExpression","identifier","CallExpression","arguments","calleePath","skipTransparentExprWrappers","get","isSuper","buildCodeFrameError","contextLiteral","buildUndefinedNode","callee","isMemberExpression","temp","maybeGenerateMemoised","object","assignmentExpression","cloneNode","thisExpression","NewExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14018, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14023, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-sticky-regex/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-sticky-regex\",\n\n    visitor: {\n      RegExpLiteral(path) {\n        const { node } = path;\n        if (!node.flags.includes(\"y\")) return;\n\n        path.replaceWith(\n          t.newExpression(t.identifier(\"RegExp\"), [\n            t.stringLiteral(node.pattern),\n            t.stringLiteral(node.flags),\n          ]),\n        );\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","RegExpLiteral","path","node","flags","includes","replaceWith","t","newExpression","identifier","stringLiteral","pattern"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AAAyC,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAE1B,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO;QACLC,IAAI,EAAE,wBAAwB;QAE9BC,OAAO,EAAE;YACPC,aAAaA,EAACC,IAAI,EAAE;gBAClB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI;gBACrB,IAAI,CAACC,IAAI,CAACC,KAAK,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAE/BH,IAAI,CAACI,WAAW,CACdC,MAAAA,KAAC,CAACC,aAAa,CAACD,MAAAA,KAAC,CAACE,UAAU,CAAC,QAAQ,CAAC,EAAE;oBACtCF,MAAAA,KAAC,CAACG,aAAa,CAACP,IAAI,CAACQ,OAAO,CAAC;oBAC7BJ,MAAAA,KAAC,CAACG,aAAa,CAACP,IAAI,CAACC,KAAK,CAAC;iBAC5B,CACH,CAAC;YACH;QACF;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 14046, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14051, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-template-literals/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t, type NodePath } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const ignoreToPrimitiveHint =\n    api.assumption(\"ignoreToPrimitiveHint\") ?? options.loose;\n  const mutableTemplateObject =\n    api.assumption(\"mutableTemplateObject\") ?? options.loose;\n\n  let helperName = \"taggedTemplateLiteral\";\n  if (mutableTemplateObject) helperName += \"Loose\";\n\n  /**\n   * This function groups the objects into multiple calls to `.concat()` in\n   * order to preserve execution order of the primitive conversion, e.g.\n   *\n   *   \"\".concat(obj.foo, \"foo\", obj2.foo, \"foo2\")\n   *\n   * would evaluate both member expressions _first_ then, `concat` will\n   * convert each one to a primitive, whereas\n   *\n   *   \"\".concat(obj.foo, \"foo\").concat(obj2.foo, \"foo2\")\n   *\n   * would evaluate the member, then convert it to a primitive, then evaluate\n   * the second member and convert that one, which reflects the spec behavior\n   * of template literals.\n   */\n  function buildConcatCallExpressions(items: t.Expression[]): t.CallExpression {\n    let avail = true;\n    // @ts-expect-error items must not be empty\n    return items.reduce(function (left, right) {\n      let canBeInserted = t.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n      if (canBeInserted && t.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n      return t.callExpression(\n        t.memberExpression(left, t.identifier(\"concat\")),\n        [right],\n      );\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const { node } = path;\n        const { quasi } = node;\n\n        const strings = [];\n        const raws = [];\n\n        // Flag variable to check if contents of strings and raw are equal\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const { raw, cooked } = elem.value;\n          const value =\n            cooked == null\n              ? path.scope.buildUndefinedNode()\n              : t.stringLiteral(cooked);\n\n          strings.push(value);\n          raws.push(t.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            // false even if one of raw and cooked are not equal\n            isStringsRawEqual = false;\n          }\n        }\n\n        const helperArgs = [t.arrayExpression(strings)];\n        // only add raw arrayExpression if there is any difference between raws and strings\n        if (!isStringsRawEqual) {\n          helperArgs.push(t.arrayExpression(raws));\n        }\n\n        const tmp = path.scope.generateUidIdentifier(\"templateObject\");\n        path.scope.getProgramParent().push({ id: t.cloneNode(tmp) });\n\n        path.replaceWith(\n          t.callExpression(node.tag, [\n            template.expression.ast`\n              ${t.cloneNode(tmp)} || (\n                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})\n              )\n            `,\n            // @ts-expect-error Fixme: quasi.expressions may contain TSAnyKeyword\n            ...quasi.expressions,\n          ]),\n        );\n      },\n\n      TemplateLiteral(path) {\n        // Skip TemplateLiteral in TSLiteralType\n        if (path.parent.type === \"TSLiteralType\") {\n          return;\n        }\n        const nodes: t.Expression[] = [];\n        const expressions = path.get(\"expressions\") as NodePath<t.Expression>[];\n\n        let index = 0;\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(t.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n            if (!t.isStringLiteral(node, { value: \"\" })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n          !t.isStringLiteral(nodes[0]) &&\n          !(ignoreToPrimitiveHint && t.isStringLiteral(nodes[1]))\n        ) {\n          nodes.unshift(t.stringLiteral(\"\"));\n        }\n        let root = nodes[0];\n\n        if (ignoreToPrimitiveHint) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = t.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","ignoreToPrimitiveHint","assumption","loose","mutableTemplateObject","helperName","buildConcatCallExpressions","items","avail","reduce","left","right","canBeInserted","t","isLiteral","isCallExpression","arguments","push","callExpression","memberExpression","identifier","name","visitor","TaggedTemplateExpression","path","node","quasi","strings","raws","isStringsRawEqual","elem","quasis","raw","cooked","value","scope","buildUndefinedNode","stringLiteral","helperArgs","arrayExpression","tmp","generateUidIdentifier","getProgramParent","id","cloneNode","replaceWith","tag","template","expression","ast","addHelper","expressions","TemplateLiteral","parent","type","nodes","get","index","length","expr","isStringLiteral","unshift","root","i","binaryExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14156, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14161, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typeof-symbol/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return {\n    name: \"transform-typeof-symbol\",\n\n    visitor: {\n      Scope({ scope }) {\n        if (!scope.getBinding(\"Symbol\")) {\n          return;\n        }\n\n        scope.rename(\"Symbol\");\n      },\n\n      UnaryExpression(path) {\n        const { node, parent } = path;\n        if (node.operator !== \"typeof\") return;\n\n        if (\n          path.parentPath.isBinaryExpression() &&\n          t.EQUALITY_BINARY_OPERATORS.includes(\n            (parent as t.BinaryExpression).operator,\n          )\n        ) {\n          // optimise `typeof foo === \"string\"` since we can determine that they'll never\n          // need to handle symbols\n          const opposite = path.getOpposite();\n          if (\n            opposite.isStringLiteral() &&\n            opposite.node.value !== \"symbol\" &&\n            opposite.node.value !== \"object\"\n          ) {\n            return;\n          }\n        }\n\n        let isUnderHelper = path.findParent(path => {\n          if (path.isFunction()) {\n            return (\n              path.get(\"body.directives.0\")?.node.value.value ===\n              \"@babel/helpers - typeof\"\n            );\n          }\n        });\n\n        if (isUnderHelper) return;\n\n        const helper = this.addHelper(\"typeof\");\n\n        // TODO: This is needed for backward compatibility with\n        // @babel/helpers <= 7.8.3.\n        // Remove in Babel 8\n        isUnderHelper = path.findParent(path => {\n          return (\n            (path.isVariableDeclarator() && path.node.id === helper) ||\n            (path.isFunctionDeclaration() &&\n              path.node.id &&\n              path.node.id.name === helper.name)\n          );\n        });\n\n        if (isUnderHelper) {\n          return;\n        }\n\n        const call = t.callExpression(helper, [node.argument]);\n        const arg = path.get(\"argument\");\n        if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {\n          const unary = t.unaryExpression(\"typeof\", t.cloneNode(node.argument));\n          path.replaceWith(\n            t.conditionalExpression(\n              t.binaryExpression(\"===\", unary, t.stringLiteral(\"undefined\")),\n              t.stringLiteral(\"undefined\"),\n              call,\n            ),\n          );\n        } else {\n          path.replaceWith(call);\n        }\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","name","visitor","Scope","scope","getBinding","rename","UnaryExpression","path","node","parent","operator","parentPath","isBinaryExpression","t","EQUALITY_BINARY_OPERATORS","includes","opposite","getOpposite","isStringLiteral","value","isUnderHelper","findParent","isFunction","_path$get","get","helper","addHelper","isVariableDeclarator","id","isFunctionDeclaration","call","callExpression","argument","arg","isIdentifier","hasBinding","unary","unaryExpression","cloneNode","replaceWith","conditionalExpression","binaryExpression","stringLiteral"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14216, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14221, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-unicode-escapes/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, type NodePath } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const surrogate = /[\\ud800-\\udfff]/g;\n  const unicodeEscape = /(\\\\+)u\\{([0-9a-fA-F]+)\\}/g;\n\n  function escape(code: number) {\n    if (process.env.BABEL_8_BREAKING) {\n      return \"\\\\u\" + code.toString(16).padStart(4, \"0\");\n    } else {\n      let str = code.toString(16);\n      while (str.length < 4) str = \"0\" + str;\n      return \"\\\\u\" + str;\n    }\n  }\n\n  function replacer(match: string, backslashes: string, code: string) {\n    if (backslashes.length % 2 === 0) {\n      return match;\n    }\n\n    const char = String.fromCodePoint(parseInt(code, 16));\n    const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));\n\n    return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));\n  }\n\n  function replaceUnicodeEscapes(str: string) {\n    return str.replace(unicodeEscape, replacer);\n  }\n\n  function getUnicodeEscape(str: string) {\n    let match;\n    while ((match = unicodeEscape.exec(str))) {\n      if (match[1].length % 2 === 0) continue;\n      unicodeEscape.lastIndex = 0;\n      return match[0];\n    }\n    return null;\n  }\n\n  return {\n    name: \"transform-unicode-escapes\",\n    manipulateOptions({ generatorOpts }) {\n      // Babel 8 will enable jsesc minimal mode by default, which outputs\n      // unescaped unicode string\n      if (!generatorOpts.jsescOption) {\n        generatorOpts.jsescOption = {};\n      }\n      generatorOpts.jsescOption.minimal ??= false;\n    },\n    visitor: {\n      Identifier(path) {\n        const { node, key } = path;\n        const { name } = node;\n        const replaced = name.replace(surrogate, c => {\n          return `_u${c.charCodeAt(0).toString(16)}`;\n        });\n        if (name === replaced) return;\n\n        const str = t.inherits(t.stringLiteral(name), node);\n\n        if (key === \"key\") {\n          path.replaceWith(str);\n          return;\n        }\n\n        const { parentPath, scope } = path;\n        if (\n          parentPath.isMemberExpression({ property: node }) ||\n          parentPath.isOptionalMemberExpression({ property: node })\n        ) {\n          parentPath.node.computed = true;\n          path.replaceWith(str);\n          return;\n        }\n\n        const binding = scope.getBinding(name);\n        if (binding) {\n          scope.rename(name, scope.generateUid(replaced));\n          return;\n        }\n\n        throw path.buildCodeFrameError(\n          `Can't reference '${name}' as a bare identifier`,\n        );\n      },\n\n      \"StringLiteral|DirectiveLiteral\"(\n        path: NodePath<t.StringLiteral | t.DirectiveLiteral>,\n      ) {\n        const { node } = path;\n        const { extra } = node;\n\n        if (extra?.raw) extra.raw = replaceUnicodeEscapes(extra.raw as string);\n      },\n\n      TemplateElement(path) {\n        const { node, parentPath } = path;\n        const { value } = node;\n\n        const firstEscape = getUnicodeEscape(value.raw);\n        if (!firstEscape) return;\n\n        const grandParent = parentPath.parentPath;\n        if (grandParent.isTaggedTemplateExpression()) {\n          throw path.buildCodeFrameError(\n            `Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`,\n          );\n        }\n\n        value.raw = replaceUnicodeEscapes(value.raw);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","assertVersion","surrogate","unicodeEscape","escape","code","str","toString","length","replacer","match","backslashes","char","String","fromCodePoint","parseInt","escaped","slice","charCodeAt","replaceUnicodeEscapes","replace","getUnicodeEscape","exec","lastIndex","name","manipulateOptions","generatorOpts","_generatorOpts$jsescO","_generatorOpts$jsescO2","jsescOption","minimal","visitor","Identifier","path","node","key","replaced","c","t","inherits","stringLiteral","replaceWith","parentPath","scope","isMemberExpression","property","isOptionalMemberExpression","computed","binding","getBinding","rename","generateUid","buildCodeFrameError","StringLiteral|DirectiveLiteral","extra","raw","TemplateElement","value","firstEscape","grandParent","isTaggedTemplateExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14317, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14322, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-unicode-property-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport interface Options {\n  useUnicodeFlag?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { useUnicodeFlag = true } = options;\n  if (typeof useUnicodeFlag !== \"boolean\") {\n    throw new Error(\".useUnicodeFlag must be a boolean, or undefined\");\n  }\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-unicode-property-regex\",\n    feature: \"unicodePropertyEscape\",\n    options: { useUnicodeFlag },\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","options","assertVersion","useUnicodeFlag","Error","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAMtC,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,OAAgB,KAAK;IAChDD,GAAG,CAACE,aAAa,CAAA,sCAAoB,CAAC;IAEtC,MAAM,EAAEC,cAAc,GAAG,IAAA,EAAM,GAAGF,OAAO;IACzC,IAAI,OAAOE,cAAc,KAAK,SAAS,EAAE;QACvC,MAAM,IAAIC,KAAK,CAAC,iDAAiD,CAAC;IACpE;IAEA,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,kCAAkC;QACxCC,OAAO,EAAE,uBAAuB;QAChCN,OAAO,EAAE;YAAEE;QAAe;IAC5B,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 14343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14348, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-unicode-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-unicode-regex\",\n    feature: \"unicodeFlag\",\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","assertVersion","createRegExpFeaturePlugin","name","feature"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,CAAE,CAAC;IAEtC,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,yBAAyB;QAC/BC,OAAO,EAAE;IACX,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 14362, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14367, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-unicode-sets-regex/src/index.ts"],"sourcesContent":["/* eslint-disable @babel/development/plugin-name */\nimport { createRegExpFeaturePlugin } from \"@babel/helper-create-regexp-features-plugin\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  return createRegExpFeaturePlugin({\n    name: \"transform-unicode-sets-regex\",\n    feature: \"unicodeSetsFlag\",\n    manipulateOptions(opts, parserOpts) {\n      if (!process.env.BABEL_8_BREAKING) {\n        // @ts-ignore(Babel 7 vs Babel 8) This plugin has been removed\n        parserOpts.plugins.push(\"regexpUnicodeSets\");\n      }\n    },\n  });\n});\n"],"names":["_helperCreateRegexpFeaturesPlugin","require","_helperPluginUtils","_default","exports","default","declare","api","assertVersion","createRegExpFeaturePlugin","name","feature","manipulateOptions","opts","parserOpts","plugins","push"],"mappings":";;;;;AACA,IAAAA,iCAAA,GAAAC,OAAA;AACA,IAAAC,kBAAA,GAAAD,OAAA;AAAqD,IAAAE,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAEtC,CAAA,GAAAC,mBAAAA,OAAO,GAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAA,sCAAoB,CAAC;IAEtC,OAAO,CAAA,GAAAC,kCAAAA,yBAAyB,EAAC;QAC/BC,IAAI,EAAE,8BAA8B;QACpCC,OAAO,EAAE,iBAAiB;QAC1BC,iBAAiBA,EAACC,IAAI,EAAEC,UAAU,EAAE;YACC;gBAEjCA,UAAU,CAACC,OAAO,CAACC,IAAI,CAAC,mBAAmB,CAAC;YAC9C;QACF;IACF,CAAC,CAAC;AACJ,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 14386, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14391, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-async-arrows-in-class/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/**\n * Safari 10.3 had an issue where async arrow function expressions within any class method would throw.\n * After an initial fix, any references to the instance via `this` within those methods would also throw.\n * This is fixed by converting arrow functions in class methods into equivalent function expressions.\n * @see https://bugs.webkit.org/show_bug.cgi?id=166879\n *\n * @example\n *   class X{ a(){ async () => {}; } }   // throws\n *   class X{ a(){ async function() {}; } }   // works\n *\n * @example\n *   class X{ a(){\n *     async () => this.a;   // throws\n *   } }\n *   class X{ a(){\n *     var _this=this;\n *     async function() { return _this.a };   // works\n *   } }\n */\nconst OPTS = {\n  allowInsertArrow: false,\n  specCompliant: false\n};\n\nvar _default = ({\n  types: t\n}) => ({\n  name: \"transform-async-arrows-in-class\",\n  visitor: {\n    ArrowFunctionExpression(path) {\n      if (path.node.async && path.findParent(t.isClassMethod)) {\n        path.arrowFunctionToExpression(OPTS);\n      }\n    }\n\n  }\n});\n\nexports.default = _default;\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AAEvB;;;;;;;;;;;;;;;;;;CAkBC,GACD,MAAM,OAAO;IACX,kBAAkB;IAClB,eAAe;AACjB;AAEA,IAAI,WAAW,CAAC,EACd,OAAO,CAAC,EACT,GAAK,CAAC;QACL,MAAM;QACN,SAAS;YACP,yBAAwB,IAAI;gBAC1B,IAAI,KAAK,IAAI,CAAC,KAAK,IAAI,KAAK,UAAU,CAAC,EAAE,aAAa,GAAG;oBACvD,KAAK,yBAAyB,CAAC;gBACjC;YACF;QAEF;IACF,CAAC;AAED,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14428, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14433, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-edge-default-parameters/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/**\n * Converts destructured parameters with default values to non-shorthand syntax.\n * This fixes the only arguments-related bug in ES Modules-supporting browsers (Edge 16 & 17).\n * Use this plugin instead of @babel/plugin-transform-parameters when targeting ES Modules.\n */\nvar _default = ({\n  types: t\n}) => {\n  const isArrowParent = p => p.parentKey === \"params\" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);\n\n  return {\n    name: \"transform-edge-default-parameters\",\n    visitor: {\n      AssignmentPattern(path) {\n        const arrowArgParent = path.find(isArrowParent);\n\n        if (arrowArgParent && path.parent.shorthand) {\n          // In Babel 7+, there is no way to force non-shorthand properties.\n          path.parent.shorthand = false;\n          (path.parent.extra || {}).shorthand = false; // So, to ensure non-shorthand, rename the local identifier so it no longer matches:\n\n          path.scope.rename(path.parent.key.name);\n        }\n      }\n\n    }\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AAEvB;;;;CAIC,GACD,IAAI,WAAW,CAAC,EACd,OAAO,CAAC,EACT;IACC,MAAM,gBAAgB,CAAA,IAAK,EAAE,SAAS,KAAK,YAAY,EAAE,UAAU,IAAI,EAAE,yBAAyB,CAAC,EAAE,UAAU;IAE/G,OAAO;QACL,MAAM;QACN,SAAS;YACP,mBAAkB,IAAI;gBACpB,MAAM,iBAAiB,KAAK,IAAI,CAAC;gBAEjC,IAAI,kBAAkB,KAAK,MAAM,CAAC,SAAS,EAAE;oBAC3C,kEAAkE;oBAClE,KAAK,MAAM,CAAC,SAAS,GAAG;oBACxB,CAAC,KAAK,MAAM,CAAC,KAAK,IAAI,CAAC,CAAC,EAAE,SAAS,GAAG,OAAO,oFAAoF;oBAEjI,KAAK,KAAK,CAAC,MAAM,CAAC,KAAK,MAAM,CAAC,GAAG,CAAC,IAAI;gBACxC;YACF;QAEF;IACF;AACF;AAEA,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14459, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14464, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-edge-function-name/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/**\n * Edge 16 & 17 do not infer function.name from variable assignment.\n * All other `function.name` behavior works fine, so we can skip most of @babel/transform-function-name.\n * @see https://kangax.github.io/compat-table/es6/#test-function_name_property_variables_(function)\n *\n * Note: contrary to various Github issues, Edge 16+ *does* correctly infer the name of Arrow Functions.\n * The variable declarator name inference issue only affects function expressions, so that's all we fix here.\n *\n * A Note on Minification: Terser undoes this transform *by default* unless `keep_fnames` is set to true.\n * There is by design - if Function.name is critical to your application, you must configure\n * your minifier to preserve function names.\n */\nvar _default = ({\n  types: t\n}) => ({\n  name: \"transform-edge-function-name\",\n  visitor: {\n    FunctionExpression: {\n      exit(path) {\n        if (!path.node.id && t.isIdentifier(path.parent.id)) {\n          const id = t.cloneNode(path.parent.id);\n          const binding = path.scope.getBinding(id.name); // if the binding gets reassigned anywhere, rename it\n\n          if (binding == null ? void 0 : binding.constantViolations.length) {\n            path.scope.rename(id.name);\n          }\n\n          path.node.id = id;\n        }\n      }\n\n    }\n  }\n});\n\nexports.default = _default;\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AAEvB;;;;;;;;;;;CAWC,GACD,IAAI,WAAW,CAAC,EACd,OAAO,CAAC,EACT,GAAK,CAAC;QACL,MAAM;QACN,SAAS;YACP,oBAAoB;gBAClB,MAAK,IAAI;oBACP,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,IAAI,EAAE,YAAY,CAAC,KAAK,MAAM,CAAC,EAAE,GAAG;wBACnD,MAAM,KAAK,EAAE,SAAS,CAAC,KAAK,MAAM,CAAC,EAAE;wBACrC,MAAM,UAAU,KAAK,KAAK,CAAC,UAAU,CAAC,GAAG,IAAI,GAAG,qDAAqD;wBAErG,IAAI,WAAW,OAAO,KAAK,IAAI,QAAQ,kBAAkB,CAAC,MAAM,EAAE;4BAChE,KAAK,KAAK,CAAC,MAAM,CAAC,GAAG,IAAI;wBAC3B;wBAEA,KAAK,IAAI,CAAC,EAAE,GAAG;oBACjB;gBACF;YAEF;QACF;IACF,CAAC;AAED,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14497, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14502, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-tagged-template-caching/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/**\n * Converts destructured parameters with default values to non-shorthand syntax.\n * This fixes the only Tagged Templates-related bug in ES Modules-supporting browsers (Safari 10 & 11).\n * Use this plugin instead of `@babel/plugin-transform-template-literals` when targeting ES Modules.\n *\n * @example\n *   // Bug 1: Safari 10/11 doesn't reliably return the same Strings value.\n *   // The value changes depending on invocation and function optimization state.\n *   function f() { return Object`` }\n *   f() === new f()  // false, should be true.\n *\n * @example\n *   // Bug 2: Safari 10/11 use the same cached strings value when the string parts are the same.\n *   // This behavior comes from an earlier version of the spec, and can cause tricky bugs.\n *   Object``===Object``  // true, should be false.\n *\n * Benchmarks: https://jsperf.com/compiled-tagged-template-performance\n */\nvar _default = ({\n  types: t\n}) => ({\n  name: \"transform-tagged-template-caching\",\n  visitor: {\n    TaggedTemplateExpression(path, state) {\n      // tagged templates we've already dealt with\n      let processed = state.get(\"processed\");\n\n      if (!processed) {\n        processed = new WeakSet();\n        state.set(\"processed\", processed);\n      }\n\n      if (processed.has(path.node)) return path.skip(); // Grab the expressions from the original tag.\n      //   tag`a${'hello'}`  // ['hello']\n\n      const expressions = path.node.quasi.expressions; // Create an identity function helper:\n      //   identity = t => t\n\n      let identity = state.get(\"identity\");\n\n      if (!identity) {\n        identity = path.scope.getProgramParent().generateDeclaredUidIdentifier(\"_\");\n        state.set(\"identity\", identity);\n        const binding = path.scope.getBinding(identity.name);\n        binding.path.get(\"init\").replaceWith(t.arrowFunctionExpression( // re-use the helper identifier for compressability\n        [t.identifier(\"t\")], t.identifier(\"t\")));\n      } // Use the identity function helper to get a reference to the template's Strings.\n      // We replace all expressions with `0` ensure Strings has the same shape.\n      //   identity`a${0}`\n\n\n      const template = t.taggedTemplateExpression(t.cloneNode(identity), t.templateLiteral(path.node.quasi.quasis, expressions.map(() => t.numericLiteral(0))));\n      processed.add(template); // Install an inline cache at the callsite using the global variable:\n      //   _t || (_t = identity`a${0}`)\n\n      const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier(\"t\");\n      path.scope.getBinding(ident.name).path.parent.kind = \"let\";\n      const inlineCache = t.logicalExpression(\"||\", ident, t.assignmentExpression(\"=\", t.cloneNode(ident), template)); // The original tag function becomes a plain function call.\n      // The expressions omitted from the cached Strings tag are directly applied as arguments.\n      //   tag(_t || (_t = Object`a${0}`), 'hello')\n\n      const node = t.callExpression(path.node.tag, [inlineCache, ...expressions]);\n      path.replaceWith(node);\n    }\n\n  }\n});\n\nexports.default = _default;\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AAEvB;;;;;;;;;;;;;;;;;CAiBC,GACD,IAAI,WAAW,CAAC,EACd,OAAO,CAAC,EACT,GAAK,CAAC;QACL,MAAM;QACN,SAAS;YACP,0BAAyB,IAAI,EAAE,KAAK;gBAClC,4CAA4C;gBAC5C,IAAI,YAAY,MAAM,GAAG,CAAC;gBAE1B,IAAI,CAAC,WAAW;oBACd,YAAY,IAAI;oBAChB,MAAM,GAAG,CAAC,aAAa;gBACzB;gBAEA,IAAI,UAAU,GAAG,CAAC,KAAK,IAAI,GAAG,OAAO,KAAK,IAAI,IAAI,8CAA8C;gBAChG,mCAAmC;gBAEnC,MAAM,cAAc,KAAK,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,sCAAsC;gBACvF,sBAAsB;gBAEtB,IAAI,WAAW,MAAM,GAAG,CAAC;gBAEzB,IAAI,CAAC,UAAU;oBACb,WAAW,KAAK,KAAK,CAAC,gBAAgB,GAAG,6BAA6B,CAAC;oBACvE,MAAM,GAAG,CAAC,YAAY;oBACtB,MAAM,UAAU,KAAK,KAAK,CAAC,UAAU,CAAC,SAAS,IAAI;oBACnD,QAAQ,IAAI,CAAC,GAAG,CAAC,QAAQ,WAAW,CAAC,EAAE,uBAAuB,CAC9D;wBAAC,EAAE,UAAU,CAAC;qBAAK,EAAE,EAAE,UAAU,CAAC;gBACpC,EAAE,iFAAiF;gBACnF,yEAAyE;gBACzE,oBAAoB;gBAGpB,MAAM,WAAW,EAAE,wBAAwB,CAAC,EAAE,SAAS,CAAC,WAAW,EAAE,eAAe,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,YAAY,GAAG,CAAC,IAAM,EAAE,cAAc,CAAC;gBACpJ,UAAU,GAAG,CAAC,WAAW,qEAAqE;gBAC9F,iCAAiC;gBAEjC,MAAM,QAAQ,KAAK,KAAK,CAAC,gBAAgB,GAAG,6BAA6B,CAAC;gBAC1E,KAAK,KAAK,CAAC,UAAU,CAAC,MAAM,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG;gBACrD,MAAM,cAAc,EAAE,iBAAiB,CAAC,MAAM,OAAO,EAAE,oBAAoB,CAAC,KAAK,EAAE,SAAS,CAAC,QAAQ,YAAY,2DAA2D;gBAC5K,yFAAyF;gBACzF,6CAA6C;gBAE7C,MAAM,OAAO,EAAE,cAAc,CAAC,KAAK,IAAI,CAAC,GAAG,EAAE;oBAAC;uBAAgB;iBAAY;gBAC1E,KAAK,WAAW,CAAC;YACnB;QAEF;IACF,CAAC;AAED,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14565, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14570, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-safari-block-shadowing/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = _default;\n\n/**\n * Fixes block-shadowed let/const bindings in Safari 10/11.\n * https://kangax.github.io/compat-table/es6/#test-let_scope_shadow_resolution\n */\nfunction _default({\n  types: t\n}) {\n  return {\n    name: \"transform-safari-block-shadowing\",\n    visitor: {\n      VariableDeclarator(path) {\n        // the issue only affects let and const bindings:\n        const kind = path.parent.kind;\n        if (kind !== \"let\" && kind !== \"const\") return; // ignore non-block-scoped bindings:\n\n        const block = path.scope.block;\n        if (t.isFunction(block) || t.isProgram(block)) return;\n        const bindings = t.getOuterBindingIdentifiers(path.node.id);\n\n        for (const name of Object.keys(bindings)) {\n          let scope = path.scope; // ignore parent bindings (note: impossible due to let/const?)\n\n          if (!scope.hasOwnBinding(name)) continue; // check if shadowed within the nearest function/program boundary\n\n          while (scope = scope.parent) {\n            if (scope.hasOwnBinding(name)) {\n              path.scope.rename(name);\n              break;\n            }\n\n            if (t.isFunction(scope.block) || t.isProgram(scope.block)) {\n              break;\n            }\n          }\n        }\n      }\n\n    }\n  };\n}\n\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG;AAElB;;;CAGC,GACD,SAAS,SAAS,EAChB,OAAO,CAAC,EACT;IACC,OAAO;QACL,MAAM;QACN,SAAS;YACP,oBAAmB,IAAI;gBACrB,iDAAiD;gBACjD,MAAM,OAAO,KAAK,MAAM,CAAC,IAAI;gBAC7B,IAAI,SAAS,SAAS,SAAS,SAAS,QAAQ,oCAAoC;gBAEpF,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK;gBAC9B,IAAI,EAAE,UAAU,CAAC,UAAU,EAAE,SAAS,CAAC,QAAQ;gBAC/C,MAAM,WAAW,EAAE,0BAA0B,CAAC,KAAK,IAAI,CAAC,EAAE;gBAE1D,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,UAAW;oBACxC,IAAI,QAAQ,KAAK,KAAK,EAAE,8DAA8D;oBAEtF,IAAI,CAAC,MAAM,aAAa,CAAC,OAAO,UAAU,iEAAiE;oBAE3G,MAAO,QAAQ,MAAM,MAAM,CAAE;wBAC3B,IAAI,MAAM,aAAa,CAAC,OAAO;4BAC7B,KAAK,KAAK,CAAC,MAAM,CAAC;4BAClB;wBACF;wBAEA,IAAI,EAAE,UAAU,CAAC,MAAM,KAAK,KAAK,EAAE,SAAS,CAAC,MAAM,KAAK,GAAG;4BACzD;wBACF;oBACF;gBACF;YACF;QAEF;IACF;AACF;AAEA,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14605, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14610, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-modules/lib/plugins/transform-safari-for-shadowing/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/**\n * Safari ~11 has an issue where variable declarations in a For statement throw if they shadow parameters.\n * This is fixed by renaming any declarations in the left/init part of a For* statement so they don't shadow.\n * @see https://bugs.webkit.org/show_bug.cgi?id=171041\n *\n * @example\n *   e => { for (let e of []) e }   // throws\n *   e => { for (let _e of []) _e }   // works\n */\nfunction handle(declaration) {\n  if (!declaration.isVariableDeclaration()) return;\n  const fn = declaration.getFunctionParent();\n  const {\n    name\n  } = declaration.node.declarations[0].id; // check if there is a shadowed binding coming from a parameter\n\n  if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === \"param\") {\n    declaration.scope.rename(name);\n  }\n}\n\nvar _default = () => ({\n  name: \"transform-safari-for-shadowing\",\n  visitor: {\n    ForXStatement(path) {\n      handle(path.get(\"left\"));\n    },\n\n    ForStatement(path) {\n      handle(path.get(\"init\"));\n    }\n\n  }\n});\n\nexports.default = _default;\nmodule.exports = exports.default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AAEvB;;;;;;;;CAQC,GACD,SAAS,OAAO,WAAW;IACzB,IAAI,CAAC,YAAY,qBAAqB,IAAI;IAC1C,MAAM,KAAK,YAAY,iBAAiB;IACxC,MAAM,EACJ,IAAI,EACL,GAAG,YAAY,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,EAAE,EAAE,+DAA+D;IAExG,IAAI,MAAM,GAAG,KAAK,CAAC,aAAa,CAAC,SAAS,GAAG,KAAK,CAAC,aAAa,CAAC,MAAM,IAAI,KAAK,SAAS;QACvF,YAAY,KAAK,CAAC,MAAM,CAAC;IAC3B;AACF;AAEA,IAAI,WAAW,IAAM,CAAC;QACpB,MAAM;QACN,SAAS;YACP,eAAc,IAAI;gBAChB,OAAO,KAAK,GAAG,CAAC;YAClB;YAEA,cAAa,IAAI;gBACf,OAAO,KAAK,GAAG,CAAC;YAClB;QAEF;IACF,CAAC;AAED,QAAQ,OAAO,GAAG;AAClB,OAAO,OAAO,GAAG,QAAQ,OAAO","ignoreList":[0]}},
    {"offset": {"line": 14642, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14647, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-firefox-class-in-computed-class-key/src/index.ts"],"sourcesContent":["import type { types as t, NodePath, Visitor } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nexport default declare(({ types: t, assertVersion }) => {\n  assertVersion(REQUIRED_VERSION(7));\n\n  const containsClassExpressionVisitor: Visitor<{ found: boolean }> = {\n    ClassExpression(path, state) {\n      state.found = true;\n      path.stop();\n    },\n    Function(path) {\n      path.skip();\n    },\n  };\n\n  const containsYieldOrAwaitVisitor = visitors.environmentVisitor<{\n    yield: boolean;\n    await: boolean;\n  }>({\n    YieldExpression(path, state) {\n      state.yield = true;\n      if (state.await) path.stop();\n    },\n    AwaitExpression(path, state) {\n      state.await = true;\n      if (state.yield) path.stop();\n    },\n  });\n\n  function containsClassExpression(path: NodePath<t.Node>) {\n    if (t.isClassExpression(path.node)) return true;\n    if (t.isFunction(path.node)) return false;\n    const state = { found: false };\n    path.traverse(containsClassExpressionVisitor, state);\n    return state.found;\n  }\n\n  function wrap(path: NodePath<t.Expression>) {\n    const context = {\n      yield: t.isYieldExpression(path.node),\n      await: t.isAwaitExpression(path.node),\n    };\n    path.traverse(containsYieldOrAwaitVisitor, context);\n\n    let replacement;\n\n    if (context.yield) {\n      const fn = t.functionExpression(\n        null,\n        [],\n        t.blockStatement([t.returnStatement(path.node)]),\n        /* generator */ true,\n        /* async */ context.await,\n      );\n\n      replacement = t.yieldExpression(\n        t.callExpression(t.memberExpression(fn, t.identifier(\"call\")), [\n          t.thisExpression(),\n          // NOTE: In some context arguments is invalid (it might not be defined\n          // in the top-level scope, or it's a syntax error in static class blocks).\n          // However, `yield` is also invalid in those contexts, so we can safely\n          // inject a reference to arguments.\n          t.identifier(\"arguments\"),\n        ]),\n        true,\n      );\n    } else {\n      const fn = t.arrowFunctionExpression([], path.node, context.await);\n\n      replacement = t.callExpression(fn, []);\n      if (context.await) replacement = t.awaitExpression(replacement);\n    }\n\n    path.replaceWith(replacement);\n  }\n\n  return {\n    name: \"bugfix-firefox-class-in-computed-class-key\",\n\n    visitor: {\n      Class(path) {\n        const hasPrivateElement = path.node.body.body.some(node =>\n          t.isPrivate(node),\n        );\n        if (!hasPrivateElement) return;\n\n        for (const elem of path.get(\"body.body\")) {\n          if (\n            \"computed\" in elem.node &&\n            elem.node.computed &&\n            containsClassExpression(elem.get(\"key\"))\n          ) {\n            wrap(\n              // @ts-expect-error .key also includes t.PrivateName\n              elem.get(\"key\") satisfies NodePath<t.Expression>,\n            );\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["_traverse","require","_helperPluginUtils","_default","exports","default","declare","types","t","assertVersion","containsClassExpressionVisitor","ClassExpression","path","state","found","stop","Function","skip","containsYieldOrAwaitVisitor","visitors","environmentVisitor","YieldExpression","yield","await","AwaitExpression","containsClassExpression","isClassExpression","node","isFunction","traverse","wrap","context","isYieldExpression","isAwaitExpression","replacement","fn","functionExpression","blockStatement","returnStatement","yieldExpression","callExpression","memberExpression","identifier","thisExpression","arrowFunctionExpression","awaitExpression","replaceWith","name","visitor","Class","hasPrivateElement","body","some","isPrivate","elem","get","computed"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14721, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14726, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/src/index.ts"],"sourcesContent":["import type { NodePath, types as t } from \"@babel/core\";\n\n/**\n * Check whether a function expression can be affected by\n * https://bugs.webkit.org/show_bug.cgi?id=220517\n * @param path The function expression NodePath\n * @returns the name of function id if it should be transformed, otherwise returns false\n */\nexport function shouldTransform(\n  path: NodePath<t.FunctionExpression>,\n): string | false {\n  const { node } = path;\n  const functionId = node.id;\n  if (!functionId) return false;\n\n  const name = functionId.name;\n  // On collision, `getOwnBinding` returns the param binding\n  // with the id binding be registered as constant violation\n  const paramNameBinding = path.scope.getOwnBinding(name);\n  if (paramNameBinding === undefined) {\n    // Case 1: the function id is injected by babel-helper-name-function, which\n    // assigns `NOT_LOCAL_BINDING` to the `functionId` and thus not registering id\n    // in scope tracking\n    // Case 2: the function id is injected by a third party plugin which does not update the\n    // scope info\n    return false;\n  }\n  if (paramNameBinding.kind !== \"param\") {\n    // the function id does not reproduce in params\n    return false;\n  }\n\n  if (paramNameBinding.identifier === paramNameBinding.path.node) {\n    // the param binding is a simple parameter\n    // e.g. (function a(a) {})\n    return false;\n  }\n\n  return name;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { shouldTransform } from \"./util.ts\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.16.0\"));\n\n  return {\n    name: \"plugin-bugfix-safari-id-destructuring-collision-in-function-expression\",\n\n    visitor: {\n      FunctionExpression(path) {\n        const name = shouldTransform(path);\n        if (name) {\n          // Now we have (function a([a]) {})\n          const { scope } = path;\n          // invariant: path.node.id is always an Identifier here\n          const newParamName = scope.generateUid(name);\n          scope.rename(name, newParamName);\n        }\n      },\n    },\n  };\n});\n"],"names":["shouldTransform","path","node","functionId","id","name","paramNameBinding","scope","getOwnBinding","undefined","kind","identifier","declare","api","assertVersion","visitor","FunctionExpression","newParamName","generateUid","rename"],"mappings":";;;;;AAQO,SAASA,eAAeA,CAC7BC,IAAoC,EACpB;IAChB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI,CAAA;IACrB,MAAME,UAAU,GAAGD,IAAI,CAACE,EAAE,CAAA;IAC1B,IAAI,CAACD,UAAU,EAAE,OAAO,KAAK,CAAA;IAE7B,MAAME,IAAI,GAAGF,UAAU,CAACE,IAAI,CAAA;IAG5B,MAAMC,gBAAgB,GAAGL,IAAI,CAACM,KAAK,CAACC,aAAa,CAACH,IAAI,CAAC,CAAA;IACvD,IAAIC,gBAAgB,KAAKG,SAAS,EAAE;QAMlC,OAAO,KAAK,CAAA;IACd,CAAA;IACA,IAAIH,gBAAgB,CAACI,IAAI,KAAK,OAAO,EAAE;QAErC,OAAO,KAAK,CAAA;IACd,CAAA;IAEA,IAAIJ,gBAAgB,CAACK,UAAU,KAAKL,gBAAgB,CAACL,IAAI,CAACC,IAAI,EAAE;QAG9D,OAAO,KAAK,CAAA;IACd,CAAA;IAEA,OAAOG,IAAI,CAAA;AACb;ACpCA,IAAA,QAAeO,kBAAAA,OAAO,EAACC,GAAG,IAAI;IAC5BA,GAAG,CAACC,aAAa,CAAkB,SAAU,CAAC,CAAA;IAE9C,OAAO;QACLT,IAAI,EAAE,wEAAwE;QAE9EU,OAAO,EAAE;YACPC,kBAAkBA,EAACf,IAAI,EAAE;gBACvB,MAAMI,IAAI,GAAGL,eAAe,CAACC,IAAI,CAAC,CAAA;gBAClC,IAAII,IAAI,EAAE;oBAER,MAAM,EAAEE,KAAAA,EAAO,GAAGN,IAAI,CAAA;oBAEtB,MAAMgB,YAAY,GAAGV,KAAK,CAACW,WAAW,CAACb,IAAI,CAAC,CAAA;oBAC5CE,KAAK,CAACY,MAAM,CAACd,IAAI,EAAEY,YAAY,CAAC,CAAA;gBAClC,CAAA;YACF,CAAA;QACF,CAAA;KACD,CAAA;AACH,CAAC,CAAC","ignoreList":[0,1]}},
    {"offset": {"line": 14765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14770, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-safari-class-field-initializer-scope/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/core\";\n\nfunction needsWrapping(node: t.Node): boolean {\n  if (t.isLiteral(node) && !t.isTemplateLiteral(node)) {\n    return false;\n  }\n\n  if (\n    t.isCallExpression(node) ||\n    t.isOptionalCallExpression(node) ||\n    t.isNewExpression(node)\n  ) {\n    return needsWrapping(node.callee) || node.arguments.some(needsWrapping);\n  }\n\n  if (t.isTemplateLiteral(node)) {\n    return node.expressions.some(needsWrapping);\n  }\n\n  if (t.isTaggedTemplateExpression(node)) {\n    return needsWrapping(node.tag) || needsWrapping(node.quasi);\n  }\n\n  if (t.isArrayExpression(node)) {\n    return node.elements.some(needsWrapping);\n  }\n\n  if (t.isObjectExpression(node)) {\n    return node.properties.some(prop => {\n      if (t.isObjectProperty(prop)) {\n        return (\n          needsWrapping(prop.value) ||\n          (prop.computed && needsWrapping(prop.key))\n        );\n      }\n      if (t.isObjectMethod(prop)) {\n        return false;\n      }\n      return false;\n    });\n  }\n\n  if (t.isMemberExpression(node) || t.isOptionalMemberExpression(node)) {\n    return (\n      needsWrapping(node.object) ||\n      (node.computed && needsWrapping(node.property))\n    );\n  }\n\n  if (\n    t.isFunctionExpression(node) ||\n    t.isArrowFunctionExpression(node) ||\n    t.isClassExpression(node)\n  ) {\n    return false;\n  }\n\n  if (t.isThisExpression(node)) {\n    return false;\n  }\n\n  if (t.isSequenceExpression(node)) {\n    return node.expressions.some(needsWrapping);\n  }\n\n  // Is an identifier, or anything else not covered above\n  return true;\n}\n\nfunction wrapInitializer(\n  path: NodePath<t.ClassProperty | t.ClassPrivateProperty>,\n) {\n  const { value } = path.node;\n\n  if (value && needsWrapping(value)) {\n    path.node.value = t.callExpression(\n      t.arrowFunctionExpression([], value),\n      [],\n    );\n  }\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(\"^7.16.0\"));\n\n  return {\n    name: \"plugin-bugfix-safari-class-field-initializer-scope\",\n\n    visitor: {\n      ClassProperty(path) {\n        wrapInitializer(path);\n      },\n      ClassPrivateProperty(path) {\n        wrapInitializer(path);\n      },\n    },\n  };\n});\n"],"names":["needsWrapping","node","t","isLiteral","isTemplateLiteral","isCallExpression","isOptionalCallExpression","isNewExpression","callee","arguments","some","expressions","isTaggedTemplateExpression","tag","quasi","isArrayExpression","elements","isObjectExpression","properties","prop","isObjectProperty","value","computed","key","isObjectMethod","isMemberExpression","isOptionalMemberExpression","object","property","isFunctionExpression","isArrowFunctionExpression","isClassExpression","isThisExpression","isSequenceExpression","wrapInitializer","path","callExpression","arrowFunctionExpression","declare","api","assertVersion","name","visitor","ClassProperty","ClassPrivateProperty"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 14838, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14843, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/src/index.ts"],"sourcesContent":["import { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport { types as t, type NodePath } from \"@babel/core\";\n// https://crbug.com/v8/11558\n\n// check if there is a spread element followed by another argument.\n// (...[], 0) or (...[], ...[])\n\nfunction matchAffectedArguments(argumentNodes: t.CallExpression[\"arguments\"]) {\n  const spreadIndex = argumentNodes.findIndex(node => t.isSpreadElement(node));\n  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;\n}\n\n/**\n * Check whether the optional chain is affected by https://crbug.com/v8/11558.\n * This routine MUST not manipulate NodePath\n *\n * @export\n * @param {(NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>)} path\n * @returns {boolean}\n */\nexport function shouldTransform(\n  path: NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>,\n): boolean {\n  let optionalPath: NodePath<t.Expression> = path;\n  const chains: (t.OptionalCallExpression | t.OptionalMemberExpression)[] = [];\n  for (;;) {\n    if (optionalPath.isOptionalMemberExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    } else {\n      break;\n    }\n  }\n  for (let i = 0; i < chains.length; i++) {\n    const node = chains[i];\n    if (\n      t.isOptionalCallExpression(node) &&\n      matchAffectedArguments(node.arguments)\n    ) {\n      // f?.(...[], 0)\n      if (node.optional) {\n        return true;\n      }\n      // o?.m(...[], 0)\n      // when node.optional is false, chains[i + 1] is always well defined\n      const callee = chains[i + 1];\n      if (t.isOptionalMemberExpression(callee, { optional: true })) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { transform } from \"@babel/plugin-transform-optional-chaining\";\nimport { shouldTransform } from \"./util.ts\";\nimport type { NodePath, types as t } from \"@babel/core\";\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const noDocumentAll = api.assumption(\"noDocumentAll\") ?? false;\n  const pureGetters = api.assumption(\"pureGetters\") ?? false;\n\n  return {\n    name: \"bugfix-v8-spread-parameters-in-optional-chaining\",\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(\n        path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n      ) {\n        if (shouldTransform(path)) {\n          transform(path, { noDocumentAll, pureGetters });\n        }\n      },\n    },\n  };\n});\n"],"names":["matchAffectedArguments","argumentNodes","spreadIndex","findIndex","node","t","isSpreadElement","length","shouldTransform","path","optionalPath","chains","isOptionalMemberExpression","push","skipTransparentExprWrappers","get","isOptionalCallExpression","i","arguments","optional","callee","declare","api","_api$assumption","_api$assumption2","assertVersion","noDocumentAll","assumption","pureGetters","name","visitor","OptionalCallExpression|OptionalMemberExpression","transform"],"mappings":";;;;;;;;AAOA,SAASA,sBAAsBA,CAACC,aAA4C,EAAE;IAC5E,MAAMC,WAAW,GAAGD,aAAa,CAACE,SAAS,EAACC,IAAI,GAAIC,KAAAA,KAAC,CAACC,eAAe,CAACF,IAAI,CAAC,CAAC,CAAA;IAC5E,OAAOF,WAAW,IAAI,CAAC,IAAIA,WAAW,KAAKD,aAAa,CAACM,MAAM,GAAG,CAAC,CAAA;AACrE,CAAA;AAUO,SAASC,eAAeA,CAC7BC,IAAqE,EAC5D;IACT,IAAIC,YAAoC,GAAGD,IAAI,CAAA;IAC/C,MAAME,MAAiE,GAAG,EAAE,CAAA;IAC5E,OAAS;QACP,IAAID,YAAY,CAACE,0BAA0B,EAAE,EAAE;YAC7CD,MAAM,CAACE,IAAI,CAACH,YAAY,CAACN,IAAI,CAAC,CAAA;YAC9BM,YAAY,GAAGI,wCAAAA,2BAA2B,CAACJ,YAAY,CAACK,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAA;QACxE,CAAC,MAAM,IAAIL,YAAY,CAACM,wBAAwB,EAAE,EAAE;YAClDL,MAAM,CAACE,IAAI,CAACH,YAAY,CAACN,IAAI,CAAC,CAAA;YAC9BM,YAAY,GAAGI,wCAAAA,2BAA2B,CAACJ,YAAY,CAACK,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAA;QACxE,CAAC,MAAM;YACL,MAAA;QACF,CAAA;IACF,CAAA;IACA,IAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,MAAM,CAACJ,MAAM,EAAEU,CAAC,EAAE,CAAE;QACtC,MAAMb,IAAI,GAAGO,MAAM,CAACM,CAAC,CAAC,CAAA;QACtB,IACEZ,KAAAA,KAAC,CAACW,wBAAwB,CAACZ,IAAI,CAAC,IAChCJ,sBAAsB,CAACI,IAAI,CAACc,SAAS,CAAC,EACtC;YAEA,IAAId,IAAI,CAACe,QAAQ,EAAE;gBACjB,OAAO,IAAI,CAAA;YACb,CAAA;YAGA,MAAMC,MAAM,GAAGT,MAAM,CAACM,CAAC,GAAG,CAAC,CAAC,CAAA;YAC5B,IAAIZ,KAAAA,KAAC,CAACO,0BAA0B,CAACQ,MAAM,EAAE;gBAAED,QAAQ,EAAE,IAAA;YAAK,CAAC,CAAC,EAAE;gBAC5D,OAAO,IAAI,CAAA;YACb,CAAA;QACF,CAAA;IACF,CAAA;IACA,OAAO,KAAK,CAAA;AACd;AClDA,IAAA,QAAeE,kBAAAA,OAAO,EAACC,GAAG,IAAI;IAAA,IAAAC,eAAA,EAAAC,gBAAA,CAAA;IAC5BF,GAAG,CAACG,aAAa,CAAkB,CAAE,CAAC,CAAA;IAEtC,MAAMC,aAAa,GAAA,CAAAH,eAAA,GAAGD,GAAG,CAACK,UAAU,CAAC,eAAe,CAAC,KAAAJ,IAAAA,GAAAA,eAAA,GAAI,KAAK,CAAA;IAC9D,MAAMK,WAAW,GAAA,CAAAJ,gBAAA,GAAGF,GAAG,CAACK,UAAU,CAAC,aAAa,CAAC,KAAAH,IAAAA,GAAAA,gBAAA,GAAI,KAAK,CAAA;IAE1D,OAAO;QACLK,IAAI,EAAE,kDAAkD;QAExDC,OAAO,EAAE;YACP,iDAAiDC,EAC/CtB,IAAqE,EACrE;gBACA,IAAID,eAAe,CAACC,IAAI,CAAC,EAAE;oBACzBuB,gCAAAA,SAAS,CAACvB,IAAI,EAAE;wBAAEiB,aAAa;wBAAEE,WAAAA;oBAAY,CAAC,CAAC,CAAA;gBACjD,CAAA;YACF,CAAA;QACF,CAAA;KACD,CAAA;AACH,CAAC,CAAC","ignoreList":[0,1]}},
    {"offset": {"line": 14905, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 14910, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/src/util.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/src/index.ts"],"sourcesContent":["import { types as t, type NodePath, type Visitor } from \"@babel/core\";\n\nfunction isNameOrLength(key: t.Node): boolean {\n  if (t.isIdentifier(key)) {\n    return key.name === \"name\" || key.name === \"length\";\n  }\n  if (t.isStringLiteral(key)) {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\nfunction isStaticFieldWithValue(\n  node: t.Node,\n): node is t.ClassProperty | t.ClassPrivateProperty {\n  return (\n    (t.isClassProperty(node) || t.isClassPrivateProperty(node)) &&\n    node.static &&\n    !!node.value\n  );\n}\n\nconst hasReferenceVisitor: Visitor<{ name: string; ref: () => void }> = {\n  ReferencedIdentifier(path, state) {\n    if (path.node.name === state.name) {\n      state.ref();\n      path.stop();\n    }\n  },\n  Scope(path, { name }) {\n    if (path.scope.hasOwnBinding(name)) {\n      path.skip();\n    }\n  },\n};\n\nfunction isReferenceOrThis(node: t.Node, name?: string) {\n  return t.isThisExpression(node) || (name && t.isIdentifier(node, { name }));\n}\n\nconst hasReferenceOrThisVisitor: Visitor<{ name?: string; ref: () => void }> = {\n  \"ThisExpression|ReferencedIdentifier\"(path, state) {\n    if (isReferenceOrThis(path.node, state.name)) {\n      state.ref();\n      path.stop();\n    }\n  },\n  FunctionParent(path, state) {\n    if (path.isArrowFunctionExpression()) return;\n    if (state.name && !path.scope.hasOwnBinding(state.name)) {\n      path.traverse(hasReferenceVisitor, state);\n    }\n    path.skip();\n    if (path.isMethod()) {\n      if (\n        process.env.BABEL_8_BREAKING ||\n        USE_ESM ||\n        IS_STANDALONE ||\n        path.requeueComputedKeyAndDecorators\n      ) {\n        path.requeueComputedKeyAndDecorators();\n      } else {\n        // eslint-disable-next-line no-restricted-globals\n        require(\"@babel/traverse\").NodePath.prototype.requeueComputedKeyAndDecorators.call(\n          path,\n        );\n      }\n    }\n  },\n};\n\ntype ClassElementWithComputedKeySupport = Extract<\n  t.ClassBody[\"body\"][number],\n  { computed?: boolean }\n>;\n\n/**\n * This function returns an array containing the indexes of class elements\n * that might be affected by https://crbug.com/v8/12421 bug.\n *\n * This bug affects public static class fields that have the same name as an\n * existing non-writable property with the same name. This usually happens when\n * the static field is named 'length' or 'name', since it clashes with the\n * predefined fn.length and fn.name properties. We must also compile static\n * fields with computed key, because they might end up being named 'length' or\n * 'name'.\n *\n * However, this bug can potentially affect public static fields with any name.\n * Consider this example:\n *\n *     class A {\n *       static {\n *         Object.defineProperty(A, \"readonly\", {\n *           value: 1,\n *           writable: false,\n *           configurable: true\n *         })\n *       }\n *\n *       static readonly = 2;\n *     }\n *\n * When initializing the 'static readonly' field, the class already has a\n * non-writable property named 'readonly' and thus V8 9.7 incorrectly throws.\n *\n * To avoid unconditionally compiling every public static field, we track how\n * the class is referenced during definition & static evaluation: any side\n * effect after a reference to the class can potentially define a non-writable\n * conficting property, so subsequent public static fields must be compiled.\n * The class could be referenced using the class name in computed keys, which\n * run before static fields, or using either the class name or 'this' in static\n * fields (both public and private) and static blocks.\n *\n * We don't need to check if computed keys referencing the class have any side\n * effect, because during the computed keys evaluation the internal class\n * binding is in TDZ. However, the first side effect in a static field/block\n * could have access to a function defined in a computed key that modifies the\n * class.\n *\n * This logic is already quite complex, so we assume that static blocks always\n * have side effects and reference the class (the reason to use them is to\n * perform additional initialization logic on the class anyway), so that we do\n * not have to check their contents.\n */\nexport function getPotentiallyBuggyFieldsIndexes(path: NodePath<t.Class>) {\n  const buggyPublicStaticFieldsIndexes: number[] = [];\n\n  let classReferenced = false;\n  const className = path.node.id?.name;\n\n  const hasReferenceState = {\n    name: className,\n    ref: () => (classReferenced = true),\n  };\n\n  if (className) {\n    for (const el of path.get(\"body.body\")) {\n      if ((el.node as ClassElementWithComputedKeySupport).computed) {\n        // Since .traverse skips the top-level node, it doesn't detect\n        // a reference happening immediately:\n        //     class A { [A]() {} }\n        // However, it's a TDZ error so it's ok not to consider this case.\n        (el as NodePath<ClassElementWithComputedKeySupport>)\n          .get(\"key\")\n          .traverse(hasReferenceVisitor, hasReferenceState);\n\n        if (classReferenced) break;\n      }\n    }\n  }\n\n  let nextPotentiallyBuggy = false;\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n\n    if (!nextPotentiallyBuggy) {\n      if (t.isStaticBlock(node)) {\n        classReferenced = true;\n        nextPotentiallyBuggy = true;\n      } else if (isStaticFieldWithValue(node)) {\n        if (!classReferenced) {\n          if (isReferenceOrThis(node.value, className)) {\n            classReferenced = true;\n          } else {\n            (\n              path.get(`body.body.${i}.value`) as NodePath<t.Expression>\n            ).traverse(hasReferenceOrThisVisitor, hasReferenceState);\n          }\n        }\n\n        if (classReferenced) {\n          nextPotentiallyBuggy = !path.scope.isPure(node.value);\n        }\n      }\n    }\n\n    if (\n      t.isClassProperty(node, { static: true }) &&\n      (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))\n    ) {\n      buggyPublicStaticFieldsIndexes.push(i);\n    }\n  }\n\n  return buggyPublicStaticFieldsIndexes;\n}\n\nexport function getNameOrLengthStaticFieldsIndexes(path: NodePath<t.Class>) {\n  const indexes: number[] = [];\n\n  const { body } = path.node.body;\n  for (let i = 0; i < body.length; i++) {\n    const node = body[i];\n    if (\n      t.isClassProperty(node, { static: true, computed: false }) &&\n      isNameOrLength(node.key)\n    ) {\n      indexes.push(i);\n    }\n  }\n\n  return indexes;\n}\n\ntype Range = [start: number, end: number];\n\n/**\n * Converts a sorted list of numbers into a list of (inclusive-exclusive)\n * ranges representing the same numbers.\n *\n * @example toRanges([1, 3, 4, 5, 8, 9]) -> [[1, 2], [3, 6], [8, 10]]\n */\nexport function toRanges(nums: number[]): Range[] {\n  const ranges: Range[] = [];\n\n  if (nums.length === 0) return ranges;\n\n  let start = nums[0];\n  let end = start + 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] <= nums[i - 1]) {\n      throw new Error(\"Internal Babel error: nums must be in ascending order\");\n    }\n    if (nums[i] === end) {\n      end++;\n    } else {\n      ranges.push([start, end]);\n      start = nums[i];\n      end = start + 1;\n    }\n  }\n  ranges.push([start, end]);\n\n  return ranges;\n}\n","import type { NodePath, Scope, PluginPass, File } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\nimport { declare } from \"@babel/helper-plugin-utils\";\n\nimport {\n  getPotentiallyBuggyFieldsIndexes,\n  getNameOrLengthStaticFieldsIndexes,\n  toRanges,\n} from \"./util.ts\";\n\nfunction buildFieldsReplacement(\n  fields: t.ClassProperty[],\n  scope: Scope,\n  file: File,\n) {\n  return t.staticBlock(\n    fields.map(field => {\n      const key =\n        field.computed || !t.isIdentifier(field.key)\n          ? field.key\n          : t.stringLiteral(field.key.name);\n\n      return t.expressionStatement(\n        t.callExpression(file.addHelper(\"defineProperty\"), [\n          t.thisExpression(),\n          key,\n          field.value || scope.buildUndefinedNode(),\n        ]),\n      );\n    }),\n  );\n}\n\nexport default declare(api => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n\n  return {\n    name: \"bugfix-v8-static-class-fields-redefine-readonly\",\n\n    visitor: {\n      Class(this: PluginPass, path: NodePath<t.Class>) {\n        const ranges = toRanges(\n          setPublicClassFields\n            ? getNameOrLengthStaticFieldsIndexes(path)\n            : getPotentiallyBuggyFieldsIndexes(path),\n        );\n\n        for (let i = ranges.length - 1; i >= 0; i--) {\n          const [start, end] = ranges[i];\n\n          const startPath = path.get(\"body.body\")[start];\n\n          startPath.replaceWith(\n            buildFieldsReplacement(\n              path.node.body.body.slice(start, end) as t.ClassProperty[],\n              path.scope,\n              this.file,\n            ),\n          );\n\n          for (let j = end - 1; j > start; j--) {\n            path.get(\"body.body\")[j].remove();\n          }\n        }\n      },\n    },\n  };\n});\n"],"names":["isNameOrLength","key","t","isIdentifier","name","isStringLiteral","value","isStaticFieldWithValue","node","isClassProperty","isClassPrivateProperty","static","hasReferenceVisitor","ReferencedIdentifier","path","state","ref","stop","Scope","scope","hasOwnBinding","skip","isReferenceOrThis","isThisExpression","hasReferenceOrThisVisitor","ThisExpression|ReferencedIdentifier","FunctionParent","isArrowFunctionExpression","traverse","isMethod","requeueComputedKeyAndDecorators","require","NodePath","prototype","call","getPotentiallyBuggyFieldsIndexes","_path$node$id","buggyPublicStaticFieldsIndexes","classReferenced","className","id","hasReferenceState","el","get","computed","nextPotentiallyBuggy","body","i","length","isStaticBlock","isPure","push","getNameOrLengthStaticFieldsIndexes","indexes","toRanges","nums","ranges","start","end","Error","buildFieldsReplacement","fields","file","staticBlock","map","field","stringLiteral","expressionStatement","callExpression","addHelper","thisExpression","buildUndefinedNode","declare","api","assertVersion","setPublicClassFields","assumption","visitor","Class","startPath","replaceWith","slice","j","remove"],"mappings":"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","ignoreList":[0,1]}},
    {"offset": {"line": 15085, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15090, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-syntax-unicode-sets-regex/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperCreateRegexpFeaturesPlugin = require(\"@babel/helper-create-regexp-features-plugin\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n  return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({\n    name: \"syntax-unicode-sets-regex\",\n    feature: \"unicodeSetsFlag_syntax\",\n\n    manipulateOptions(opts, parserOpts) {\n      parserOpts.plugins.push(\"regexpUnicodeSets\");\n    }\n\n  });\n});\n\nexports.default = _default;"],"names":[],"mappings":"AAAA;AAEA,OAAO,cAAc,CAAC,SAAS,cAAc;IAC3C,OAAO;AACT;AACA,QAAQ,OAAO,GAAG,KAAK;AAEvB,IAAI;AAEJ,IAAI;AAEJ,IAAI,WAAW,CAAC,GAAG,mBAAmB,OAAO,EAAE,CAAA;IAC7C,IAAI,aAAa,CAAC;IAClB,OAAO,CAAC,GAAG,kCAAkC,yBAAyB,EAAE;QACtE,MAAM;QACN,SAAS;QAET,mBAAkB,IAAI,EAAE,UAAU;YAChC,WAAW,OAAO,CAAC,IAAI,CAAC;QAC1B;IAEF;AACF;AAEA,QAAQ,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 15108, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15113, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/utils.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.createUtilsGetter = createUtilsGetter;\nexports.getImportSource = getImportSource;\nexports.getRequireSource = getRequireSource;\nexports.has = has;\nexports.intersection = intersection;\nexports.resolveKey = resolveKey;\nexports.resolveSource = resolveSource;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst {\n  types: t,\n  template: template\n} = _babel.default || _babel;\nfunction intersection(a, b) {\n  const result = new Set();\n  a.forEach(v => b.has(v) && result.add(v));\n  return result;\n}\nfunction has(object, key) {\n  return Object.prototype.hasOwnProperty.call(object, key);\n}\nfunction getType(target) {\n  return Object.prototype.toString.call(target).slice(8, -1);\n}\nfunction resolveId(path) {\n  if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, /* noGlobals */true)) {\n    return path.node.name;\n  }\n  if (path.isPure()) {\n    const {\n      deopt\n    } = path.evaluate();\n    if (deopt && deopt.isIdentifier()) {\n      return deopt.node.name;\n    }\n  }\n}\nfunction resolveKey(path, computed = false) {\n  const {\n    scope\n  } = path;\n  if (path.isStringLiteral()) return path.node.value;\n  const isIdentifier = path.isIdentifier();\n  if (isIdentifier && !(computed || path.parent.computed)) {\n    return path.node.name;\n  }\n  if (computed && path.isMemberExpression() && path.get(\"object\").isIdentifier({\n    name: \"Symbol\"\n  }) && !scope.hasBinding(\"Symbol\", /* noGlobals */true)) {\n    const sym = resolveKey(path.get(\"property\"), path.node.computed);\n    if (sym) return \"Symbol.\" + sym;\n  }\n  if (isIdentifier ? scope.hasBinding(path.node.name, /* noGlobals */true) : path.isPure()) {\n    const {\n      value\n    } = path.evaluate();\n    if (typeof value === \"string\") return value;\n  }\n}\nfunction resolveSource(obj) {\n  if (obj.isMemberExpression() && obj.get(\"property\").isIdentifier({\n    name: \"prototype\"\n  })) {\n    const id = resolveId(obj.get(\"object\"));\n    if (id) {\n      return {\n        id,\n        placement: \"prototype\"\n      };\n    }\n    return {\n      id: null,\n      placement: null\n    };\n  }\n  const id = resolveId(obj);\n  if (id) {\n    return {\n      id,\n      placement: \"static\"\n    };\n  }\n  if (obj.isRegExpLiteral()) {\n    return {\n      id: \"RegExp\",\n      placement: \"prototype\"\n    };\n  } else if (obj.isFunction()) {\n    return {\n      id: \"Function\",\n      placement: \"prototype\"\n    };\n  } else if (obj.isPure()) {\n    const {\n      value\n    } = obj.evaluate();\n    if (value !== undefined) {\n      return {\n        id: getType(value),\n        placement: \"prototype\"\n      };\n    }\n  }\n  return {\n    id: null,\n    placement: null\n  };\n}\nfunction getImportSource({\n  node\n}) {\n  if (node.specifiers.length === 0) return node.source.value;\n}\nfunction getRequireSource({\n  node\n}) {\n  if (!t.isExpressionStatement(node)) return;\n  const {\n    expression\n  } = node;\n  if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === \"require\" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0])) {\n    return expression.arguments[0].value;\n  }\n}\nfunction hoist(node) {\n  // @ts-expect-error\n  node._blockHoist = 3;\n  return node;\n}\nfunction createUtilsGetter(cache) {\n  return path => {\n    const prog = path.findParent(p => p.isProgram());\n    return {\n      injectGlobalImport(url, moduleName) {\n        cache.storeAnonymous(prog, url, moduleName, (isScript, source) => {\n          return isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source);\n        });\n      },\n      injectNamedImport(url, name, hint = name, moduleName) {\n        return cache.storeNamed(prog, url, name, moduleName, (isScript, source, name) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`\n                  var ${id} = require(${source}).${name}\n                `) : t.importDeclaration([t.importSpecifier(id, name)], source),\n            name: id.name\n          };\n        });\n      },\n      injectDefaultImport(url, hint = url, moduleName) {\n        return cache.storeNamed(prog, url, \"default\", moduleName, (isScript, source) => {\n          const id = prog.scope.generateUidIdentifier(hint);\n          return {\n            node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([t.importDefaultSpecifier(id)], source),\n            name: id.name\n          };\n        });\n      }\n    };\n  };\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15301, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15306, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/imports-injector.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _babel = _interopRequireWildcard(require(\"@babel/core\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst {\n  types: t\n} = _babel.default || _babel;\nclass ImportsCachedInjector {\n  constructor(resolver, getPreferredIndex) {\n    this._imports = new WeakMap();\n    this._anonymousImports = new WeakMap();\n    this._lastImports = new WeakMap();\n    this._resolver = resolver;\n    this._getPreferredIndex = getPreferredIndex;\n  }\n  storeAnonymous(programPath, url, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url);\n    const imports = this._ensure(this._anonymousImports, programPath, Set);\n    if (imports.has(key)) return;\n    const node = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)));\n    imports.add(key);\n    this._injectImport(programPath, node, moduleName);\n  }\n  storeNamed(programPath, url, name, moduleName, getVal) {\n    const key = this._normalizeKey(programPath, url, name);\n    const imports = this._ensure(this._imports, programPath, Map);\n    if (!imports.has(key)) {\n      const {\n        node,\n        name: id\n      } = getVal(programPath.node.sourceType === \"script\", t.stringLiteral(this._resolver(url)), t.identifier(name));\n      imports.set(key, id);\n      this._injectImport(programPath, node, moduleName);\n    }\n    return t.identifier(imports.get(key));\n  }\n  _injectImport(programPath, node, moduleName) {\n    var _this$_lastImports$ge;\n    const newIndex = this._getPreferredIndex(moduleName);\n    const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];\n    const isPathStillValid = path => path.node &&\n    // Sometimes the AST is modified and the \"last import\"\n    // we have has been replaced\n    path.parent === programPath.node && path.container === programPath.node.body;\n    let last;\n    if (newIndex === Infinity) {\n      // Fast path: we can always just insert at the end if newIndex is `Infinity`\n      if (lastImports.length > 0) {\n        last = lastImports[lastImports.length - 1].path;\n        if (!isPathStillValid(last)) last = undefined;\n      }\n    } else {\n      for (const [i, data] of lastImports.entries()) {\n        const {\n          path,\n          index\n        } = data;\n        if (isPathStillValid(path)) {\n          if (newIndex < index) {\n            const [newPath] = path.insertBefore(node);\n            lastImports.splice(i, 0, {\n              path: newPath,\n              index: newIndex\n            });\n            return;\n          }\n          last = path;\n        }\n      }\n    }\n    if (last) {\n      const [newPath] = last.insertAfter(node);\n      lastImports.push({\n        path: newPath,\n        index: newIndex\n      });\n    } else {\n      const [newPath] = programPath.unshiftContainer(\"body\", node);\n      this._lastImports.set(programPath, [{\n        path: newPath,\n        index: newIndex\n      }]);\n    }\n  }\n  _ensure(map, programPath, Collection) {\n    let collection = map.get(programPath);\n    if (!collection) {\n      collection = new Collection();\n      map.set(programPath, collection);\n    }\n    return collection;\n  }\n  _normalizeKey(programPath, url, name = \"\") {\n    const {\n      sourceType\n    } = programPath.node;\n\n    // If we rely on the imported binding (the \"name\" parameter), we also need to cache\n    // based on the sourceType. This is because the module transforms change the names\n    // of the import variables.\n    return `${name && sourceType}::${url}::${name}`;\n  }\n}\nexports.default = ImportsCachedInjector;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AACvB,IAAI,SAAS;AACb,SAAS,yBAAyB,WAAW;IAAI,IAAI,OAAO,YAAY,YAAY,OAAO;IAAM,IAAI,oBAAoB,IAAI;IAAW,IAAI,mBAAmB,IAAI;IAAW,OAAO,CAAC,2BAA2B,SAAU,WAAW;QAAI,OAAO,cAAc,mBAAmB;IAAmB,CAAC,EAAE;AAAc;AACtT,SAAS,wBAAwB,GAAG,EAAE,WAAW;IAAI,IAAI,CAAC,eAAe,OAAO,IAAI,UAAU,EAAE;QAAE,OAAO;IAAK;IAAE,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY;QAAE,OAAO;YAAE,SAAS;QAAI;IAAG;IAAE,IAAI,QAAQ,yBAAyB;IAAc,IAAI,SAAS,MAAM,GAAG,CAAC,MAAM;QAAE,OAAO,MAAM,GAAG,CAAC;IAAM;IAAE,IAAI,SAAS,CAAC;IAAG,IAAI,wBAAwB,OAAO,cAAc,IAAI,OAAO,wBAAwB;IAAE,IAAK,IAAI,OAAO,IAAK;QAAE,IAAI,QAAQ,aAAa,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,MAAM;YAAE,IAAI,OAAO,wBAAwB,OAAO,wBAAwB,CAAC,KAAK,OAAO;YAAM,IAAI,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG;gBAAE,OAAO,cAAc,CAAC,QAAQ,KAAK;YAAO,OAAO;gBAAE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI;YAAE;QAAE;IAAE;IAAE,OAAO,OAAO,GAAG;IAAK,IAAI,OAAO;QAAE,MAAM,GAAG,CAAC,KAAK;IAAS;IAAE,OAAO;AAAQ;AACnyB,MAAM,EACJ,OAAO,CAAC,EACT,GAAG,OAAO,OAAO,IAAI;AACtB,MAAM;IACJ,YAAY,QAAQ,EAAE,iBAAiB,CAAE;QACvC,IAAI,CAAC,QAAQ,GAAG,IAAI;QACpB,IAAI,CAAC,iBAAiB,GAAG,IAAI;QAC7B,IAAI,CAAC,YAAY,GAAG,IAAI;QACxB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,kBAAkB,GAAG;IAC5B;IACA,eAAe,WAAW,EAAE,GAAG,EAAE,UAAU,EAAE,MAAM,EAAE;QACnD,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa;QAC5C,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,EAAE,aAAa;QAClE,IAAI,QAAQ,GAAG,CAAC,MAAM;QACtB,MAAM,OAAO,OAAO,YAAY,IAAI,CAAC,UAAU,KAAK,UAAU,EAAE,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC;QAC7F,QAAQ,GAAG,CAAC;QACZ,IAAI,CAAC,aAAa,CAAC,aAAa,MAAM;IACxC;IACA,WAAW,WAAW,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE;QACrD,MAAM,MAAM,IAAI,CAAC,aAAa,CAAC,aAAa,KAAK;QACjD,MAAM,UAAU,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,aAAa;QACzD,IAAI,CAAC,QAAQ,GAAG,CAAC,MAAM;YACrB,MAAM,EACJ,IAAI,EACJ,MAAM,EAAE,EACT,GAAG,OAAO,YAAY,IAAI,CAAC,UAAU,KAAK,UAAU,EAAE,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,UAAU,CAAC;YACxG,QAAQ,GAAG,CAAC,KAAK;YACjB,IAAI,CAAC,aAAa,CAAC,aAAa,MAAM;QACxC;QACA,OAAO,EAAE,UAAU,CAAC,QAAQ,GAAG,CAAC;IAClC;IACA,cAAc,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE;QAC3C,IAAI;QACJ,MAAM,WAAW,IAAI,CAAC,kBAAkB,CAAC;QACzC,MAAM,cAAc,CAAC,wBAAwB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,YAAY,KAAK,OAAO,wBAAwB,EAAE;QACrH,MAAM,mBAAmB,CAAA,OAAQ,KAAK,IAAI,IAC1C,sDAAsD;YACtD,4BAA4B;YAC5B,KAAK,MAAM,KAAK,YAAY,IAAI,IAAI,KAAK,SAAS,KAAK,YAAY,IAAI,CAAC,IAAI;QAC5E,IAAI;QACJ,IAAI,aAAa,UAAU;YACzB,4EAA4E;YAC5E,IAAI,YAAY,MAAM,GAAG,GAAG;gBAC1B,OAAO,WAAW,CAAC,YAAY,MAAM,GAAG,EAAE,CAAC,IAAI;gBAC/C,IAAI,CAAC,iBAAiB,OAAO,OAAO;YACtC;QACF,OAAO;YACL,KAAK,MAAM,CAAC,GAAG,KAAK,IAAI,YAAY,OAAO,GAAI;gBAC7C,MAAM,EACJ,IAAI,EACJ,KAAK,EACN,GAAG;gBACJ,IAAI,iBAAiB,OAAO;oBAC1B,IAAI,WAAW,OAAO;wBACpB,MAAM,CAAC,QAAQ,GAAG,KAAK,YAAY,CAAC;wBACpC,YAAY,MAAM,CAAC,GAAG,GAAG;4BACvB,MAAM;4BACN,OAAO;wBACT;wBACA;oBACF;oBACA,OAAO;gBACT;YACF;QACF;QACA,IAAI,MAAM;YACR,MAAM,CAAC,QAAQ,GAAG,KAAK,WAAW,CAAC;YACnC,YAAY,IAAI,CAAC;gBACf,MAAM;gBACN,OAAO;YACT;QACF,OAAO;YACL,MAAM,CAAC,QAAQ,GAAG,YAAY,gBAAgB,CAAC,QAAQ;YACvD,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,aAAa;gBAAC;oBAClC,MAAM;oBACN,OAAO;gBACT;aAAE;QACJ;IACF;IACA,QAAQ,GAAG,EAAE,WAAW,EAAE,UAAU,EAAE;QACpC,IAAI,aAAa,IAAI,GAAG,CAAC;QACzB,IAAI,CAAC,YAAY;YACf,aAAa,IAAI;YACjB,IAAI,GAAG,CAAC,aAAa;QACvB;QACA,OAAO;IACT;IACA,cAAc,WAAW,EAAE,GAAG,EAAE,OAAO,EAAE,EAAE;QACzC,MAAM,EACJ,UAAU,EACX,GAAG,YAAY,IAAI;QAEpB,mFAAmF;QACnF,kFAAkF;QAClF,2BAA2B;QAC3B,OAAO,GAAG,QAAQ,WAAW,EAAE,EAAE,IAAI,EAAE,EAAE,MAAM;IACjD;AACF;AACA,QAAQ,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 15439, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15444, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/debug-utils.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.presetEnvSilentDebugHeader = void 0;\nexports.stringifyTargets = stringifyTargets;\nexports.stringifyTargetsMultiline = stringifyTargetsMultiline;\nvar _helperCompilationTargets = require(\"@babel/helper-compilation-targets\");\nconst presetEnvSilentDebugHeader = \"#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets\";\nexports.presetEnvSilentDebugHeader = presetEnvSilentDebugHeader;\nfunction stringifyTargetsMultiline(targets) {\n  return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);\n}\nfunction stringifyTargets(targets) {\n  return JSON.stringify(targets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n}"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,0BAA0B,GAAG,KAAK;AAC1C,QAAQ,gBAAgB,GAAG;AAC3B,QAAQ,yBAAyB,GAAG;AACpC,IAAI;AACJ,MAAM,6BAA6B;AACnC,QAAQ,0BAA0B,GAAG;AACrC,SAAS,0BAA0B,OAAO;IACxC,OAAO,KAAK,SAAS,CAAC,CAAC,GAAG,0BAA0B,eAAe,EAAE,UAAU,MAAM;AACvF;AACA,SAAS,iBAAiB,OAAO;IAC/B,OAAO,KAAK,SAAS,CAAC,SAAS,OAAO,CAAC,MAAM,MAAM,OAAO,CAAC,QAAQ,OAAO,OAAO,CAAC,QAAQ;AAC5F","ignoreList":[0]}},
    {"offset": {"line": 15458, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15463, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/normalize-options.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;\nexports.validateIncludeExclude = validateIncludeExclude;\nvar _utils = require(\"./utils\");\nfunction patternToRegExp(pattern) {\n  if (pattern instanceof RegExp) return pattern;\n  try {\n    return new RegExp(`^${pattern}$`);\n  } catch (_unused) {\n    return null;\n  }\n}\nfunction buildUnusedError(label, unused) {\n  if (!unused.length) return \"\";\n  return `  - The following \"${label}\" patterns didn't match any polyfill:\\n` + unused.map(original => `    ${String(original)}\\n`).join(\"\");\n}\nfunction buldDuplicatesError(duplicates) {\n  if (!duplicates.size) return \"\";\n  return `  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\\n` + Array.from(duplicates, name => `    ${name}\\n`).join(\"\");\n}\nfunction validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {\n  let current;\n  const filter = pattern => {\n    const regexp = patternToRegExp(pattern);\n    if (!regexp) return false;\n    let matched = false;\n    for (const polyfill of polyfills.keys()) {\n      if (regexp.test(polyfill)) {\n        matched = true;\n        current.add(polyfill);\n      }\n    }\n    return !matched;\n  };\n\n  // prettier-ignore\n  const include = current = new Set();\n  const unusedInclude = Array.from(includePatterns).filter(filter);\n\n  // prettier-ignore\n  const exclude = current = new Set();\n  const unusedExclude = Array.from(excludePatterns).filter(filter);\n  const duplicates = (0, _utils.intersection)(include, exclude);\n  if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {\n    throw new Error(`Error while validating the \"${provider}\" provider options:\\n` + buildUnusedError(\"include\", unusedInclude) + buildUnusedError(\"exclude\", unusedExclude) + buldDuplicatesError(duplicates));\n  }\n  return {\n    include,\n    exclude\n  };\n}\nfunction applyMissingDependenciesDefaults(options, babelApi) {\n  const {\n    missingDependencies = {}\n  } = options;\n  if (missingDependencies === false) return false;\n  const caller = babelApi.caller(caller => caller == null ? void 0 : caller.name);\n  const {\n    log = \"deferred\",\n    inject = caller === \"rollup-plugin-babel\" ? \"throw\" : \"import\",\n    all = false\n  } = missingDependencies;\n  return {\n    log,\n    inject,\n    all\n  };\n}"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,gCAAgC,GAAG;AAC3C,QAAQ,sBAAsB,GAAG;AACjC,IAAI;AACJ,SAAS,gBAAgB,OAAO;IAC9B,IAAI,mBAAmB,QAAQ,OAAO;IACtC,IAAI;QACF,OAAO,IAAI,OAAO,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;IAClC,EAAE,OAAO,SAAS;QAChB,OAAO;IACT;AACF;AACA,SAAS,iBAAiB,KAAK,EAAE,MAAM;IACrC,IAAI,CAAC,OAAO,MAAM,EAAE,OAAO;IAC3B,OAAO,CAAC,mBAAmB,EAAE,MAAM,uCAAuC,CAAC,GAAG,OAAO,GAAG,CAAC,CAAA,WAAY,CAAC,IAAI,EAAE,OAAO,UAAU,EAAE,CAAC,EAAE,IAAI,CAAC;AACzI;AACA,SAAS,oBAAoB,UAAU;IACrC,IAAI,CAAC,WAAW,IAAI,EAAE,OAAO;IAC7B,OAAO,CAAC,oFAAoF,CAAC,GAAG,MAAM,IAAI,CAAC,YAAY,CAAA,OAAQ,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC;AACvJ;AACA,SAAS,uBAAuB,QAAQ,EAAE,SAAS,EAAE,eAAe,EAAE,eAAe;IACnF,IAAI;IACJ,MAAM,SAAS,CAAA;QACb,MAAM,SAAS,gBAAgB;QAC/B,IAAI,CAAC,QAAQ,OAAO;QACpB,IAAI,UAAU;QACd,KAAK,MAAM,YAAY,UAAU,IAAI,GAAI;YACvC,IAAI,OAAO,IAAI,CAAC,WAAW;gBACzB,UAAU;gBACV,QAAQ,GAAG,CAAC;YACd;QACF;QACA,OAAO,CAAC;IACV;IAEA,kBAAkB;IAClB,MAAM,UAAU,UAAU,IAAI;IAC9B,MAAM,gBAAgB,MAAM,IAAI,CAAC,iBAAiB,MAAM,CAAC;IAEzD,kBAAkB;IAClB,MAAM,UAAU,UAAU,IAAI;IAC9B,MAAM,gBAAgB,MAAM,IAAI,CAAC,iBAAiB,MAAM,CAAC;IACzD,MAAM,aAAa,CAAC,GAAG,OAAO,YAAY,EAAE,SAAS;IACrD,IAAI,WAAW,IAAI,GAAG,KAAK,cAAc,MAAM,GAAG,KAAK,cAAc,MAAM,GAAG,GAAG;QAC/E,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,SAAS,qBAAqB,CAAC,GAAG,iBAAiB,WAAW,iBAAiB,iBAAiB,WAAW,iBAAiB,oBAAoB;IACjM;IACA,OAAO;QACL;QACA;IACF;AACF;AACA,SAAS,iCAAiC,OAAO,EAAE,QAAQ;IACzD,MAAM,EACJ,sBAAsB,CAAC,CAAC,EACzB,GAAG;IACJ,IAAI,wBAAwB,OAAO,OAAO;IAC1C,MAAM,SAAS,SAAS,MAAM,CAAC,CAAA,SAAU,UAAU,OAAO,KAAK,IAAI,OAAO,IAAI;IAC9E,MAAM,EACJ,MAAM,UAAU,EAChB,SAAS,WAAW,wBAAwB,UAAU,QAAQ,EAC9D,MAAM,KAAK,EACZ,GAAG;IACJ,OAAO;QACL;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 15524, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15529, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/visitors/usage.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nfunction isRemoved(path) {\n  if (path.removed) return true;\n  if (!path.parentPath) return false;\n  if (path.listKey) {\n    var _path$parentPath$node;\n    if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;\n  } else {\n    if (path.parentPath.node[path.key] !== path.node) return true;\n  }\n  return isRemoved(path.parentPath);\n}\nvar _default = callProvider => {\n  function property(object, key, placement, path) {\n    return callProvider({\n      kind: \"property\",\n      object,\n      key,\n      placement\n    }, path);\n  }\n  function handleReferencedIdentifier(path) {\n    const {\n      node: {\n        name\n      },\n      scope\n    } = path;\n    if (scope.getBindingIdentifier(name)) return;\n    callProvider({\n      kind: \"global\",\n      name\n    }, path);\n  }\n  function analyzeMemberExpression(path) {\n    const key = (0, _utils.resolveKey)(path.get(\"property\"), path.node.computed);\n    return {\n      key,\n      handleAsMemberExpression: !!key && key !== \"prototype\"\n    };\n  }\n  return {\n    // Symbol(), new Promise\n    ReferencedIdentifier(path) {\n      const {\n        parentPath\n      } = path;\n      if (parentPath.isMemberExpression({\n        object: path.node\n      }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {\n        return;\n      }\n      handleReferencedIdentifier(path);\n    },\n    \"MemberExpression|OptionalMemberExpression\"(path) {\n      const {\n        key,\n        handleAsMemberExpression\n      } = analyzeMemberExpression(path);\n      if (!handleAsMemberExpression) return;\n      const object = path.get(\"object\");\n      let objectIsGlobalIdentifier = object.isIdentifier();\n      if (objectIsGlobalIdentifier) {\n        const binding = object.scope.getBinding(object.node.name);\n        if (binding) {\n          if (binding.path.isImportNamespaceSpecifier()) return;\n          objectIsGlobalIdentifier = false;\n        }\n      }\n      const source = (0, _utils.resolveSource)(object);\n      let skipObject = property(source.id, key, source.placement, path);\n      skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));\n      if (!skipObject) handleReferencedIdentifier(object);\n    },\n    ObjectPattern(path) {\n      const {\n        parentPath,\n        parent\n      } = path;\n      let obj;\n\n      // const { keys, values } = Object\n      if (parentPath.isVariableDeclarator()) {\n        obj = parentPath.get(\"init\");\n        // ({ keys, values } = Object)\n      } else if (parentPath.isAssignmentExpression()) {\n        obj = parentPath.get(\"right\");\n        // !function ({ keys, values }) {...} (Object)\n        // resolution does not work after properties transform :-(\n      } else if (parentPath.isFunction()) {\n        const grand = parentPath.parentPath;\n        if (grand.isCallExpression() || grand.isNewExpression()) {\n          if (grand.node.callee === parent) {\n            obj = grand.get(\"arguments\")[path.key];\n          }\n        }\n      }\n      let id = null;\n      let placement = null;\n      if (obj) ({\n        id,\n        placement\n      } = (0, _utils.resolveSource)(obj));\n      for (const prop of path.get(\"properties\")) {\n        if (prop.isObjectProperty()) {\n          const key = (0, _utils.resolveKey)(prop.get(\"key\"));\n          if (key) property(id, key, placement, prop);\n        }\n      }\n    },\n    BinaryExpression(path) {\n      if (path.node.operator !== \"in\") return;\n      const source = (0, _utils.resolveSource)(path.get(\"right\"));\n      const key = (0, _utils.resolveKey)(path.get(\"left\"), true);\n      if (!key) return;\n      callProvider({\n        kind: \"in\",\n        object: source.id,\n        key,\n        placement: source.placement\n      }, path);\n    }\n  };\n};\nexports.default = _default;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 15640, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15645, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/visitors/entry.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\nvar _utils = require(\"../utils\");\nvar _default = callProvider => ({\n  ImportDeclaration(path) {\n    const source = (0, _utils.getImportSource)(path);\n    if (!source) return;\n    callProvider({\n      kind: \"import\",\n      source\n    }, path);\n  },\n  Program(path) {\n    path.get(\"body\").forEach(bodyPath => {\n      const source = (0, _utils.getRequireSource)(bodyPath);\n      if (!source) return;\n      callProvider({\n        kind: \"import\",\n        source\n      }, bodyPath);\n    });\n  }\n});\nexports.default = _default;"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG,KAAK;AACvB,IAAI;AACJ,IAAI,WAAW,CAAA,eAAgB,CAAC;QAC9B,mBAAkB,IAAI;YACpB,MAAM,SAAS,CAAC,GAAG,OAAO,eAAe,EAAE;YAC3C,IAAI,CAAC,QAAQ;YACb,aAAa;gBACX,MAAM;gBACN;YACF,GAAG;QACL;QACA,SAAQ,IAAI;YACV,KAAK,GAAG,CAAC,QAAQ,OAAO,CAAC,CAAA;gBACvB,MAAM,SAAS,CAAC,GAAG,OAAO,gBAAgB,EAAE;gBAC5C,IAAI,CAAC,QAAQ;gBACb,aAAa;oBACX,MAAM;oBACN;gBACF,GAAG;YACL;QACF;IACF,CAAC;AACD,QAAQ,OAAO,GAAG","ignoreList":[0]}},
    {"offset": {"line": 15670, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15675, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/visitors/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.usage = exports.entry = void 0;\nvar _usage = _interopRequireDefault(require(\"./usage\"));\nexports.usage = _usage.default;\nvar _entry = _interopRequireDefault(require(\"./entry\"));\nexports.entry = _entry.default;\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,KAAK,GAAG,QAAQ,KAAK,GAAG,KAAK;AACrC,IAAI,SAAS;AACb,QAAQ,KAAK,GAAG,OAAO,OAAO;AAC9B,IAAI,SAAS;AACb,QAAQ,KAAK,GAAG,OAAO,OAAO;AAC9B,SAAS,uBAAuB,GAAG;IAAI,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AAAG","ignoreList":[0]}},
    {"offset": {"line": 15687, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15692, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/browser/dependencies.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.has = has;\nexports.laterLogMissing = laterLogMissing;\nexports.logMissing = logMissing;\nexports.resolve = resolve;\nfunction resolve(dirname, moduleName, absoluteImports) {\n  if (absoluteImports === false) return moduleName;\n  throw new Error(`\"absoluteImports\" is not supported in bundles prepared for the browser.`);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction has(basedir, name) {\n  return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction logMissing(missingDeps) {}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction laterLogMissing(missingDeps) {}"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,GAAG,GAAG;AACd,QAAQ,eAAe,GAAG;AAC1B,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG;AAClB,SAAS,QAAQ,OAAO,EAAE,UAAU,EAAE,eAAe;IACnD,IAAI,oBAAoB,OAAO,OAAO;IACtC,MAAM,IAAI,MAAM,CAAC,uEAAuE,CAAC;AAC3F;AAEA,6DAA6D;AAC7D,SAAS,IAAI,OAAO,EAAE,IAAI;IACxB,OAAO;AACT;AAEA,6DAA6D;AAC7D,SAAS,WAAW,WAAW,GAAG;AAElC,6DAA6D;AAC7D,SAAS,gBAAgB,WAAW,GAAG","ignoreList":[0]}},
    {"offset": {"line": 15710, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15715, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/meta-resolver.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = createMetaResolver;\nvar _utils = require(\"./utils\");\nconst PossibleGlobalObjects = new Set([\"global\", \"globalThis\", \"self\", \"window\"]);\nfunction createMetaResolver(polyfills) {\n  const {\n    static: staticP,\n    instance: instanceP,\n    global: globalP\n  } = polyfills;\n  return meta => {\n    if (meta.kind === \"global\" && globalP && (0, _utils.has)(globalP, meta.name)) {\n      return {\n        kind: \"global\",\n        desc: globalP[meta.name],\n        name: meta.name\n      };\n    }\n    if (meta.kind === \"property\" || meta.kind === \"in\") {\n      const {\n        placement,\n        object,\n        key\n      } = meta;\n      if (object && placement === \"static\") {\n        if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) {\n          return {\n            kind: \"global\",\n            desc: globalP[key],\n            name: key\n          };\n        }\n        if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) {\n          return {\n            kind: \"static\",\n            desc: staticP[object][key],\n            name: `${object}$${key}`\n          };\n        }\n      }\n      if (instanceP && (0, _utils.has)(instanceP, key)) {\n        return {\n          kind: \"instance\",\n          desc: instanceP[key],\n          name: `${key}`\n        };\n      }\n    }\n  };\n}"],"names":[],"mappings":"AAAA;AAEA,QAAQ,UAAU,GAAG;AACrB,QAAQ,OAAO,GAAG;AAClB,IAAI;AACJ,MAAM,wBAAwB,IAAI,IAAI;IAAC;IAAU;IAAc;IAAQ;CAAS;AAChF,SAAS,mBAAmB,SAAS;IACnC,MAAM,EACJ,QAAQ,OAAO,EACf,UAAU,SAAS,EACnB,QAAQ,OAAO,EAChB,GAAG;IACJ,OAAO,CAAA;QACL,IAAI,KAAK,IAAI,KAAK,YAAY,WAAW,CAAC,GAAG,OAAO,GAAG,EAAE,SAAS,KAAK,IAAI,GAAG;YAC5E,OAAO;gBACL,MAAM;gBACN,MAAM,OAAO,CAAC,KAAK,IAAI,CAAC;gBACxB,MAAM,KAAK,IAAI;YACjB;QACF;QACA,IAAI,KAAK,IAAI,KAAK,cAAc,KAAK,IAAI,KAAK,MAAM;YAClD,MAAM,EACJ,SAAS,EACT,MAAM,EACN,GAAG,EACJ,GAAG;YACJ,IAAI,UAAU,cAAc,UAAU;gBACpC,IAAI,WAAW,sBAAsB,GAAG,CAAC,WAAW,CAAC,GAAG,OAAO,GAAG,EAAE,SAAS,MAAM;oBACjF,OAAO;wBACL,MAAM;wBACN,MAAM,OAAO,CAAC,IAAI;wBAClB,MAAM;oBACR;gBACF;gBACA,IAAI,WAAW,CAAC,GAAG,OAAO,GAAG,EAAE,SAAS,WAAW,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,CAAC,OAAO,EAAE,MAAM;oBACxF,OAAO;wBACL,MAAM;wBACN,MAAM,OAAO,CAAC,OAAO,CAAC,IAAI;wBAC1B,MAAM,GAAG,OAAO,CAAC,EAAE,KAAK;oBAC1B;gBACF;YACF;YACA,IAAI,aAAa,CAAC,GAAG,OAAO,GAAG,EAAE,WAAW,MAAM;gBAChD,OAAO;oBACL,MAAM;oBACN,MAAM,SAAS,CAAC,IAAI;oBACpB,MAAM,GAAG,KAAK;gBAChB;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 15763, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 15768, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-define-polyfill-provider/lib/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = definePolyfillProvider;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _helperCompilationTargets = _interopRequireWildcard(require(\"@babel/helper-compilation-targets\"));\nvar _utils = require(\"./utils\");\nvar _importsInjector = _interopRequireDefault(require(\"./imports-injector\"));\nvar _debugUtils = require(\"./debug-utils\");\nvar _normalizeOptions = require(\"./normalize-options\");\nvar v = _interopRequireWildcard(require(\"./visitors\"));\nvar deps = _interopRequireWildcard(require(\"./node/dependencies\"));\nvar _metaResolver = _interopRequireDefault(require(\"./meta-resolver\"));\nconst _excluded = [\"method\", \"targets\", \"ignoreBrowserslistConfig\", \"configPath\", \"debug\", \"shouldInjectPolyfill\", \"absoluteImports\"];\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nconst getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;\nfunction resolveOptions(options, babelApi) {\n  const {\n      method,\n      targets: targetsOption,\n      ignoreBrowserslistConfig,\n      configPath,\n      debug,\n      shouldInjectPolyfill,\n      absoluteImports\n    } = options,\n    providerOptions = _objectWithoutPropertiesLoose(options, _excluded);\n  if (isEmpty(options)) {\n    throw new Error(`\\\nThis plugin requires options, for example:\n    {\n      \"plugins\": [\n        [\"<plugin name>\", { method: \"usage-pure\" }]\n      ]\n    }\n\nSee more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);\n  }\n  let methodName;\n  if (method === \"usage-global\") methodName = \"usageGlobal\";else if (method === \"entry-global\") methodName = \"entryGlobal\";else if (method === \"usage-pure\") methodName = \"usagePure\";else if (typeof method !== \"string\") {\n    throw new Error(\".method must be a string\");\n  } else {\n    throw new Error(`.method must be one of \"entry-global\", \"usage-global\"` + ` or \"usage-pure\" (received ${JSON.stringify(method)})`);\n  }\n  if (typeof shouldInjectPolyfill === \"function\") {\n    if (options.include || options.exclude) {\n      throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`);\n    }\n  } else if (shouldInjectPolyfill != null) {\n    throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`);\n  }\n  if (absoluteImports != null && typeof absoluteImports !== \"boolean\" && typeof absoluteImports !== \"string\") {\n    throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`);\n  }\n  let targets;\n  if (\n  // If any browserslist-related option is specified, fallback to the old\n  // behavior of not using the targets specified in the top-level options.\n  targetsOption || configPath || ignoreBrowserslistConfig) {\n    const targetsObj = typeof targetsOption === \"string\" || Array.isArray(targetsOption) ? {\n      browsers: targetsOption\n    } : targetsOption;\n    targets = getTargets(targetsObj, {\n      ignoreBrowserslistConfig,\n      configPath\n    });\n  } else {\n    targets = babelApi.targets();\n  }\n  return {\n    method,\n    methodName,\n    targets,\n    absoluteImports: absoluteImports != null ? absoluteImports : false,\n    shouldInjectPolyfill,\n    debug: !!debug,\n    providerOptions: providerOptions\n  };\n}\nfunction instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {\n  const {\n    method,\n    methodName,\n    targets,\n    debug,\n    shouldInjectPolyfill,\n    providerOptions,\n    absoluteImports\n  } = resolveOptions(options, babelApi);\n\n  // eslint-disable-next-line prefer-const\n  let include, exclude;\n  let polyfillsSupport;\n  let polyfillsNames;\n  let filterPolyfills;\n  const getUtils = (0, _utils.createUtilsGetter)(new _importsInjector.default(moduleName => deps.resolve(dirname, moduleName, absoluteImports), name => {\n    var _polyfillsNames$get, _polyfillsNames;\n    return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;\n  }));\n  const depsCache = new Map();\n  const api = {\n    babel: babelApi,\n    getUtils,\n    method: options.method,\n    targets,\n    createMetaResolver: _metaResolver.default,\n    shouldInjectPolyfill(name) {\n      if (polyfillsNames === undefined) {\n        throw new Error(`Internal error in the ${factory.name} provider: ` + `shouldInjectPolyfill() can't be called during initialization.`);\n      }\n      if (!polyfillsNames.has(name)) {\n        console.warn(`Internal error in the ${providerName} provider: ` + `unknown polyfill \"${name}\".`);\n      }\n      if (filterPolyfills && !filterPolyfills(name)) return false;\n      let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {\n        compatData: polyfillsSupport,\n        includes: include,\n        excludes: exclude\n      });\n      if (shouldInjectPolyfill) {\n        shouldInject = shouldInjectPolyfill(name, shouldInject);\n        if (typeof shouldInject !== \"boolean\") {\n          throw new Error(`.shouldInjectPolyfill must return a boolean.`);\n        }\n      }\n      return shouldInject;\n    },\n    debug(name) {\n      var _debugLog, _debugLog$polyfillsSu;\n      debugLog().found = true;\n      if (!debug || !name) return;\n      if (debugLog().polyfills.has(providerName)) return;\n      debugLog().polyfills.add(name);\n      (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;\n    },\n    assertDependency(name, version = \"*\") {\n      if (missingDependencies === false) return;\n      if (absoluteImports) {\n        // If absoluteImports is not false, we will try resolving\n        // the dependency and throw if it's not possible. We can\n        // skip the check here.\n        return;\n      }\n      const dep = version === \"*\" ? name : `${name}@^${version}`;\n      const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, () => deps.has(dirname, name));\n      if (!found) {\n        debugLog().missingDeps.add(dep);\n      }\n    }\n  };\n  const provider = factory(api, providerOptions, dirname);\n  const providerName = provider.name || factory.name;\n  if (typeof provider[methodName] !== \"function\") {\n    throw new Error(`The \"${providerName}\" provider doesn't support the \"${method}\" polyfilling method.`);\n  }\n  if (Array.isArray(provider.polyfills)) {\n    polyfillsNames = new Map(provider.polyfills.map((name, index) => [name, index]));\n    filterPolyfills = provider.filterPolyfills;\n  } else if (provider.polyfills) {\n    polyfillsNames = new Map(Object.keys(provider.polyfills).map((name, index) => [name, index]));\n    polyfillsSupport = provider.polyfills;\n    filterPolyfills = provider.filterPolyfills;\n  } else {\n    polyfillsNames = new Map();\n  }\n  ({\n    include,\n    exclude\n  } = (0, _normalizeOptions.validateIncludeExclude)(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));\n  let callProvider;\n  if (methodName === \"usageGlobal\") {\n    callProvider = (payload, path) => {\n      var _ref;\n      const utils = getUtils(path);\n      return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;\n    };\n  } else {\n    callProvider = (payload, path) => {\n      const utils = getUtils(path);\n      provider[methodName](payload, utils, path);\n      return false;\n    };\n  }\n  return {\n    debug,\n    method,\n    targets,\n    provider,\n    providerName,\n    callProvider\n  };\n}\nfunction definePolyfillProvider(factory) {\n  return (0, _helperPluginUtils.declare)((babelApi, options, dirname) => {\n    babelApi.assertVersion(\"^7.0.0 || ^8.0.0-alpha.0\");\n    const {\n      traverse\n    } = babelApi;\n    let debugLog;\n    const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);\n    const {\n      debug,\n      method,\n      targets,\n      provider,\n      providerName,\n      callProvider\n    } = instantiateProvider(factory, options, missingDependencies, dirname, () => debugLog, babelApi);\n    const createVisitor = method === \"entry-global\" ? v.entry : v.usage;\n    const visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);\n    if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {\n      console.log(`${providerName}: \\`DEBUG\\` option`);\n      console.log(`\\nUsing targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`);\n      console.log(`\\nUsing polyfills with \\`${method}\\` method:`);\n    }\n    const {\n      runtimeName\n    } = provider;\n    return {\n      name: \"inject-polyfills\",\n      visitor,\n      pre(file) {\n        var _provider$pre;\n        if (runtimeName) {\n          if (file.get(\"runtimeHelpersModuleName\") && file.get(\"runtimeHelpersModuleName\") !== runtimeName) {\n            console.warn(`Two different polyfill providers` + ` (${file.get(\"runtimeHelpersModuleProvider\")}` + ` and ${providerName}) are trying to define two` + ` conflicting @babel/runtime alternatives:` + ` ${file.get(\"runtimeHelpersModuleName\")} and ${runtimeName}.` + ` The second one will be ignored.`);\n          } else {\n            file.set(\"runtimeHelpersModuleName\", runtimeName);\n            file.set(\"runtimeHelpersModuleProvider\", providerName);\n          }\n        }\n        debugLog = {\n          polyfills: new Set(),\n          polyfillsSupport: undefined,\n          found: false,\n          providers: new Set(),\n          missingDeps: new Set()\n        };\n        (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);\n      },\n      post() {\n        var _provider$post;\n        (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);\n        if (missingDependencies !== false) {\n          if (missingDependencies.log === \"per-file\") {\n            deps.logMissing(debugLog.missingDeps);\n          } else {\n            deps.laterLogMissing(debugLog.missingDeps);\n          }\n        }\n        if (!debug) return;\n        if (this.filename) console.log(`\\n[${this.filename}]`);\n        if (debugLog.polyfills.size === 0) {\n          console.log(method === \"entry-global\" ? debugLog.found ? `Based on your targets, the ${providerName} polyfill did not add any polyfill.` : `The entry point for the ${providerName} polyfill has not been found.` : `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`);\n          return;\n        }\n        if (method === \"entry-global\") {\n          console.log(`The ${providerName} polyfill entry has been replaced with ` + `the following polyfills:`);\n        } else {\n          console.log(`The ${providerName} polyfill added the following polyfills:`);\n        }\n        for (const name of debugLog.polyfills) {\n          var _debugLog$polyfillsSu2;\n          if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {\n            const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);\n            const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, \", \").replace(/^\\{\"/, '{ \"').replace(/\"\\}$/, '\" }');\n            console.log(`  ${name} ${formattedTargets}`);\n          } else {\n            console.log(`  ${name}`);\n          }\n        }\n      }\n    };\n  });\n}\nfunction mapGetOr(map, key, getDefault) {\n  let val = map.get(key);\n  if (val === undefined) {\n    val = getDefault();\n    map.set(key, val);\n  }\n  return val;\n}\nfunction isEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16100, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-syntax-typescript/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var removePlugin = function (plugins: any[], name: string) {\n    const indices: number[] = [];\n    plugins.forEach((plugin, i) => {\n      const n = Array.isArray(plugin) ? plugin[0] : plugin;\n\n      if (n === name) {\n        indices.unshift(i);\n      }\n    });\n\n    for (const i of indices) {\n      plugins.splice(i, 1);\n    }\n  };\n}\n\nexport interface Options {\n  disallowAmbiguousJSXLike?: boolean;\n  dts?: boolean;\n  isTSX?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { disallowAmbiguousJSXLike, dts } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { isTSX } = opts;\n  }\n\n  return {\n    name: \"syntax-typescript\",\n\n    manipulateOptions(opts, parserOpts) {\n      if (!process.env.BABEL_8_BREAKING) {\n        const { plugins } = parserOpts;\n        // If the Flow syntax plugin already ran, remove it since Typescript\n        // takes priority.\n        removePlugin(plugins, \"flow\");\n\n        // If the JSX syntax plugin already ran, remove it because JSX handling\n        // in TS depends on the extensions, and is purely dependent on 'isTSX'.\n        removePlugin(plugins, \"jsx\");\n\n        if (!process.env.BABEL_8_BREAKING) {\n          // These are now enabled by default in @babel/parser, but we push\n          // them for compat with older versions.\n          // @ts-ignore(Babel 7 vs Babel 8) These plugins have been removed\n          plugins.push(\"objectRestSpread\", \"classProperties\");\n        }\n\n        if (isTSX) {\n          plugins.push(\"jsx\");\n        }\n      }\n\n      parserOpts.plugins.push([\n        \"typescript\",\n        { disallowAmbiguousJSXLike, dts },\n      ]);\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","removePlugin","plugins","name","indices","forEach","plugin","i","n","Array","isArray","unshift","splice","_default","exports","default","declare","api","opts","assertVersion","disallowAmbiguousJSXLike","dts","isTSX","manipulateOptions","parserOpts","push"],"mappings":";;;;;AAAA,IAAAA,kBAAA,GAAAC,OAAA;AAEmC;IAEjC,IAAIC,YAAY,GAAG,SAAAA,AAAUC,OAAc,EAAEC,IAAY,EAAE;QACzD,MAAMC,OAAiB,GAAG,EAAE;QAC5BF,OAAO,CAACG,OAAO,CAAC,CAACC,MAAM,EAAEC,CAAC,KAAK;YAC7B,MAAMC,CAAC,GAAGC,KAAK,CAACC,OAAO,CAACJ,MAAM,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM;YAEpD,IAAIE,CAAC,KAAKL,IAAI,EAAE;gBACdC,OAAO,CAACO,OAAO,CAACJ,CAAC,CAAC;YACpB;QACF,CAAC,CAAC;QAEF,KAAK,MAAMA,CAAC,IAAIH,OAAO,CAAE;YACvBF,OAAO,CAACU,MAAM,CAACL,CAAC,EAAE,CAAC,CAAC;QACtB;IACF,CAAC;AACH,CAAC,IAAAM,QAAA,GAAAC,OAAA,CAAAC,OAAA,GAQc,CAAA,GAAAC,mBAAAA,OAAO,EAAC,CAACC,GAAG,EAAEC,IAAa,KAAK;IAC7CD,GAAG,CAACE,aAAa,CAAkB,CAAE,CAAC;IAEtC,MAAM,EAAEC,wBAAwB,EAAEC,GAAAA,EAAK,GAAGH,IAAI;IAEX;QAEjC,IAAI,EAAEI,KAAAA,EAAO,GAAGJ,IAAI;IACtB;IAEA,OAAO;QACLf,IAAI,EAAE,mBAAmB;QAEzBoB,iBAAiBA,EAACL,IAAI,EAAEM,UAAU,EAAE;YACC;gBACjC,MAAM,EAAEtB,OAAAA,EAAS,GAAGsB,UAAU;gBAG9BvB,YAAY,CAACC,OAAO,EAAE,MAAM,CAAC;gBAI7BD,YAAY,CAACC,OAAO,EAAE,KAAK,CAAC;gBAEO;oBAIjCA,OAAO,CAACuB,IAAI,CAAC,kBAAkB,EAAE,iBAAiB,CAAC;gBACrD;gBAEA,IAAIH,KAAK,EAAE;oBACTpB,OAAO,CAACuB,IAAI,CAAC,KAAK,CAAC;gBACrB;YACF;YAEAD,UAAU,CAACtB,OAAO,CAACuB,IAAI,CAAC;gBACtB,YAAY;gBACZ;oBAAEL,wBAAwB;oBAAEC;gBAAI,CAAC;aAClC,CAAC;QACJ;IACF,CAAC;AACH,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 16149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16154, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typescript/src/enum.ts"],"sourcesContent":["import { template, types as t, type NodePath } from \"@babel/core\";\nimport assert from \"assert\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\ntype t = typeof t;\n\nconst ENUMS = new WeakMap<t.Identifier, PreviousEnumMembers>();\n\nconst buildEnumWrapper = template.expression(\n  `\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `,\n);\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node, parentPath } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const { fill, data, isPure } = enumFill(path, t, node.id);\n\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      // todo: Consider exclude program with import/export\n      // && !path.parent.body.some(n => t.isImportDeclaration(n) || t.isExportDeclaration(n));\n      const isGlobal = t.isProgram(path.parent);\n      const isSeen = seen(parentPath);\n\n      let init: t.Expression = t.objectExpression([]);\n      if (isSeen || isGlobal) {\n        init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n      }\n      const enumIIFE = buildEnumWrapper({ ...fill, INIT: init });\n      if (isPure) annotateAsPure(enumIIFE);\n\n      if (isSeen) {\n        const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n        toReplace.replaceWith(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE),\n          ),\n        );\n      } else {\n        path.scope.registerDeclaration(\n          path.replaceWith(\n            t.variableDeclaration(isGlobal ? \"var\" : \"let\", [\n              t.variableDeclarator(node.id, enumIIFE),\n            ]),\n          )[0],\n        );\n      }\n      ENUMS.set(path.scope.getBindingIdentifier(name), data);\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const { enumValues: x, data, isPure } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(isSyntacticallyString(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments,\n    },\n    data,\n    isPure,\n  };\n}\n\nexport function isSyntacticallyString(expr: t.Expression): boolean {\n  // @ts-ignore(Babel 7 vs Babel 8) Type 'Expression | Super' is not assignable to type 'Expression' in Babel 8\n  expr = skipTransparentExprWrapperNodes(expr);\n  switch (expr.type) {\n    case \"BinaryExpression\": {\n      const left = expr.left;\n      const right = expr.right;\n      return (\n        expr.operator === \"+\" &&\n        (isSyntacticallyString(left as t.Expression) ||\n          isSyntacticallyString(right))\n      );\n    }\n    case \"TemplateLiteral\":\n    case \"StringLiteral\":\n      return true;\n  }\n  return false;\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(path: NodePath<t.TSEnumDeclaration>, t: t) {\n  const bindingIdentifier = path.scope.getBindingIdentifier(path.node.id.name);\n  const seen: PreviousEnumMembers = ENUMS.get(bindingIdentifier) ?? new Map();\n\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n  let isPure = true;\n\n  const enumValues: Array<[name: string, value: t.Expression]> = path\n    .get(\"members\")\n    .map(memberPath => {\n      const member = memberPath.node;\n      const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n      const initializerPath = memberPath.get(\"initializer\");\n      const initializer = member.initializer;\n      let value: t.Expression;\n      if (initializer) {\n        constValue = computeConstantValue(initializerPath, seen);\n        if (constValue !== undefined) {\n          seen.set(name, constValue);\n          assert(\n            typeof constValue === \"number\" || typeof constValue === \"string\",\n          );\n          // We do not use `t.valueToNode` because `Infinity`/`NaN` might refer\n          // to a local variable. Even 1/0\n          // Revisit once https://github.com/microsoft/TypeScript/issues/55091\n          // is fixed. Note: we will have to distinguish between actual\n          // infinities and reference  to non-infinite variables names Infinity.\n          if (constValue === Infinity || Number.isNaN(constValue)) {\n            value = t.identifier(String(constValue));\n          } else if (constValue === -Infinity) {\n            value = t.unaryExpression(\"-\", t.identifier(\"Infinity\"));\n          } else {\n            value = t.valueToNode(constValue);\n          }\n        } else {\n          isPure &&= initializerPath.isPure();\n\n          if (initializerPath.isReferencedIdentifier()) {\n            ReferencedIdentifier(initializerPath, {\n              t,\n              seen,\n              path,\n            });\n          } else {\n            initializerPath.traverse(enumSelfReferenceVisitor, {\n              t,\n              seen,\n              path,\n            });\n          }\n\n          value = initializerPath.node;\n          seen.set(name, undefined);\n        }\n      } else if (typeof constValue === \"number\") {\n        constValue += 1;\n        value = t.numericLiteral(constValue);\n        seen.set(name, constValue);\n      } else if (typeof constValue === \"string\") {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      } else {\n        // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n        const lastRef = t.memberExpression(\n          t.cloneNode(path.node.id),\n          t.stringLiteral(lastName),\n          true,\n        );\n        value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n        seen.set(name, undefined);\n      }\n\n      lastName = name;\n      return [name, value];\n    });\n\n  return {\n    isPure,\n    data: seen,\n    enumValues,\n  };\n}\n\n// Based on the TypeScript repository's `computeConstantValue` in `checker.ts`.\nfunction computeConstantValue(\n  path: NodePath,\n  prevMembers?: PreviousEnumMembers,\n  seen: Set<t.Identifier> = new Set(),\n): number | string | undefined {\n  return evaluate(path);\n\n  function evaluate(path: NodePath): number | string | undefined {\n    const expr = path.node;\n    switch (expr.type) {\n      case \"MemberExpression\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(path as NodePath<t.UnaryExpression>);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(path as NodePath<t.BinaryExpression>);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evaluate(path.get(\"expression\"));\n      case \"Identifier\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"TemplateLiteral\": {\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n        const paths = (path as NodePath<t.TemplateLiteral>).get(\"expressions\");\n        const quasis = expr.quasis;\n        let str = \"\";\n\n        for (let i = 0; i < quasis.length; i++) {\n          str += quasis[i].value.cooked;\n\n          if (i + 1 < quasis.length) {\n            const value = evaluateRef(paths[i], prevMembers, seen);\n            if (value === undefined) return undefined;\n            str += value;\n          }\n        }\n        return str;\n      }\n      default:\n        return undefined;\n    }\n  }\n\n  function evaluateRef(\n    path: NodePath,\n    prevMembers: PreviousEnumMembers,\n    seen: Set<t.Identifier>,\n  ): number | string | undefined {\n    if (path.isMemberExpression()) {\n      const expr = path.node;\n\n      const obj = expr.object;\n      const prop = expr.property;\n      if (\n        !t.isIdentifier(obj) ||\n        (expr.computed ? !t.isStringLiteral(prop) : !t.isIdentifier(prop))\n      ) {\n        return;\n      }\n      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);\n      const data = ENUMS.get(bindingIdentifier);\n      if (!data) return;\n      // @ts-expect-error checked above\n      return data.get(prop.computed ? prop.value : prop.name);\n    } else if (path.isIdentifier()) {\n      const name = path.node.name;\n\n      if ([\"Infinity\", \"NaN\"].includes(name)) {\n        return Number(name);\n      }\n\n      let value = prevMembers?.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n\n      value = computeConstantValue(path.resolve(), prevMembers, seen);\n      prevMembers?.set(name, value);\n      return value;\n    }\n  }\n\n  function evalUnaryExpression(\n    path: NodePath<t.UnaryExpression>,\n  ): number | string | undefined {\n    const value = evaluate(path.get(\"argument\"));\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-unary-minus\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(\n    path: NodePath<t.BinaryExpression>,\n  ): number | string | undefined {\n    const left = evaluate(path.get(\"left\")) as any;\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evaluate(path.get(\"right\")) as any;\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      default:\n        return undefined;\n    }\n  }\n}\n"],"names":["_core","require","_assert","_helperAnnotateAsPure","_helperSkipTransparentExpressionWrappers","ENUMS","WeakMap","buildEnumWrapper","template","expression","transpileEnum","path","t","node","parentPath","declare","remove","name","id","fill","data","isPure","enumFill","type","isGlobal","isProgram","parent","isSeen","seen","init","objectExpression","logicalExpression","cloneNode","ID","enumIIFE","Object","assign","INIT","annotateAsPure","toReplace","isExportDeclaration","replaceWith","expressionStatement","assignmentExpression","scope","registerDeclaration","variableDeclaration","variableDeclarator","set","getBindingIdentifier","Error","getData","setData","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","enumValues","x","translateEnumValues","assignments","map","memberName","memberValue","isSyntacticallyString","ENUM","NAME","VALUE","ASSIGNMENTS","expr","skipTransparentExprWrapperNodes","left","right","operator","ReferencedIdentifier","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","_ENUMS$get","bindingIdentifier","get","Map","constValue","lastName","memberPath","member","isIdentifier","value","initializerPath","initializer","computeConstantValue","undefined","assert","Infinity","Number","isNaN","identifier","String","unaryExpression","valueToNode","isReferencedIdentifier","traverse","numericLiteral","buildCodeFrameError","lastRef","stringLiteral","binaryExpression","prevMembers","Set","evaluate","evaluateRef","evalUnaryExpression","evalBinaryExpression","quasis","length","cooked","paths","str","i","isMemberExpression","obj","object","prop","property","computed","isStringLiteral","includes","add","resolve","Math","pow"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16469, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typescript/src/const-enum.ts"],"sourcesContent":["import type { NodePath, types as t } from \"@babel/core\";\n\nimport { translateEnumValues } from \"./enum.ts\";\n\nexport type NodePathConstEnum = NodePath<t.TSEnumDeclaration & { const: true }>;\nexport default function transpileConstEnum(\n  path: NodePathConstEnum,\n  t: typeof import(\"@babel/types\"),\n) {\n  const { name } = path.node.id;\n\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(\n      stmt =>\n        t.isExportNamedDeclaration(stmt) &&\n        stmt.exportKind !== \"type\" &&\n        !stmt.source &&\n        stmt.specifiers.some(\n          spec =>\n            t.isExportSpecifier(spec) &&\n            spec.exportKind !== \"type\" &&\n            spec.local.name === name,\n        ),\n    );\n  }\n\n  const { enumValues: entries } = translateEnumValues(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(\n      entries.map(([name, value]) =>\n        t.objectProperty(\n          t.isValidIdentifier(name)\n            ? t.identifier(name)\n            : t.stringLiteral(name),\n          value,\n        ),\n      ),\n    );\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(\n        t.expressionStatement(\n          t.callExpression(\n            t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n            [path.node.id, obj],\n          ),\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.variableDeclaration(process.env.BABEL_8_BREAKING ? \"const\" : \"var\", [\n          t.variableDeclarator(path.node.id, obj),\n        ]),\n      );\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n\n  // TODO: After fixing https://github.com/babel/babel/pull/11065, we can\n  // use path.scope.getBinding(name).referencePaths rather than doing\n  // a full traversal.\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, { name })) return;\n\n      let key: string;\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n      if (!entriesMap.has(key)) return;\n\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    },\n  });\n\n  path.remove();\n}\n"],"names":["_enum","require","transpileConstEnum","path","t","name","node","id","parentIsExport","parentPath","isExportNamedDeclaration","isExported","isProgram","parent","body","some","stmt","exportKind","source","specifiers","spec","isExportSpecifier","local","enumValues","entries","translateEnumValues","obj","objectExpression","map","value","objectProperty","isValidIdentifier","identifier","stringLiteral","scope","hasOwnBinding","replaceWith","expressionStatement","callExpression","memberExpression","variableDeclaration","variableDeclarator","registerDeclaration","entriesMap","Map","traverse","Scope","skip","MemberExpression","isIdentifier","object","key","computed","isStringLiteral","property","has","cloneNode","get","remove"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16525, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16530, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typescript/src/global-types.ts"],"sourcesContent":["import type { NodePath, Scope } from \"@babel/core\";\n\nexport const GLOBAL_TYPES = new WeakMap<Scope, Set<string>>();\n\nexport function isGlobalType({ scope }: NodePath, name: string) {\n  if (scope.hasBinding(name)) return false;\n  if (GLOBAL_TYPES.get(scope).has(name)) return true;\n\n  console.warn(\n    `The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` +\n      `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` +\n      `never encountered it as a TypeScript type declaration.\\n` +\n      `It will be treated as a JavaScript value.\\n\\n` +\n      `This problem is likely caused by another plugin injecting\\n` +\n      `\"${name}\" without registering it in the scope tracker. If you are the author\\n` +\n      ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`,\n  );\n\n  return false;\n}\n\nexport function registerGlobalType(programScope: Scope, name: string) {\n  GLOBAL_TYPES.get(programScope).add(name);\n}\n"],"names":["GLOBAL_TYPES","exports","WeakMap","isGlobalType","scope","name","hasBinding","get","has","console","warn","registerGlobalType","programScope","add"],"mappings":";;;;;;;AAEO,MAAMA,YAAY,GAAAC,OAAA,CAAAD,YAAA,GAAG,IAAIE,OAAO,CAAqB,CAAC;AAEtD,SAASC,YAAYA,CAAC,EAAEC,KAAAA,EAAiB,EAAEC,IAAY,EAAE;IAC9D,IAAID,KAAK,CAACE,UAAU,CAACD,IAAI,CAAC,EAAE,OAAO,KAAK;IACxC,IAAIL,YAAY,CAACO,GAAG,CAACH,KAAK,CAAC,CAACI,GAAG,CAACH,IAAI,CAAC,EAAE,OAAO,IAAI;IAElDI,OAAO,CAACC,IAAI,CACV,CAAA,yBAAA,EAA4BL,IAAI,CAAA,4CAAA,CAA8C,GAC5E,CAAA,yEAAA,CAA2E,GAC3E,CAAA,wDAAA,CAA0D,GAC1D,CAAA,6CAAA,CAA+C,GAC/C,CAAA,2DAAA,CAA6D,GAC7D,CAAA,CAAA,EAAIA,IAAI,CAAA,sEAAA,CAAwE,GAChF,CAAA,yEAAA,CACJ,CAAC;IAED,OAAO,KAAK;AACd;AAEO,SAASM,kBAAkBA,CAACC,YAAmB,EAAEP,IAAY,EAAE;IACpEL,YAAY,CAACO,GAAG,CAACK,YAAY,CAAC,CAACC,GAAG,CAACR,IAAI,CAAC;AAC1C","ignoreList":[0]}},
    {"offset": {"line": 16547, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16552, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typescript/src/namespace.ts"],"sourcesContent":["import { template, types as t, type NodePath } from \"@babel/core\";\n\nimport { registerGlobalType } from \"./global-types.ts\";\n\nexport function getFirstIdentifier(node: t.TSEntityName): t.Identifier {\n  if (t.isIdentifier(node)) {\n    return node;\n  }\n  return getFirstIdentifier(node.left);\n}\n\nexport default function transpileNamespace(\n  path: NodePath<t.TSModuleDeclaration>,\n  allowNamespaces: boolean,\n) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path\n      .get(\"id\")\n      .buildCodeFrameError(\n        \"Namespace not marked type-only declare.\" +\n          \" Non-declarative namespaces are only supported experimentally in Babel.\" +\n          \" To enable and review caveats see:\" +\n          \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n      );\n  }\n\n  const name = getFirstIdentifier(path.node.id).name;\n  const value = handleNested(path, path.node);\n  if (value === null) {\n    // This means that `path` is a type-only namespace.\n    // We call `registerGlobalType` here to allow it to be stripped.\n    const program = path.findParent(p => p.isProgram());\n    registerGlobalType(program.scope, name);\n\n    path.remove();\n  } else if (path.scope.hasOwnBinding(name)) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(\n      path.replaceWithMultiple([getDeclaration(name), value])[0],\n    );\n  }\n}\n\nfunction getDeclaration(name: string) {\n  return t.variableDeclaration(\"let\", [\n    t.variableDeclarator(t.identifier(name)),\n  ]);\n}\n\nfunction getMemberExpression(name: string, itemName: string) {\n  return t.memberExpression(t.identifier(name), t.identifier(itemName));\n}\n\n/**\n * Convert export const foo = 1 to Namespace.foo = 1;\n *\n * @param {t.VariableDeclaration} node given variable declaration, e.g. `const foo = 1`\n * @param {string} name the generated unique namespace member name\n * @param {*} hub An instance implements HubInterface defined in `@babel/traverse` that can throw a code frame error\n */\nfunction handleVariableDeclaration(\n  node: t.VariableDeclaration,\n  name: string,\n  hub: any,\n): t.Statement[] {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(\n      node,\n      \"Namespaces exporting non-const are not supported by Babel.\" +\n        \" Change to const or see:\" +\n        \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n    );\n  }\n  const { declarations } = node;\n  if (\n    declarations.every(\n      (declarator): declarator is t.VariableDeclarator & { id: t.Identifier } =>\n        t.isIdentifier(declarator.id),\n    )\n  ) {\n    // `export const a = 1` transforms to `const a = N.a = 1`, the output\n    // is smaller than `const a = 1; N.a = a`;\n    for (const declarator of declarations) {\n      declarator.init = t.assignmentExpression(\n        \"=\",\n        getMemberExpression(name, declarator.id.name),\n        declarator.init,\n      );\n    }\n    return [node];\n  }\n  // Now we have pattern in declarators\n  // `export const [a] = 1` transforms to `const [a] = 1; N.a = a`\n  const bindingIdentifiers = t.getBindingIdentifiers(node);\n  const assignments = [];\n  // getBindingIdentifiers returns an object without prototype.\n  // eslint-disable-next-line guard-for-in\n  for (const idName in bindingIdentifiers) {\n    assignments.push(\n      t.assignmentExpression(\n        \"=\",\n        getMemberExpression(name, idName),\n        t.cloneNode(bindingIdentifiers[idName]),\n      ),\n    );\n  }\n  return [node, t.expressionStatement(t.sequenceExpression(assignments))];\n}\n\nfunction buildNestedAmbientModuleError(path: NodePath, node: t.Node) {\n  return path.hub.buildError(\n    node,\n    \"Ambient modules cannot be nested in other modules or namespaces.\",\n    Error,\n  );\n}\n\nfunction handleNested(\n  path: NodePath,\n  node: t.TSModuleDeclaration,\n  parentExport?: t.Expression,\n): t.Statement | null {\n  const names = new Set();\n  const realName =\n    !process.env.BABEL_8_BREAKING || t.isIdentifier(node.id)\n      ? (node.id as t.Identifier)\n      : getFirstIdentifier(node.id as unknown as t.TSQualifiedName);\n\n  const name = path.scope.generateUid(realName.name);\n\n  const body = node.body;\n  let id = node.id;\n  let namespaceTopLevel: t.Statement[];\n  if (process.env.BABEL_8_BREAKING) {\n    if (t.isTSQualifiedName(id)) {\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      namespaceTopLevel = body.body;\n      while (t.isTSQualifiedName(id)) {\n        namespaceTopLevel = [\n          t.exportNamedDeclaration(\n            t.tsModuleDeclaration(\n              // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n              t.cloneNode(id.right),\n              t.tsModuleBlock(namespaceTopLevel),\n            ),\n          ),\n        ];\n\n        // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n        id = id.left;\n      }\n    } else {\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      namespaceTopLevel = body.body;\n    }\n  } else {\n    namespaceTopLevel = t.isTSModuleBlock(body)\n      ? body.body\n      : // We handle `namespace X.Y {}` as if it was\n        //   namespace X {\n        //     export namespace Y {}\n        //   }\n        [t.exportNamedDeclaration(body)];\n  }\n\n  let isEmpty = true;\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    // The first switch is mainly to detect name usage. Only export\n    // declarations require further transformation.\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.id)) {\n          throw buildNestedAmbientModuleError(path, subNode);\n        }\n\n        const transformed = handleNested(path, subNode);\n        if (transformed !== null) {\n          isEmpty = false;\n          const moduleName = subNode.id.name;\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(\n              i++,\n              1,\n              getDeclaration(moduleName),\n              transformed,\n            );\n          }\n        }\n        continue;\n      }\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        isEmpty = false;\n        names.add(subNode.id.name);\n        continue;\n      case \"VariableDeclaration\": {\n        isEmpty = false;\n        // getBindingIdentifiers returns an object without prototype.\n        // eslint-disable-next-line guard-for-in\n        for (const name in t.getBindingIdentifiers(subNode)) {\n          names.add(name);\n        }\n        continue;\n      }\n      default:\n        isEmpty &&= t.isTypeScript(subNode);\n        // Neither named declaration nor export, continue to next item.\n        continue;\n      case \"ExportNamedDeclaration\":\n      // Export declarations get parsed using the next switch.\n    }\n\n    if (\"declare\" in subNode.declaration && subNode.declaration.declare) {\n      continue;\n    }\n\n    // Transform the export declarations that occur inside of a namespace.\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\": {\n        isEmpty = false;\n        const itemName = subNode.declaration.id.name;\n        names.add(itemName);\n        namespaceTopLevel.splice(\n          i++,\n          1,\n          subNode.declaration,\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              getMemberExpression(name, itemName),\n              t.identifier(itemName),\n            ),\n          ),\n        );\n        break;\n      }\n      case \"VariableDeclaration\": {\n        isEmpty = false;\n        const nodes = handleVariableDeclaration(\n          subNode.declaration,\n          name,\n          path.hub,\n        );\n        namespaceTopLevel.splice(i, nodes.length, ...nodes);\n        i += nodes.length - 1;\n        break;\n      }\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.declaration.id)) {\n          throw buildNestedAmbientModuleError(path, subNode.declaration);\n        }\n\n        const transformed = handleNested(\n          path,\n          subNode.declaration,\n          t.identifier(name),\n        );\n        if (transformed !== null) {\n          isEmpty = false;\n          const moduleName = subNode.declaration.id.name;\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(\n              i++,\n              1,\n              getDeclaration(moduleName),\n              transformed,\n            );\n          }\n        } else {\n          namespaceTopLevel.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  }\n\n  if (isEmpty) return null;\n\n  // {}\n  let fallthroughValue: t.Expression = t.objectExpression([]);\n\n  if (parentExport) {\n    const memberExpr = t.memberExpression(parentExport, realName);\n    fallthroughValue = template.expression.ast`\n      ${t.cloneNode(memberExpr)} ||\n        (${t.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n\n  return template.statement.ast`\n    (function (${t.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}\n"],"names":["_core","require","_globalTypes","getFirstIdentifier","node","t","isIdentifier","left","transpileNamespace","path","allowNamespaces","declare","id","type","remove","get","buildCodeFrameError","name","value","handleNested","program","findParent","p","isProgram","registerGlobalType","scope","hasOwnBinding","replaceWith","registerDeclaration","replaceWithMultiple","getDeclaration","variableDeclaration","variableDeclarator","identifier","getMemberExpression","itemName","memberExpression","handleVariableDeclaration","hub","kind","file","declarations","every","declarator","init","assignmentExpression","bindingIdentifiers","getBindingIdentifiers","assignments","idName","push","cloneNode","expressionStatement","sequenceExpression","buildNestedAmbientModuleError","buildError","Error","parentExport","names","Set","realName","generateUid","body","namespaceTopLevel","isTSModuleBlock","exportNamedDeclaration","isEmpty","i","length","subNode","transformed","moduleName","has","add","splice","isTypeScript","declaration","nodes","fallthroughValue","objectExpression","memberExpr","template","expression","ast","statement"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 16735, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 16740, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-typescript/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxTypeScript from \"@babel/plugin-syntax-typescript\";\nimport type { PluginPass, types as t, Scope, NodePath } from \"@babel/core\";\nimport { injectInitialization } from \"@babel/helper-create-class-features-plugin\";\nimport type { Options as SyntaxOptions } from \"@babel/plugin-syntax-typescript\";\n\nimport transpileConstEnum from \"./const-enum.ts\";\nimport type { NodePathConstEnum } from \"./const-enum.ts\";\nimport transpileEnum from \"./enum.ts\";\nimport {\n  GLOBAL_TYPES,\n  isGlobalType,\n  registerGlobalType,\n} from \"./global-types.ts\";\nimport transpileNamespace, { getFirstIdentifier } from \"./namespace.ts\";\n\nfunction isInType(path: NodePath) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case process.env.BABEL_8_BREAKING\n      ? \"TSClassImplements\"\n      : \"TSExpressionWithTypeArguments\":\n    case process.env.BABEL_8_BREAKING\n      ? \"TSInterfaceHeritage\"\n      : \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return (\n        // `import foo = ns.bar` is transformed to `var foo = ns.bar` and should not be removed\n        path.parentPath.findParent(path => path.type !== \"TSQualifiedName\")\n          .type !== \"TSImportEqualsDeclaration\"\n      );\n    case \"ExportSpecifier\":\n      return (\n        // export { type foo };\n        path.parent.exportKind === \"type\" ||\n        // export type { foo };\n        // @ts-expect-error: DeclareExportDeclaration does not have `exportKind`\n        (path.parentPath as NodePath<t.ExportSpecifier>).parent.exportKind ===\n          \"type\"\n      );\n    default:\n      return false;\n  }\n}\n\n// Track programs which contain imports/exports of values, so that we can include\n// empty exports for programs that do not, but were parsed as modules. This allows\n// tools to infer unambiguously that results are ESM.\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\n// A hack to avoid removing the impl Binding when we remove the declare NodePath\nfunction safeRemove(path: NodePath) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\n\nfunction assertCjsTransformEnabled(\n  path: NodePath,\n  pass: PluginPass,\n  wrong: string,\n  suggestion: string,\n  extra: string = \"\",\n): void {\n  if (pass.file.get(\"@babel/plugin-transform-modules-*\") !== \"commonjs\") {\n    throw path.buildCodeFrameError(\n      `\\`${wrong}\\` is only supported when compiling modules to CommonJS.\\n` +\n        `Please consider using \\`${suggestion}\\`${extra}, or add ` +\n        `@babel/plugin-transform-modules-commonjs to your Babel config.`,\n    );\n  }\n}\n\nexport interface Options extends SyntaxOptions {\n  /** @default true */\n  allowNamespaces?: boolean;\n  /** @default \"React.createElement\" */\n  jsxPragma?: string;\n  /** @default \"React.Fragment\" */\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  allowDeclareFields?: boolean;\n}\n\ntype ExtraNodeProps = {\n  declare?: unknown;\n  accessibility?: unknown;\n  abstract?: unknown;\n  optional?: unknown;\n  override?: unknown;\n};\n\nexport default declare((api, opts: Options) => {\n  // `@babel/core` and `@babel/types` are bundled in some downstream libraries.\n  // Ref: https://github.com/babel/babel/issues/15089\n  const { types: t, template } = api;\n\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+(\\S+)/;\n\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false,\n  } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  const classMemberVisitors = {\n    field(\n      path: NodePath<\n        (t.ClassPrivateProperty | t.ClassProperty | t.ClassAccessorProperty) &\n          ExtraNodeProps\n      >,\n    ) {\n      const { node } = path;\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(\n            `The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` +\n              `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`,\n          );\n        }\n      }\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Definitely assigned fields cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!process.env.BABEL_8_BREAKING) {\n          // keep the definitely assigned fields only when `allowDeclareFields` (equivalent of\n          // Typescript's `useDefineForClassFields`) is true\n          if (\n            !allowDeclareFields &&\n            !node.decorators &&\n            !t.isClassPrivateProperty(node)\n          ) {\n            path.remove();\n          }\n        }\n      } else if (node.abstract) {\n        path.remove();\n      } else if (!process.env.BABEL_8_BREAKING) {\n        if (\n          !allowDeclareFields &&\n          !node.value &&\n          !node.decorators &&\n          !t.isClassPrivateProperty(node)\n        ) {\n          path.remove();\n        }\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n    method({ node }: NodePath<t.ClassMethod | t.ClassPrivateMethod>) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n\n      // Rest handled by Function visitor\n    },\n    constructor(path: NodePath<t.ClassMethod>, classPath: NodePath<t.Class>) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      // Collects parameter properties so that we can add an assignment\n      // for each of them in the constructor body\n      //\n      // We use a WeakSet to ensure an assignment for a parameter\n      // property is only added once. This is necessary for cases like\n      // using `transform-classes`, which causes this visitor to run\n      // twice.\n      const assigns: t.ExpressionStatement[] = [];\n      const { scope } = path;\n      for (const paramPath of path.get(\"params\")) {\n        const param = paramPath.node;\n        if (param.type === \"TSParameterProperty\") {\n          const parameter = param.parameter;\n          if (PARSED_PARAMS.has(parameter)) continue;\n          PARSED_PARAMS.add(parameter);\n          let id;\n          if (t.isIdentifier(parameter)) {\n            id = parameter;\n          } else if (\n            t.isAssignmentPattern(parameter) &&\n            t.isIdentifier(parameter.left)\n          ) {\n            id = parameter.left;\n          } else {\n            throw paramPath.buildCodeFrameError(\n              \"Parameter properties can not be destructuring patterns.\",\n            );\n          }\n          assigns.push(\n            template.statement.ast`\n              this.${t.cloneNode(id)} = ${t.cloneNode(id)}\n            ` as t.ExpressionStatement,\n          );\n\n          paramPath.replaceWith(paramPath.get(\"parameter\"));\n          scope.registerBinding(\"param\", paramPath);\n        }\n      }\n      injectInitialization(classPath, path, assigns);\n    },\n  };\n\n  return {\n    name: \"transform-typescript\",\n    inherits: syntaxTypeScript,\n\n    visitor: {\n      //\"Pattern\" alias doesn't include Identifier or RestElement.\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program: {\n        enter(path, state) {\n          const { file } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programScope = path.scope;\n\n          if (!GLOBAL_TYPES.has(programScope)) {\n            GLOBAL_TYPES.set(programScope, new Set());\n          }\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  // isFragment\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n\n          // remove type imports\n          for (let stmt of path.get(\"body\") as Iterable<\n            NodePath<t.Statement | t.Expression>\n          >) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programScope, specifier.local.name);\n                }\n                stmt.remove();\n                continue;\n              }\n\n              const importsToRemove: Set<NodePath<t.Node>> = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n              const isAllSpecifiersElided = () =>\n                specifiersLength > 0 &&\n                specifiersLength === importsToRemove.size;\n\n              for (const specifier of stmt.node.specifiers) {\n                if (\n                  specifier.type === \"ImportSpecifier\" &&\n                  specifier.importKind === \"type\"\n                ) {\n                  registerGlobalType(programScope, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n\n              // If onlyRemoveTypeImports is `true`, only remove type-only imports\n              // and exports introduced in TypeScript 3.8.\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                // Note: this will allow both `import { } from \"m\"` and `import \"m\";`.\n                // In TypeScript, the former would be elided.\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  // The binding may not exist if the import node was explicitly\n                  // injected by another plugin. Currently core does not do a good job\n                  // of keeping scope bindings synchronized with the AST. For now we\n                  // just bail if there is no binding, since chances are good that if\n                  // the import statement was injected then it wasn't a typescript type\n                  // import anyway.\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (\n                      isImportTypeOnly({\n                        binding,\n                        programPath: path,\n                        pragmaImportName,\n                        pragmaFragImportName,\n                      })\n                    ) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n\n              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n\n              continue;\n            }\n\n            if (stmt.isExportDeclaration()) {\n              stmt = stmt.get(\"declaration\");\n            }\n\n            if (stmt.isVariableDeclaration({ declare: true })) {\n              for (const name of Object.keys(stmt.getBindingIdentifiers())) {\n                registerGlobalType(programScope, name);\n              }\n            } else if (\n              stmt.isTSTypeAliasDeclaration() ||\n              (stmt.isTSDeclareFunction() && stmt.get(\"id\").isIdentifier()) ||\n              stmt.isTSInterfaceDeclaration() ||\n              stmt.isClassDeclaration({ declare: true }) ||\n              stmt.isTSEnumDeclaration({ declare: true }) ||\n              (stmt.isTSModuleDeclaration({ declare: true }) &&\n                stmt.get(\"id\").isIdentifier())\n            ) {\n              registerGlobalType(\n                programScope,\n                (stmt.node.id as t.Identifier).name,\n              );\n            }\n          }\n        },\n        exit(path) {\n          if (\n            path.node.sourceType === \"module\" &&\n            NEEDS_EXPLICIT_ESM.get(path.node)\n          ) {\n            // If there are no remaining value exports, this file can no longer\n            // be inferred to be ESM. Leave behind an empty export declaration\n            // so it can be.\n            path.pushContainer(\"body\", t.exportNamedDeclaration());\n          }\n        },\n      },\n\n      ExportNamedDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        if (path.node.exportKind === \"type\") {\n          path.remove();\n          return;\n        }\n\n        // remove export declaration that is filled with type-only specifiers\n        //   export { type A1, type A2 } from \"a\";\n        if (\n          path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              specifier.type === \"ExportSpecifier\" &&\n              specifier.exportKind === \"type\",\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        // remove export declaration if it's exporting only types\n        // This logic is needed when exportKind is \"value\", because\n        // currently the \"type\" keyword is optional.\n        // TODO:\n        // Also, currently @babel/parser sets exportKind to \"value\" for\n        //   export interface A {}\n        //   etc.\n        if (\n          !path.node.source &&\n          path.node.specifiers.length > 0 &&\n          path.node.specifiers.every(\n            specifier =>\n              t.isExportSpecifier(specifier) &&\n              isGlobalType(path, specifier.local.name),\n          )\n        ) {\n          path.remove();\n          return;\n        }\n\n        // Convert `export namespace X {}` into `export let X; namespace X {}`,\n        // so that when visiting TSModuleDeclaration we do not have to possibly\n        // replace its parent path.\n        if (t.isTSModuleDeclaration(path.node.declaration)) {\n          const namespace = path.node.declaration;\n          if (!t.isStringLiteral(namespace.id)) {\n            const id = getFirstIdentifier(namespace.id);\n            if (path.scope.hasOwnBinding(id.name)) {\n              path.replaceWith(namespace);\n            } else {\n              const [newExport] = path.replaceWithMultiple([\n                t.exportNamedDeclaration(\n                  t.variableDeclaration(\"let\", [\n                    t.variableDeclarator(t.cloneNode(id)),\n                  ]),\n                ),\n                namespace,\n              ]);\n              path.scope.registerDeclaration(newExport);\n            }\n          }\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      ExportAllDeclaration(path) {\n        if (path.node.exportKind === \"type\") path.remove();\n      },\n\n      ExportSpecifier(path) {\n        // remove type exports\n        type Parent = t.ExportDeclaration & { source?: t.StringLiteral };\n        const parent = path.parent as Parent;\n        if (\n          (!parent.source && isGlobalType(path, path.node.local.name)) ||\n          path.node.exportKind === \"type\"\n        ) {\n          path.remove();\n        }\n      },\n\n      ExportDefaultDeclaration(path, state) {\n        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n        }\n\n        // remove whole declaration if it's exporting a TS type\n        if (\n          t.isIdentifier(path.node.declaration) &&\n          isGlobalType(path, path.node.declaration.name)\n        ) {\n          path.remove();\n\n          return;\n        }\n\n        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);\n      },\n\n      TSDeclareFunction(path) {\n        safeRemove(path);\n      },\n\n      TSDeclareMethod(path) {\n        safeRemove(path);\n      },\n\n      VariableDeclaration(path) {\n        if (path.node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      VariableDeclarator({ node }) {\n        if (node.definite) node.definite = null;\n      },\n\n      TSIndexSignature(path) {\n        path.remove();\n      },\n\n      ClassDeclaration(path) {\n        const { node } = path;\n        if (node.declare) {\n          safeRemove(path);\n        }\n      },\n\n      Class(path) {\n        const { node }: { node: typeof path.node & ExtraNodeProps } = path;\n\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.superTypeParameters) node.superTypeParameters = null;\n        if (node.implements) node.implements = null;\n        if (node.abstract) node.abstract = null;\n\n        // Similar to the logic in `transform-flow-strip-types`, we need to\n        // handle `TSParameterProperty` and `ClassProperty` here because the\n        // class transform would transform the class, causing more specific\n        // visitors to not run.\n        path.get(\"body.body\").forEach(child => {\n          if (child.isClassMethod() || child.isClassPrivateMethod()) {\n            if (child.node.kind === \"constructor\") {\n              classMemberVisitors.constructor(\n                // @ts-expect-error A constructor must not be a private method\n                child,\n                path,\n              );\n            } else {\n              classMemberVisitors.method(child);\n            }\n          } else if (\n            child.isClassProperty() ||\n            child.isClassPrivateProperty() ||\n            child.isClassAccessorProperty()\n          ) {\n            classMemberVisitors.field(child);\n          }\n        });\n      },\n\n      Function(path) {\n        const { node } = path;\n        if (node.typeParameters) node.typeParameters = null;\n        if (node.returnType) node.returnType = null;\n\n        const params = node.params;\n        if (params.length > 0 && t.isIdentifier(params[0], { name: \"this\" })) {\n          params.shift();\n        }\n      },\n\n      TSModuleDeclaration(path) {\n        transpileNamespace(path, allowNamespaces);\n      },\n\n      TSInterfaceDeclaration(path) {\n        path.remove();\n      },\n\n      TSTypeAliasDeclaration(path) {\n        path.remove();\n      },\n\n      TSEnumDeclaration(path) {\n        if (optimizeConstEnums && path.node.const) {\n          transpileConstEnum(path as NodePathConstEnum, t);\n        } else {\n          transpileEnum(path, t);\n        }\n      },\n\n      TSImportEqualsDeclaration(\n        path: NodePath<t.TSImportEqualsDeclaration>,\n        pass,\n      ) {\n        const { id, moduleReference, isExport } = path.node;\n\n        let init: t.Expression;\n        let varKind: \"var\" | \"const\";\n        if (t.isTSExternalModuleReference(moduleReference)) {\n          // import alias = require('foo');\n          assertCjsTransformEnabled(\n            path,\n            pass,\n            `import ${id.name} = require(...);`,\n            `import ${id.name} from '...';`,\n            \" alongside Typescript's --allowSyntheticDefaultImports option\",\n          );\n          init = t.callExpression(t.identifier(\"require\"), [\n            moduleReference.expression,\n          ]);\n          varKind = \"const\";\n        } else {\n          // import alias = Namespace;\n          init = entityNameToExpr(moduleReference);\n          varKind = \"var\";\n        }\n        const newNode = t.variableDeclaration(varKind, [\n          t.variableDeclarator(id, init),\n        ]);\n\n        path.replaceWith(\n          isExport ? t.exportNamedDeclaration(newNode) : newNode,\n        );\n        path.scope.registerDeclaration(path);\n      },\n\n      TSExportAssignment(path, pass) {\n        assertCjsTransformEnabled(\n          path,\n          pass,\n          `export = <value>;`,\n          `export default <value>;`,\n        );\n        path.replaceWith(\n          template.statement.ast`module.exports = ${path.node.expression}`,\n        );\n      },\n\n      TSTypeAssertion(path) {\n        path.replaceWith(path.node.expression);\n      },\n\n      [`TSAsExpression${\n        // Added in Babel 7.20.0\n        t.tsSatisfiesExpression ? \"|TSSatisfiesExpression\" : \"\"\n      }`](path: NodePath<t.TSAsExpression | t.TSSatisfiesExpression>) {\n        let { node }: { node: t.Expression } = path;\n        do {\n          node = node.expression;\n        } while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression?.(node));\n        path.replaceWith(node);\n      },\n\n      [process.env.BABEL_8_BREAKING\n        ? \"TSNonNullExpression|TSInstantiationExpression\"\n        : /* This has been introduced in Babel 7.18.0\n             We use api.types.* and not t.* for feature detection,\n             because the Babel version that is running this plugin\n             (where we check if the visitor is valid) might be different\n             from the Babel version that we resolve with `import \"@babel/core\"`.\n             This happens, for example, with Next.js that bundled `@babel/core`\n             but allows loading unbundled plugin (which cannot obviously import\n             the bundled `@babel/core` version).\n           */\n          api.types.tsInstantiationExpression\n          ? \"TSNonNullExpression|TSInstantiationExpression\"\n          : \"TSNonNullExpression\"](\n        path: NodePath<t.TSNonNullExpression | t.TSInstantiationExpression>,\n      ) {\n        path.replaceWith(path.node.expression);\n      },\n\n      CallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      OptionalCallExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      NewExpression(path) {\n        path.node.typeParameters = null;\n      },\n\n      JSXOpeningElement(path) {\n        path.node.typeParameters = null;\n      },\n\n      TaggedTemplateExpression(path) {\n        path.node.typeParameters = null;\n      },\n    },\n  };\n\n  function entityNameToExpr(node: t.TSEntityName): t.Expression {\n    if (t.isTSQualifiedName(node)) {\n      return t.memberExpression(entityNameToExpr(node.left), node.right);\n    }\n\n    return node;\n  }\n\n  function visitPattern({\n    node,\n  }: NodePath<t.Identifier | t.Pattern | t.RestElement>) {\n    if (node.typeAnnotation) node.typeAnnotation = null;\n    if (t.isIdentifier(node) && node.optional) node.optional = null;\n    // 'access' and 'readonly' are only for parameter properties, so constructor visitor will handle them.\n  }\n\n  function isImportTypeOnly({\n    binding,\n    programPath,\n    pragmaImportName,\n    pragmaFragImportName,\n  }: {\n    binding: Scope.Binding;\n    programPath: NodePath<t.Program>;\n    pragmaImportName: string;\n    pragmaFragImportName: string;\n  }) {\n    for (const path of binding.referencePaths) {\n      if (!isInType(path)) {\n        return false;\n      }\n    }\n\n    if (\n      binding.identifier.name !== pragmaImportName &&\n      binding.identifier.name !== pragmaFragImportName\n    ) {\n      return true;\n    }\n\n    // \"React\" or the JSX pragma is referenced as a value if there are any JSX elements/fragments in the code.\n    let sourceFileHasJsx = false;\n    programPath.traverse({\n      \"JSXElement|JSXFragment\"(path) {\n        sourceFileHasJsx = true;\n        path.stop();\n      },\n    });\n    return !sourceFileHasJsx;\n  }\n});\n"],"names":["_helperPluginUtils","require","_pluginSyntaxTypescript","_helperCreateClassFeaturesPlugin","_constEnum","_enum","_globalTypes","_namespace","isInType","path","parent","type","parentPath","findParent","exportKind","NEEDS_EXPLICIT_ESM","WeakMap","PARSED_PARAMS","WeakSet","safeRemove","ids","getBindingIdentifiers","name","Object","keys","binding","scope","getBinding","identifier","removeBinding","opts","noScope","remove","assertCjsTransformEnabled","pass","wrong","suggestion","extra","file","get","buildCodeFrameError","_default","exports","default","declare","api","types","t","template","assertVersion","JSX_PRAGMA_REGEX","allowNamespaces","jsxPragma","jsxPragmaFrag","onlyRemoveTypeImports","optimizeConstEnums","allowDeclareFields","classMemberVisitors","field","node","value","decorators","definite","isClassPrivateProperty","abstract","accessibility","readonly","optional","typeAnnotation","override","method","constructor","classPath","assigns","paramPath","param","parameter","has","add","id","isIdentifier","isAssignmentPattern","left","push","statement","ast","cloneNode","replaceWith","registerBinding","injectInitialization","inherits","syntaxTypeScript","visitor","Pattern","visitPattern","Identifier","RestElement","Program","enter","state","fileJsxPragma","fileJsxPragmaFrag","programScope","GLOBAL_TYPES","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","pragmaFragImportName","stmt","isImportDeclaration","program","importKind","specifier","specifiers","registerGlobalType","local","importsToRemove","specifiersLength","length","isAllSpecifiersElided","size","isImportTypeOnly","programPath","importPath","isExportDeclaration","isVariableDeclaration","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","exit","sourceType","pushContainer","exportNamedDeclaration","ExportNamedDeclaration","source","every","isExportSpecifier","isGlobalType","declaration","namespace","isStringLiteral","getFirstIdentifier","hasOwnBinding","newExport","replaceWithMultiple","variableDeclaration","variableDeclarator","registerDeclaration","ExportAllDeclaration","ExportSpecifier","ExportDefaultDeclaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","isClassAccessorProperty","Function","returnType","params","shift","TSModuleDeclaration","transpileNamespace","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","const","transpileConstEnum","transpileEnum","TSImportEqualsDeclaration","moduleReference","isExport","init","varKind","isTSExternalModuleReference","callExpression","expression","entityNameToExpr","newNode","TSExportAssignment","TSTypeAssertion","tsSatisfiesExpression","isTSAsExpression","isTSSatisfiesExpression","tsInstantiationExpression","CallExpression","OptionalCallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","isTSQualifiedName","memberExpression","right","referencePaths","sourceFileHasJsx","traverse","JSXElement|JSXFragment","stop"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17197, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-typescript/src/normalize-options.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-typescript/src/plugin-rewrite-ts-imports.ts","file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/preset-typescript/src/index.ts"],"sourcesContent":["import { OptionValidator } from \"@babel/helper-validator-option\";\nconst v = new OptionValidator(\"@babel/preset-typescript\");\n\nexport interface Options {\n  ignoreExtensions?: boolean;\n  allowDeclareFields?: boolean;\n  allowNamespaces?: boolean;\n  disallowAmbiguousJSXLike?: boolean;\n  jsxPragma?: string;\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  rewriteImportExtensions?: boolean;\n\n  // TODO: Remove in Babel 8\n  allExtensions?: boolean;\n  isTSX?: boolean;\n}\n\nexport default function normalizeOptions(options: Options = {}) {\n  let { allowNamespaces = true, jsxPragma, onlyRemoveTypeImports } = options;\n\n  const TopLevelOptions: {\n    [Key in keyof Omit<Options, \"allowDeclareFields\">]-?: Key;\n  } = {\n    ignoreExtensions: \"ignoreExtensions\",\n    allowNamespaces: \"allowNamespaces\",\n    disallowAmbiguousJSXLike: \"disallowAmbiguousJSXLike\",\n    jsxPragma: \"jsxPragma\",\n    jsxPragmaFrag: \"jsxPragmaFrag\",\n    onlyRemoveTypeImports: \"onlyRemoveTypeImports\",\n    optimizeConstEnums: \"optimizeConstEnums\",\n    rewriteImportExtensions: \"rewriteImportExtensions\",\n\n    // TODO: Remove in Babel 8\n    allExtensions: \"allExtensions\",\n    isTSX: \"isTSX\",\n  };\n\n  if (process.env.BABEL_8_BREAKING) {\n    v.invariant(\n      !(\"allowDeclareFields\" in options),\n      \"The .allowDeclareFields option has been removed and it's now always enabled. Please remove it from your config.\",\n    );\n    v.invariant(\n      !(\"allExtensions\" in options) && !(\"isTSX\" in options),\n      \"The .allExtensions and .isTSX options have been removed.\\n\" +\n        \"If you want to disable JSX detection based on file extensions, \" +\n        \"you can set the .ignoreExtensions option to true.\\n\" +\n        \"If you want to force JSX parsing, you can enable the \" +\n        \"@babel/plugin-syntax-jsx plugin.\",\n    );\n\n    v.validateTopLevelOptions(options, TopLevelOptions);\n    allowNamespaces = v.validateBooleanOption(\n      TopLevelOptions.allowNamespaces,\n      options.allowNamespaces,\n      true,\n    );\n    jsxPragma = v.validateStringOption(\n      TopLevelOptions.jsxPragma,\n      options.jsxPragma,\n      \"React\",\n    );\n    onlyRemoveTypeImports = v.validateBooleanOption(\n      TopLevelOptions.onlyRemoveTypeImports,\n      options.onlyRemoveTypeImports,\n      true,\n    );\n  }\n\n  const jsxPragmaFrag = v.validateStringOption(\n    TopLevelOptions.jsxPragmaFrag,\n    options.jsxPragmaFrag,\n    \"React.Fragment\",\n  );\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var allExtensions = v.validateBooleanOption(\n      TopLevelOptions.allExtensions,\n      options.allExtensions,\n      false,\n    );\n\n    // eslint-disable-next-line no-var\n    var isTSX = v.validateBooleanOption(\n      TopLevelOptions.isTSX,\n      options.isTSX,\n      false,\n    );\n    if (isTSX) {\n      v.invariant(allExtensions, \"isTSX:true requires allExtensions:true\");\n    }\n  }\n\n  const ignoreExtensions = v.validateBooleanOption(\n    TopLevelOptions.ignoreExtensions,\n    options.ignoreExtensions,\n    false,\n  );\n\n  const disallowAmbiguousJSXLike = v.validateBooleanOption(\n    TopLevelOptions.disallowAmbiguousJSXLike,\n    options.disallowAmbiguousJSXLike,\n    false,\n  );\n  if (disallowAmbiguousJSXLike) {\n    if (process.env.BABEL_8_BREAKING) {\n      v.invariant(\n        ignoreExtensions,\n        \"disallowAmbiguousJSXLike:true requires ignoreExtensions:true\",\n      );\n    } else {\n      v.invariant(\n        allExtensions,\n        \"disallowAmbiguousJSXLike:true requires allExtensions:true\",\n      );\n    }\n  }\n\n  const optimizeConstEnums = v.validateBooleanOption(\n    TopLevelOptions.optimizeConstEnums,\n    options.optimizeConstEnums,\n    false,\n  );\n\n  const rewriteImportExtensions = v.validateBooleanOption(\n    TopLevelOptions.rewriteImportExtensions,\n    options.rewriteImportExtensions,\n    false,\n  );\n\n  const normalized: Options = {\n    ignoreExtensions,\n    allowNamespaces,\n    disallowAmbiguousJSXLike,\n    jsxPragma,\n    jsxPragmaFrag,\n    onlyRemoveTypeImports,\n    optimizeConstEnums,\n    rewriteImportExtensions,\n  };\n  if (!process.env.BABEL_8_BREAKING) {\n    normalized.allExtensions = allExtensions;\n    normalized.isTSX = isTSX;\n  }\n  return normalized;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport type { types as t, NodePath } from \"@babel/core\";\n\nexport default declare(function ({ types: t, template }) {\n  function maybeReplace(\n    source: t.ArgumentPlaceholder | t.SpreadElement | t.Expression,\n    path: NodePath,\n  ) {\n    if (!source) return;\n    if (t.isStringLiteral(source)) {\n      if (/[\\\\/]/.test(source.value)) {\n        source.value = source.value\n          .replace(/(\\.[mc]?)ts$/, \"$1js\")\n          .replace(/\\.tsx$/, \".js\");\n      }\n      return;\n    }\n\n    path.replaceWith(\n      template.expression\n        .ast`(${source} + \"\").replace(/([\\\\/].*\\.[mc]?)tsx?$/, \"$1js\")`,\n    );\n  }\n\n  return {\n    name: \"preset-typescript/plugin-rewrite-ts-imports\",\n    visitor: {\n      \"ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration\"(\n        path: NodePath<\n          | t.ImportDeclaration\n          | t.ExportAllDeclaration\n          | t.ExportNamedDeclaration\n        >,\n      ) {\n        const node = path.node;\n        const kind = t.isImportDeclaration(node)\n          ? node.importKind\n          : node.exportKind;\n        if (kind === \"value\") {\n          maybeReplace(node.source, path.get(\"source\"));\n        }\n      },\n      CallExpression(path) {\n        if (t.isImport(path.node.callee)) {\n          maybeReplace(path.node.arguments[0], path.get(\"arguments.0\"));\n        }\n      },\n      ImportExpression(path) {\n        maybeReplace(path.node.source, path.get(\"source\"));\n      },\n    },\n  };\n});\n","import { declarePreset } from \"@babel/helper-plugin-utils\";\nimport transformTypeScript from \"@babel/plugin-transform-typescript\";\nimport syntaxJSX from \"@babel/plugin-syntax-jsx\";\nimport transformModulesCommonJS from \"@babel/plugin-transform-modules-commonjs\";\nimport normalizeOptions from \"./normalize-options.ts\";\nimport type { Options } from \"./normalize-options.ts\";\nimport pluginRewriteTSImports from \"./plugin-rewrite-ts-imports.ts\";\n\nexport default declarePreset((api, opts: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const {\n    allExtensions,\n    ignoreExtensions,\n    allowNamespaces,\n    disallowAmbiguousJSXLike,\n    isTSX,\n    jsxPragma,\n    jsxPragmaFrag,\n    onlyRemoveTypeImports,\n    optimizeConstEnums,\n    rewriteImportExtensions,\n  } = normalizeOptions(opts);\n\n  const pluginOptions = process.env.BABEL_8_BREAKING\n    ? (disallowAmbiguousJSXLike: boolean) => ({\n        allowNamespaces,\n        disallowAmbiguousJSXLike,\n        jsxPragma,\n        jsxPragmaFrag,\n        onlyRemoveTypeImports,\n        optimizeConstEnums,\n      })\n    : (disallowAmbiguousJSXLike: boolean) => ({\n        allowDeclareFields: opts.allowDeclareFields,\n        allowNamespaces,\n        disallowAmbiguousJSXLike,\n        jsxPragma,\n        jsxPragmaFrag,\n        onlyRemoveTypeImports,\n        optimizeConstEnums,\n      });\n\n  const getPlugins = (isTSX: boolean, disallowAmbiguousJSXLike: boolean) => {\n    if (process.env.BABEL_8_BREAKING) {\n      const tsPlugin = [\n        transformTypeScript,\n        pluginOptions(disallowAmbiguousJSXLike),\n      ];\n      return isTSX ? [tsPlugin, syntaxJSX] : [tsPlugin];\n    } else {\n      return [\n        [\n          transformTypeScript,\n          { isTSX, ...pluginOptions(disallowAmbiguousJSXLike) },\n        ],\n      ];\n    }\n  };\n\n  const disableExtensionDetect = allExtensions || ignoreExtensions;\n\n  return {\n    plugins: rewriteImportExtensions ? [pluginRewriteTSImports] : [],\n    overrides: disableExtensionDetect\n      ? [{ plugins: getPlugins(isTSX, disallowAmbiguousJSXLike) }]\n      : // Only set 'test' if explicitly requested, since it requires that\n        // Babel is being called with a filename.\n        [\n          {\n            test: !process.env.BABEL_8_BREAKING\n              ? /\\.ts$/\n              : filename => filename == null || filename.endsWith(\".ts\"),\n            plugins: getPlugins(false, false),\n          },\n          {\n            test: !process.env.BABEL_8_BREAKING\n              ? /\\.mts$/\n              : filename => filename?.endsWith(\".mts\"),\n            sourceType: \"module\",\n            plugins: getPlugins(false, true),\n          },\n          {\n            test: !process.env.BABEL_8_BREAKING\n              ? /\\.cts$/\n              : filename => filename?.endsWith(\".cts\"),\n            sourceType: \"unambiguous\",\n            plugins: [\n              [transformModulesCommonJS, { allowTopLevelThis: true }],\n              [transformTypeScript, pluginOptions(true)],\n            ],\n          },\n          {\n            test: !process.env.BABEL_8_BREAKING\n              ? /\\.tsx$/\n              : filename => filename?.endsWith(\".tsx\"),\n            // disallowAmbiguousJSXLike is a no-op when parsing TSX, since it's\n            // always disallowed.\n            plugins: getPlugins(true, false),\n          },\n        ],\n  };\n});\n"],"names":["v","OptionValidator","normalizeOptions","options","allowNamespaces","jsxPragma","onlyRemoveTypeImports","TopLevelOptions","ignoreExtensions","disallowAmbiguousJSXLike","jsxPragmaFrag","optimizeConstEnums","rewriteImportExtensions","allExtensions","isTSX","validateStringOption","validateBooleanOption","invariant","normalized","declare","types","t","template","maybeReplace","source","path","isStringLiteral","test","value","replace","replaceWith","expression","ast","name","visitor","ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration","node","kind","isImportDeclaration","importKind","exportKind","get","CallExpression","isImport","callee","arguments","ImportExpression","declarePreset","api","opts","assertVersion","pluginOptions","allowDeclareFields","getPlugins","transformTypeScript","Object","assign","disableExtensionDetect","plugins","pluginRewriteTSImports","overrides","sourceType","transformModulesCommonJS","allowTopLevelThis"],"mappings":"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","ignoreList":[0,1,2]}},
    {"offset": {"line": 17360, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 17365, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/plugin-transform-react-constant-elements/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t, template } from \"@babel/core\";\nimport type { Visitor, Scope, NodePath } from \"@babel/core\";\n\nexport interface Options {\n  allowMutablePropsOnTags?: null | string[];\n}\n\ninterface VisitorState {\n  isImmutable: boolean;\n  mutablePropsAllowed: boolean;\n  jsxScope: Scope;\n  targetScope: Scope;\n}\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const { allowMutablePropsOnTags } = options;\n\n  if (\n    allowMutablePropsOnTags != null &&\n    !Array.isArray(allowMutablePropsOnTags)\n  ) {\n    throw new Error(\n      \".allowMutablePropsOnTags must be an array, null, or undefined.\",\n    );\n  }\n\n  // Element -> Target scope\n  const HOISTED = new WeakMap();\n\n  function declares(node: t.Identifier | t.JSXIdentifier, scope: Scope) {\n    if (\n      t.isJSXIdentifier(node, { name: \"this\" }) ||\n      t.isJSXIdentifier(node, { name: \"arguments\" }) ||\n      t.isJSXIdentifier(node, { name: \"super\" }) ||\n      t.isJSXIdentifier(node, { name: \"new\" })\n    ) {\n      const { path } = scope;\n      return path.isFunctionParent() && !path.isArrowFunctionExpression();\n    }\n\n    return scope.hasOwnBinding(node.name);\n  }\n\n  function isHoistingScope({ path }: Scope) {\n    return path.isFunctionParent() || path.isLoop() || path.isProgram();\n  }\n\n  function getHoistingScope(scope: Scope) {\n    while (!isHoistingScope(scope)) scope = scope.parent;\n    return scope;\n  }\n\n  const targetScopeVisitor: Visitor<VisitorState> = {\n    ReferencedIdentifier(path, state) {\n      const { node } = path;\n      let { scope } = path;\n\n      while (scope !== state.jsxScope) {\n        // If a binding is declared in an inner function, it doesn't affect hoisting.\n        if (declares(node, scope)) return;\n\n        scope = scope.parent;\n      }\n\n      while (scope) {\n        // We cannot hoist outside of the previous hoisting target\n        // scope, so we return early and we don't update it.\n        if (scope === state.targetScope) return;\n\n        // If the scope declares this identifier (or we're at the function\n        // providing the lexical env binding), we can't hoist the var any\n        // higher.\n        if (declares(node, scope)) break;\n\n        scope = scope.parent;\n      }\n\n      state.targetScope = getHoistingScope(scope);\n    },\n  };\n\n  const immutabilityVisitor: Visitor<VisitorState> = {\n    enter(path, state) {\n      const stop = () => {\n        state.isImmutable = false;\n        path.stop();\n      };\n\n      const skip = () => {\n        path.skip();\n      };\n\n      if (path.isJSXClosingElement()) {\n        skip();\n        return;\n      }\n\n      // Elements with refs are not safe to hoist.\n      if (\n        path.isJSXIdentifier({ name: \"ref\" }) &&\n        path.parentPath.isJSXAttribute({ name: path.node })\n      ) {\n        stop();\n        return;\n      }\n\n      // Ignore JSX expressions and immutable values.\n      if (\n        path.isJSXIdentifier() ||\n        path.isJSXMemberExpression() ||\n        path.isJSXNamespacedName() ||\n        path.isImmutable()\n      ) {\n        return;\n      }\n\n      // Ignore constant bindings.\n      if (path.isIdentifier()) {\n        const binding = path.scope.getBinding(path.node.name);\n        if (binding?.constant) return;\n      }\n\n      // If we allow mutable props, tags with function expressions can be\n      // safely hoisted.\n      const { mutablePropsAllowed } = state;\n      if (mutablePropsAllowed && path.isFunction()) {\n        path.traverse(targetScopeVisitor, state);\n        skip();\n        return;\n      }\n\n      if (!path.isPure()) {\n        stop();\n        return;\n      }\n\n      // If it's not immutable, it may still be a pure expression, such as string concatenation.\n      // It is still safe to hoist that, so long as its result is immutable.\n      // If not, it is not safe to replace as mutable values (like objects) could be mutated after render.\n      // https://github.com/facebook/react/issues/3226\n      const expressionResult = path.evaluate();\n      if (expressionResult.confident) {\n        // We know the result; check its mutability.\n        const { value } = expressionResult;\n        if (\n          mutablePropsAllowed ||\n          value === null ||\n          (typeof value !== \"object\" && typeof value !== \"function\")\n        ) {\n          // It evaluated to an immutable value, so we can hoist it.\n          skip();\n          return;\n        }\n      } else if (expressionResult.deopt?.isIdentifier()) {\n        // It's safe to hoist here if the deopt reason is an identifier (e.g. func param).\n        // The hoister will take care of how high up it can be hoisted.\n        return;\n      }\n\n      stop();\n    },\n  };\n\n  // We cannot use traverse.visitors.merge because it doesn't support\n  // immutabilityVisitor's bare `enter` visitor.\n  // It's safe to just use ... because the two visitors don't share any key.\n  const hoistingVisitor = { ...immutabilityVisitor, ...targetScopeVisitor };\n\n  return {\n    name: \"transform-react-constant-elements\",\n\n    visitor: {\n      \"JSXElement|JSXFragment\"(path: NodePath<t.JSXElement | t.JSXFragment>) {\n        if (HOISTED.has(path.node)) return;\n        let mutablePropsAllowed = false;\n        let name: t.JSXOpeningElement[\"name\"] | t.JSXFragment;\n        if (path.isJSXElement()) {\n          name = path.node.openingElement.name;\n\n          // This transform takes the option `allowMutablePropsOnTags`, which is an array\n          // of JSX tags to allow mutable props (such as objects, functions) on. Use sparingly\n          // and only on tags you know will never modify their own props.\n          if (allowMutablePropsOnTags != null) {\n            // Get the element's name. If it's a member expression, we use the last part of the path.\n            // So the option [\"FormattedMessage\"] would match \"Intl.FormattedMessage\".\n            let lastSegment = name;\n            while (t.isJSXMemberExpression(lastSegment)) {\n              lastSegment = lastSegment.property;\n            }\n\n            const elementName = lastSegment.name;\n            // @ts-expect-error Fixme: allowMutablePropsOnTags should handle JSXNamespacedName\n            mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);\n          }\n        } else {\n          name = path.node;\n        }\n\n        // In order to avoid hoisting unnecessarily, we need to know which is\n        // the scope containing the current JSX element. If a parent of the\n        // current element has already been hoisted, we can consider its target\n        // scope as the base scope for the current element.\n        let jsxScope;\n        let current: NodePath<t.JSX> = path;\n        while (!jsxScope && current.parentPath.isJSX()) {\n          current = current.parentPath;\n          jsxScope = HOISTED.get(current.node);\n        }\n        jsxScope ??= path.scope;\n        // The initial HOISTED is set to jsxScope, s.t.\n        // if the element's JSX ancestor has been hoisted, it will be skipped\n        HOISTED.set(path.node, jsxScope);\n\n        const visitorState: VisitorState = {\n          isImmutable: true,\n          mutablePropsAllowed,\n          jsxScope,\n          targetScope: path.scope.getProgramParent(),\n        };\n        path.traverse(hoistingVisitor, visitorState);\n        if (!visitorState.isImmutable) return;\n\n        const { targetScope } = visitorState;\n        // Only hoist if it would give us an advantage.\n        for (let currentScope = jsxScope; ; ) {\n          if (targetScope === currentScope) return;\n          if (isHoistingScope(currentScope)) break;\n\n          currentScope = currentScope.parent;\n          if (!currentScope) {\n            throw new Error(\n              \"Internal @babel/plugin-transform-react-constant-elements error: \" +\n                \"targetScope must be an ancestor of jsxScope. \" +\n                \"This is a Babel bug, please report it.\",\n            );\n          }\n        }\n\n        const id = path.scope.generateUidBasedOnNode(name);\n        targetScope.push({ id: t.identifier(id) });\n        // If the element is to be hoisted, update HOISTED to be the target scope\n        HOISTED.set(path.node, targetScope);\n\n        let replacement: t.Expression | t.JSXExpressionContainer = template\n          .expression.ast`\n          ${t.identifier(id)} || (${t.identifier(id)} = ${path.node})\n        `;\n        if (\n          path.parentPath.isJSXElement() ||\n          path.parentPath.isJSXAttribute() ||\n          path.parentPath.isJSXFragment()\n        ) {\n          replacement = t.jsxExpressionContainer(replacement);\n        }\n\n        path.replaceWith(replacement);\n      },\n    },\n  };\n});\n"],"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","options","assertVersion","allowMutablePropsOnTags","Array","isArray","Error","HOISTED","WeakMap","declares","node","scope","t","isJSXIdentifier","name","path","isFunctionParent","isArrowFunctionExpression","hasOwnBinding","isHoistingScope","isLoop","isProgram","getHoistingScope","parent","targetScopeVisitor","ReferencedIdentifier","state","jsxScope","targetScope","immutabilityVisitor","enter","_expressionResult$deo","stop","isImmutable","skip","isJSXClosingElement","parentPath","isJSXAttribute","isJSXMemberExpression","isJSXNamespacedName","isIdentifier","binding","getBinding","constant","mutablePropsAllowed","isFunction","traverse","isPure","expressionResult","evaluate","confident","value","deopt","hoistingVisitor","Object","assign","visitor","JSXElement|JSXFragment","_jsxScope","has","isJSXElement","openingElement","lastSegment","property","elementName","includes","current","isJSX","get","set","visitorState","getProgramParent","currentScope","id","generateUidBasedOnNode","push","identifier","replacement","template","expression","ast","isJSXFragment","jsxExpressionContainer","replaceWith"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 17532, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}