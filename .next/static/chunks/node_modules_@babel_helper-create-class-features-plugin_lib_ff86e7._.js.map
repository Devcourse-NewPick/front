{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/typescript.ts"],"sourcesContent":["import type { NodePath, types as t } from \"@babel/core\";\n\nexport function assertFieldTransformed(\n  path: NodePath<t.ClassProperty | t.ClassDeclaration>,\n) {\n  if (\n    path.node.declare ||\n    (process.env.BABEL_8_BREAKING\n      ? path.isClassProperty({ definite: true })\n      : false)\n  ) {\n    throw path.buildCodeFrameError(\n      `TypeScript 'declare' fields must first be transformed by ` +\n        `@babel/plugin-transform-typescript.\\n` +\n        `If you have already enabled that plugin (or '@babel/preset-typescript'), make sure ` +\n        `that it runs before any plugin related to additional class features:\\n` +\n        ` - @babel/plugin-transform-class-properties\\n` +\n        ` - @babel/plugin-transform-private-methods\\n` +\n        ` - @babel/plugin-proposal-decorators`,\n    );\n  }\n}\n"],"names":["assertFieldTransformed","path","node","declare","buildCodeFrameError"],"mappings":";;;;;AAEO,SAASA,sBAAsBA,CACpCC,IAAoD,EACpD;IACA,IACEA,IAAI,CAACC,IAAI,CAACC,OAAO,IAGb,KAAM,EACV;QACA,MAAMF,IAAI,CAACG,mBAAmB,CAC5B,CAAA,yDAAA,CAA2D,GACzD,CAAA,qCAAA,CAAuC,GACvC,CAAA,mFAAA,CAAqF,GACrF,CAAA,sEAAA,CAAwE,GACxE,CAAA,6CAAA,CAA+C,GAC/C,CAAA,4CAAA,CAA8C,GAC9C,CAAA,oCAAA,CACJ,CAAC;IACH;AACF","ignoreList":[0]}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 21, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/fields.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { File, NodePath, Visitor, Scope } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type {\n  Handler,\n  HandlerState,\n} from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\nimport * as ts from \"./typescript.ts\";\n\ninterface PrivateNameMetadata {\n  id: t.Identifier;\n  static: boolean;\n  method: boolean;\n  getId?: t.Identifier;\n  setId?: t.Identifier;\n  methodId?: t.Identifier;\n  initAdded?: boolean;\n  getterDeclared?: boolean;\n  setterDeclared?: boolean;\n}\n\ntype PrivateNamesMapGeneric<V> = Map<string, V>;\n\ntype PrivateNamesMap = PrivateNamesMapGeneric<PrivateNameMetadata>;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var newHelpers = (file: File) => {\n    if (!process.env.IS_PUBLISH) {\n      const { comments } = file.ast;\n      // This is needed for the test in\n      // babel-plugin-transform-class-properties/test/fixtures/regression/old-helpers\n      if (comments?.some(c => c.value.includes(\"@force-old-private-helpers\"))) {\n        return false;\n      }\n    }\n    return file.availableHelper(\"classPrivateFieldGet2\");\n  };\n}\n\nexport function buildPrivateNamesMap(\n  className: string,\n  privateFieldsAsSymbolsOrProperties: boolean,\n  props: PropPath[],\n  file: File,\n) {\n  const privateNamesMap: PrivateNamesMap = new Map();\n  let classBrandId: t.Identifier;\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const { name } = prop.node.key.id;\n      let update: PrivateNameMetadata = privateNamesMap.get(name);\n      if (!update) {\n        const isMethod = !prop.isProperty();\n        const isStatic = prop.node.static;\n        let initAdded = false;\n        let id: t.Identifier;\n        if (\n          !privateFieldsAsSymbolsOrProperties &&\n          (process.env.BABEL_8_BREAKING || newHelpers(file)) &&\n          isMethod &&\n          !isStatic\n        ) {\n          initAdded = !!classBrandId;\n          classBrandId ??= prop.scope.generateUidIdentifier(\n            `${className}_brand`,\n          );\n          id = classBrandId;\n        } else {\n          id = prop.scope.generateUidIdentifier(name);\n        }\n        update = { id, static: isStatic, method: isMethod, initAdded };\n        privateNamesMap.set(name, update);\n      }\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          const { body } = prop.node.body;\n          let $: t.Node;\n          if (\n            // If we have\n            //   get #foo() { return _some_fn(this); }\n            // we can use _some_fn directly.\n            body.length === 1 &&\n            t.isReturnStatement(($ = body[0])) &&\n            t.isCallExpression(($ = $.argument)) &&\n            $.arguments.length === 1 &&\n            t.isThisExpression($.arguments[0]) &&\n            t.isIdentifier(($ = $.callee))\n          ) {\n            update.getId = t.cloneNode($);\n            update.getterDeclared = true;\n          } else {\n            update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n          }\n        } else if (prop.node.kind === \"set\") {\n          const { params } = prop.node;\n          const { body } = prop.node.body;\n          let $: t.Node;\n          if (\n            // If we have\n            //   set #foo(val) { _some_fn(this, val); }\n            // we can use _some_fn directly.\n            body.length === 1 &&\n            t.isExpressionStatement(($ = body[0])) &&\n            t.isCallExpression(($ = $.expression)) &&\n            $.arguments.length === 2 &&\n            t.isThisExpression($.arguments[0]) &&\n            t.isIdentifier($.arguments[1], {\n              name: (params[0] as t.Identifier).name,\n            }) &&\n            t.isIdentifier(($ = $.callee))\n          ) {\n            update.setId = t.cloneNode($);\n            update.setterDeclared = true;\n          } else {\n            update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n          }\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\n\nexport function buildPrivateNamesNodes(\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties: boolean,\n  privateFieldsAsSymbols: boolean,\n  state: File,\n) {\n  const initNodes: t.Statement[] = [];\n\n  const injectedIds = new Set<string>();\n\n  for (const [name, value] of privateNamesMap) {\n    // - When the privateFieldsAsProperties assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   secret non-enumerable property. Hence, we also need to generate that\n    //   key (using the classPrivateFieldLooseKey helper).\n    // - When the privateFieldsAsSymbols assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   unique Symbol to define a non-enumerable property.\n    // - In spec mode, only instance fields need a \"private name\" initializer\n    //   because static fields are directly assigned to a variable in the\n    //   buildPrivateStaticFieldInitSpec function.\n    const { static: isStatic, method: isMethod, getId, setId } = value;\n    const isGetterOrSetter = getId || setId;\n    const id = t.cloneNode(value.id);\n\n    let init: t.Expression;\n\n    if (privateFieldsAsProperties) {\n      init = t.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [\n        t.stringLiteral(name),\n      ]);\n    } else if (privateFieldsAsSymbols) {\n      init = t.callExpression(t.identifier(\"Symbol\"), [t.stringLiteral(name)]);\n    } else if (!isStatic) {\n      if (injectedIds.has(id.name)) continue;\n      injectedIds.add(id.name);\n\n      init = t.newExpression(\n        t.identifier(\n          isMethod &&\n            (process.env.BABEL_8_BREAKING ||\n              !isGetterOrSetter ||\n              newHelpers(state))\n            ? \"WeakSet\"\n            : \"WeakMap\",\n        ),\n        [],\n      );\n    }\n\n    if (init) {\n      if (!privateFieldsAsSymbols) {\n        annotateAsPure(init);\n      }\n      initNodes.push(template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\nexport interface PrivateNameVisitorState<V> {\n  privateNamesMap: PrivateNamesMapGeneric<V>;\n  redeclared?: string[];\n}\n\n// Traverses the class scope, handling private name references. If an inner\n// class redeclares the same private name, it will hand off traversal to the\n// restricted visitor (which doesn't traverse the inner class's inner scope).\nexport function privateNameVisitorFactory<S, V>(\n  visitor: Visitor<PrivateNameVisitorState<V & PrivateNameMetadata> & S>,\n) {\n  // Traverses the outer portion of a class, without touching the class's inner\n  // scope, for private names.\n  const nestedVisitor = visitors.environmentVisitor({ ...visitor });\n\n  const privateNameVisitor: Visitor<\n    PrivateNameVisitorState<V & PrivateNameMetadata> & S\n  > = {\n    ...visitor,\n\n    Class(path) {\n      const { privateNamesMap } = this;\n      const body = path.get(\"body.body\");\n\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const { name } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      // If the class doesn't redeclare any private fields, we can continue with\n      // our overall traversal.\n      if (!redeclared.length) {\n        return;\n      }\n\n      // This class redeclares some private field. We need to process the outer\n      // environment with access to all the outer privates, then we can process\n      // the inner environment with only the still-visible outer privates.\n      path.get(\"body\").traverse(nestedVisitor, {\n        ...this,\n        redeclared,\n      });\n      path.traverse(privateNameVisitor, {\n        ...this,\n        privateNamesMap: visiblePrivateNames,\n      });\n\n      // We'll eventually hit this class node again with the overall Class\n      // Features visitor, which'll process the redeclared privates.\n      path.skipKey(\"body\");\n    },\n  };\n\n  return privateNameVisitor;\n}\n\ninterface PrivateNameState {\n  privateNamesMap: PrivateNamesMap;\n  classRef: t.Identifier;\n  file: File;\n  noDocumentAll: boolean;\n  noUninitializedPrivateFieldAccess: boolean;\n  innerBinding?: t.Identifier;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory<\n  HandlerState<PrivateNameState> & PrivateNameState,\n  PrivateNameMetadata\n>({\n  PrivateName(path, { noDocumentAll }) {\n    const { privateNamesMap, redeclared } = this;\n    const { node, parentPath } = path;\n\n    if (\n      !parentPath.isMemberExpression({ property: node }) &&\n      !parentPath.isOptionalMemberExpression({ property: node })\n    ) {\n      return;\n    }\n    const { name } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared?.includes(name)) return;\n\n    this.handle(parentPath, noDocumentAll);\n  },\n});\n\n// rename all bindings that shadows innerBinding\nfunction unshadow(\n  name: string,\n  scope: Scope,\n  innerBinding: t.Identifier | undefined,\n) {\n  // in some cases, scope.getBinding(name) === undefined\n  // so we check hasBinding to avoid keeping looping\n  // see: https://github.com/babel/babel/pull/13656#discussion_r686030715\n  while (\n    scope?.hasBinding(name) &&\n    !scope.bindingIdentifierEquals(name, innerBinding)\n  ) {\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\n\nexport function buildCheckInRHS(\n  rhs: t.Expression,\n  file: File,\n  inRHSIsObject?: boolean,\n) {\n  if (inRHSIsObject || !file.availableHelper?.(\"checkInRHS\")) return rhs;\n  return t.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\n\nconst privateInVisitor = privateNameVisitorFactory<\n  {\n    classRef: t.Identifier;\n    file: File;\n    innerBinding?: t.Identifier;\n    privateFieldsAsProperties: boolean;\n  },\n  PrivateNameMetadata\n>({\n  BinaryExpression(path, { file }) {\n    const { operator, left, right } = path.node;\n    if (operator !== \"in\") return;\n    if (!t.isPrivateName(left)) return;\n\n    const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;\n\n    const { name } = left.id;\n\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared?.includes(name)) return;\n\n    // if there are any local variable shadowing classRef, unshadow it\n    // see #12960\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n\n    if (privateFieldsAsProperties) {\n      const { id } = privateNamesMap.get(name);\n      path.replaceWith(template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(\n          right,\n          file,\n        )}, ${t.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const { id, static: isStatic } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(\n        template.expression.ast`${buildCheckInRHS(\n          right,\n          file,\n        )} === ${t.cloneNode(this.classRef)}`,\n      );\n      return;\n    }\n\n    path.replaceWith(\n      template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(\n        right,\n        file,\n      )})`,\n    );\n  },\n});\n\ninterface Receiver {\n  receiver(\n    this: HandlerState<PrivateNameState> & PrivateNameState,\n    member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  ): t.Expression;\n}\n\nfunction readOnlyError(file: File, name: string) {\n  return t.callExpression(file.addHelper(\"readOnlyError\"), [\n    t.stringLiteral(`#${name}`),\n  ]);\n}\n\nfunction writeOnlyError(file: File, name: string) {\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    !file.availableHelper(\"writeOnlyError\")\n  ) {\n    console.warn(\n      `@babel/helpers is outdated, update it to silence this warning.`,\n    );\n    return t.buildUndefinedNode();\n  }\n  return t.callExpression(file.addHelper(\"writeOnlyError\"), [\n    t.stringLiteral(`#${name}`),\n  ]);\n}\n\nfunction buildStaticPrivateFieldAccess<N extends t.Expression>(\n  expr: N,\n  noUninitializedPrivateFieldAccess: boolean,\n) {\n  if (noUninitializedPrivateFieldAccess) return expr;\n  return t.memberExpression(expr, t.identifier(\"_\"));\n}\n\nfunction autoInherits<\n  Member extends { node: t.Node },\n  Result extends t.Node,\n  Fn extends (member: Member, ...args: unknown[]) => Result,\n>(fn: Fn): Fn {\n  return function (this: ThisParameterType<Fn>, member) {\n    return t.inherits(fn.apply(this, arguments as any), member.node);\n  } as Fn;\n}\n\nconst privateNameHandlerSpec: Handler<PrivateNameState & Receiver> & Receiver =\n  {\n    memoise(member, count) {\n      const { scope } = member;\n      const { object } = member.node as { object: t.Expression };\n\n      const memo = scope.maybeGenerateMemoised(object);\n      if (!memo) {\n        return;\n      }\n\n      this.memoiser.set(object, memo, count);\n    },\n\n    receiver(member) {\n      const { object } = member.node as { object: t.Expression };\n\n      if (this.memoiser.has(object)) {\n        return t.cloneNode(this.memoiser.get(object));\n      }\n\n      return t.cloneNode(object);\n    },\n\n    get: autoInherits(function (member) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        innerBinding,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        methodId,\n        getId,\n        setId,\n      } = privateNamesMap.get(name);\n      const isGetterOrSetter = getId || setId;\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (isStatic) {\n        // if there are any local variable shadowing classRef, unshadow it\n        // see #12960\n        unshadow(classRef.name, member.scope, innerBinding);\n\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          // NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these\n          // helpers have been introduced in @babel/helpers@7.1.0.\n          const helperName =\n            isMethod && !isGetterOrSetter\n              ? \"classStaticPrivateMethodGet\"\n              : \"classStaticPrivateFieldSpecGet\";\n\n          return t.callExpression(file.addHelper(helperName), [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            cloneId(id),\n          ]);\n        }\n\n        const receiver = this.receiver(member);\n        const skipCheck =\n          t.isIdentifier(receiver) && receiver.name === classRef.name;\n\n        if (!isMethod) {\n          if (skipCheck) {\n            return buildStaticPrivateFieldAccess(\n              cloneId(id),\n              noUninitializedPrivateFieldAccess,\n            );\n          }\n\n          return buildStaticPrivateFieldAccess(\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n              cloneId(id),\n            ]),\n            noUninitializedPrivateFieldAccess,\n          );\n        }\n\n        if (getId) {\n          if (skipCheck) {\n            return t.callExpression(cloneId(getId), [receiver]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateGetter\"), [\n            t.cloneNode(classRef),\n            receiver,\n            cloneId(getId),\n          ]);\n        }\n\n        if (setId) {\n          const err = t.buildUndefinedNode(); // TODO: writeOnlyError(file, name)\n          if (skipCheck) return err;\n          return t.sequenceExpression([\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n            ]),\n            err,\n          ]);\n        }\n\n        if (skipCheck) return cloneId(id);\n        return t.callExpression(file.addHelper(\"assertClassBrand\"), [\n          t.cloneNode(classRef),\n          receiver,\n          cloneId(id),\n        ]);\n      }\n\n      if (isMethod) {\n        if (isGetterOrSetter) {\n          if (!getId) {\n            return t.sequenceExpression([\n              this.receiver(member),\n              writeOnlyError(file, name),\n            ]);\n          }\n          if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n            return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n              this.receiver(member),\n              cloneId(id),\n            ]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateGetter\"), [\n            t.cloneNode(id),\n            this.receiver(member),\n            cloneId(getId),\n          ]);\n        }\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          return t.callExpression(file.addHelper(\"classPrivateMethodGet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n            cloneId(methodId),\n          ]);\n        }\n        return t.callExpression(file.addHelper(\"assertClassBrand\"), [\n          t.cloneNode(id),\n          this.receiver(member),\n          cloneId(methodId),\n        ]);\n      }\n      if (process.env.BABEL_8_BREAKING || newHelpers(file)) {\n        return t.callExpression(file.addHelper(\"classPrivateFieldGet2\"), [\n          cloneId(id),\n          this.receiver(member),\n        ]);\n      }\n\n      return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n        this.receiver(member),\n        cloneId(id),\n      ]);\n    }),\n\n    boundGet(member) {\n      this.memoise(member, 1);\n\n      return t.callExpression(\n        t.memberExpression(this.get(member), t.identifier(\"bind\")),\n        [this.receiver(member)],\n      );\n    },\n\n    set: autoInherits(function (member, value) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n        getId,\n      } = privateNamesMap.get(name);\n      const isGetterOrSetter = getId || setId;\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (isStatic) {\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          const helperName =\n            isMethod && !isGetterOrSetter\n              ? \"classStaticPrivateMethodSet\"\n              : \"classStaticPrivateFieldSpecSet\";\n\n          return t.callExpression(file.addHelper(helperName), [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            cloneId(id),\n            value,\n          ]);\n        }\n\n        const receiver = this.receiver(member);\n        const skipCheck =\n          t.isIdentifier(receiver) && receiver.name === classRef.name;\n\n        if (isMethod && !setId) {\n          const err = readOnlyError(file, name);\n          if (skipCheck) return t.sequenceExpression([value, err]);\n          return t.sequenceExpression([\n            value,\n            t.callExpression(file.addHelper(\"assertClassBrand\"), [\n              t.cloneNode(classRef),\n              receiver,\n            ]),\n            readOnlyError(file, name),\n          ]);\n        }\n\n        if (setId) {\n          if (skipCheck) {\n            return t.callExpression(t.cloneNode(setId), [receiver, value]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateSetter\"), [\n            t.cloneNode(classRef),\n            cloneId(setId),\n            receiver,\n            value,\n          ]);\n        }\n        return t.assignmentExpression(\n          \"=\",\n          buildStaticPrivateFieldAccess(\n            cloneId(id),\n            noUninitializedPrivateFieldAccess,\n          ),\n          skipCheck\n            ? value\n            : t.callExpression(file.addHelper(\"assertClassBrand\"), [\n                t.cloneNode(classRef),\n                receiver,\n                value,\n              ]),\n        );\n      }\n      if (isMethod) {\n        if (setId) {\n          if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n            return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n              this.receiver(member),\n              cloneId(id),\n              value,\n            ]);\n          }\n          return t.callExpression(file.addHelper(\"classPrivateSetter\"), [\n            t.cloneNode(id),\n            cloneId(setId),\n            this.receiver(member),\n            value,\n          ]);\n        }\n        return t.sequenceExpression([\n          this.receiver(member),\n          value,\n          readOnlyError(file, name),\n        ]);\n      }\n\n      if (process.env.BABEL_8_BREAKING || newHelpers(file)) {\n        return t.callExpression(file.addHelper(\"classPrivateFieldSet2\"), [\n          cloneId(id),\n          this.receiver(member),\n          value,\n        ]);\n      }\n\n      return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n        this.receiver(member),\n        cloneId(id),\n        value,\n      ]);\n    }),\n\n    destructureSet(member) {\n      const {\n        classRef,\n        privateNamesMap,\n        file,\n        noUninitializedPrivateFieldAccess,\n      } = this;\n      const privateName = member.node.property as t.PrivateName;\n      const { name } = privateName.id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n      } = privateNamesMap.get(name);\n\n      const cloneId = (id: t.Identifier) =>\n        t.inherits(t.cloneNode(id), privateName);\n\n      if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n        if (isStatic) {\n          try {\n            // classStaticPrivateFieldDestructureSet was introduced in 7.13.10\n            // eslint-disable-next-line no-var\n            var helper = file.addHelper(\n              \"classStaticPrivateFieldDestructureSet\",\n            );\n          } catch {\n            throw new Error(\n              \"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" +\n                \"please update @babel/helpers to the latest version.\",\n            );\n          }\n          return t.memberExpression(\n            t.callExpression(helper, [\n              this.receiver(member),\n              t.cloneNode(classRef),\n              cloneId(id),\n            ]),\n            t.identifier(\"value\"),\n          );\n        }\n\n        return t.memberExpression(\n          t.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [\n            this.receiver(member),\n            cloneId(id),\n          ]),\n          t.identifier(\"value\"),\n        );\n      }\n\n      if (isMethod && !setId) {\n        return t.memberExpression(\n          t.sequenceExpression([\n            // @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super\n            member.node.object,\n            readOnlyError(file, name),\n          ]),\n          t.identifier(\"_\"),\n        );\n      }\n\n      if (isStatic && !isMethod) {\n        const getCall = this.get(member);\n        if (\n          !noUninitializedPrivateFieldAccess ||\n          !t.isCallExpression(getCall)\n        ) {\n          return getCall;\n        }\n        const ref = getCall.arguments.pop();\n        getCall.arguments.push(template.expression.ast`(_) => ${ref} = _`);\n        return t.memberExpression(\n          t.callExpression(file.addHelper(\"toSetter\"), [getCall]),\n          t.identifier(\"_\"),\n        );\n      }\n\n      const setCall = this.set(member, t.identifier(\"_\"));\n      if (\n        !t.isCallExpression(setCall) ||\n        !t.isIdentifier(setCall.arguments[setCall.arguments.length - 1], {\n          name: \"_\",\n        })\n      ) {\n        throw member.buildCodeFrameError(\n          \"Internal Babel error while compiling this code. This is a Babel bug. \" +\n            \"Please report it at https://github.com/babel/babel/issues.\",\n        );\n      }\n\n      // someHelper(foo, bar, _) -> someHelper, [foo, bar]\n      // aFn.call(foo, bar, _) -> aFn, [bar], foo\n      let args: t.Expression[];\n      if (\n        t.isMemberExpression(setCall.callee, { computed: false }) &&\n        t.isIdentifier(setCall.callee.property) &&\n        setCall.callee.property.name === \"call\"\n      ) {\n        args = [\n          // @ts-ignore(Babel 7 vs Babel 8) member.node.object is not t.Super\n          setCall.callee.object,\n          t.arrayExpression(\n            // Remove '_'\n            (setCall.arguments as t.Expression[]).slice(1, -1),\n          ),\n          setCall.arguments[0] as t.Expression,\n        ];\n      } else {\n        args = [\n          setCall.callee as t.Expression,\n          t.arrayExpression(\n            // Remove '_'\n            (setCall.arguments as t.Expression[]).slice(0, -1),\n          ),\n        ];\n      }\n\n      return t.memberExpression(\n        t.callExpression(file.addHelper(\"toSetter\"), args),\n        t.identifier(\"_\"),\n      );\n    },\n\n    call(member, args: (t.Expression | t.SpreadElement)[]) {\n      // The first access (the get) should do the memo assignment.\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, false);\n    },\n\n    optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, true);\n    },\n\n    delete() {\n      throw new Error(\n        \"Internal Babel error: deleting private elements is a parsing error.\",\n      );\n    },\n  };\n\nconst privateNameHandlerLoose: Handler<PrivateNameState> = {\n  get(member) {\n    const { privateNamesMap, file } = this;\n    const { object } = member.node;\n    const { name } = (member.node.property as t.PrivateName).id;\n\n    return template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: t.cloneNode(object),\n      PROP: t.cloneNode(privateNamesMap.get(name).id),\n    });\n  },\n\n  set() {\n    // noop\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n\n  boundGet(member) {\n    return t.callExpression(\n      t.memberExpression(this.get(member), t.identifier(\"bind\")),\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      [t.cloneNode(member.node.object as t.Expression)],\n    );\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return t.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return t.optionalCallExpression(this.get(member), args, true);\n  },\n\n  delete() {\n    throw new Error(\n      \"Internal Babel error: deleting private elements is a parsing error.\",\n    );\n  },\n};\n\nexport function transformPrivateNamesUsage(\n  ref: t.Identifier,\n  path: NodePath<t.Class>,\n  privateNamesMap: PrivateNamesMap,\n  {\n    privateFieldsAsProperties,\n    noUninitializedPrivateFieldAccess,\n    noDocumentAll,\n    innerBinding,\n  }: {\n    privateFieldsAsProperties: boolean;\n    noUninitializedPrivateFieldAccess: boolean;\n    noDocumentAll: boolean;\n    innerBinding: t.Identifier;\n  },\n  state: File,\n) {\n  if (!privateNamesMap.size) return;\n\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties\n    ? privateNameHandlerLoose\n    : privateNameHandlerSpec;\n\n  memberExpressionToFunctions<PrivateNameState>(body, privateNameVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    ...handler,\n    noDocumentAll,\n    noUninitializedPrivateFieldAccess,\n    innerBinding,\n  });\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding,\n  });\n}\n\nfunction buildPrivateFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${t.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    ` as t.ExpressionStatement,\n    prop,\n  );\n}\n\nfunction buildPrivateInstanceFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`${t.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })` as t.ExpressionStatement,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritLoc(\n    inheritPropComments(\n      t.expressionStatement(\n        t.callExpression(helper, [\n          t.thisExpression(),\n          inheritLoc(t.cloneNode(id), prop.node.key),\n          process.env.BABEL_8_BREAKING || newHelpers(state)\n            ? value\n            : template.expression.ast`{ writable: true, value: ${value} }`,\n        ]),\n      ),\n      prop,\n    ),\n    prop.node,\n  );\n}\n\nfunction buildPrivateStaticFieldInitSpec(\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n  noUninitializedPrivateFieldAccess: boolean,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n\n  const value = noUninitializedPrivateFieldAccess\n    ? prop.node.value\n    : template.expression.ast`{\n        _: ${prop.node.value || t.buildUndefinedNode()}\n      }`;\n\n  return inheritPropComments(\n    t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(privateName.id), value),\n    ]),\n    prop,\n  );\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var buildPrivateStaticFieldInitSpecOld = function (\n    prop: NodePath<t.ClassPrivateProperty>,\n    privateNamesMap: PrivateNamesMap,\n  ) {\n    const privateName = privateNamesMap.get(prop.node.key.id.name);\n    const { id, getId, setId, initAdded } = privateName;\n    const isGetterOrSetter = getId || setId;\n\n    if (!prop.isProperty() && (initAdded || !isGetterOrSetter)) return;\n\n    if (isGetterOrSetter) {\n      privateNamesMap.set(prop.node.key.id.name, {\n        ...privateName,\n        initAdded: true,\n      });\n\n      return inheritPropComments(\n        template.statement.ast`\n          var ${t.cloneNode(id)} = {\n            // configurable is false by default\n            // enumerable is false by default\n            // writable is false by default\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          }\n        `,\n        prop,\n      );\n    }\n\n    const value = prop.node.value || prop.scope.buildUndefinedNode();\n    return inheritPropComments(\n      template.statement.ast`\n        var ${t.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          writable: true,\n          value: ${value}\n        };\n      `,\n      prop,\n    );\n  };\n}\n\nfunction buildPrivateMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { methodId, id, getId, setId, initAdded } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      ` as t.ExpressionStatement,\n      prop,\n    );\n  }\n  const isGetterOrSetter = getId || setId;\n  if (isGetterOrSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      ` as t.ExpressionStatement,\n      prop,\n    );\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n\n  if (privateName.initAdded) return;\n\n  if (!process.env.BABEL_8_BREAKING && !newHelpers(state)) {\n    const isGetterOrSetter = privateName.getId || privateName.setId;\n    if (isGetterOrSetter) {\n      return buildPrivateAccessorInitialization(\n        ref,\n        prop,\n        privateNamesMap,\n        state,\n      );\n    }\n  }\n\n  return buildPrivateInstanceMethodInitialization(\n    ref,\n    prop,\n    privateNamesMap,\n    state,\n  );\n}\n\nfunction buildPrivateAccessorInitialization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId } = privateName;\n\n  privateNamesMap.set(prop.node.key.id.name, {\n    ...privateName,\n    initAdded: true,\n  });\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        ` as t.ExpressionStatement,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritLoc(\n    inheritPropComments(\n      template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )` as t.ExpressionStatement,\n      prop,\n    ),\n    prop.node,\n  );\n}\n\nfunction buildPrivateInstanceMethodInitialization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id } = privateName;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`${id}.add(${ref})` as t.ExpressionStatement,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)}\n    )` as t.ExpressionStatement,\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(ref, key, computed || t.isLiteral(key)),\n        value,\n      ),\n    ),\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n  state: File,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.callExpression(state.addHelper(\"defineProperty\"), [\n        ref,\n        computed || t.isLiteral(key)\n          ? key\n          : t.stringLiteral((key as t.Identifier).name),\n        value,\n      ]),\n    ),\n    prop,\n  );\n}\n\nfunction buildPrivateStaticMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  state: File,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, methodId, getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isGetterOrSetter = getId || setId;\n  if (isGetterOrSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `,\n      prop,\n    );\n  }\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateMethodDeclaration(\n  file: File,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsSymbolsOrProperties = false,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic,\n  } = privateName;\n  const { params, body, generator, async } = prop.node;\n  const isGetter = getId && params.length === 0;\n  const isSetter = setId && params.length > 0;\n\n  if ((isGetter && getterDeclared) || (isSetter && setterDeclared)) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n    return null;\n  }\n\n  if (\n    (process.env.BABEL_8_BREAKING || newHelpers(file)) &&\n    (isGetter || isSetter) &&\n    !privateFieldsAsSymbolsOrProperties\n  ) {\n    const scope = prop.get(\"body\").scope;\n    const thisArg = scope.generateUidIdentifier(\"this\");\n    const state: ReplaceThisState = {\n      thisRef: thisArg,\n      argumentsPath: [],\n    };\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    prop.traverse(thisContextVisitor, state);\n    if (state.argumentsPath.length) {\n      const argumentsId = scope.generateUidIdentifier(\"arguments\");\n      scope.push({\n        id: argumentsId,\n        init: template.expression.ast`[].slice.call(arguments, 1)`,\n      });\n      for (const path of state.argumentsPath) {\n        path.replaceWith(t.cloneNode(argumentsId));\n      }\n    }\n\n    params.unshift(t.cloneNode(thisArg));\n  }\n\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      getterDeclared: true,\n      initAdded: true,\n    });\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      setterDeclared: true,\n      initAdded: true,\n    });\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsSymbolsOrProperties) {\n    declId = id;\n  }\n\n  return inheritPropComments(\n    t.functionDeclaration(\n      t.cloneNode(declId),\n      // @ts-expect-error params for ClassMethod has TSParameterProperty\n      params,\n      body,\n      generator,\n      async,\n    ),\n    prop,\n  );\n}\n\ntype ReplaceThisState = {\n  thisRef: t.Identifier;\n  needsClassRef?: boolean;\n  innerBinding?: t.Identifier | null;\n  argumentsPath?: NodePath<t.Identifier>[];\n};\n\ntype ReplaceInnerBindingReferenceState = ReplaceThisState;\n\nconst thisContextVisitor = visitors.environmentVisitor<ReplaceThisState>({\n  Identifier(path, state) {\n    if (state.argumentsPath && path.node.name === \"arguments\") {\n      state.argumentsPath.push(path);\n    }\n  },\n  UnaryExpression(path) {\n    // Replace `delete this` with `true`\n    const { node } = path;\n    if (node.operator === \"delete\") {\n      const argument = skipTransparentExprWrapperNodes(node.argument);\n      if (t.isThisExpression(argument)) {\n        path.replaceWith(t.booleanLiteral(true));\n      }\n    }\n  },\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(t.cloneNode(state.thisRef));\n  },\n  MetaProperty(path) {\n    const { node, scope } = path;\n    // if there are `new.target` in static field\n    // we should replace it with `undefined`\n    if (node.meta.name === \"new\" && node.property.name === \"target\") {\n      path.replaceWith(scope.buildUndefinedNode());\n    }\n  },\n});\n\nconst innerReferencesVisitor: Visitor<ReplaceInnerBindingReferenceState> = {\n  ReferencedIdentifier(path, state) {\n    if (\n      path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)\n    ) {\n      state.needsClassRef = true;\n      path.node.name = state.thisRef.name;\n    }\n  },\n};\n\nfunction replaceThisContext(\n  path: PropPath,\n  ref: t.Identifier,\n  innerBindingRef: t.Identifier | null,\n) {\n  const state: ReplaceThisState = {\n    thisRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef,\n  };\n  if (!path.isMethod()) {\n    // replace `this` in property initializers and static blocks\n    path.traverse(thisContextVisitor, state);\n  }\n\n  // todo: use innerBinding.referencePaths to avoid full traversal\n  if (\n    innerBindingRef != null &&\n    state.thisRef?.name &&\n    state.thisRef.name !== innerBindingRef.name\n  ) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nexport type PropNode =\n  | t.ClassProperty\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.StaticBlock;\nexport type PropPath = NodePath<PropNode>;\n\nfunction isNameOrLength({ key, computed }: t.ClassProperty) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\n/**\n * Inherit comments from class members. This is a reduced version of\n * t.inheritsComments: the trailing comments are not inherited because\n * for most class members except the last one, their trailing comments are\n * the next sibling's leading comments.\n *\n * @template T transformed class member type\n * @param {T} node transformed class member\n * @param {PropPath} prop class member\n * @returns transformed class member type with comments inherited\n */\nfunction inheritPropComments<T extends t.Node>(node: T, prop: PropPath) {\n  t.inheritLeadingComments(node, prop.node);\n  t.inheritInnerComments(node, prop.node);\n  return node;\n}\n\nfunction inheritLoc<T extends t.Node>(node: T, original: t.Node) {\n  node.start = original.start;\n  node.end = original.end;\n  node.loc = original.loc;\n  return node;\n}\n\n/**\n * ClassRefFlag records the requirement of the class binding reference.\n *\n * @enum {number}\n */\nconst enum ClassRefFlag {\n  None,\n  /**\n   * When this flag is enabled, the binding reference can be the class id,\n   * if exists, or the uid identifier generated for class expression. The\n   * reference is safe to be consumed by [[Define]].\n   */\n  ForDefine = 1 << 0,\n  /**\n   * When this flag is enabled, the reference must be a uid, because the outer\n   * class binding can be mutated by user codes.\n   * E.g.\n   * class C { static p = C }; const oldC = C; C = null; oldC.p;\n   * we must memoize class `C` before defining the property `p`.\n   */\n  ForInnerBinding = 1 << 1,\n}\n\nexport function buildFieldsInitNodes(\n  ref: t.Identifier | null,\n  superRef: t.Expression | undefined,\n  props: PropPath[],\n  privateNamesMap: PrivateNamesMap,\n  file: File,\n  setPublicClassFields: boolean,\n  privateFieldsAsSymbolsOrProperties: boolean,\n  noUninitializedPrivateFieldAccess: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier | null,\n) {\n  let classRefFlags = ClassRefFlag.None;\n  let injectSuperRef: t.Identifier;\n  const staticNodes: t.Statement[] = [];\n  const instanceNodes: t.ExpressionStatement[] = [];\n  let lastInstanceNodeReturnsThis = false;\n  // These nodes are pure and can be moved to the closest statement position\n  const pureStaticNodes: t.FunctionDeclaration[] = [];\n  let classBindingNode: t.ExpressionStatement | null = null;\n\n  const getSuperRef = t.isIdentifier(superRef)\n    ? () => superRef\n    : () => {\n        injectSuperRef ??=\n          props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n        return injectSuperRef;\n      };\n\n  const classRefForInnerBinding =\n    ref ??\n    props[0].scope.generateUidIdentifier(innerBindingRef?.name || \"Class\");\n  ref ??= t.cloneNode(innerBindingRef);\n\n  for (const prop of props) {\n    if (prop.isClassProperty()) {\n      ts.assertFieldTransformed(prop);\n    }\n\n    // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n    const isStatic = !t.isStaticBlock?.(prop.node) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock?.();\n\n    if (isStatic) classRefFlags |= ClassRefFlag.ForDefine;\n\n    if (isStatic || (isMethod && isPrivate) || isStaticBlock) {\n      new ReplaceSupers({\n        methodPath: prop,\n        constantSuper,\n        file: file,\n        refToPreserve: innerBindingRef,\n        getSuperRef,\n        getObjectRef() {\n          classRefFlags |= ClassRefFlag.ForInnerBinding;\n          if (isStatic || isStaticBlock) {\n            return classRefForInnerBinding;\n          } else {\n            return t.memberExpression(\n              classRefForInnerBinding,\n              t.identifier(\"prototype\"),\n            );\n          }\n        },\n      }).replace();\n\n      const replaced = replaceThisContext(\n        prop,\n        classRefForInnerBinding,\n        innerBindingRef,\n      );\n      if (replaced) {\n        classRefFlags |= ClassRefFlag.ForInnerBinding;\n      }\n    }\n\n    lastInstanceNodeReturnsThis = false;\n\n    // TODO(ts): there are so many `ts-expect-error` inside cases since\n    // ts can not infer type from pre-computed values (or a case test)\n    // even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop\n    // a `NodePath<t.StaticBlock>`\n    // this maybe a bug for ts\n    switch (true) {\n      case isStaticBlock: {\n        const blockBody = prop.node.body;\n        // We special-case the single expression case to avoid the iife, since\n        // it's common.\n        if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n          staticNodes.push(inheritPropComments(blockBody[0], prop));\n        } else {\n          staticNodes.push(\n            t.inheritsComments(\n              template.statement.ast`(() => { ${blockBody} })()`,\n              prop.node,\n            ),\n          );\n        }\n        break;\n      }\n      case isStatic &&\n        isPrivate &&\n        isField &&\n        privateFieldsAsSymbolsOrProperties:\n        staticNodes.push(\n          buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),\n        );\n        break;\n      case isStatic &&\n        isPrivate &&\n        isField &&\n        !privateFieldsAsSymbolsOrProperties:\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          staticNodes.push(\n            buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap),\n          );\n        } else {\n          staticNodes.push(\n            buildPrivateStaticFieldInitSpec(\n              prop,\n              privateNamesMap,\n              noUninitializedPrivateFieldAccess,\n            ),\n          );\n        }\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        // Functions always have non-writable .name and .length properties,\n        // so we must always use [[Define]] for them.\n        // It might still be possible to a computed static fields whose resulting\n        // key is \"name\" or \"length\", but the assumption is telling us that it's\n        // not going to happen.\n        if (!isNameOrLength(prop.node)) {\n          staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));\n          break;\n        }\n      // falls through\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        staticNodes.push(\n          buildPublicFieldInitSpec(t.cloneNode(ref), prop, file),\n        );\n        break;\n      case isInstance &&\n        isPrivate &&\n        isField &&\n        privateFieldsAsSymbolsOrProperties:\n        instanceNodes.push(\n          buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),\n        );\n        break;\n      case isInstance &&\n        isPrivate &&\n        isField &&\n        !privateFieldsAsSymbolsOrProperties:\n        instanceNodes.push(\n          buildPrivateInstanceFieldInitSpec(\n            t.thisExpression(),\n            prop,\n            privateNamesMap,\n            file,\n          ),\n        );\n        break;\n      case isInstance &&\n        isPrivate &&\n        isMethod &&\n        privateFieldsAsSymbolsOrProperties:\n        instanceNodes.unshift(\n          buildPrivateMethodInitLoose(\n            t.thisExpression(),\n            prop,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            file,\n            prop,\n            privateNamesMap,\n            privateFieldsAsSymbolsOrProperties,\n          ),\n        );\n        break;\n      case isInstance &&\n        isPrivate &&\n        isMethod &&\n        !privateFieldsAsSymbolsOrProperties:\n        instanceNodes.unshift(\n          buildPrivateInstanceMethodInitSpec(\n            t.thisExpression(),\n            prop,\n            privateNamesMap,\n            file,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            file,\n            prop,\n            privateNamesMap,\n            privateFieldsAsSymbolsOrProperties,\n          ),\n        );\n        break;\n      case isStatic &&\n        isPrivate &&\n        isMethod &&\n        !privateFieldsAsSymbolsOrProperties:\n        if (!process.env.BABEL_8_BREAKING && !newHelpers(file)) {\n          staticNodes.unshift(\n            // @ts-expect-error checked in switch\n            buildPrivateStaticFieldInitSpecOld(prop, privateNamesMap),\n          );\n        }\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            file,\n            prop,\n            privateNamesMap,\n            privateFieldsAsSymbolsOrProperties,\n          ),\n        );\n        break;\n      case isStatic &&\n        isPrivate &&\n        isMethod &&\n        privateFieldsAsSymbolsOrProperties:\n        staticNodes.unshift(\n          buildPrivateStaticMethodInitLoose(\n            t.cloneNode(ref),\n            prop,\n            file,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            file,\n            prop,\n            privateNamesMap,\n            privateFieldsAsSymbolsOrProperties,\n          ),\n        );\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        lastInstanceNodeReturnsThis = true;\n        instanceNodes.push(\n          buildPublicFieldInitSpec(t.thisExpression(), prop, file),\n        );\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  if (classRefFlags & ClassRefFlag.ForInnerBinding && innerBindingRef != null) {\n    classBindingNode = t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.cloneNode(classRefForInnerBinding),\n        t.cloneNode(innerBindingRef),\n      ),\n    );\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    lastInstanceNodeReturnsThis,\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    classBindingNode,\n    wrapClass(path: NodePath<t.Class>) {\n      for (const prop of props) {\n        // Delete leading comments so that they don't get attached as\n        // trailing comments of the previous sibling.\n        // When transforming props, we explicitly attach their leading\n        // comments to the transformed node with `inheritPropComments`\n        // above.\n        prop.node.leadingComments = null;\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({ id: t.cloneNode(injectSuperRef) });\n        path.set(\n          \"superClass\",\n          t.assignmentExpression(\"=\", injectSuperRef, path.node.superClass),\n        );\n      }\n\n      if (classRefFlags !== ClassRefFlag.None) {\n        if (path.isClassExpression()) {\n          path.scope.push({ id: ref });\n          path.replaceWith(\n            t.assignmentExpression(\"=\", t.cloneNode(ref), path.node),\n          );\n        } else {\n          if (innerBindingRef == null) {\n            // export anonymous class declaration\n            path.node.id = ref;\n          }\n          if (classBindingNode != null) {\n            path.scope.push({ id: classRefForInnerBinding });\n          }\n        }\n      }\n\n      return path;\n    },\n  };\n}\n"],"names":["_core","require","_traverse","_helperReplaceSupers","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_helperAnnotateAsPure","_helperSkipTransparentExpressionWrappers","ts","newHelpers","file","availableHelper","buildPrivateNamesMap","className","privateFieldsAsSymbolsOrProperties","props","privateNamesMap","Map","classBrandId","prop","isPrivate","name","node","key","id","update","get","isMethod","isProperty","isStatic","static","initAdded","_classBrandId","scope","generateUidIdentifier","method","set","isClassPrivateMethod","kind","body","$","length","t","isReturnStatement","isCallExpression","argument","arguments","isThisExpression","isIdentifier","callee","getId","cloneNode","getterDeclared","params","isExpressionStatement","expression","setId","setterDeclared","methodId","buildPrivateNamesNodes","privateFieldsAsProperties","privateFieldsAsSymbols","state","initNodes","injectedIds","Set","value","isGetterOrSetter","init","callExpression","addHelper","stringLiteral","identifier","has","add","newExpression","annotateAsPure","push","template","statement","ast","privateNameVisitorFactory","visitor","nestedVisitor","visitors","environmentVisitor","Object","assign","privateNameVisitor","Class","path","visiblePrivateNames","redeclared","delete","traverse","skipKey","PrivateName","noDocumentAll","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","unshadow","innerBinding","_scope","hasBinding","bindingIdentifierEquals","rename","parent","buildCheckInRHS","rhs","inRHSIsObject","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","classRef","replaceWith","readOnlyError","writeOnlyError","console","warn","buildUndefinedNode","buildStaticPrivateFieldAccess","expr","noUninitializedPrivateFieldAccess","memberExpression","autoInherits","fn","member","inherits","apply","privateNameHandlerSpec","memoise","count","object","memo","maybeGenerateMemoised","memoiser","receiver","privateName","cloneId","helperName","skipCheck","err","sequenceExpression","boundGet","assignmentExpression","destructureSet","helper","_unused","Error","getCall","ref","pop","setCall","buildCodeFrameError","args","computed","arrayExpression","slice","call","optimiseCall","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","transformPrivateNamesUsage","size","handler","memberExpressionToFunctions","buildPrivateFieldInitLoose","inheritPropComments","buildPrivateInstanceFieldInitSpec","inheritLoc","expressionStatement","thisExpression","buildPrivateStaticFieldInitSpec","variableDeclaration","variableDeclarator","buildPrivateStaticFieldInitSpecOld","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPrivateAccessorInitialization","buildPrivateInstanceMethodInitialization","buildPublicFieldInitLoose","isLiteral","buildPublicFieldInitSpec","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","generator","async","isGetter","isSetter","thisArg","thisRef","argumentsPath","thisContextVisitor","argumentsId","unshift","declId","functionDeclaration","Identifier","UnaryExpression","skipTransparentExprWrapperNodes","booleanLiteral","ThisExpression","needsClassRef","MetaProperty","meta","innerReferencesVisitor","ReferencedIdentifier","replaceThisContext","innerBindingRef","_state$thisRef","isNameOrLength","type","inheritLeadingComments","inheritInnerComments","original","start","end","loc","buildFieldsInitNodes","superRef","setPublicClassFields","constantSuper","_ref","_ref2","classRefFlags","injectSuperRef","staticNodes","instanceNodes","lastInstanceNodeReturnsThis","pureStaticNodes","classBindingNode","getSuperRef","_injectSuperRef","generateUidIdentifierBasedOnNode","classRefForInnerBinding","isClassProperty","assertFieldTransformed","isStaticBlock","isInstance","isPublic","isField","ReplaceSupers","methodPath","refToPreserve","getObjectRef","replace","replaced","blockBody","inheritsComments","filter","Boolean","wrapClass","leadingComments","remove","superClass","isClassExpression"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/misc.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { File, NodePath, Scope, Visitor } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\n\nconst findBareSupers = visitors.environmentVisitor<\n  NodePath<t.CallExpression>[]\n>({\n  Super(path) {\n    const { node, parentPath } = path;\n    if (parentPath.isCallExpression({ callee: node })) {\n      this.push(parentPath);\n    }\n  },\n});\n\nconst referenceVisitor: Visitor<{ scope: Scope }> = {\n  \"TSTypeAnnotation|TypeAnnotation\"(\n    path: NodePath<t.TSTypeAnnotation | t.TypeAnnotation>,\n  ) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path: NodePath<t.Identifier>, { scope }) {\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  },\n};\n\ntype HandleClassTDZState = {\n  classBinding: Scope.Binding;\n  file: File;\n};\n\nfunction handleClassTDZ(\n  path: NodePath<t.Identifier>,\n  state: HandleClassTDZState,\n) {\n  if (\n    state.classBinding &&\n    state.classBinding === path.scope.getBinding(path.node.name)\n  ) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n    const throwNode = t.callExpression(classNameTDZError, [\n      t.stringLiteral(path.node.name),\n    ]);\n\n    path.replaceWith(t.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor: Visitor<HandleClassTDZState> = {\n  ReferencedIdentifier: handleClassTDZ,\n};\n\ninterface RenamerState {\n  scope: Scope;\n}\n\nexport function injectInitialization(\n  path: NodePath<t.Class>,\n  constructor: NodePath<t.ClassMethod> | undefined,\n  nodes: t.ExpressionStatement[],\n  renamer?: (visitor: Visitor<RenamerState>, state: RenamerState) => void,\n  lastReturnsThis?: boolean,\n) {\n  if (!nodes.length) return;\n\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = t.classMethod(\n      \"constructor\",\n      t.identifier(\"constructor\"),\n      [],\n      t.blockStatement([]),\n    );\n\n    if (isDerived) {\n      newConstructor.params = [t.restElement(t.identifier(\"args\"))];\n      newConstructor.body.body.push(template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path\n      .get(\"body\")\n      .unshiftContainer(\"body\", newConstructor) as NodePath<t.ClassMethod>[];\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, { scope: constructor.scope });\n  }\n\n  if (isDerived) {\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        isFirst = false;\n      } else {\n        nodes = nodes.map(n => t.cloneNode(n));\n      }\n      if (!bareSuper.parentPath.isExpressionStatement()) {\n        const allNodes: t.Expression[] = [\n          bareSuper.node,\n          ...nodes.map(n => t.toExpression(n)),\n        ];\n        if (!lastReturnsThis) allNodes.push(t.thisExpression());\n        bareSuper.replaceWith(t.sequenceExpression(allNodes));\n      } else {\n        bareSuper.insertAfter(nodes);\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\ntype ComputedKeyAssignmentExpression = t.AssignmentExpression & {\n  left: t.Identifier;\n};\n\n/**\n * Try to memoise a computed key.\n * It returns undefined when the computed key is an uid reference, otherwise\n * an assignment expression `memoiserId = computed key`\n * @export\n * @param {t.Expression} keyNode Computed key\n * @param {Scope} scope The scope where memoiser id should be registered\n * @param {string} hint The memoiser id hint\n * @returns {(ComputedKeyAssignmentExpression | undefined)}\n */\nexport function memoiseComputedKey(\n  keyNode: t.Expression,\n  scope: Scope,\n  hint: string,\n): ComputedKeyAssignmentExpression | undefined {\n  const isUidReference = t.isIdentifier(keyNode) && scope.hasUid(keyNode.name);\n  if (isUidReference) {\n    return;\n  }\n  const isMemoiseAssignment =\n    t.isAssignmentExpression(keyNode, { operator: \"=\" }) &&\n    t.isIdentifier(keyNode.left) &&\n    scope.hasUid(keyNode.left.name);\n  if (isMemoiseAssignment) {\n    return t.cloneNode(keyNode as ComputedKeyAssignmentExpression);\n  } else {\n    const ident = t.identifier(hint);\n    // Declaring in the same block scope\n    // Ref: https://github.com/babel/babel/pull/10029/files#diff-fbbdd83e7a9c998721c1484529c2ce92\n    scope.push({\n      id: ident,\n      kind: \"let\",\n    });\n    return t.assignmentExpression(\n      \"=\",\n      t.cloneNode(ident),\n      keyNode,\n    ) as ComputedKeyAssignmentExpression;\n  }\n}\n\nexport function extractComputedKeys(\n  path: NodePath<t.Class>,\n  computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[],\n  file: File,\n) {\n  const { scope } = path;\n  const declarations: t.ExpressionStatement[] = [];\n  const state = {\n    classBinding: path.node.id && scope.getBinding(path.node.id.name),\n    file,\n  };\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n    // Make sure computed property names are only evaluated once (upon class definition)\n    // and in the right order in combination with static properties\n    if (!computedKey.isConstantExpression()) {\n      const assignment = memoiseComputedKey(\n        computedKey.node,\n        scope,\n        scope.generateUidBasedOnNode(computedKey.node),\n      );\n      if (assignment) {\n        declarations.push(t.expressionStatement(assignment));\n        computedNode.key = t.cloneNode(assignment.left);\n      }\n    }\n  }\n\n  return declarations;\n}\n"],"names":["_core","require","_traverse","findBareSupers","visitors","environmentVisitor","Super","path","node","parentPath","isCallExpression","callee","push","referenceVisitor","TSTypeAnnotation|TypeAnnotation","skip","ReferencedIdentifier","scope","hasOwnBinding","name","rename","handleClassTDZ","state","classBinding","getBinding","classNameTDZError","file","addHelper","throwNode","t","callExpression","stringLiteral","replaceWith","sequenceExpression","classFieldDefinitionEvaluationTDZVisitor","injectInitialization","constructor","nodes","renamer","lastReturnsThis","length","isDerived","superClass","newConstructor","classMethod","identifier","blockStatement","params","restElement","body","template","statement","ast","get","unshiftContainer","bareSupers","traverse","isFirst","bareSuper","map","n","cloneNode","isExpressionStatement","allNodes","toExpression","thisExpression","insertAfter","memoiseComputedKey","keyNode","hint","isUidReference","isIdentifier","hasUid","isMemoiseAssignment","isAssignmentExpression","operator","left","ident","id","kind","assignmentExpression","extractComputedKeys","computedPaths","declarations","computedPath","computedKey","isReferencedIdentifier","computedNode","isConstantExpression","assignment","generateUidBasedOnNode","expressionStatement","key"],"mappings":";;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,SAAA,GAAAD,OAAA;AAEA,MAAME,cAAc,GAAGC,UAAAA,QAAQ,CAACC,kBAAkB,CAEhD;IACAC,KAAKA,EAACC,IAAI,EAAE;QACV,MAAM,EAAEC,IAAI,EAAEC,UAAAA,EAAY,GAAGF,IAAI;QACjC,IAAIE,UAAU,CAACC,gBAAgB,CAAC;YAAEC,MAAM,EAAEH;QAAK,CAAC,CAAC,EAAE;YACjD,IAAI,CAACI,IAAI,CAACH,UAAU,CAAC;QACvB;IACF;AACF,CAAC,CAAC;AAEF,MAAMI,gBAA2C,GAAG;IAClD,iCAAiCC,EAC/BP,IAAqD,EACrD;QACAA,IAAI,CAACQ,IAAI,CAAC,CAAC;IACb,CAAC;IAEDC,oBAAoBA,EAACT,IAA4B,EAAE,EAAEU,KAAAA,EAAO,EAAE;QAC5D,IAAIA,KAAK,CAACC,aAAa,CAACX,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAAE;YACvCF,KAAK,CAACG,MAAM,CAACb,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC;YAC5BZ,IAAI,CAACQ,IAAI,CAAC,CAAC;QACb;IACF;AACF,CAAC;AAOD,SAASM,cAAcA,CACrBd,IAA4B,EAC5Be,KAA0B,EAC1B;IACA,IACEA,KAAK,CAACC,YAAY,IAClBD,KAAK,CAACC,YAAY,KAAKhB,IAAI,CAACU,KAAK,CAACO,UAAU,CAACjB,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC,EAC5D;QACA,MAAMM,iBAAiB,GAAGH,KAAK,CAACI,IAAI,CAACC,SAAS,CAAC,mBAAmB,CAAC;QACnE,MAAMC,SAAS,GAAGC,MAAAA,KAAC,CAACC,cAAc,CAACL,iBAAiB,EAAE;YACpDI,MAAAA,KAAC,CAACE,aAAa,CAACxB,IAAI,CAACC,IAAI,CAACW,IAAI,CAAC;SAChC,CAAC;QAEFZ,IAAI,CAACyB,WAAW,CAACH,MAAAA,KAAC,CAACI,kBAAkB,CAAC;YAACL,SAAS;YAAErB,IAAI,CAACC,IAAI;SAAC,CAAC,CAAC;QAC9DD,IAAI,CAACQ,IAAI,CAAC,CAAC;IACb;AACF;AAEA,MAAMmB,wCAAsE,GAAG;IAC7ElB,oBAAoB,EAAEK;AACxB,CAAC;AAMM,SAASc,oBAAoBA,CAClC5B,IAAuB,EACvB6B,WAAgD,EAChDC,KAA8B,EAC9BC,OAAuE,EACvEC,eAAyB,EACzB;IACA,IAAI,CAACF,KAAK,CAACG,MAAM,EAAE;IAEnB,MAAMC,SAAS,GAAG,CAAC,CAAClC,IAAI,CAACC,IAAI,CAACkC,UAAU;IAExC,IAAI,CAACN,WAAW,EAAE;QAChB,MAAMO,cAAc,GAAGd,MAAAA,KAAC,CAACe,WAAW,CAClC,aAAa,EACbf,MAAAA,KAAC,CAACgB,UAAU,CAAC,aAAa,CAAC,EAC3B,EAAE,EACFhB,MAAAA,KAAC,CAACiB,cAAc,CAAC,EAAE,CACrB,CAAC;QAED,IAAIL,SAAS,EAAE;YACbE,cAAc,CAACI,MAAM,GAAG;gBAAClB,MAAAA,KAAC,CAACmB,WAAW,CAACnB,MAAAA,KAAC,CAACgB,UAAU,CAAC,MAAM,CAAC,CAAC;aAAC;YAC7DF,cAAc,CAACM,IAAI,CAACA,IAAI,CAACrC,IAAI,CAACsC,MAAAA,QAAQ,CAACC,SAAS,CAACC,GAAG,CAAA,cAAA,CAAgB,CAAC;QACvE;QAEA,CAAChB,WAAW,CAAC,GAAG7B,IAAI,CACjB8C,GAAG,CAAC,MAAM,CAAC,CACXC,gBAAgB,CAAC,MAAM,EAAEX,cAAc,CAA8B;IAC1E;IAEA,IAAIL,OAAO,EAAE;QACXA,OAAO,CAACzB,gBAAgB,EAAE;YAAEI,KAAK,EAAEmB,WAAW,CAACnB,KAAAA;QAAM,CAAC,CAAC;IACzD;IAEA,IAAIwB,SAAS,EAAE;QACb,MAAMc,UAAwC,GAAG,EAAE;QACnDnB,WAAW,CAACoB,QAAQ,CAACrD,cAAc,EAAEoD,UAAU,CAAC;QAChD,IAAIE,OAAO,GAAG,IAAI;QAClB,KAAK,MAAMC,SAAS,IAAIH,UAAU,CAAE;YAClC,IAAIE,OAAO,EAAE;gBACXA,OAAO,GAAG,KAAK;YACjB,CAAC,MAAM;gBACLpB,KAAK,GAAGA,KAAK,CAACsB,GAAG,EAACC,CAAC,GAAI/B,MAAAA,KAAC,CAACgC,SAAS,CAACD,CAAC,CAAC,CAAC;YACxC;YACA,IAAI,CAACF,SAAS,CAACjD,UAAU,CAACqD,qBAAqB,CAAC,CAAC,EAAE;gBACjD,MAAMC,QAAwB,GAAG;oBAC/BL,SAAS,CAAClD,IAAI,EACd;uBAAG6B,KAAK,CAACsB,GAAG,EAACC,CAAC,GAAI/B,MAAAA,KAAC,CAACmC,YAAY,CAACJ,CAAC,CAAC,CAAC;iBACrC;gBACD,IAAI,CAACrB,eAAe,EAAEwB,QAAQ,CAACnD,IAAI,CAACiB,MAAAA,KAAC,CAACoC,cAAc,CAAC,CAAC,CAAC;gBACvDP,SAAS,CAAC1B,WAAW,CAACH,MAAAA,KAAC,CAACI,kBAAkB,CAAC8B,QAAQ,CAAC,CAAC;YACvD,CAAC,MAAM;gBACLL,SAAS,CAACQ,WAAW,CAAC7B,KAAK,CAAC;YAC9B;QACF;IACF,CAAC,MAAM;QACLD,WAAW,CAACiB,GAAG,CAAC,MAAM,CAAC,CAACC,gBAAgB,CAAC,MAAM,EAAEjB,KAAK,CAAC;IACzD;AACF;AAgBO,SAAS8B,kBAAkBA,CAChCC,OAAqB,EACrBnD,KAAY,EACZoD,IAAY,EACiC;IAC7C,MAAMC,cAAc,GAAGzC,MAAAA,KAAC,CAAC0C,YAAY,CAACH,OAAO,CAAC,IAAInD,KAAK,CAACuD,MAAM,CAACJ,OAAO,CAACjD,IAAI,CAAC;IAC5E,IAAImD,cAAc,EAAE;QAClB;IACF;IACA,MAAMG,mBAAmB,GACvB5C,MAAAA,KAAC,CAAC6C,sBAAsB,CAACN,OAAO,EAAE;QAAEO,QAAQ,EAAE;IAAI,CAAC,CAAC,IACpD9C,MAAAA,KAAC,CAAC0C,YAAY,CAACH,OAAO,CAACQ,IAAI,CAAC,IAC5B3D,KAAK,CAACuD,MAAM,CAACJ,OAAO,CAACQ,IAAI,CAACzD,IAAI,CAAC;IACjC,IAAIsD,mBAAmB,EAAE;QACvB,OAAO5C,MAAAA,KAAC,CAACgC,SAAS,CAACO,OAA0C,CAAC;IAChE,CAAC,MAAM;QACL,MAAMS,KAAK,GAAGhD,MAAAA,KAAC,CAACgB,UAAU,CAACwB,IAAI,CAAC;QAGhCpD,KAAK,CAACL,IAAI,CAAC;YACTkE,EAAE,EAAED,KAAK;YACTE,IAAI,EAAE;QACR,CAAC,CAAC;QACF,OAAOlD,MAAAA,KAAC,CAACmD,oBAAoB,CAC3B,GAAG,EACHnD,MAAAA,KAAC,CAACgC,SAAS,CAACgB,KAAK,CAAC,EAClBT,OACF,CAAC;IACH;AACF;AAEO,SAASa,mBAAmBA,CACjC1E,IAAuB,EACvB2E,aAA0D,EAC1DxD,IAAU,EACV;IACA,MAAM,EAAET,KAAAA,EAAO,GAAGV,IAAI;IACtB,MAAM4E,YAAqC,GAAG,EAAE;IAChD,MAAM7D,KAAK,GAAG;QACZC,YAAY,EAAEhB,IAAI,CAACC,IAAI,CAACsE,EAAE,IAAI7D,KAAK,CAACO,UAAU,CAACjB,IAAI,CAACC,IAAI,CAACsE,EAAE,CAAC3D,IAAI,CAAC;QACjEO;IACF,CAAC;IACD,KAAK,MAAM0D,YAAY,IAAIF,aAAa,CAAE;QACxC,MAAMG,WAAW,GAAGD,YAAY,CAAC/B,GAAG,CAAC,KAAK,CAAC;QAC3C,IAAIgC,WAAW,CAACC,sBAAsB,CAAC,CAAC,EAAE;YACxCjE,cAAc,CAACgE,WAAW,EAAE/D,KAAK,CAAC;QACpC,CAAC,MAAM;YACL+D,WAAW,CAAC7B,QAAQ,CAACtB,wCAAwC,EAAEZ,KAAK,CAAC;QACvE;QAEA,MAAMiE,YAAY,GAAGH,YAAY,CAAC5E,IAAI;QAGtC,IAAI,CAAC6E,WAAW,CAACG,oBAAoB,CAAC,CAAC,EAAE;YACvC,MAAMC,UAAU,GAAGtB,kBAAkB,CACnCkB,WAAW,CAAC7E,IAAI,EAChBS,KAAK,EACLA,KAAK,CAACyE,sBAAsB,CAACL,WAAW,CAAC7E,IAAI,CAC/C,CAAC;YACD,IAAIiF,UAAU,EAAE;gBACdN,YAAY,CAACvE,IAAI,CAACiB,MAAAA,KAAC,CAAC8D,mBAAmB,CAACF,UAAU,CAAC,CAAC;gBACpDF,YAAY,CAACK,GAAG,GAAG/D,MAAAA,KAAC,CAACgC,SAAS,CAAC4B,UAAU,CAACb,IAAI,CAAC;YACjD;QACF;IACF;IAEA,OAAOO,YAAY;AACrB","ignoreList":[0]}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1197, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/decorators.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/core\";\nimport { types as t, template } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport type { PluginAPI, PluginObject, PluginPass } from \"@babel/core\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport {\n  privateNameVisitorFactory,\n  type PrivateNameVisitorState,\n} from \"./fields.ts\";\nimport { memoiseComputedKey } from \"./misc.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\ninterface Options {\n  /** @deprecated use `constantSuper` assumption instead. Only supported in 2021-12 version. */\n  loose?: boolean;\n}\n\ntype ClassDecoratableElement =\n  | t.ClassMethod\n  | t.ClassPrivateMethod\n  | t.ClassProperty\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty;\n\ntype ClassElement =\n  | ClassDecoratableElement\n  | t.TSDeclareMethod\n  | t.TSIndexSignature\n  | t.StaticBlock;\n\ntype ClassElementCanHaveComputedKeys =\n  | t.ClassMethod\n  | t.ClassProperty\n  | t.ClassAccessorProperty;\n\n// TODO(Babel 8): Only keep 2023-11\nexport type DecoratorVersionKind =\n  | \"2023-11\"\n  | \"2023-05\"\n  | \"2023-01\"\n  | \"2022-03\"\n  | \"2021-12\";\n\nfunction incrementId(id: number[], idx = id.length - 1): void {\n  // If index is -1, id needs an additional character, unshift A\n  if (idx === -1) {\n    id.unshift(charCodes.uppercaseA);\n    return;\n  }\n\n  const current = id[idx];\n\n  if (current === charCodes.uppercaseZ) {\n    // if current is Z, skip to a\n    id[idx] = charCodes.lowercaseA;\n  } else if (current === charCodes.lowercaseZ) {\n    // if current is z, reset to A and carry the 1\n    id[idx] = charCodes.uppercaseA;\n    incrementId(id, idx - 1);\n  } else {\n    // else, increment by one\n    id[idx] = current + 1;\n  }\n}\n\n/**\n * Generates a new private name that is unique to the given class. This can be\n * used to create extra class fields and methods for the implementation, while\n * keeping the length of those names as small as possible. This is important for\n * minification purposes (though private names can generally be minified,\n * transpilations and polyfills cannot yet).\n */\nfunction createPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  const currentPrivateId: number[] = [];\n  const privateNames = new Set<string>();\n\n  classPath.traverse({\n    PrivateName(path) {\n      privateNames.add(path.node.id.name);\n    },\n  });\n\n  return (): t.PrivateName => {\n    let reifiedId;\n    do {\n      incrementId(currentPrivateId);\n      reifiedId = String.fromCharCode(...currentPrivateId);\n    } while (privateNames.has(reifiedId));\n\n    return t.privateName(t.identifier(reifiedId));\n  };\n}\n\n/**\n * Wraps the above generator function so that it's run lazily the first time\n * it's actually required. Several types of decoration do not require this, so it\n * saves iterating the class elements an additional time and allocating the space\n * for the Sets of element names.\n */\nfunction createLazyPrivateUidGeneratorForClass(\n  classPath: NodePath<t.ClassDeclaration | t.ClassExpression>,\n): () => t.PrivateName {\n  let generator: () => t.PrivateName;\n\n  return (): t.PrivateName => {\n    if (!generator) {\n      generator = createPrivateUidGeneratorForClass(classPath);\n    }\n\n    return generator();\n  };\n}\n\n/**\n * Takes a class definition and the desired class name if anonymous and\n * replaces it with an equivalent class declaration (path) which is then\n * assigned to a local variable (id). This allows us to reassign the local variable with the\n * decorated version of the class. The class definition retains its original\n * name so that `toString` is not affected, other references to the class\n * are renamed instead.\n */\nfunction replaceClassWithVar(\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n): {\n  id: t.Identifier;\n  path: NodePath<t.ClassDeclaration | t.ClassExpression>;\n} {\n  const id = path.node.id;\n  const scope = path.scope;\n  if (path.type === \"ClassDeclaration\") {\n    const className = id.name;\n    const varId = scope.generateUidIdentifierBasedOnNode(id);\n    const classId = t.identifier(className);\n\n    scope.rename(className, varId.name);\n\n    path.get(\"id\").replaceWith(classId);\n\n    return { id: t.cloneNode(varId), path };\n  } else {\n    let varId: t.Identifier;\n\n    if (id) {\n      className = id.name;\n      varId = generateLetUidIdentifier(scope.parent, className);\n      scope.rename(className, varId.name);\n    } else {\n      varId = generateLetUidIdentifier(\n        scope.parent,\n        typeof className === \"string\" ? className : \"decorated_class\",\n      );\n    }\n\n    const newClassExpr = t.classExpression(\n      typeof className === \"string\" ? t.identifier(className) : null,\n      path.node.superClass,\n      path.node.body,\n    );\n\n    const [newPath] = path.replaceWith(\n      t.sequenceExpression([newClassExpr, varId]),\n    );\n\n    return {\n      id: t.cloneNode(varId),\n      path: newPath.get(\"expressions.0\") as NodePath<t.ClassExpression>,\n    };\n  }\n}\n\nfunction generateClassProperty(\n  key: t.PrivateName | t.Identifier,\n  value: t.Expression | undefined,\n  isStatic: boolean,\n): t.ClassPrivateProperty | t.ClassProperty {\n  if (key.type === \"PrivateName\") {\n    return t.classPrivateProperty(key, value, undefined, isStatic);\n  } else {\n    return t.classProperty(key, value, undefined, undefined, isStatic);\n  }\n}\n\nfunction assignIdForAnonymousClass(\n  path: NodePath<t.Class>,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n) {\n  if (!path.node.id) {\n    path.node.id =\n      typeof className === \"string\"\n        ? t.identifier(className)\n        : path.scope.generateUidIdentifier(\"Class\");\n  }\n}\n\nfunction addProxyAccessorsFor(\n  className: t.Identifier,\n  element: NodePath<ClassDecoratableElement>,\n  getterKey: t.PrivateName | t.Expression,\n  setterKey: t.PrivateName | t.Expression,\n  targetKey: t.PrivateName,\n  isComputed: boolean,\n  isStatic: boolean,\n  version: DecoratorVersionKind,\n): void {\n  const thisArg =\n    (version === \"2023-11\" ||\n      (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n    isStatic\n      ? className\n      : t.thisExpression();\n\n  const getterBody = t.blockStatement([\n    t.returnStatement(\n      t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n    ),\n  ]);\n\n  const setterBody = t.blockStatement([\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(t.cloneNode(thisArg), t.cloneNode(targetKey)),\n        t.identifier(\"v\"),\n      ),\n    ),\n  ]);\n\n  let getter: t.ClassMethod | t.ClassPrivateMethod,\n    setter: t.ClassMethod | t.ClassPrivateMethod;\n\n  if (getterKey.type === \"PrivateName\") {\n    getter = t.classPrivateMethod(\"get\", getterKey, [], getterBody, isStatic);\n    setter = t.classPrivateMethod(\n      \"set\",\n      setterKey as t.PrivateName,\n      [t.identifier(\"v\")],\n      setterBody,\n      isStatic,\n    );\n  } else {\n    getter = t.classMethod(\n      \"get\",\n      getterKey,\n      [],\n      getterBody,\n      isComputed,\n      isStatic,\n    );\n    setter = t.classMethod(\n      \"set\",\n      setterKey as t.Expression,\n      [t.identifier(\"v\")],\n      setterBody,\n      isComputed,\n      isStatic,\n    );\n  }\n\n  element.insertAfter(setter);\n  element.insertAfter(getter);\n}\n\nfunction extractProxyAccessorsFor(\n  targetKey: t.PrivateName,\n  version: DecoratorVersionKind,\n): (t.FunctionExpression | t.ArrowFunctionExpression)[] {\n  if (version !== \"2023-11\" && version !== \"2023-05\" && version !== \"2023-01\") {\n    return [\n      template.expression.ast`\n        function () {\n          return this.${t.cloneNode(targetKey)};\n        }\n      ` as t.FunctionExpression,\n      template.expression.ast`\n        function (value) {\n          this.${t.cloneNode(targetKey)} = value;\n        }\n      ` as t.FunctionExpression,\n    ];\n  }\n  return [\n    template.expression.ast`\n      o => o.${t.cloneNode(targetKey)}\n    ` as t.ArrowFunctionExpression,\n    template.expression.ast`\n      (o, v) => o.${t.cloneNode(targetKey)} = v\n    ` as t.ArrowFunctionExpression,\n  ];\n}\n\n/**\n * Get the last element for the given computed key path.\n *\n * This function unwraps transparent wrappers and gets the last item when\n * the key is a SequenceExpression.\n *\n * @param {NodePath<t.Expression>} path The key of a computed class element\n * @returns {NodePath<t.Expression>} The simple completion result\n */\nfunction getComputedKeyLastElement(\n  path: NodePath<t.Expression>,\n): NodePath<t.Expression> {\n  path = skipTransparentExprWrappers(path);\n  if (path.isSequenceExpression()) {\n    const expressions = path.get(\"expressions\");\n    return getComputedKeyLastElement(expressions[expressions.length - 1]);\n  }\n  return path;\n}\n\n/**\n * Get a memoiser of the computed key path.\n *\n * This function does not mutate AST. If the computed key is not a constant\n * expression, this function must be called after the key has been memoised.\n *\n * @param {NodePath<t.Expression>} path The key of a computed class element.\n * @returns {t.Expression} A clone of key if key is a constant expression,\n * otherwise a memoiser identifier.\n */\nfunction getComputedKeyMemoiser(path: NodePath<t.Expression>): t.Expression {\n  const element = getComputedKeyLastElement(path);\n  if (element.isConstantExpression()) {\n    return t.cloneNode(path.node);\n  } else if (element.isIdentifier() && path.scope.hasUid(element.node.name)) {\n    return t.cloneNode(path.node);\n  } else if (\n    element.isAssignmentExpression() &&\n    element.get(\"left\").isIdentifier()\n  ) {\n    return t.cloneNode(element.node.left as t.Identifier);\n  } else {\n    throw new Error(\n      `Internal Error: the computed key ${path.toString()} has not yet been memoised.`,\n    );\n  }\n}\n\n/**\n * Prepend expressions to the computed key of the given field path.\n *\n * If the computed key is a sequence expression, this function will unwrap\n * the sequence expression for optimal output size.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction prependExpressionsToComputedKey(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n  >,\n) {\n  const key = fieldPath.get(\"key\") as NodePath<t.Expression>;\n  if (key.isSequenceExpression()) {\n    expressions.push(...key.node.expressions);\n  } else {\n    expressions.push(key.node);\n  }\n  key.replaceWith(maybeSequenceExpression(expressions));\n}\n\n/**\n * Append expressions to the computed key of the given field path.\n *\n * If the computed key is a constant expression or uid reference, it\n * will prepend expressions before the comptued key. Otherwise it will\n * memoise the computed key to preserve its completion result.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction appendExpressionsToComputedKey(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassMethod | t.ClassProperty | t.ClassAccessorProperty\n  >,\n) {\n  const key = fieldPath.get(\"key\") as NodePath<t.Expression>;\n  const completion = getComputedKeyLastElement(key);\n  if (completion.isConstantExpression()) {\n    prependExpressionsToComputedKey(expressions, fieldPath);\n  } else {\n    const scopeParent = key.scope.parent;\n    const maybeAssignment = memoiseComputedKey(\n      completion.node,\n      scopeParent,\n      scopeParent.generateUid(\"computedKey\"),\n    );\n    if (!maybeAssignment) {\n      // If the memoiseComputedKey returns undefined, the key is already a uid reference,\n      // treat it as a constant expression and prepend expressions before it\n      prependExpressionsToComputedKey(expressions, fieldPath);\n    } else {\n      const expressionSequence = [\n        ...expressions,\n        // preserve the completion result\n        t.cloneNode(maybeAssignment.left),\n      ];\n      const completionParent = completion.parentPath;\n      if (completionParent.isSequenceExpression()) {\n        completionParent.pushContainer(\"expressions\", expressionSequence);\n      } else {\n        completion.replaceWith(\n          maybeSequenceExpression([\n            t.cloneNode(maybeAssignment),\n            ...expressionSequence,\n          ]),\n        );\n      }\n    }\n  }\n}\n\n/**\n * Prepend expressions to the field initializer. If the initializer is not defined,\n * this function will wrap the last expression within a `void` unary expression.\n *\n * @param {t.Expression[]} expressions\n * @param {(NodePath<\n *     t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty\n *   >)} fieldPath\n */\nfunction prependExpressionsToFieldInitializer(\n  expressions: t.Expression[],\n  fieldPath: NodePath<\n    t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty\n  >,\n) {\n  const initializer = fieldPath.get(\"value\");\n  if (initializer.node) {\n    expressions.push(initializer.node);\n  } else if (expressions.length > 0) {\n    expressions[expressions.length - 1] = t.unaryExpression(\n      \"void\",\n      expressions[expressions.length - 1],\n    );\n  }\n  initializer.replaceWith(maybeSequenceExpression(expressions));\n}\n\nfunction prependExpressionsToStaticBlock(\n  expressions: t.Expression[],\n  blockPath: NodePath<t.StaticBlock>,\n) {\n  blockPath.unshiftContainer(\n    \"body\",\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  );\n}\n\nfunction prependExpressionsToConstructor(\n  expressions: t.Expression[],\n  constructorPath: NodePath<t.ClassMethod>,\n) {\n  constructorPath.node.body.body.unshift(\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  );\n}\n\nfunction isProtoInitCallExpression(\n  expression: t.Expression,\n  protoInitCall: t.Identifier,\n) {\n  return (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee, { name: protoInitCall.name })\n  );\n}\n\n/**\n * Optimize super call and its following expressions\n *\n * @param {t.Expression[]} expressions Mutated by this function. The first element must by a super call\n * @param {t.Identifier} protoInitLocal The generated protoInit id\n * @returns optimized expression\n */\nfunction optimizeSuperCallAndExpressions(\n  expressions: t.Expression[],\n  protoInitLocal: t.Identifier,\n) {\n  if (protoInitLocal) {\n    if (\n      expressions.length >= 2 &&\n      isProtoInitCallExpression(expressions[1], protoInitLocal)\n    ) {\n      // Merge `super(), protoInit(this)` into `protoInit(super())`\n      const mergedSuperCall = t.callExpression(t.cloneNode(protoInitLocal), [\n        expressions[0],\n      ]);\n      expressions.splice(0, 2, mergedSuperCall);\n    }\n    // Merge `protoInit(super()), this` into `protoInit(super())`\n    if (\n      expressions.length >= 2 &&\n      t.isThisExpression(expressions[expressions.length - 1]) &&\n      isProtoInitCallExpression(\n        expressions[expressions.length - 2],\n        protoInitLocal,\n      )\n    ) {\n      expressions.splice(expressions.length - 1, 1);\n    }\n  }\n  return maybeSequenceExpression(expressions);\n}\n\n/**\n * Insert expressions immediately after super() and optimize the output if possible.\n * This function will preserve the completion result using the trailing this expression.\n *\n * @param {t.Expression[]} expressions\n * @param {NodePath<t.ClassMethod>} constructorPath\n * @param {t.Identifier} protoInitLocal The generated protoInit id\n * @returns\n */\nfunction insertExpressionsAfterSuperCallAndOptimize(\n  expressions: t.Expression[],\n  constructorPath: NodePath<t.ClassMethod>,\n  protoInitLocal: t.Identifier,\n) {\n  constructorPath.traverse({\n    CallExpression: {\n      exit(path) {\n        if (!path.get(\"callee\").isSuper()) return;\n        const newNodes = [\n          path.node,\n          ...expressions.map(expr => t.cloneNode(expr)),\n        ];\n        // preserve completion result if super() is in an RHS or a return statement\n        if (path.isCompletionRecord()) {\n          newNodes.push(t.thisExpression());\n        }\n        path.replaceWith(\n          optimizeSuperCallAndExpressions(newNodes, protoInitLocal),\n        );\n\n        path.skip();\n      },\n    },\n    ClassMethod(path) {\n      if (path.node.kind === \"constructor\") {\n        path.skip();\n      }\n    },\n  });\n}\n\n/**\n * Build a class constructor node from the given expressions. If the class is\n * derived, the constructor will call super() first to ensure that `this`\n * in the expressions work as expected.\n *\n * @param {t.Expression[]} expressions\n * @param {boolean} isDerivedClass\n * @returns The class constructor node\n */\nfunction createConstructorFromExpressions(\n  expressions: t.Expression[],\n  isDerivedClass: boolean,\n) {\n  const body: t.Statement[] = [\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  ];\n  if (isDerivedClass) {\n    body.unshift(\n      t.expressionStatement(\n        t.callExpression(t.super(), [t.spreadElement(t.identifier(\"args\"))]),\n      ),\n    );\n  }\n  return t.classMethod(\n    \"constructor\",\n    t.identifier(\"constructor\"),\n    isDerivedClass ? [t.restElement(t.identifier(\"args\"))] : [],\n    t.blockStatement(body),\n  );\n}\n\nfunction createStaticBlockFromExpressions(expressions: t.Expression[]) {\n  return t.staticBlock([\n    t.expressionStatement(maybeSequenceExpression(expressions)),\n  ]);\n}\n\n// 3 bits reserved to this (0-7)\nconst FIELD = 0;\nconst ACCESSOR = 1;\nconst METHOD = 2;\nconst GETTER = 3;\nconst SETTER = 4;\n\nconst STATIC_OLD_VERSION = 5; // Before 2023-05\nconst STATIC = 8; // 1 << 3\nconst DECORATORS_HAVE_THIS = 16; // 1 << 4\n\nfunction getElementKind(element: NodePath<ClassDecoratableElement>): number {\n  switch (element.node.type) {\n    case \"ClassProperty\":\n    case \"ClassPrivateProperty\":\n      return FIELD;\n    case \"ClassAccessorProperty\":\n      return ACCESSOR;\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      if (element.node.kind === \"get\") {\n        return GETTER;\n      } else if (element.node.kind === \"set\") {\n        return SETTER;\n      } else {\n        return METHOD;\n      }\n  }\n}\n\n// Information about the decorators applied to an element\ninterface DecoratorInfo {\n  // An array of applied decorators or a memoised identifier\n  decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;\n  decoratorsHaveThis: boolean;\n\n  // The kind of the decorated value, matches the kind value passed to applyDecs\n  kind: number;\n\n  // whether or not the field is static\n  isStatic: boolean;\n\n  // The name of the decorator\n  name: t.StringLiteral | t.Expression;\n\n  privateMethods:\n    | (t.FunctionExpression | t.ArrowFunctionExpression)[]\n    | undefined;\n\n  // The names of local variables that will be used/returned from the decoration\n  locals: t.Identifier | t.Identifier[] | undefined;\n}\n\n/**\n * Sort decoration info in the application order:\n * - static non-fields\n * - instance non-fields\n * - static fields\n * - instance fields\n *\n * @param {DecoratorInfo[]} info\n * @returns {DecoratorInfo[]} Sorted decoration info\n */\nfunction toSortedDecoratorInfo(info: DecoratorInfo[]): DecoratorInfo[] {\n  return [\n    ...info.filter(\n      el => el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...info.filter(\n      el => !el.isStatic && el.kind >= ACCESSOR && el.kind <= SETTER,\n    ),\n    ...info.filter(el => el.isStatic && el.kind === FIELD),\n    ...info.filter(el => !el.isStatic && el.kind === FIELD),\n  ];\n}\n\ntype GenerateDecorationListResult = {\n  // The zipped decorators array that will be passed to generateDecorationExprs\n  decs: t.Expression[];\n  // Whether there are non-empty decorator this values\n  haveThis: boolean;\n};\n/**\n * Zip decorators and decorator this values into an array\n *\n * @param {t.Decorator[]} decorators\n * @param {((t.Expression | undefined)[])} decoratorsThis decorator this values\n * @param {DecoratorVersionKind} version\n * @returns {GenerateDecorationListResult}\n */\nfunction generateDecorationList(\n  decorators: t.Decorator[],\n  decoratorsThis: (t.Expression | undefined)[],\n  version: DecoratorVersionKind,\n): GenerateDecorationListResult {\n  const decsCount = decorators.length;\n  const haveOneThis = decoratorsThis.some(Boolean);\n  const decs: t.Expression[] = [];\n  for (let i = 0; i < decsCount; i++) {\n    if (\n      (version === \"2023-11\" ||\n        (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n      haveOneThis\n    ) {\n      decs.push(\n        decoratorsThis[i] || t.unaryExpression(\"void\", t.numericLiteral(0)),\n      );\n    }\n    decs.push(decorators[i].expression);\n  }\n\n  return { haveThis: haveOneThis, decs };\n}\n\nfunction generateDecorationExprs(\n  decorationInfo: DecoratorInfo[],\n  version: DecoratorVersionKind,\n): t.ArrayExpression {\n  return t.arrayExpression(\n    decorationInfo.map(el => {\n      let flag = el.kind;\n      if (el.isStatic) {\n        flag +=\n          version === \"2023-11\" ||\n          (!process.env.BABEL_8_BREAKING && version === \"2023-05\")\n            ? STATIC\n            : STATIC_OLD_VERSION;\n      }\n      if (el.decoratorsHaveThis) flag += DECORATORS_HAVE_THIS;\n\n      return t.arrayExpression([\n        el.decoratorsArray,\n        t.numericLiteral(flag),\n        el.name,\n        ...(el.privateMethods || []),\n      ]);\n    }),\n  );\n}\n\nfunction extractElementLocalAssignments(decorationInfo: DecoratorInfo[]) {\n  const localIds: t.Identifier[] = [];\n\n  for (const el of decorationInfo) {\n    const { locals } = el;\n\n    if (Array.isArray(locals)) {\n      localIds.push(...locals);\n    } else if (locals !== undefined) {\n      localIds.push(locals);\n    }\n  }\n\n  return localIds;\n}\n\nfunction addCallAccessorsFor(\n  version: DecoratorVersionKind,\n  element: NodePath,\n  key: t.PrivateName,\n  getId: t.Identifier,\n  setId: t.Identifier,\n  isStatic: boolean,\n) {\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"get\",\n      t.cloneNode(key),\n      [],\n      t.blockStatement([\n        t.returnStatement(\n          t.callExpression(\n            t.cloneNode(getId),\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()],\n          ),\n        ),\n      ]),\n      isStatic,\n    ),\n  );\n\n  element.insertAfter(\n    t.classPrivateMethod(\n      \"set\",\n      t.cloneNode(key),\n      [t.identifier(\"v\")],\n      t.blockStatement([\n        t.expressionStatement(\n          t.callExpression(\n            t.cloneNode(setId),\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? [t.identifier(\"v\")]\n              : [t.thisExpression(), t.identifier(\"v\")],\n          ),\n        ),\n      ]),\n      isStatic,\n    ),\n  );\n}\n\nfunction movePrivateAccessor(\n  element: NodePath<t.ClassPrivateMethod>,\n  key: t.PrivateName,\n  methodLocalVar: t.Identifier,\n  isStatic: boolean,\n) {\n  let params: (t.Identifier | t.RestElement)[];\n  let block: t.Statement[];\n\n  if (element.node.kind === \"set\") {\n    params = [t.identifier(\"v\")];\n    block = [\n      t.expressionStatement(\n        t.callExpression(methodLocalVar, [\n          t.thisExpression(),\n          t.identifier(\"v\"),\n        ]),\n      ),\n    ];\n  } else {\n    params = [];\n    block = [\n      t.returnStatement(t.callExpression(methodLocalVar, [t.thisExpression()])),\n    ];\n  }\n\n  element.replaceWith(\n    t.classPrivateMethod(\n      element.node.kind,\n      t.cloneNode(key),\n      params,\n      t.blockStatement(block),\n      isStatic,\n    ),\n  );\n}\n\nfunction isClassDecoratableElementPath(\n  path: NodePath<ClassElement>,\n): path is NodePath<ClassDecoratableElement> {\n  const { type } = path;\n\n  return (\n    type !== \"TSDeclareMethod\" &&\n    type !== \"TSIndexSignature\" &&\n    type !== \"StaticBlock\"\n  );\n}\n\nfunction staticBlockToIIFE(block: t.StaticBlock) {\n  return t.callExpression(\n    t.arrowFunctionExpression([], t.blockStatement(block.body)),\n    [],\n  );\n}\n\nfunction staticBlockToFunctionClosure(block: t.StaticBlock) {\n  return t.functionExpression(null, [], t.blockStatement(block.body));\n}\n\nfunction fieldInitializerToClosure(value: t.Expression) {\n  return t.functionExpression(\n    null,\n    [],\n    t.blockStatement([t.returnStatement(value)]),\n  );\n}\n\nfunction maybeSequenceExpression(exprs: t.Expression[]) {\n  if (exprs.length === 0) return t.unaryExpression(\"void\", t.numericLiteral(0));\n  if (exprs.length === 1) return exprs[0];\n  return t.sequenceExpression(exprs);\n}\n\n/**\n * Create FunctionExpression from a ClassPrivateMethod.\n * The returned FunctionExpression node takes ownership of the private method's body and params.\n *\n * @param {t.ClassPrivateMethod} node\n * @returns\n */\nfunction createFunctionExpressionFromPrivateMethod(node: t.ClassPrivateMethod) {\n  const { params, body, generator: isGenerator, async: isAsync } = node;\n  return t.functionExpression(\n    undefined,\n    // @ts-expect-error todo: Improve typings: TSParameterProperty is only allowed in constructor\n    params,\n    body,\n    isGenerator,\n    isAsync,\n  );\n}\n\nfunction createSetFunctionNameCall(\n  state: PluginPass,\n  className: t.Identifier | t.StringLiteral,\n) {\n  return t.callExpression(state.addHelper(\"setFunctionName\"), [\n    t.thisExpression(),\n    className,\n  ]);\n}\n\nfunction createToPropertyKeyCall(state: PluginPass, propertyKey: t.Expression) {\n  return t.callExpression(state.addHelper(\"toPropertyKey\"), [propertyKey]);\n}\n\nfunction createPrivateBrandCheckClosure(brandName: t.PrivateName) {\n  return t.arrowFunctionExpression(\n    [t.identifier(\"_\")],\n    t.binaryExpression(\"in\", t.cloneNode(brandName), t.identifier(\"_\")),\n  );\n}\n\nfunction usesPrivateField(expression: t.Node) {\n  try {\n    t.traverseFast(expression, node => {\n      if (t.isPrivateName(node)) {\n        // TODO: Add early return support to t.traverseFast\n        // eslint-disable-next-line @typescript-eslint/only-throw-error\n        throw null;\n      }\n    });\n    return false;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Convert a non-computed class element to its equivalent computed form.\n *\n * This function is to provide a decorator evaluation storage from non-computed\n * class elements.\n *\n * @param {(NodePath<t.ClassProperty | t.ClassMethod>)} path A non-computed class property or method\n */\nfunction convertToComputedKey(path: NodePath<t.ClassProperty | t.ClassMethod>) {\n  const { node } = path;\n  node.computed = true;\n  if (t.isIdentifier(node.key)) {\n    node.key = t.stringLiteral(node.key.name);\n  }\n}\n\nfunction hasInstancePrivateAccess(path: NodePath, privateNames: string[]) {\n  let containsInstancePrivateAccess = false;\n  if (privateNames.length > 0) {\n    const privateNameVisitor = privateNameVisitorFactory<\n      PrivateNameVisitorState<null>,\n      null\n    >({\n      PrivateName(path, state) {\n        if (state.privateNamesMap.has(path.node.id.name)) {\n          containsInstancePrivateAccess = true;\n          path.stop();\n        }\n      },\n    });\n    const privateNamesMap = new Map<string, null>();\n    for (const name of privateNames) {\n      privateNamesMap.set(name, null);\n    }\n    path.traverse(privateNameVisitor, {\n      privateNamesMap: privateNamesMap,\n    });\n  }\n  return containsInstancePrivateAccess;\n}\n\nfunction checkPrivateMethodUpdateError(\n  path: NodePath<t.Class>,\n  decoratedPrivateMethods: Set<string>,\n) {\n  const privateNameVisitor = privateNameVisitorFactory<\n    PrivateNameVisitorState<null>,\n    null\n  >({\n    PrivateName(path, state) {\n      if (!state.privateNamesMap.has(path.node.id.name)) return;\n\n      const parentPath = path.parentPath;\n      const parentParentPath = parentPath.parentPath;\n\n      if (\n        // this.bar().#x = 123;\n        (parentParentPath.node.type === \"AssignmentExpression\" &&\n          parentParentPath.node.left === parentPath.node) ||\n        // this.#x++;\n        parentParentPath.node.type === \"UpdateExpression\" ||\n        // ([...this.#x] = foo);\n        parentParentPath.node.type === \"RestElement\" ||\n        // ([this.#x] = foo);\n        parentParentPath.node.type === \"ArrayPattern\" ||\n        // ({ a: this.#x } = bar);\n        (parentParentPath.node.type === \"ObjectProperty\" &&\n          parentParentPath.node.value === parentPath.node &&\n          parentParentPath.parentPath.type === \"ObjectPattern\") ||\n        // for (this.#x of []);\n        (parentParentPath.node.type === \"ForOfStatement\" &&\n          parentParentPath.node.left === parentPath.node)\n      ) {\n        throw path.buildCodeFrameError(\n          `Decorated private methods are read-only, but \"#${path.node.id.name}\" is updated via this expression.`,\n        );\n      }\n    },\n  });\n  const privateNamesMap = new Map<string, null>();\n  for (const name of decoratedPrivateMethods) {\n    privateNamesMap.set(name, null);\n  }\n  path.traverse(privateNameVisitor, {\n    privateNamesMap: privateNamesMap,\n  });\n}\n\n/**\n * Apply decorator and accessor transform\n * @param path The class path.\n * @param state The plugin pass.\n * @param constantSuper The constantSuper compiler assumption.\n * @param ignoreFunctionLength The ignoreFunctionLength compiler assumption.\n * @param className The class name.\n * - If className is a `string`, it will be a valid identifier name that can safely serve as a class id\n * - If className is an Identifier, it is the reference to the name derived from NamedEvaluation\n * - If className is a StringLiteral, it is derived from NamedEvaluation on literal computed keys\n * @param propertyVisitor The visitor that should be applied on property prior to the transform.\n * @param version The decorator version.\n * @returns The transformed class path or undefined if there are no decorators.\n */\nfunction transformClass(\n  path: NodePath<t.Class>,\n  state: PluginPass,\n  constantSuper: boolean,\n  ignoreFunctionLength: boolean,\n  className: string | t.Identifier | t.StringLiteral | undefined,\n  propertyVisitor: Visitor<PluginPass>,\n  version: DecoratorVersionKind,\n): NodePath | undefined {\n  const body = path.get(\"body.body\");\n\n  const classDecorators = path.node.decorators;\n  let hasElementDecorators = false;\n  let hasComputedKeysSideEffects = false;\n  let elemDecsUseFnContext = false;\n\n  const generateClassPrivateUid = createLazyPrivateUidGeneratorForClass(path);\n\n  const classAssignments: t.AssignmentExpression[] = [];\n  const scopeParent: Scope = path.scope.parent;\n  const memoiseExpression = (\n    expression: t.Expression,\n    hint: string,\n    assignments: t.AssignmentExpression[],\n  ) => {\n    const localEvaluatedId = generateLetUidIdentifier(scopeParent, hint);\n    assignments.push(t.assignmentExpression(\"=\", localEvaluatedId, expression));\n    return t.cloneNode(localEvaluatedId);\n  };\n\n  let protoInitLocal: t.Identifier;\n  let staticInitLocal: t.Identifier;\n  const classIdName = path.node.id?.name;\n  // Whether to generate a setFunctionName call to preserve the class name\n  const setClassName = typeof className === \"object\" ? className : undefined;\n  // Check if the decorator does not reference function-specific\n  // context or the given identifier name or contains yield or await expression.\n  // `true` means \"maybe\" and `false` means \"no\".\n  const usesFunctionContextOrYieldAwait = (decorator: t.Decorator) => {\n    try {\n      t.traverseFast(decorator, node => {\n        if (\n          t.isThisExpression(node) ||\n          t.isSuper(node) ||\n          t.isYieldExpression(node) ||\n          t.isAwaitExpression(node) ||\n          t.isIdentifier(node, { name: \"arguments\" }) ||\n          (classIdName && t.isIdentifier(node, { name: classIdName })) ||\n          (t.isMetaProperty(node) && node.meta.name !== \"import\")\n        ) {\n          // TODO: Add early return support to t.traverseFast\n          // eslint-disable-next-line @typescript-eslint/only-throw-error\n          throw null;\n        }\n      });\n      return false;\n    } catch {\n      return true;\n    }\n  };\n\n  const instancePrivateNames: string[] = [];\n  // Iterate over the class to see if we need to decorate it, and also to\n  // transform simple auto accessors which are not decorated, and handle inferred\n  // class name when the initializer of the class field is a class expression\n  for (const element of body) {\n    if (!isClassDecoratableElementPath(element)) {\n      continue;\n    }\n\n    const elementNode = element.node;\n\n    if (!elementNode.static && t.isPrivateName(elementNode.key)) {\n      instancePrivateNames.push(elementNode.key.id.name);\n    }\n\n    if (isDecorated(elementNode)) {\n      switch (elementNode.type) {\n        case \"ClassProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassProperty should be callable. Improve typings.\n          propertyVisitor.ClassProperty(\n            element as NodePath<t.ClassProperty>,\n            state,\n          );\n          break;\n        case \"ClassPrivateProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassPrivateProperty should be callable. Improve typings.\n          propertyVisitor.ClassPrivateProperty(\n            element as NodePath<t.ClassPrivateProperty>,\n            state,\n          );\n          break;\n        case \"ClassAccessorProperty\":\n          // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n          propertyVisitor.ClassAccessorProperty(\n            element as NodePath<t.ClassAccessorProperty>,\n            state,\n          );\n          if (version === \"2023-11\") {\n            break;\n          }\n        /* fallthrough */\n        default:\n          if (elementNode.static) {\n            staticInitLocal ??= generateLetUidIdentifier(\n              scopeParent,\n              \"initStatic\",\n            );\n          } else {\n            protoInitLocal ??= generateLetUidIdentifier(\n              scopeParent,\n              \"initProto\",\n            );\n          }\n          break;\n      }\n      hasElementDecorators = true;\n      elemDecsUseFnContext ||= elementNode.decorators.some(\n        usesFunctionContextOrYieldAwait,\n      );\n    } else if (elementNode.type === \"ClassAccessorProperty\") {\n      // @ts-expect-error todo: propertyVisitor.ClassAccessorProperty should be callable. Improve typings.\n      propertyVisitor.ClassAccessorProperty(\n        element as NodePath<t.ClassAccessorProperty>,\n        state,\n      );\n      const { key, value, static: isStatic, computed } = elementNode;\n\n      const newId = generateClassPrivateUid();\n      const newField = generateClassProperty(newId, value, isStatic);\n      const keyPath = element.get(\"key\");\n      const [newPath] = element.replaceWith(newField);\n\n      let getterKey, setterKey;\n      if (computed && !keyPath.isConstantExpression()) {\n        getterKey = memoiseComputedKey(\n          createToPropertyKeyCall(state, key as t.Expression),\n          scopeParent,\n          scopeParent.generateUid(\"computedKey\"),\n        )!;\n        setterKey = t.cloneNode(getterKey.left as t.Identifier);\n      } else {\n        getterKey = t.cloneNode(key);\n        setterKey = t.cloneNode(key);\n      }\n\n      assignIdForAnonymousClass(path, className);\n\n      addProxyAccessorsFor(\n        path.node.id,\n        newPath,\n        getterKey,\n        setterKey,\n        newId,\n        computed,\n        isStatic,\n        version,\n      );\n    }\n\n    if (\"computed\" in element.node && element.node.computed) {\n      hasComputedKeysSideEffects ||= !scopeParent.isStatic(element.node.key);\n    }\n  }\n\n  if (!classDecorators && !hasElementDecorators) {\n    if (!path.node.id && typeof className === \"string\") {\n      path.node.id = t.identifier(className);\n    }\n    if (setClassName) {\n      path.node.body.body.unshift(\n        createStaticBlockFromExpressions([\n          createSetFunctionNameCall(state, setClassName),\n        ]),\n      );\n    }\n    // If nothing is decorated and no assignments inserted, return\n    return;\n  }\n\n  const elementDecoratorInfo: DecoratorInfo[] = [];\n\n  let constructorPath: NodePath<t.ClassMethod> | undefined;\n  const decoratedPrivateMethods = new Set<string>();\n\n  let classInitLocal: t.Identifier, classIdLocal: t.Identifier;\n  let decoratorReceiverId: t.Identifier | null = null;\n\n  // Memoise the this value `a.b` of decorator member expressions `@a.b.dec`,\n  type HandleDecoratorsResult = {\n    // whether the whole decorator list requires memoisation\n    hasSideEffects: boolean;\n    usesFnContext: boolean;\n    // the this value of each decorator if applicable\n    decoratorsThis: (t.Expression | undefined)[];\n  };\n  function handleDecorators(decorators: t.Decorator[]): HandleDecoratorsResult {\n    let hasSideEffects = false;\n    let usesFnContext = false;\n    const decoratorsThis: (t.Expression | null)[] = [];\n    for (const decorator of decorators) {\n      const { expression } = decorator;\n      let object;\n      if (\n        (version === \"2023-11\" ||\n          (!process.env.BABEL_8_BREAKING && version === \"2023-05\")) &&\n        t.isMemberExpression(expression)\n      ) {\n        if (t.isSuper(expression.object)) {\n          object = t.thisExpression();\n        } else if (scopeParent.isStatic(expression.object)) {\n          object = t.cloneNode(expression.object);\n        } else {\n          decoratorReceiverId ??= generateLetUidIdentifier(scopeParent, \"obj\");\n          object = t.assignmentExpression(\n            \"=\",\n            t.cloneNode(decoratorReceiverId),\n            expression.object,\n          );\n          expression.object = t.cloneNode(decoratorReceiverId);\n        }\n      }\n      decoratorsThis.push(object);\n      hasSideEffects ||= !scopeParent.isStatic(expression);\n      usesFnContext ||= usesFunctionContextOrYieldAwait(decorator);\n    }\n    return { hasSideEffects, usesFnContext, decoratorsThis };\n  }\n\n  const willExtractSomeElemDecs =\n    hasComputedKeysSideEffects ||\n    (process.env.BABEL_8_BREAKING\n      ? elemDecsUseFnContext\n      : elemDecsUseFnContext || version !== \"2023-11\");\n\n  let needsDeclaraionForClassBinding = false;\n  let classDecorationsFlag = 0;\n  let classDecorations: t.Expression[] = [];\n  let classDecorationsId: t.Identifier;\n  let computedKeyAssignments: t.AssignmentExpression[] = [];\n  if (classDecorators) {\n    classInitLocal = generateLetUidIdentifier(scopeParent, \"initClass\");\n    needsDeclaraionForClassBinding = path.isClassDeclaration();\n    ({ id: classIdLocal, path } = replaceClassWithVar(path, className));\n\n    path.node.decorators = null;\n\n    const classDecsUsePrivateName = classDecorators.some(usesPrivateField);\n    const { hasSideEffects, usesFnContext, decoratorsThis } =\n      handleDecorators(classDecorators);\n\n    const { haveThis, decs } = generateDecorationList(\n      classDecorators,\n      decoratorsThis,\n      version,\n    );\n    classDecorationsFlag = haveThis ? 1 : 0;\n    classDecorations = decs;\n\n    if (\n      usesFnContext ||\n      (hasSideEffects && willExtractSomeElemDecs) ||\n      classDecsUsePrivateName\n    ) {\n      classDecorationsId = memoiseExpression(\n        t.arrayExpression(classDecorations),\n        \"classDecs\",\n        classAssignments,\n      );\n    }\n\n    if (!hasElementDecorators) {\n      // Sync body paths as non-decorated computed accessors have been transpiled\n      // to getter-setter pairs.\n      for (const element of path.get(\"body.body\")) {\n        const { node } = element;\n        const isComputed = \"computed\" in node && node.computed;\n        if (isComputed) {\n          if (element.isClassProperty({ static: true })) {\n            if (!element.get(\"key\").isConstantExpression()) {\n              const key = (node as t.ClassProperty).key;\n              const maybeAssignment = memoiseComputedKey(\n                key,\n                scopeParent,\n                scopeParent.generateUid(\"computedKey\"),\n              );\n              if (maybeAssignment != null) {\n                // If it is a static computed field within a decorated class, we move the computed key\n                // into `computedKeyAssignments` which will be then moved into the non-static class,\n                // to ensure that the evaluation order and private environment are correct\n                node.key = t.cloneNode(maybeAssignment.left);\n                computedKeyAssignments.push(maybeAssignment);\n              }\n            }\n          } else if (computedKeyAssignments.length > 0) {\n            prependExpressionsToComputedKey(\n              computedKeyAssignments,\n              element as NodePath<ClassElementCanHaveComputedKeys>,\n            );\n            computedKeyAssignments = [];\n          }\n        }\n      }\n    }\n  } else {\n    assignIdForAnonymousClass(path, className);\n    classIdLocal = t.cloneNode(path.node.id);\n  }\n\n  let lastInstancePrivateName: t.PrivateName;\n  let needsInstancePrivateBrandCheck = false;\n\n  let fieldInitializerExpressions = [];\n  let staticFieldInitializerExpressions: t.Expression[] = [];\n\n  if (hasElementDecorators) {\n    if (protoInitLocal) {\n      const protoInitCall = t.callExpression(t.cloneNode(protoInitLocal), [\n        t.thisExpression(),\n      ]);\n      fieldInitializerExpressions.push(protoInitCall);\n    }\n    for (const element of body) {\n      if (!isClassDecoratableElementPath(element)) {\n        if (\n          staticFieldInitializerExpressions.length > 0 &&\n          element.isStaticBlock()\n        ) {\n          prependExpressionsToStaticBlock(\n            staticFieldInitializerExpressions,\n            element,\n          );\n          staticFieldInitializerExpressions = [];\n        }\n        continue;\n      }\n\n      const { node } = element;\n      const decorators = node.decorators;\n\n      const hasDecorators = !!decorators?.length;\n\n      const isComputed = \"computed\" in node && node.computed;\n\n      let name = \"computedKey\";\n\n      if (node.key.type === \"PrivateName\") {\n        name = node.key.id.name;\n      } else if (!isComputed && node.key.type === \"Identifier\") {\n        name = node.key.name;\n      }\n      let decoratorsArray: t.Identifier | t.ArrayExpression | t.Expression;\n      let decoratorsHaveThis;\n\n      if (hasDecorators) {\n        const { hasSideEffects, usesFnContext, decoratorsThis } =\n          handleDecorators(decorators);\n        const { decs, haveThis } = generateDecorationList(\n          decorators,\n          decoratorsThis,\n          version,\n        );\n        decoratorsHaveThis = haveThis;\n        decoratorsArray = decs.length === 1 ? decs[0] : t.arrayExpression(decs);\n        if (usesFnContext || (hasSideEffects && willExtractSomeElemDecs)) {\n          decoratorsArray = memoiseExpression(\n            decoratorsArray,\n            name + \"Decs\",\n            computedKeyAssignments,\n          );\n        }\n      }\n\n      if (isComputed) {\n        if (!element.get(\"key\").isConstantExpression()) {\n          const key = node.key as t.Expression;\n          const maybeAssignment = memoiseComputedKey(\n            hasDecorators ? createToPropertyKeyCall(state, key) : key,\n            scopeParent,\n            scopeParent.generateUid(\"computedKey\"),\n          );\n          if (maybeAssignment != null) {\n            // If it is a static computed field within a decorated class, we move the computed key\n            // into `computedKeyAssignments` which will be then moved into the non-static class,\n            // to ensure that the evaluation order and private environment are correct\n            if (classDecorators && element.isClassProperty({ static: true })) {\n              node.key = t.cloneNode(maybeAssignment.left);\n              computedKeyAssignments.push(maybeAssignment);\n            } else {\n              node.key = maybeAssignment;\n            }\n          }\n        }\n      }\n\n      const { key, static: isStatic } = node;\n\n      const isPrivate = key.type === \"PrivateName\";\n\n      const kind = getElementKind(element);\n\n      if (isPrivate && !isStatic) {\n        if (hasDecorators) {\n          needsInstancePrivateBrandCheck = true;\n        }\n        if (t.isClassPrivateProperty(node) || !lastInstancePrivateName) {\n          lastInstancePrivateName = key;\n        }\n      }\n\n      if (element.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = element;\n      }\n\n      let locals: t.Identifier[];\n      if (hasDecorators) {\n        let privateMethods: Array<\n          t.FunctionExpression | t.ArrowFunctionExpression\n        >;\n\n        let nameExpr: t.Expression;\n\n        if (isComputed) {\n          nameExpr = getComputedKeyMemoiser(\n            element.get(\"key\") as NodePath<t.Expression>,\n          );\n        } else if (key.type === \"PrivateName\") {\n          nameExpr = t.stringLiteral(key.id.name);\n        } else if (key.type === \"Identifier\") {\n          nameExpr = t.stringLiteral(key.name);\n        } else {\n          nameExpr = t.cloneNode(key as t.Expression);\n        }\n\n        if (kind === ACCESSOR) {\n          const { value } = element.node as t.ClassAccessorProperty;\n\n          const params: t.Expression[] =\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()];\n\n          if (value) {\n            params.push(t.cloneNode(value));\n          }\n\n          const newId = generateClassPrivateUid();\n          const newFieldInitId = generateLetUidIdentifier(\n            scopeParent,\n            `init_${name}`,\n          );\n          const newValue = t.callExpression(\n            t.cloneNode(newFieldInitId),\n            params,\n          );\n\n          const newField = generateClassProperty(newId, newValue, isStatic);\n          const [newPath] = element.replaceWith(newField);\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(newId, version);\n\n            const getId = generateLetUidIdentifier(scopeParent, `get_${name}`);\n            const setId = generateLetUidIdentifier(scopeParent, `set_${name}`);\n\n            addCallAccessorsFor(version, newPath, key, getId, setId, isStatic);\n\n            locals = [newFieldInitId, getId, setId];\n          } else {\n            assignIdForAnonymousClass(path, className);\n            addProxyAccessorsFor(\n              path.node.id,\n              newPath,\n              t.cloneNode(key),\n              t.isAssignmentExpression(key)\n                ? t.cloneNode(key.left as t.Identifier)\n                : t.cloneNode(key),\n              newId,\n              isComputed,\n              isStatic,\n              version,\n            );\n            locals = [newFieldInitId];\n          }\n        } else if (kind === FIELD) {\n          const initId = generateLetUidIdentifier(scopeParent, `init_${name}`);\n          const valuePath = (\n            element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n          ).get(\"value\");\n\n          const args: t.Expression[] =\n            (process.env.BABEL_8_BREAKING || version === \"2023-11\") && isStatic\n              ? []\n              : [t.thisExpression()];\n          if (valuePath.node) args.push(valuePath.node);\n\n          valuePath.replaceWith(t.callExpression(t.cloneNode(initId), args));\n\n          locals = [initId];\n\n          if (isPrivate) {\n            privateMethods = extractProxyAccessorsFor(key, version);\n          }\n        } else if (isPrivate) {\n          const callId = generateLetUidIdentifier(scopeParent, `call_${name}`);\n          locals = [callId];\n\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element as NodePath<t.ClassPrivateMethod>,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          privateMethods = [\n            createFunctionExpressionFromPrivateMethod(\n              element.node as t.ClassPrivateMethod,\n            ),\n          ];\n\n          if (kind === GETTER || kind === SETTER) {\n            movePrivateAccessor(\n              element as NodePath<t.ClassPrivateMethod>,\n              t.cloneNode(key),\n              t.cloneNode(callId),\n              isStatic,\n            );\n          } else {\n            const node = element.node as t.ClassPrivateMethod;\n\n            // Unshift\n            path.node.body.body.unshift(\n              t.classPrivateProperty(key, t.cloneNode(callId), [], node.static),\n            );\n\n            decoratedPrivateMethods.add(key.id.name);\n\n            element.remove();\n          }\n        }\n\n        elementDecoratorInfo.push({\n          kind,\n          decoratorsArray,\n          decoratorsHaveThis,\n          name: nameExpr,\n          isStatic,\n          privateMethods,\n          locals,\n        });\n\n        if (element.node) {\n          element.node.decorators = null;\n        }\n      }\n\n      if (isComputed && computedKeyAssignments.length > 0) {\n        if (classDecorators && element.isClassProperty({ static: true })) {\n          // If the class is decorated, we don't insert computedKeyAssignments here\n          // because any non-static computed elements defined after it will be moved\n          // into the non-static class, so they will be evaluated before the key of\n          // this field. At this momemnt, its key must be either a constant expression\n          // or a uid reference which has been assigned _within_ the non-static class.\n        } else {\n          prependExpressionsToComputedKey(\n            computedKeyAssignments,\n            (kind === ACCESSOR\n              ? element.getNextSibling() // the transpiled getter of the accessor property\n              : element) as NodePath<ClassElementCanHaveComputedKeys>,\n          );\n          computedKeyAssignments = [];\n        }\n      }\n\n      if (\n        fieldInitializerExpressions.length > 0 &&\n        !isStatic &&\n        (kind === FIELD || kind === ACCESSOR)\n      ) {\n        prependExpressionsToFieldInitializer(\n          fieldInitializerExpressions,\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>,\n        );\n        fieldInitializerExpressions = [];\n      }\n\n      if (\n        staticFieldInitializerExpressions.length > 0 &&\n        isStatic &&\n        (kind === FIELD || kind === ACCESSOR)\n      ) {\n        prependExpressionsToFieldInitializer(\n          staticFieldInitializerExpressions,\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>,\n        );\n        staticFieldInitializerExpressions = [];\n      }\n\n      if (hasDecorators && version === \"2023-11\") {\n        if (kind === FIELD || kind === ACCESSOR) {\n          const initExtraId = generateLetUidIdentifier(\n            scopeParent,\n            `init_extra_${name}`,\n          );\n          locals.push(initExtraId);\n          const initExtraCall = t.callExpression(\n            t.cloneNode(initExtraId),\n            isStatic ? [] : [t.thisExpression()],\n          );\n          if (!isStatic) {\n            fieldInitializerExpressions.push(initExtraCall);\n          } else {\n            staticFieldInitializerExpressions.push(initExtraCall);\n          }\n        }\n      }\n    }\n  }\n\n  if (computedKeyAssignments.length > 0) {\n    const elements = path.get(\"body.body\");\n    let lastComputedElement: NodePath<ClassElementCanHaveComputedKeys>;\n    for (let i = elements.length - 1; i >= 0; i--) {\n      const path = elements[i];\n      const node = path.node as ClassElementCanHaveComputedKeys;\n      if (node.computed) {\n        if (classDecorators && t.isClassProperty(node, { static: true })) {\n          continue;\n        }\n        lastComputedElement = path as NodePath<ClassElementCanHaveComputedKeys>;\n        break;\n      }\n    }\n    if (lastComputedElement != null) {\n      appendExpressionsToComputedKey(\n        computedKeyAssignments,\n        lastComputedElement,\n      );\n      computedKeyAssignments = [];\n    } else {\n      // If there is no computed key, we will try to convert the first non-computed\n      // class element into a computed key and insert assignments there. This will\n      // be done after we handle the class elements split when the class is decorated.\n    }\n  }\n\n  if (fieldInitializerExpressions.length > 0) {\n    const isDerivedClass = !!path.node.superClass;\n    if (constructorPath) {\n      if (isDerivedClass) {\n        insertExpressionsAfterSuperCallAndOptimize(\n          fieldInitializerExpressions,\n          constructorPath,\n          protoInitLocal,\n        );\n      } else {\n        prependExpressionsToConstructor(\n          fieldInitializerExpressions,\n          constructorPath,\n        );\n      }\n    } else {\n      path.node.body.body.unshift(\n        createConstructorFromExpressions(\n          fieldInitializerExpressions,\n          isDerivedClass,\n        ),\n      );\n    }\n    fieldInitializerExpressions = [];\n  }\n\n  if (staticFieldInitializerExpressions.length > 0) {\n    path.node.body.body.push(\n      createStaticBlockFromExpressions(staticFieldInitializerExpressions),\n    );\n    staticFieldInitializerExpressions = [];\n  }\n\n  const sortedElementDecoratorInfo =\n    toSortedDecoratorInfo(elementDecoratorInfo);\n\n  const elementDecorations = generateDecorationExprs(\n    process.env.BABEL_8_BREAKING || version === \"2023-11\"\n      ? elementDecoratorInfo\n      : sortedElementDecoratorInfo,\n    version,\n  );\n\n  const elementLocals: t.Identifier[] = extractElementLocalAssignments(\n    sortedElementDecoratorInfo,\n  );\n\n  if (protoInitLocal) {\n    elementLocals.push(protoInitLocal);\n  }\n\n  if (staticInitLocal) {\n    elementLocals.push(staticInitLocal);\n  }\n\n  const classLocals: t.Identifier[] = [];\n  let classInitInjected = false;\n  const classInitCall =\n    classInitLocal && t.callExpression(t.cloneNode(classInitLocal), []);\n\n  let originalClassPath = path;\n  const originalClass = path.node;\n\n  const staticClosures: t.AssignmentExpression[] = [];\n  if (classDecorators) {\n    classLocals.push(classIdLocal, classInitLocal);\n    const statics: (\n      | t.ClassProperty\n      | t.ClassPrivateProperty\n      | t.ClassPrivateMethod\n    )[] = [];\n    path.get(\"body.body\").forEach(element => {\n      // Static blocks cannot be compiled to \"instance blocks\", but we can inline\n      // them as IIFEs in the next property.\n      if (element.isStaticBlock()) {\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const staticBlockClosureId = memoiseExpression(\n            staticBlockToFunctionClosure(element.node),\n            \"staticBlock\",\n            staticClosures,\n          );\n          staticFieldInitializerExpressions.push(\n            t.callExpression(\n              t.memberExpression(staticBlockClosureId, t.identifier(\"call\")),\n              [t.thisExpression()],\n            ),\n          );\n        } else {\n          staticFieldInitializerExpressions.push(\n            staticBlockToIIFE(element.node),\n          );\n        }\n        element.remove();\n        return;\n      }\n\n      if (\n        (element.isClassProperty() || element.isClassPrivateProperty()) &&\n        element.node.static\n      ) {\n        const valuePath = (\n          element as NodePath<t.ClassProperty | t.ClassPrivateProperty>\n        ).get(\"value\");\n        if (hasInstancePrivateAccess(valuePath, instancePrivateNames)) {\n          const fieldValueClosureId = memoiseExpression(\n            fieldInitializerToClosure(valuePath.node),\n            \"fieldValue\",\n            staticClosures,\n          );\n          valuePath.replaceWith(\n            t.callExpression(\n              t.memberExpression(fieldValueClosureId, t.identifier(\"call\")),\n              [t.thisExpression()],\n            ),\n          );\n        }\n        if (staticFieldInitializerExpressions.length > 0) {\n          prependExpressionsToFieldInitializer(\n            staticFieldInitializerExpressions,\n            element,\n          );\n          staticFieldInitializerExpressions = [];\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      } else if (element.isClassPrivateMethod({ static: true })) {\n        // At this moment the element must not have decorators, so any private name\n        // within the element must come from either params or body\n        if (hasInstancePrivateAccess(element, instancePrivateNames)) {\n          const replaceSupers = new ReplaceSupers({\n            constantSuper,\n            methodPath: element,\n            objectRef: classIdLocal,\n            superRef: path.node.superClass,\n            file: state.file,\n            refToPreserve: classIdLocal,\n          });\n\n          replaceSupers.replace();\n\n          const privateMethodDelegateId = memoiseExpression(\n            createFunctionExpressionFromPrivateMethod(element.node),\n            element.get(\"key.id\").node.name,\n            staticClosures,\n          );\n\n          if (ignoreFunctionLength) {\n            element.node.params = [t.restElement(t.identifier(\"arg\"))];\n            element.node.body = t.blockStatement([\n              t.returnStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    privateMethodDelegateId,\n                    t.identifier(\"apply\"),\n                  ),\n                  [t.thisExpression(), t.identifier(\"arg\")],\n                ),\n              ),\n            ]);\n          } else {\n            element.node.params = element.node.params.map((p, i) => {\n              if (t.isRestElement(p)) {\n                return t.restElement(t.identifier(\"arg\"));\n              } else {\n                return t.identifier(\"_\" + i);\n              }\n            });\n            element.node.body = t.blockStatement([\n              t.returnStatement(\n                t.callExpression(\n                  t.memberExpression(\n                    privateMethodDelegateId,\n                    t.identifier(\"apply\"),\n                  ),\n                  [t.thisExpression(), t.identifier(\"arguments\")],\n                ),\n              ),\n            ]);\n          }\n        }\n        element.node.static = false;\n        statics.push(element.node);\n        element.remove();\n      }\n    });\n\n    if (statics.length > 0 || staticFieldInitializerExpressions.length > 0) {\n      const staticsClass = template.expression.ast`\n        class extends ${state.addHelper(\"identity\")} {}\n      ` as t.ClassExpression;\n      staticsClass.body.body = [\n        // Insert the original class to a computed key of the wrapper so that\n        // 1) they share the same function context with the wrapper class\n        // 2) the memoisation of static computed field is evaluated before they\n        //    are referenced in the wrapper class keys\n        // Note that any static elements of the wrapper class can not be accessed\n        // in the user land, so we don't have to remove the temporary class field.\n        t.classProperty(\n          t.toExpression(originalClass),\n          undefined,\n          undefined,\n          undefined,\n          /* computed */ true,\n          /* static */ true,\n        ),\n        ...statics,\n      ];\n\n      const constructorBody: t.Expression[] = [];\n\n      const newExpr = t.newExpression(staticsClass, []);\n\n      if (staticFieldInitializerExpressions.length > 0) {\n        constructorBody.push(...staticFieldInitializerExpressions);\n      }\n      if (classInitCall) {\n        classInitInjected = true;\n        constructorBody.push(classInitCall);\n      }\n      if (constructorBody.length > 0) {\n        constructorBody.unshift(\n          t.callExpression(t.super(), [t.cloneNode(classIdLocal)]),\n        );\n\n        // set isDerivedClass to false as we have already prepended super call\n        staticsClass.body.body.push(\n          createConstructorFromExpressions(\n            constructorBody,\n            /* isDerivedClass */ false,\n          ),\n        );\n      } else {\n        newExpr.arguments.push(t.cloneNode(classIdLocal));\n      }\n\n      const [newPath] = path.replaceWith(newExpr);\n\n      // update originalClassPath according to the new AST\n      originalClassPath = (\n        newPath.get(\"callee\").get(\"body\") as NodePath<t.Class>\n      ).get(\"body.0.key\");\n    }\n  }\n  if (!classInitInjected && classInitCall) {\n    path.node.body.body.push(\n      t.staticBlock([t.expressionStatement(classInitCall)]),\n    );\n  }\n\n  let { superClass } = originalClass;\n  if (\n    superClass &&\n    (process.env.BABEL_8_BREAKING ||\n      version === \"2023-11\" ||\n      version === \"2023-05\")\n  ) {\n    const id = path.scope.maybeGenerateMemoised(superClass);\n    if (id) {\n      originalClass.superClass = t.assignmentExpression(\"=\", id, superClass);\n      superClass = id;\n    }\n  }\n\n  const applyDecoratorWrapper = t.staticBlock([]);\n  originalClass.body.body.unshift(applyDecoratorWrapper);\n  const applyDecsBody = applyDecoratorWrapper.body;\n  if (computedKeyAssignments.length > 0) {\n    const elements = originalClassPath.get(\"body.body\");\n    let firstPublicElement: NodePath<t.ClassProperty | t.ClassMethod>;\n    for (const path of elements) {\n      if (\n        (path.isClassProperty() || path.isClassMethod()) &&\n        (path.node as t.ClassMethod).kind !== \"constructor\"\n      ) {\n        firstPublicElement = path;\n        break;\n      }\n    }\n    if (firstPublicElement != null) {\n      // Convert its key to a computed one to host the decorator evaluations.\n      convertToComputedKey(firstPublicElement);\n      prependExpressionsToComputedKey(\n        computedKeyAssignments,\n        firstPublicElement,\n      );\n    } else {\n      // When there is no public class elements, we inject a temporary computed\n      // field whose key will host the decorator evaluations. The field will be\n      // deleted immediately after it is defiend.\n      originalClass.body.body.unshift(\n        t.classProperty(\n          t.sequenceExpression([\n            ...computedKeyAssignments,\n            t.stringLiteral(\"_\"),\n          ]),\n          undefined,\n          undefined,\n          undefined,\n          /* computed */ true,\n          /* static */ true,\n        ),\n      );\n      applyDecsBody.push(\n        t.expressionStatement(\n          t.unaryExpression(\n            \"delete\",\n            t.memberExpression(t.thisExpression(), t.identifier(\"_\")),\n          ),\n        ),\n      );\n    }\n    computedKeyAssignments = [];\n  }\n\n  applyDecsBody.push(\n    t.expressionStatement(\n      createLocalsAssignment(\n        elementLocals,\n        classLocals,\n        elementDecorations,\n        classDecorationsId ?? t.arrayExpression(classDecorations),\n        t.numericLiteral(classDecorationsFlag),\n        needsInstancePrivateBrandCheck ? lastInstancePrivateName : null,\n        setClassName,\n        t.cloneNode(superClass),\n        state,\n        version,\n      ),\n    ),\n  );\n  if (staticInitLocal) {\n    applyDecsBody.push(\n      t.expressionStatement(\n        t.callExpression(t.cloneNode(staticInitLocal), [t.thisExpression()]),\n      ),\n    );\n  }\n  if (staticClosures.length > 0) {\n    applyDecsBody.push(\n      ...staticClosures.map(expr => t.expressionStatement(expr)),\n    );\n  }\n\n  // When path is a ClassExpression, path.insertBefore will convert `path`\n  // into a SequenceExpression\n  path.insertBefore(classAssignments.map(expr => t.expressionStatement(expr)));\n\n  if (needsDeclaraionForClassBinding) {\n    const classBindingInfo = scopeParent.getBinding(classIdLocal.name);\n    if (!classBindingInfo.constantViolations.length) {\n      // optimization: reuse the inner class binding if the outer class binding is not mutated\n      path.insertBefore(\n        t.variableDeclaration(\"let\", [\n          t.variableDeclarator(t.cloneNode(classIdLocal)),\n        ]),\n      );\n    } else {\n      const classOuterBindingDelegateLocal = scopeParent.generateUidIdentifier(\n        \"t\" + classIdLocal.name,\n      );\n      const classOuterBindingLocal = classIdLocal;\n      path.replaceWithMultiple([\n        t.variableDeclaration(\"let\", [\n          t.variableDeclarator(t.cloneNode(classOuterBindingLocal)),\n          t.variableDeclarator(classOuterBindingDelegateLocal),\n        ]),\n        t.blockStatement([\n          t.variableDeclaration(\"let\", [\n            t.variableDeclarator(t.cloneNode(classIdLocal)),\n          ]),\n          // needsDeclaraionForClassBinding is true  node is a class declaration\n          path.node as t.ClassDeclaration,\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              t.cloneNode(classOuterBindingDelegateLocal),\n              t.cloneNode(classIdLocal),\n            ),\n          ),\n        ]),\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.cloneNode(classOuterBindingLocal),\n            t.cloneNode(classOuterBindingDelegateLocal),\n          ),\n        ),\n      ]);\n    }\n  }\n\n  if (decoratedPrivateMethods.size > 0) {\n    checkPrivateMethodUpdateError(path, decoratedPrivateMethods);\n  }\n\n  // Recrawl the scope to make sure new identifiers are properly synced\n  path.scope.crawl();\n\n  return path;\n}\n\nfunction createLocalsAssignment(\n  elementLocals: t.Identifier[],\n  classLocals: t.Identifier[],\n  elementDecorations: t.ArrayExpression | t.Identifier,\n  classDecorations: t.ArrayExpression | t.Identifier,\n  classDecorationsFlag: t.NumericLiteral,\n  maybePrivateBrandName: t.PrivateName | null,\n  setClassName: t.Identifier | t.StringLiteral | undefined,\n  superClass: null | t.Expression,\n  state: PluginPass,\n  version: DecoratorVersionKind,\n) {\n  let lhs, rhs;\n  const args: t.Expression[] = [\n    setClassName\n      ? createSetFunctionNameCall(state, setClassName)\n      : t.thisExpression(),\n    classDecorations,\n    elementDecorations,\n  ];\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (version !== \"2023-11\") {\n      args.splice(1, 2, elementDecorations, classDecorations);\n    }\n    if (\n      version === \"2021-12\" ||\n      (version === \"2022-03\" && !state.availableHelper(\"applyDecs2203R\"))\n    ) {\n      lhs = t.arrayPattern([...elementLocals, ...classLocals]);\n      rhs = t.callExpression(\n        state.addHelper(version === \"2021-12\" ? \"applyDecs\" : \"applyDecs2203\"),\n        args,\n      );\n      return t.assignmentExpression(\"=\", lhs, rhs);\n    } else if (version === \"2022-03\") {\n      rhs = t.callExpression(state.addHelper(\"applyDecs2203R\"), args);\n    } else if (version === \"2023-01\") {\n      if (maybePrivateBrandName) {\n        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n      }\n      rhs = t.callExpression(state.addHelper(\"applyDecs2301\"), args);\n    } else if (version === \"2023-05\") {\n      if (\n        maybePrivateBrandName ||\n        superClass ||\n        classDecorationsFlag.value !== 0\n      ) {\n        args.push(classDecorationsFlag);\n      }\n      if (maybePrivateBrandName) {\n        args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n      } else if (superClass) {\n        args.push(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      }\n      if (superClass) args.push(superClass);\n      rhs = t.callExpression(state.addHelper(\"applyDecs2305\"), args);\n    }\n  }\n  if (process.env.BABEL_8_BREAKING || version === \"2023-11\") {\n    if (\n      maybePrivateBrandName ||\n      superClass ||\n      classDecorationsFlag.value !== 0\n    ) {\n      args.push(classDecorationsFlag);\n    }\n    if (maybePrivateBrandName) {\n      args.push(createPrivateBrandCheckClosure(maybePrivateBrandName));\n    } else if (superClass) {\n      args.push(t.unaryExpression(\"void\", t.numericLiteral(0)));\n    }\n    if (superClass) args.push(superClass);\n    rhs = t.callExpression(state.addHelper(\"applyDecs2311\"), args);\n  }\n\n  // optimize `{ c: [classLocals] } = applyDecsHelper(...)` to\n  // `[classLocals] = applyDecsHelper(...).c`\n  if (elementLocals.length > 0) {\n    if (classLocals.length > 0) {\n      lhs = t.objectPattern([\n        t.objectProperty(t.identifier(\"e\"), t.arrayPattern(elementLocals)),\n        t.objectProperty(t.identifier(\"c\"), t.arrayPattern(classLocals)),\n      ]);\n    } else {\n      lhs = t.arrayPattern(elementLocals);\n      // @ts-ignore(Babel 7 vs Babel 8) optional removed in Babel 8\n      rhs = t.memberExpression(rhs, t.identifier(\"e\"), false, false);\n    }\n  } else {\n    // invariant: classLocals.length > 0\n    lhs = t.arrayPattern(classLocals);\n    // @ts-ignore(Babel 7 vs Babel 8) optional removed in Babel 8\n    rhs = t.memberExpression(rhs, t.identifier(\"c\"), false, false);\n  }\n\n  return t.assignmentExpression(\"=\", lhs, rhs);\n}\n\nfunction isProtoKey(\n  node: t.Identifier | t.StringLiteral | t.BigIntLiteral | t.NumericLiteral,\n) {\n  return node.type === \"Identifier\"\n    ? node.name === \"__proto__\"\n    : node.value === \"__proto__\";\n}\n\nfunction isDecorated(node: t.Class | ClassDecoratableElement) {\n  return node.decorators && node.decorators.length > 0;\n}\n\nfunction shouldTransformElement(node: ClassElement) {\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      return true;\n    case \"ClassMethod\":\n    case \"ClassProperty\":\n    case \"ClassPrivateMethod\":\n    case \"ClassPrivateProperty\":\n      return isDecorated(node);\n    default:\n      return false;\n  }\n}\n\nfunction shouldTransformClass(node: t.Class) {\n  return isDecorated(node) || node.body.body.some(shouldTransformElement);\n}\n\n// Todo: unify name references logic with helper-function-name\nfunction NamedEvaluationVisitoryFactory(\n  isAnonymous: (path: NodePath) => boolean,\n  visitor: (\n    path: NodePath,\n    state: PluginPass,\n    name:\n      | string\n      | t.Identifier\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral,\n  ) => void,\n) {\n  function handleComputedProperty(\n    propertyPath: NodePath<\n      t.ObjectProperty | t.ClassProperty | t.ClassAccessorProperty\n    >,\n    key: t.Expression,\n    state: PluginPass,\n  ): t.StringLiteral | t.Identifier {\n    switch (key.type) {\n      case \"StringLiteral\":\n        return t.stringLiteral(key.value);\n      case \"NumericLiteral\":\n      case \"BigIntLiteral\": {\n        const keyValue = key.value + \"\";\n        propertyPath.get(\"key\").replaceWith(t.stringLiteral(keyValue));\n        return t.stringLiteral(keyValue);\n      }\n      default: {\n        const ref = propertyPath.scope.maybeGenerateMemoised(key);\n        propertyPath\n          .get(\"key\")\n          .replaceWith(\n            t.assignmentExpression(\n              \"=\",\n              ref,\n              createToPropertyKeyCall(state, key),\n            ),\n          );\n        return t.cloneNode(ref);\n      }\n    }\n  }\n  return {\n    VariableDeclarator(path, state) {\n      const id = path.node.id;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"init\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    AssignmentExpression(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          switch (path.node.operator) {\n            case \"=\":\n            case \"&&=\":\n            case \"||=\":\n            case \"??=\":\n              visitor(initializer, state, id.name);\n          }\n        }\n      }\n    },\n    AssignmentPattern(path, state) {\n      const id = path.node.left;\n      if (id.type === \"Identifier\") {\n        const initializer = skipTransparentExprWrappers(path.get(\"right\"));\n        if (isAnonymous(initializer)) {\n          const name = id.name;\n          visitor(initializer, state, name);\n        }\n      }\n    },\n    // We listen on ObjectExpression so that we don't have to visit\n    // the object properties under object patterns\n    ObjectExpression(path, state) {\n      for (const propertyPath of path.get(\"properties\")) {\n        if (!propertyPath.isObjectProperty()) continue;\n        const { node } = propertyPath;\n        const id = node.key;\n        const initializer = skipTransparentExprWrappers(\n          propertyPath.get(\"value\") as NodePath<t.Expression>,\n        );\n        if (isAnonymous(initializer)) {\n          if (!node.computed) {\n            // 13.2.5.5 RS: PropertyDefinitionEvaluation\n            if (!isProtoKey(id as t.StringLiteral | t.Identifier)) {\n              if (id.type === \"Identifier\") {\n                visitor(initializer, state, id.name);\n              } else {\n                const className = t.stringLiteral(\n                  (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                    .value + \"\",\n                );\n                visitor(initializer, state, className);\n              }\n            }\n          } else {\n            const ref = handleComputedProperty(\n              propertyPath,\n              // The key of a computed object property must not be a private name\n              id as t.Expression,\n              state,\n            );\n            visitor(initializer, state, ref);\n          }\n        }\n      }\n    },\n    ClassPrivateProperty(path, state) {\n      const { node } = path;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        const className = t.stringLiteral(\"#\" + node.key.id.name);\n        visitor(initializer, state, className);\n      }\n    },\n    ClassAccessorProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else if (id.type === \"PrivateName\") {\n            const className = t.stringLiteral(\"#\" + id.id.name);\n            visitor(initializer, state, className);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(\n            path,\n            // The key of a computed accessor property must not be a private name\n            id as t.Expression,\n            state,\n          );\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n    ClassProperty(path, state) {\n      const { node } = path;\n      const id = node.key;\n      const initializer = skipTransparentExprWrappers(path.get(\"value\"));\n      if (isAnonymous(initializer)) {\n        if (!node.computed) {\n          if (id.type === \"Identifier\") {\n            visitor(initializer, state, id.name);\n          } else {\n            const className = t.stringLiteral(\n              (id as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n                .value + \"\",\n            );\n            visitor(initializer, state, className);\n          }\n        } else {\n          const ref = handleComputedProperty(path, id, state);\n          visitor(initializer, state, ref);\n        }\n      }\n    },\n  } satisfies Visitor<PluginPass>;\n}\n\nfunction isDecoratedAnonymousClassExpression(path: NodePath) {\n  return (\n    path.isClassExpression({ id: null }) && shouldTransformClass(path.node)\n  );\n}\n\nfunction generateLetUidIdentifier(scope: Scope, name: string) {\n  const id = scope.generateUidIdentifier(name);\n  scope.push({ id, kind: \"let\" });\n  return t.cloneNode(id);\n}\n\nexport default function (\n  { assertVersion, assumption }: PluginAPI,\n  { loose }: Options,\n  version: DecoratorVersionKind,\n  inherits: PluginObject[\"inherits\"],\n): PluginObject {\n  if (process.env.BABEL_8_BREAKING) {\n    assertVersion(REQUIRED_VERSION(\"^7.21.0\"));\n  } else {\n    if (\n      version === \"2023-11\" ||\n      version === \"2023-05\" ||\n      version === \"2023-01\"\n    ) {\n      assertVersion(REQUIRED_VERSION(\"^7.21.0\"));\n    } else if (version === \"2021-12\") {\n      assertVersion(REQUIRED_VERSION(\"^7.16.0\"));\n    } else {\n      assertVersion(REQUIRED_VERSION(\"^7.19.0\"));\n    }\n  }\n\n  const VISITED = new WeakSet<NodePath>();\n  const constantSuper = assumption(\"constantSuper\") ?? loose;\n  const ignoreFunctionLength = assumption(\"ignoreFunctionLength\") ?? loose;\n\n  const namedEvaluationVisitor: Visitor<PluginPass> =\n    NamedEvaluationVisitoryFactory(\n      isDecoratedAnonymousClassExpression,\n      visitClass,\n    );\n\n  function visitClass(\n    path: NodePath<t.Class>,\n    state: PluginPass,\n    className: string | t.Identifier | t.StringLiteral | undefined,\n  ) {\n    if (VISITED.has(path)) return;\n    const { node } = path;\n    className ??= node.id?.name;\n    const newPath = transformClass(\n      path,\n      state,\n      constantSuper,\n      ignoreFunctionLength,\n      className,\n      namedEvaluationVisitor,\n      version,\n    );\n    if (newPath) {\n      VISITED.add(newPath);\n      return;\n    }\n    VISITED.add(path);\n  }\n\n  return {\n    name: \"proposal-decorators\",\n    inherits: inherits,\n\n    visitor: {\n      ExportDefaultDeclaration(path, state) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          const isAnonymous = !declaration.id;\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.splitExportDeclaration ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n          }\n          const updatedVarDeclarationPath =\n            path.splitExportDeclaration() as NodePath<t.ClassDeclaration>;\n          if (isAnonymous) {\n            visitClass(\n              updatedVarDeclarationPath,\n              state,\n              t.stringLiteral(\"default\"),\n            );\n          }\n        }\n      },\n      ExportNamedDeclaration(path) {\n        const { declaration } = path.node;\n        if (\n          declaration?.type === \"ClassDeclaration\" &&\n          // When compiling class decorators we need to replace the class\n          // binding, so we must split it in two separate declarations.\n          isDecorated(declaration)\n        ) {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.splitExportDeclaration ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n          }\n          path.splitExportDeclaration();\n        }\n      },\n\n      Class(path, state) {\n        visitClass(path, state, undefined);\n      },\n\n      ...namedEvaluationVisitor,\n    },\n  };\n}\n"],"names":["_core","require","_helperReplaceSupers","_helperSkipTransparentExpressionWrappers","_fields","_misc","incrementId","id","idx","length","unshift","current","createPrivateUidGeneratorForClass","classPath","currentPrivateId","privateNames","Set","traverse","PrivateName","path","add","node","name","reifiedId","String","fromCharCode","has","t","privateName","identifier","createLazyPrivateUidGeneratorForClass","generator","replaceClassWithVar","className","scope","type","varId","generateUidIdentifierBasedOnNode","classId","rename","get","replaceWith","cloneNode","generateLetUidIdentifier","parent","newClassExpr","classExpression","superClass","body","newPath","sequenceExpression","generateClassProperty","key","value","isStatic","classPrivateProperty","undefined","classProperty","assignIdForAnonymousClass","generateUidIdentifier","addProxyAccessorsFor","element","getterKey","setterKey","targetKey","isComputed","version","thisArg","thisExpression","getterBody","blockStatement","returnStatement","memberExpression","setterBody","expressionStatement","assignmentExpression","getter","setter","classPrivateMethod","classMethod","insertAfter","extractProxyAccessorsFor","template","expression","ast","getComputedKeyLastElement","skipTransparentExprWrappers","isSequenceExpression","expressions","getComputedKeyMemoiser","isConstantExpression","isIdentifier","hasUid","isAssignmentExpression","left","Error","toString","prependExpressionsToComputedKey","fieldPath","push","maybeSequenceExpression","appendExpressionsToComputedKey","completion","scopeParent","maybeAssignment","memoiseComputedKey","generateUid","expressionSequence","completionParent","parentPath","pushContainer","prependExpressionsToFieldInitializer","initializer","unaryExpression","prependExpressionsToStaticBlock","blockPath","unshiftContainer","prependExpressionsToConstructor","constructorPath","isProtoInitCallExpression","protoInitCall","isCallExpression","callee","optimizeSuperCallAndExpressions","protoInitLocal","mergedSuperCall","callExpression","splice","isThisExpression","insertExpressionsAfterSuperCallAndOptimize","CallExpression","exit","isSuper","newNodes","map","expr","isCompletionRecord","skip","ClassMethod","kind","createConstructorFromExpressions","isDerivedClass","super","spreadElement","restElement","createStaticBlockFromExpressions","staticBlock","FIELD","ACCESSOR","METHOD","GETTER","SETTER","STATIC_OLD_VERSION","STATIC","DECORATORS_HAVE_THIS","getElementKind","toSortedDecoratorInfo","info","filter","el","generateDecorationList","decorators","decoratorsThis","decsCount","haveOneThis","some","Boolean","decs","i","numericLiteral","haveThis","generateDecorationExprs","decorationInfo","arrayExpression","flag","decoratorsHaveThis","decoratorsArray","privateMethods","extractElementLocalAssignments","localIds","locals","Array","isArray","addCallAccessorsFor","getId","setId","movePrivateAccessor","methodLocalVar","params","block","isClassDecoratableElementPath","staticBlockToIIFE","arrowFunctionExpression","staticBlockToFunctionClosure","functionExpression","fieldInitializerToClosure","exprs","createFunctionExpressionFromPrivateMethod","isGenerator","async","isAsync","createSetFunctionNameCall","state","addHelper","createToPropertyKeyCall","propertyKey","createPrivateBrandCheckClosure","brandName","binaryExpression","usesPrivateField","traverseFast","isPrivateName","_unused","convertToComputedKey","computed","stringLiteral","hasInstancePrivateAccess","containsInstancePrivateAccess","privateNameVisitor","privateNameVisitorFactory","privateNamesMap","stop","Map","set","checkPrivateMethodUpdateError","decoratedPrivateMethods","parentParentPath","buildCodeFrameError","transformClass","constantSuper","ignoreFunctionLength","propertyVisitor","_path$node$id","_classDecorationsId","classDecorators","hasElementDecorators","hasComputedKeysSideEffects","elemDecsUseFnContext","generateClassPrivateUid","classAssignments","memoiseExpression","hint","assignments","localEvaluatedId","staticInitLocal","classIdName","setClassName","usesFunctionContextOrYieldAwait","decorator","isYieldExpression","isAwaitExpression","isMetaProperty","meta","_unused2","instancePrivateNames","elementNode","static","isDecorated","ClassProperty","ClassPrivateProperty","ClassAccessorProperty","_staticInitLocal","_protoInitLocal","newId","newField","keyPath","elementDecoratorInfo","classInitLocal","classIdLocal","decoratorReceiverId","handleDecorators","hasSideEffects","usesFnContext","object","isMemberExpression","_decoratorReceiverId","willExtractSomeElemDecs","needsDeclaraionForClassBinding","classDecorationsFlag","classDecorations","classDecorationsId","computedKeyAssignments","isClassDeclaration","classDecsUsePrivateName","isClassProperty","lastInstancePrivateName","needsInstancePrivateBrandCheck","fieldInitializerExpressions","staticFieldInitializerExpressions","isStaticBlock","hasDecorators","isPrivate","isClassPrivateProperty","isClassMethod","nameExpr","newFieldInitId","newValue","initId","valuePath","args","callId","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","file","refToPreserve","replace","remove","getNextSibling","initExtraId","initExtraCall","elements","lastComputedElement","sortedElementDecoratorInfo","elementDecorations","elementLocals","classLocals","classInitInjected","classInitCall","originalClassPath","originalClass","staticClosures","statics","forEach","staticBlockClosureId","fieldValueClosureId","isClassPrivateMethod","privateMethodDelegateId","p","isRestElement","staticsClass","toExpression","constructorBody","newExpr","newExpression","arguments","maybeGenerateMemoised","applyDecoratorWrapper","applyDecsBody","firstPublicElement","createLocalsAssignment","insertBefore","classBindingInfo","getBinding","constantViolations","variableDeclaration","variableDeclarator","classOuterBindingDelegateLocal","classOuterBindingLocal","replaceWithMultiple","size","crawl","maybePrivateBrandName","lhs","rhs","availableHelper","arrayPattern","objectPattern","objectProperty","isProtoKey","shouldTransformElement","shouldTransformClass","NamedEvaluationVisitoryFactory","isAnonymous","visitor","handleComputedProperty","propertyPath","keyValue","ref","VariableDeclarator","AssignmentExpression","operator","AssignmentPattern","ObjectExpression","isObjectProperty","isDecoratedAnonymousClassExpression","isClassExpression","_default","assertVersion","assumption","loose","inherits","_assumption","_assumption2","VISITED","WeakSet","namedEvaluationVisitor","visitClass","_className","_node$id","Object","assign","ExportDefaultDeclaration","declaration","_path$splitExportDecl","splitExportDeclaration","NodePath","prototype","updatedVarDeclarationPath","ExportNamedDeclaration","_path$splitExportDecl2","Class"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2594, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2599, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/decorators-2018-09.ts"],"sourcesContent":["// TODO(Babel 8): Remove this file\n\nimport { types as t, template } from \"@babel/core\";\nimport type { File, NodePath } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\n\ntype Decoratable = Extract<t.Node, { decorators?: t.Decorator[] | null }>;\n\nexport function hasOwnDecorators(node: t.Class | t.ClassBody[\"body\"][number]) {\n  // @ts-expect-error: 'decorators' not in TSIndexSignature\n  return !!node.decorators?.length;\n}\n\nexport function hasDecorators(node: t.Class) {\n  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);\n}\n\nfunction prop(key: string, value?: t.Expression) {\n  if (!value) return null;\n  return t.objectProperty(t.identifier(key), value);\n}\n\nfunction method(key: string, body: t.Statement[]) {\n  return t.objectMethod(\n    \"method\",\n    t.identifier(key),\n    [],\n    t.blockStatement(body),\n  );\n}\n\nfunction takeDecorators(node: Decoratable) {\n  let result: t.ArrayExpression | undefined;\n  if (node.decorators && node.decorators.length > 0) {\n    result = t.arrayExpression(\n      node.decorators.map(decorator => decorator.expression),\n    );\n  }\n  node.decorators = undefined;\n  return result;\n}\n\ntype AcceptedElement = Exclude<ClassElement, t.TSIndexSignature>;\ntype SupportedElement = Exclude<\n  AcceptedElement,\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.ClassAccessorProperty\n  | t.StaticBlock\n>;\n\nfunction getKey(node: SupportedElement) {\n  if (node.computed) {\n    return node.key;\n  } else if (t.isIdentifier(node.key)) {\n    return t.stringLiteral(node.key.name);\n  } else {\n    return t.stringLiteral(\n      String(\n        // A non-identifier non-computed key\n        (node.key as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral)\n          .value,\n      ),\n    );\n  }\n}\n\nfunction extractElementDescriptor(\n  file: File,\n  classRef: t.Identifier,\n  superRef: t.Identifier,\n  path: NodePath<AcceptedElement>,\n) {\n  const isMethod = path.isClassMethod();\n  if (path.isPrivate()) {\n    throw path.buildCodeFrameError(\n      `Private ${\n        isMethod ? \"methods\" : \"fields\"\n      } in decorated classes are not supported yet.`,\n    );\n  }\n  if (path.node.type === \"ClassAccessorProperty\") {\n    throw path.buildCodeFrameError(\n      `Accessor properties are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`,\n    );\n  }\n  if (path.node.type === \"StaticBlock\") {\n    throw path.buildCodeFrameError(\n      `Static blocks are not supported in 2018-09 decorator transform, please specify { \"version\": \"2021-12\" } instead.`,\n    );\n  }\n\n  const { node, scope } = path as NodePath<SupportedElement>;\n\n  if (!path.isTSDeclareMethod()) {\n    new ReplaceSupers({\n      methodPath: path as NodePath<\n        Exclude<SupportedElement, t.TSDeclareMethod>\n      >,\n      objectRef: classRef,\n      superRef,\n      file,\n      refToPreserve: classRef,\n    }).replace();\n  }\n\n  const properties: t.ObjectExpression[\"properties\"] = [\n    prop(\"kind\", t.stringLiteral(t.isClassMethod(node) ? node.kind : \"field\")),\n    prop(\"decorators\", takeDecorators(node as Decoratable)),\n    prop(\"static\", node.static && t.booleanLiteral(true)),\n    prop(\"key\", getKey(node)),\n  ].filter(Boolean);\n\n  if (isMethod) {\n    if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n      // polyfill when being run by an older Babel version\n      path.ensureFunctionName ??=\n        // eslint-disable-next-line no-restricted-globals\n        require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n    }\n    // @ts-expect-error path is a ClassMethod, that technically\n    // is not supported as it does not have an .id property\n    // This plugin will however then transform the ClassMethod\n    // to a function expression, so it's fine.\n    path.ensureFunctionName(false);\n\n    properties.push(prop(\"value\", t.toExpression(path.node)));\n  } else if (t.isClassProperty(node) && node.value) {\n    properties.push(\n      method(\"value\", template.statements.ast`return ${node.value}`),\n    );\n  } else {\n    properties.push(prop(\"value\", scope.buildUndefinedNode()));\n  }\n\n  path.remove();\n\n  return t.objectExpression(properties);\n}\n\nfunction addDecorateHelper(file: File) {\n  return file.addHelper(\"decorate\");\n}\n\ntype ClassElement = t.Class[\"body\"][\"body\"][number];\ntype ClassElementPath = NodePath<ClassElement>;\n\nexport function buildDecoratedClass(\n  ref: t.Identifier,\n  path: NodePath<t.Class>,\n  elements: ClassElementPath[],\n  file: File,\n) {\n  const { node, scope } = path;\n  const initializeId = scope.generateUidIdentifier(\"initialize\");\n  const isDeclaration = node.id && path.isDeclaration();\n  const isStrict = path.isInStrictMode();\n  const { superClass } = node;\n\n  node.type = \"ClassDeclaration\";\n  if (!node.id) node.id = t.cloneNode(ref);\n\n  let superId: t.Identifier;\n  if (superClass) {\n    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, \"super\");\n    node.superClass = superId;\n  }\n\n  const classDecorators = takeDecorators(node);\n  const definitions = t.arrayExpression(\n    elements\n      .filter(\n        element =>\n          // @ts-expect-error Ignore TypeScript's abstract methods (see #10514)\n          !element.node.abstract && element.node.type !== \"TSIndexSignature\",\n      )\n      .map(path =>\n        extractElementDescriptor(\n          file,\n          node.id,\n          superId,\n          // @ts-expect-error TS can not exclude TSIndexSignature\n          path,\n        ),\n      ),\n  );\n\n  const wrapperCall = template.expression.ast`\n    ${addDecorateHelper(file)}(\n      ${classDecorators || t.nullLiteral()},\n      function (${initializeId}, ${superClass ? t.cloneNode(superId) : null}) {\n        ${node}\n        return { F: ${t.cloneNode(node.id)}, d: ${definitions} };\n      },\n      ${superClass}\n    )\n  ` as t.CallExpression & { arguments: [unknown, t.FunctionExpression] };\n\n  if (!isStrict) {\n    wrapperCall.arguments[1].body.directives.push(\n      t.directive(t.directiveLiteral(\"use strict\")),\n    );\n  }\n\n  let replacement: t.Node = wrapperCall;\n  let classPathDesc = \"arguments.1.body.body.0\";\n  if (isDeclaration) {\n    replacement = template.statement.ast`let ${ref} = ${wrapperCall}`;\n    classPathDesc = \"declarations.0.init.\" + classPathDesc;\n  }\n\n  return {\n    instanceNodes: [\n      template.statement.ast`\n        ${t.cloneNode(initializeId)}(this)\n      ` as t.ExpressionStatement,\n    ],\n    wrapClass(path: NodePath<t.Class>) {\n      path.replaceWith(replacement);\n      return path.get(classPathDesc) as NodePath;\n    },\n  };\n}\n"],"names":["_core","require","_helperReplaceSupers","hasOwnDecorators","node","_node$decorators","decorators","length","hasDecorators","body","some","prop","key","value","t","objectProperty","identifier","method","objectMethod","blockStatement","takeDecorators","result","arrayExpression","map","decorator","expression","undefined","getKey","computed","isIdentifier","stringLiteral","name","String","extractElementDescriptor","file","classRef","superRef","path","isMethod","isClassMethod","isPrivate","buildCodeFrameError","type","scope","isTSDeclareMethod","ReplaceSupers","methodPath","objectRef","refToPreserve","replace","properties","kind","static","booleanLiteral","filter","Boolean","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","push","toExpression","isClassProperty","template","statements","ast","buildUndefinedNode","remove","objectExpression","addDecorateHelper","addHelper","buildDecoratedClass","ref","elements","initializeId","generateUidIdentifier","isDeclaration","id","isStrict","isInStrictMode","superClass","cloneNode","superId","generateUidIdentifierBasedOnNode","classDecorators","definitions","element","abstract","wrapperCall","nullLiteral","arguments","directives","directive","directiveLiteral","replacement","classPathDesc","statement","instanceNodes","wrapClass","replaceWith","get"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2735, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/features.ts"],"sourcesContent":["import type { File, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/core\";\nimport { hasOwnDecorators } from \"./decorators-2018-09.ts\";\n\nexport const FEATURES = Object.freeze({\n  //classes: 1 << 0,\n  fields: 1 << 1,\n  privateMethods: 1 << 2,\n  decorators: 1 << 3,\n  privateIn: 1 << 4,\n  staticBlocks: 1 << 5,\n});\n\nconst featuresSameLoose = new Map([\n  [FEATURES.fields, \"@babel/plugin-transform-class-properties\"],\n  [FEATURES.privateMethods, \"@babel/plugin-transform-private-methods\"],\n  [FEATURES.privateIn, \"@babel/plugin-transform-private-property-in-object\"],\n]);\n\n// We can't use a symbol because this needs to always be the same, even if\n// this package isn't deduped by npm. e.g.\n//  - node_modules/\n//    - @babel/plugin-class-features\n//    - @babel/plugin-proposal-decorators\n//      - node_modules\n//        - @babel-plugin-class-features\nconst featuresKey = \"@babel/plugin-class-features/featuresKey\";\nconst looseKey = \"@babel/plugin-class-features/looseKey\";\n\nif (!process.env.BABEL_8_BREAKING) {\n  // See https://github.com/babel/babel/issues/11622.\n  // Since preset-env sets loose for the fields and private methods plugins, it can\n  // cause conflicts with the loose mode set by an explicit plugin in the config.\n  // To solve this problem, we ignore preset-env's loose mode if another plugin\n  // explicitly sets it\n  // The code to handle this logic doesn't check that \"low priority loose\" is always\n  // the same. However, it is only set by the preset and not directly by users:\n  // unless someone _wants_ to break it, it shouldn't be a problem.\n  // eslint-disable-next-line no-var\n  var looseLowPriorityKey =\n    \"@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing\";\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var canIgnoreLoose = function (file: File, feature: number) {\n    return !!(file.get(looseLowPriorityKey) & feature);\n  };\n}\n\nexport function enableFeature(file: File, feature: number, loose: boolean) {\n  // We can't blindly enable the feature because, if it was already set,\n  // \"loose\" can't be changed, so that\n  //   @babel/plugin-class-properties { loose: true }\n  //   @babel/plugin-class-properties { loose: false }\n  // is transformed in loose mode.\n  // We only enabled the feature if it was previously disabled.\n  if (process.env.BABEL_8_BREAKING) {\n    if (!hasFeature(file, feature)) {\n      file.set(featuresKey, file.get(featuresKey) | feature);\n      setLoose(file, feature, loose);\n    }\n  } else if (!hasFeature(file, feature) || canIgnoreLoose(file, feature)) {\n    file.set(featuresKey, file.get(featuresKey) | feature);\n    if (\n      // @ts-expect-error comparing loose with internal private magic string\n      loose ===\n      \"#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error\"\n    ) {\n      setLoose(file, feature, true);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else if (\n      // @ts-expect-error comparing loose with internal private magic string\n      loose ===\n      \"#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error\"\n    ) {\n      setLoose(file, feature, false);\n      file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);\n    } else {\n      setLoose(file, feature, loose);\n    }\n  }\n\n  let resolvedLoose: boolean | undefined;\n  for (const [mask, name] of featuresSameLoose) {\n    if (!hasFeature(file, mask)) continue;\n    if (!process.env.BABEL_8_BREAKING) {\n      if (canIgnoreLoose(file, mask)) continue;\n    }\n\n    const loose = isLoose(file, mask);\n\n    if (resolvedLoose === !loose) {\n      throw new Error(\n        \"'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, \" +\n          \"@babel/plugin-transform-private-methods and \" +\n          \"@babel/plugin-transform-private-property-in-object (when they are enabled).\" +\n          \"\\n\\n\" +\n          getBabelShowConfigForHint(file),\n      );\n    } else {\n      resolvedLoose = loose;\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // eslint-disable-next-line no-var\n        var higherPriorityPluginName = name;\n      }\n    }\n  }\n\n  if (!process.env.BABEL_8_BREAKING && resolvedLoose !== undefined) {\n    for (const [mask, name] of featuresSameLoose) {\n      if (hasFeature(file, mask) && isLoose(file, mask) !== resolvedLoose) {\n        setLoose(file, mask, resolvedLoose);\n        console.warn(\n          `Though the \"loose\" option was set to \"${!resolvedLoose}\" in your @babel/preset-env ` +\n            `config, it will not be used for ${name} since the \"loose\" mode option was set to ` +\n            `\"${resolvedLoose}\" for ${higherPriorityPluginName}.\\nThe \"loose\" option must be the ` +\n            `same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods ` +\n            `and @babel/plugin-transform-private-property-in-object (when they are enabled): you can ` +\n            `silence this warning by explicitly adding\\n` +\n            `\\t[\"${name}\", { \"loose\": ${resolvedLoose} }]\\n` +\n            `to the \"plugins\" section of your Babel config.` +\n            \"\\n\\n\" +\n            getBabelShowConfigForHint(file),\n        );\n      }\n    }\n  }\n}\n\nfunction getBabelShowConfigForHint(file: File) {\n  let { filename } = file.opts;\n  if (!filename || filename === \"unknown\") {\n    filename = \"[name of the input file]\";\n  }\n  return `\\\nIf you already set the same 'loose' mode for these plugins in your config, it's possible that they \\\nare enabled multiple times with different options.\nYou can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded \\\nconfiguration:\n\\tnpx cross-env BABEL_SHOW_CONFIG_FOR=${filename} <your build command>\nSee https://babeljs.io/docs/configuration#print-effective-configs for more info.`;\n}\n\nfunction hasFeature(file: File, feature: number) {\n  return !!(file.get(featuresKey) & feature);\n}\n\nexport function isLoose(file: File, feature: number) {\n  return !!(file.get(looseKey) & feature);\n}\n\nfunction setLoose(file: File, feature: number, loose: boolean) {\n  if (loose) file.set(looseKey, file.get(looseKey) | feature);\n  else file.set(looseKey, file.get(looseKey) & ~feature);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);\n  }\n}\n\nexport function shouldTransform(path: NodePath<t.Class>, file: File): boolean {\n  let decoratorPath: NodePath<t.Decorator> | null = null;\n  let publicFieldPath: NodePath<t.ClassProperty> | null = null;\n  let privateFieldPath: NodePath<t.ClassPrivateProperty> | null = null;\n  let privateMethodPath: NodePath<t.ClassPrivateMethod> | null = null;\n  let staticBlockPath: NodePath<t.StaticBlock> | null = null;\n\n  if (hasOwnDecorators(path.node)) {\n    decoratorPath = path.get(\"decorators.0\");\n  }\n  for (const el of path.get(\"body.body\")) {\n    if (!decoratorPath && hasOwnDecorators(el.node)) {\n      decoratorPath = el.get(\"decorators.0\");\n    }\n    if (!publicFieldPath && el.isClassProperty()) {\n      publicFieldPath = el;\n    }\n    if (!privateFieldPath && el.isClassPrivateProperty()) {\n      privateFieldPath = el;\n    }\n    // NOTE: path.isClassPrivateMethod() it isn't supported in <7.2.0\n    if (!privateMethodPath && el.isClassPrivateMethod?.()) {\n      privateMethodPath = el;\n    }\n    if (!staticBlockPath && el.isStaticBlock?.()) {\n      staticBlockPath = el;\n    }\n  }\n\n  if (decoratorPath && privateFieldPath) {\n    throw privateFieldPath.buildCodeFrameError(\n      \"Private fields in decorated classes are not supported yet.\",\n    );\n  }\n  if (decoratorPath && privateMethodPath) {\n    throw privateMethodPath.buildCodeFrameError(\n      \"Private methods in decorated classes are not supported yet.\",\n    );\n  }\n\n  if (decoratorPath && !hasFeature(file, FEATURES.decorators)) {\n    throw path.buildCodeFrameError(\n      \"Decorators are not enabled.\" +\n        \"\\nIf you are using \" +\n        '[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }], ' +\n        'make sure it comes *before* \"@babel/plugin-transform-class-properties\" ' +\n        \"and enable loose mode, like so:\\n\" +\n        '\\t[\"@babel/plugin-proposal-decorators\", { \"version\": \"legacy\" }]\\n' +\n        '\\t[\"@babel/plugin-transform-class-properties\", { \"loose\": true }]',\n    );\n  }\n\n  if (privateMethodPath && !hasFeature(file, FEATURES.privateMethods)) {\n    throw privateMethodPath.buildCodeFrameError(\n      \"Class private methods are not enabled. \" +\n        \"Please add `@babel/plugin-transform-private-methods` to your configuration.\",\n    );\n  }\n\n  if (\n    (publicFieldPath || privateFieldPath) &&\n    !hasFeature(file, FEATURES.fields) &&\n    // We want to allow enabling the private-methods plugin even without enabling\n    // the class-properties plugin. Class fields will still be compiled in classes\n    // that contain private methods.\n    // This is already allowed with the other various class features plugins, but\n    // it's because they can fallback to a transform separated from this helper.\n    !hasFeature(file, FEATURES.privateMethods)\n  ) {\n    throw path.buildCodeFrameError(\n      \"Class fields are not enabled. \" +\n        \"Please add `@babel/plugin-transform-class-properties` to your configuration.\",\n    );\n  }\n\n  if (staticBlockPath && !hasFeature(file, FEATURES.staticBlocks)) {\n    throw path.buildCodeFrameError(\n      \"Static class blocks are not enabled. \" +\n        \"Please add `@babel/plugin-transform-class-static-block` to your configuration.\",\n    );\n  }\n\n  if (decoratorPath || privateMethodPath || staticBlockPath) {\n    // If one of those feature is used we know that its transform is\n    // enabled, otherwise the previous checks throw.\n    return true;\n  }\n  if (\n    (publicFieldPath || privateFieldPath) &&\n    hasFeature(file, FEATURES.fields)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"],"names":["_decorators","require","FEATURES","exports","Object","freeze","fields","privateMethods","decorators","privateIn","staticBlocks","featuresSameLoose","Map","featuresKey","looseKey","looseLowPriorityKey","canIgnoreLoose","file","feature","get","enableFeature","loose","hasFeature","set","setLoose","resolvedLoose","mask","name","isLoose","Error","getBabelShowConfigForHint","higherPriorityPluginName","undefined","console","warn","filename","opts","shouldTransform","path","decoratorPath","publicFieldPath","privateFieldPath","privateMethodPath","staticBlockPath","hasOwnDecorators","node","el","isClassProperty","isClassPrivateProperty","isClassPrivateMethod","isStaticBlock","buildCodeFrameError"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2894, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/helper-create-class-features-plugin/src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginAPI, PluginObject, NodePath } from \"@babel/core\";\nimport createDecoratorTransform from \"./decorators.ts\";\nimport type { DecoratorVersionKind } from \"./decorators.ts\";\n\nimport semver from \"semver\";\n\nimport {\n  buildPrivateNamesNodes,\n  buildPrivateNamesMap,\n  transformPrivateNamesUsage,\n  buildFieldsInitNodes,\n  buildCheckInRHS,\n} from \"./fields.ts\";\nimport type { PropPath } from \"./fields.ts\";\nimport { buildDecoratedClass, hasDecorators } from \"./decorators-2018-09.ts\";\nimport { injectInitialization, extractComputedKeys } from \"./misc.ts\";\nimport {\n  enableFeature,\n  FEATURES,\n  isLoose,\n  shouldTransform,\n} from \"./features.ts\";\nimport { assertFieldTransformed } from \"./typescript.ts\";\n\nexport { FEATURES, enableFeature, injectInitialization, buildCheckInRHS };\n\nconst versionKey = \"@babel/plugin-class-features/version\";\n\ninterface Options {\n  name: string;\n  feature: number;\n  loose?: boolean;\n  inherits?: PluginObject[\"inherits\"];\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n  api?: PluginAPI;\n  decoratorVersion?: DecoratorVersionKind | \"2018-09\";\n}\n\nexport function createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  api,\n  inherits,\n  decoratorVersion,\n}: Options): PluginObject {\n  if (feature & FEATURES.decorators) {\n    if (process.env.BABEL_8_BREAKING) {\n      return createDecoratorTransform(api, { loose }, \"2023-11\", inherits);\n    } else {\n      if (\n        decoratorVersion === \"2023-11\" ||\n        decoratorVersion === \"2023-05\" ||\n        decoratorVersion === \"2023-01\" ||\n        decoratorVersion === \"2022-03\" ||\n        decoratorVersion === \"2021-12\"\n      ) {\n        return createDecoratorTransform(\n          api,\n          { loose },\n          decoratorVersion,\n          inherits,\n        );\n      }\n    }\n  }\n  if (!process.env.BABEL_8_BREAKING) {\n    api ??= { assumption: () => void 0 as any } as any;\n  }\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsSymbols = api.assumption(\"privateFieldsAsSymbols\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const noUninitializedPrivateFieldAccess =\n    api.assumption(\"noUninitializedPrivateFieldAccess\") ?? false;\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (privateFieldsAsProperties && privateFieldsAsSymbols) {\n    throw new Error(\n      `Cannot enable both the \"privateFieldsAsProperties\" and ` +\n        `\"privateFieldsAsSymbols\" assumptions as the same time.`,\n    );\n  }\n  const privateFieldsAsSymbolsOrProperties =\n    privateFieldsAsProperties || privateFieldsAsSymbols;\n\n  if (loose === true) {\n    type AssumptionName = Parameters<PluginAPI[\"assumption\"]>[0];\n    const explicit: `\"${AssumptionName}\"`[] = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (privateFieldsAsSymbols !== undefined) {\n      explicit.push(`\"privateFieldsAsSymbols\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(\n        `[${name}]: You are using the \"loose: true\" option and you are` +\n          ` explicitly setting a value for the ${explicit.join(\" and \")}` +\n          ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` +\n          ` can cause incompatibilities with the other class features` +\n          ` plugins, so it's recommended that you replace it with the` +\n          ` following top-level option:\\n` +\n          `\\t\"assumptions\": {\\n` +\n          `\\t\\t\"setPublicClassFields\": true,\\n` +\n          `\\t\\t\"privateFieldsAsSymbols\": true\\n` +\n          `\\t}`,\n      );\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      enableFeature(file, feature, loose);\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // Until 7.21.4, we used to encode the version as a number.\n        // If file.get(versionKey) is a number, it has thus been\n        // set by an older version of this plugin.\n        if (typeof file.get(versionKey) === \"number\") {\n          file.set(versionKey, PACKAGE_JSON.version);\n          return;\n        }\n      }\n      if (\n        !file.get(versionKey) ||\n        semver.lt(file.get(versionKey), PACKAGE_JSON.version)\n      ) {\n        file.set(versionKey, PACKAGE_JSON.version);\n      }\n    },\n\n    visitor: {\n      Class(path, { file }) {\n        if (file.get(versionKey) !== PACKAGE_JSON.version) return;\n\n        if (!shouldTransform(path, file)) return;\n\n        const pathIsClassDeclaration = path.isClassDeclaration();\n\n        if (pathIsClassDeclaration) assertFieldTransformed(path);\n\n        const loose = isLoose(file, feature);\n\n        let constructor: NodePath<t.ClassMethod>;\n        const isDecorated = hasDecorators(path.node);\n        const props: PropPath[] = [];\n        const elements = [];\n        const computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[] = [];\n        const privateNames = new Set<string>();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if (\n            // check path.node.computed is enough, but ts will complain\n            (path.isClassProperty() || path.isClassMethod()) &&\n            path.node.computed\n          ) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const { name } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (\n                  privateNames.has(getName) ||\n                  (privateNames.has(name) && !privateNames.has(setName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (\n                  privateNames.has(setName) ||\n                  (privateNames.has(name) && !privateNames.has(getName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (\n                (privateNames.has(name) &&\n                  !privateNames.has(getName) &&\n                  !privateNames.has(setName)) ||\n                (privateNames.has(name) &&\n                  (privateNames.has(getName) || privateNames.has(setName)))\n              ) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({ kind: \"constructor\" })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (\n              path.isProperty() ||\n              path.isPrivate() ||\n              path.isStaticBlock?.()\n            ) {\n              props.push(path as PropPath);\n            }\n          }\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (!props.length) return;\n        } else {\n          if (!props.length && !isDecorated) return;\n        }\n\n        const innerBinding = path.node.id;\n        let ref: t.Identifier | null;\n        if (!innerBinding || !pathIsClassDeclaration) {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.ensureFunctionName ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          }\n          (path as NodePath<t.ClassExpression>).ensureFunctionName(false);\n          ref = path.scope.generateUidIdentifier(innerBinding?.name || \"Class\");\n        }\n        const classRefForDefine = ref ?? t.cloneNode(innerBinding);\n\n        const privateNamesMap = buildPrivateNamesMap(\n          classRefForDefine.name,\n          privateFieldsAsSymbolsOrProperties ?? loose,\n          props,\n          file,\n        );\n        const privateNamesNodes = buildPrivateNamesNodes(\n          privateNamesMap,\n          privateFieldsAsProperties ?? loose,\n          privateFieldsAsSymbols ?? false,\n          file,\n        );\n\n        transformPrivateNamesUsage(\n          classRefForDefine,\n          path,\n          privateNamesMap,\n          {\n            privateFieldsAsProperties:\n              privateFieldsAsSymbolsOrProperties ?? loose,\n            noUninitializedPrivateFieldAccess,\n            noDocumentAll,\n            innerBinding,\n          },\n          file,\n        );\n\n        let keysNodes: t.Statement[],\n          staticNodes: t.Statement[],\n          instanceNodes: t.ExpressionStatement[],\n          lastInstanceNodeReturnsThis: boolean,\n          pureStaticNodes: t.FunctionDeclaration[],\n          classBindingNode: t.Statement | null,\n          wrapClass: (path: NodePath<t.Class>) => NodePath;\n\n        if (!process.env.BABEL_8_BREAKING) {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({ instanceNodes, wrapClass } = buildDecoratedClass(\n              classRefForDefine,\n              path,\n              elements,\n              file,\n            ));\n          } else {\n            keysNodes = extractComputedKeys(path, computedPaths, file);\n            ({\n              staticNodes,\n              pureStaticNodes,\n              instanceNodes,\n              lastInstanceNodeReturnsThis,\n              classBindingNode,\n              wrapClass,\n            } = buildFieldsInitNodes(\n              ref,\n              path.node.superClass,\n              props,\n              privateNamesMap,\n              file,\n              setPublicClassFields ?? loose,\n              privateFieldsAsSymbolsOrProperties ?? loose,\n              noUninitializedPrivateFieldAccess,\n              constantSuper ?? loose,\n              innerBinding,\n            ));\n          }\n        } else {\n          keysNodes = extractComputedKeys(path, computedPaths, file);\n          ({\n            staticNodes,\n            pureStaticNodes,\n            instanceNodes,\n            lastInstanceNodeReturnsThis,\n            classBindingNode,\n            wrapClass,\n          } = buildFieldsInitNodes(\n            ref,\n            path.node.superClass,\n            props,\n            privateNamesMap,\n            file,\n            setPublicClassFields ?? loose,\n            privateFieldsAsSymbolsOrProperties ?? loose,\n            noUninitializedPrivateFieldAccess,\n            constantSuper ?? loose,\n            innerBinding,\n          ));\n        }\n\n        if (instanceNodes.length > 0) {\n          injectInitialization(\n            path,\n            constructor,\n            instanceNodes,\n            (referenceVisitor, state) => {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (isDecorated) return;\n              }\n              for (const prop of props) {\n                // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n                if (t.isStaticBlock?.(prop.node) || prop.node.static) continue;\n                prop.traverse(referenceVisitor, state);\n              }\n            },\n            lastInstanceNodeReturnsThis,\n          );\n        }\n\n        // rename to make ts happy\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath\n            .find(parent => parent.isStatement() || parent.isDeclaration())\n            .insertAfter(pureStaticNodes);\n        }\n        if (classBindingNode != null && pathIsClassDeclaration) {\n          wrappedPath.insertAfter(classBindingNode);\n        }\n      },\n\n      ExportDefaultDeclaration(path, { file }) {\n        if (!process.env.BABEL_8_BREAKING) {\n          if (file.get(versionKey) !== PACKAGE_JSON.version) return;\n\n          const decl = path.get(\"declaration\");\n\n          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {\n            if (decl.node.id) {\n              // export default class Foo {}\n              //   -->\n              // class Foo {} export { Foo as default }\n              if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n                // polyfill when being run by an older Babel version\n                path.splitExportDeclaration ??=\n                  // eslint-disable-next-line no-restricted-globals\n                  require(\"@babel/traverse\").NodePath.prototype.splitExportDeclaration;\n              }\n              path.splitExportDeclaration();\n            } else {\n              // @ts-expect-error Anonymous class declarations can be\n              // transformed as if they were expressions\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      },\n    },\n  };\n}\n"],"names":["_core","require","_decorators","_semver","_fields","_decorators2","_misc","_features","_typescript","versionKey","createClassFeaturePlugin","name","feature","loose","manipulateOptions","api","inherits","decoratorVersion","_api$assumption","FEATURES","decorators","createDecoratorTransform","_api","assumption","setPublicClassFields","privateFieldsAsSymbols","privateFieldsAsProperties","noUninitializedPrivateFieldAccess","constantSuper","noDocumentAll","Error","privateFieldsAsSymbolsOrProperties","explicit","undefined","push","length","console","warn","join","pre","file","enableFeature","get","set","semver","lt","visitor","Class","path","_ref","shouldTransform","pathIsClassDeclaration","isClassDeclaration","assertFieldTransformed","isLoose","constructor","isDecorated","hasDecorators","node","props","elements","computedPaths","privateNames","Set","body","isClassProperty","isClassMethod","computed","isPrivate","key","id","getName","setName","isClassPrivateMethod","kind","has","buildCodeFrameError","add","isProperty","isStaticBlock","innerBinding","ref","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","scope","generateUidIdentifier","classRefForDefine","t","cloneNode","privateNamesMap","buildPrivateNamesMap","privateNamesNodes","buildPrivateNamesNodes","transformPrivateNamesUsage","keysNodes","staticNodes","instanceNodes","lastInstanceNodeReturnsThis","pureStaticNodes","classBindingNode","wrapClass","buildDecoratedClass","extractComputedKeys","buildFieldsInitNodes","superClass","injectInitialization","referenceVisitor","state","prop","static","traverse","wrappedPath","insertBefore","insertAfter","find","parent","isStatement","isDeclaration","ExportDefaultDeclaration","decl","_path$splitExportDecl","splitExportDeclaration","type"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AAEA,IAAAC,WAAA,GAAAD,OAAA;AAGA,IAAAE,OAAA,GAAAF,OAAA;AAEA,IAAAG,OAAA,GAAAH,OAAA;AAQA,IAAAI,YAAA,GAAAJ,OAAA;AACA,IAAAK,KAAA,GAAAL,OAAA;AACA,IAAAM,SAAA,GAAAN,OAAA;AAMA,IAAAO,WAAA,GAAAP,OAAA;AAIA,MAAMQ,UAAU,GAAG,sCAAsC;AAYlD,SAASC,wBAAwBA,CAAC,EACvCC,IAAI,EACJC,OAAO,EACPC,KAAK,EACLC,iBAAiB,EACjBC,GAAG,EACHC,QAAQ,EACRC,gBAAAA,EACQ,EAAgB;IAAA,IAAAC,eAAA;IACxB,IAAIN,OAAO,GAAGO,UAAAA,QAAQ,CAACC,UAAU,EAAE;QAG1B;YACL,IACEH,gBAAgB,KAAK,SAAS,IAC9BA,gBAAgB,KAAK,SAAS,IAC9BA,gBAAgB,KAAK,SAAS,IAC9BA,gBAAgB,KAAK,SAAS,IAC9BA,gBAAgB,KAAK,SAAS,EAC9B;gBACA,OAAO,CAAA,GAAAI,YAAAA,OAAwB,EAC7BN,GAAG,EACH;oBAAEF;gBAAM,CAAC,EACTI,gBAAgB,EAChBD,QACF,CAAC;YACH;QACF;IACF;IACmC;QAAA,IAAAM,IAAA;QACjC,CAAAA,IAAA,GAAAP,GAAG,KAAA,OAAAO,IAAA,GAAHP,GAAG,GAAK;YAAEQ,UAAU,EAAEA,CAAA,GAAM,KAAK;QAAS,CAAC;IAC7C;IACA,MAAMC,oBAAoB,GAAGT,GAAG,CAACQ,UAAU,CAAC,sBAAsB,CAAC;IACnE,MAAME,sBAAsB,GAAGV,GAAG,CAACQ,UAAU,CAAC,wBAAwB,CAAC;IACvE,MAAMG,yBAAyB,GAAGX,GAAG,CAACQ,UAAU,CAAC,2BAA2B,CAAC;IAC7E,MAAMI,iCAAiC,GAAA,CAAAT,eAAA,GACrCH,GAAG,CAACQ,UAAU,CAAC,mCAAmC,CAAC,KAAA,OAAAL,eAAA,GAAI,KAAK;IAC9D,MAAMU,aAAa,GAAGb,GAAG,CAACQ,UAAU,CAAC,eAAe,CAAC;IACrD,MAAMM,aAAa,GAAGd,GAAG,CAACQ,UAAU,CAAC,eAAe,CAAC;IAErD,IAAIG,yBAAyB,IAAID,sBAAsB,EAAE;QACvD,MAAM,IAAIK,KAAK,CACb,CAAA,uDAAA,CAAyD,GACvD,CAAA,sDAAA,CACJ,CAAC;IACH;IACA,MAAMC,kCAAkC,GACtCL,yBAAyB,IAAID,sBAAsB;IAErD,IAAIZ,KAAK,KAAK,IAAI,EAAE;QAElB,MAAMmB,QAAiC,GAAG,EAAE;QAE5C,IAAIR,oBAAoB,KAAKS,SAAS,EAAE;YACtCD,QAAQ,CAACE,IAAI,CAAC,CAAA,sBAAA,CAAwB,CAAC;QACzC;QACA,IAAIR,yBAAyB,KAAKO,SAAS,EAAE;YAC3CD,QAAQ,CAACE,IAAI,CAAC,CAAA,2BAAA,CAA6B,CAAC;QAC9C;QACA,IAAIT,sBAAsB,KAAKQ,SAAS,EAAE;YACxCD,QAAQ,CAACE,IAAI,CAAC,CAAA,wBAAA,CAA0B,CAAC;QAC3C;QACA,IAAIF,QAAQ,CAACG,MAAM,KAAK,CAAC,EAAE;YACzBC,OAAO,CAACC,IAAI,CACV,CAAA,CAAA,EAAI1B,IAAI,CAAA,qDAAA,CAAuD,GAC7D,CAAA,oCAAA,EAAuCqB,QAAQ,CAACM,IAAI,CAAC,OAAO,CAAC,EAAE,GAC/D,CAAA,WAAA,EAAcN,QAAQ,CAACG,MAAM,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE,CAAA,oBAAA,CAAsB,GAClE,CAAA,0DAAA,CAA4D,GAC5D,CAAA,0DAAA,CAA4D,GAC5D,CAAA,8BAAA,CAAgC,GAChC,CAAA,oBAAA,CAAsB,GACtB,CAAA,mCAAA,CAAqC,GACrC,CAAA,oCAAA,CAAsC,GACtC,CAAA,GAAA,CACJ,CAAC;QACH;IACF;IAEA,OAAO;QACLxB,IAAI;QACJG,iBAAiB;QACjBE,QAAQ;QAERuB,GAAGA,EAACC,IAAI,EAAE;YACR,CAAA,GAAAC,UAAAA,aAAa,EAACD,IAAI,EAAE5B,OAAO,EAAEC,KAAK,CAAC;YAEA;gBAIjC,IAAI,OAAO2B,IAAI,CAACE,GAAG,CAACjC,UAAU,CAAC,KAAK,QAAQ,EAAE;oBAC5C+B,IAAI,CAACG,GAAG,CAAClC,UAAU,EAAA,QAAsB,CAAC;oBAC1C;gBACF;YACF;YACA,IACE,CAAC+B,IAAI,CAACE,GAAG,CAACjC,UAAU,CAAC,IACrBmC,OAAM,CAACC,EAAE,CAACL,IAAI,CAACE,GAAG,CAACjC,UAAU,CAAC,EAAA,QAAsB,CAAC,EACrD;gBACA+B,IAAI,CAACG,GAAG,CAAClC,UAAU,EAAA,QAAsB,CAAC;YAC5C;QACF,CAAC;QAEDqC,OAAO,EAAE;YACPC,KAAKA,EAACC,IAAI,EAAE,EAAER,IAAAA,EAAM,EAAE;gBAAA,IAAAS,IAAA;gBACpB,IAAIT,IAAI,CAACE,GAAG,CAACjC,UAAU,CAAC,KAAA,QAAyB,EAAE;gBAEnD,IAAI,CAAC,CAAA,GAAAyC,UAAAA,eAAe,EAACF,IAAI,EAAER,IAAI,CAAC,EAAE;gBAElC,MAAMW,sBAAsB,GAAGH,IAAI,CAACI,kBAAkB,CAAC,CAAC;gBAExD,IAAID,sBAAsB,EAAE,CAAA,GAAAE,YAAAA,sBAAsB,EAACL,IAAI,CAAC;gBAExD,MAAMnC,KAAK,GAAG,CAAA,GAAAyC,UAAAA,OAAO,EAACd,IAAI,EAAE5B,OAAO,CAAC;gBAEpC,IAAI2C,WAAoC;gBACxC,MAAMC,WAAW,GAAG,CAAA,GAAAC,aAAAA,aAAa,EAACT,IAAI,CAACU,IAAI,CAAC;gBAC5C,MAAMC,KAAiB,GAAG,EAAE;gBAC5B,MAAMC,QAAQ,GAAG,EAAE;gBACnB,MAAMC,aAA0D,GAAG,EAAE;gBACrE,MAAMC,YAAY,GAAG,IAAIC,GAAG,CAAS,CAAC;gBACtC,MAAMC,IAAI,GAAGhB,IAAI,CAACN,GAAG,CAAC,MAAM,CAAC;gBAE7B,KAAK,MAAMM,IAAI,IAAIgB,IAAI,CAACtB,GAAG,CAAC,MAAM,CAAC,CAAE;oBACnC,IAEE,CAACM,IAAI,CAACiB,eAAe,CAAC,CAAC,IAAIjB,IAAI,CAACkB,aAAa,CAAC,CAAC,KAC/ClB,IAAI,CAACU,IAAI,CAACS,QAAQ,EAClB;wBACAN,aAAa,CAAC3B,IAAI,CAACc,IAAI,CAAC;oBAC1B;oBAEA,IAAIA,IAAI,CAACoB,SAAS,CAAC,CAAC,EAAE;wBACpB,MAAM,EAAEzD,IAAAA,EAAM,GAAGqC,IAAI,CAACU,IAAI,CAACW,GAAG,CAACC,EAAE;wBACjC,MAAMC,OAAO,GAAG,CAAA,IAAA,EAAO5D,IAAI,EAAE;wBAC7B,MAAM6D,OAAO,GAAG,CAAA,IAAA,EAAO7D,IAAI,EAAE;wBAE7B,IAAIqC,IAAI,CAACyB,oBAAoB,CAAC,CAAC,EAAE;4BAC/B,IAAIzB,IAAI,CAACU,IAAI,CAACgB,IAAI,KAAK,KAAK,EAAE;gCAC5B,IACEZ,YAAY,CAACa,GAAG,CAACJ,OAAO,CAAC,IACxBT,YAAY,CAACa,GAAG,CAAChE,IAAI,CAAC,IAAI,CAACmD,YAAY,CAACa,GAAG,CAACH,OAAO,CAAE,EACtD;oCACA,MAAMxB,IAAI,CAAC4B,mBAAmB,CAAC,yBAAyB,CAAC;gCAC3D;gCACAd,YAAY,CAACe,GAAG,CAACN,OAAO,CAAC,CAACM,GAAG,CAAClE,IAAI,CAAC;4BACrC,CAAC,MAAM,IAAIqC,IAAI,CAACU,IAAI,CAACgB,IAAI,KAAK,KAAK,EAAE;gCACnC,IACEZ,YAAY,CAACa,GAAG,CAACH,OAAO,CAAC,IACxBV,YAAY,CAACa,GAAG,CAAChE,IAAI,CAAC,IAAI,CAACmD,YAAY,CAACa,GAAG,CAACJ,OAAO,CAAE,EACtD;oCACA,MAAMvB,IAAI,CAAC4B,mBAAmB,CAAC,yBAAyB,CAAC;gCAC3D;gCACAd,YAAY,CAACe,GAAG,CAACL,OAAO,CAAC,CAACK,GAAG,CAAClE,IAAI,CAAC;4BACrC;wBACF,CAAC,MAAM;4BACL,IACGmD,YAAY,CAACa,GAAG,CAAChE,IAAI,CAAC,IACrB,CAACmD,YAAY,CAACa,GAAG,CAACJ,OAAO,CAAC,IAC1B,CAACT,YAAY,CAACa,GAAG,CAACH,OAAO,CAAC,IAC3BV,YAAY,CAACa,GAAG,CAAChE,IAAI,CAAC,IAAA,CACpBmD,YAAY,CAACa,GAAG,CAACJ,OAAO,CAAC,IAAIT,YAAY,CAACa,GAAG,CAACH,OAAO,CAAC,CAAE,EAC3D;gCACA,MAAMxB,IAAI,CAAC4B,mBAAmB,CAAC,yBAAyB,CAAC;4BAC3D;4BAEAd,YAAY,CAACe,GAAG,CAAClE,IAAI,CAAC;wBACxB;oBACF;oBAEA,IAAIqC,IAAI,CAACkB,aAAa,CAAC;wBAAEQ,IAAI,EAAE;oBAAc,CAAC,CAAC,EAAE;wBAC/CnB,WAAW,GAAGP,IAAI;oBACpB,CAAC,MAAM;wBACLY,QAAQ,CAAC1B,IAAI,CAACc,IAAI,CAAC;wBACnB,IACEA,IAAI,CAAC8B,UAAU,CAAC,CAAC,IACjB9B,IAAI,CAACoB,SAAS,CAAC,CAAC,IAChBpB,IAAI,CAAC+B,aAAa,IAAA,QAAlB/B,IAAI,CAAC+B,aAAa,CAAG,CAAC,EACtB;4BACApB,KAAK,CAACzB,IAAI,CAACc,IAAgB,CAAC;wBAC9B;oBACF;gBACF;gBAIO;oBACL,IAAI,CAACW,KAAK,CAACxB,MAAM,IAAI,CAACqB,WAAW,EAAE;gBACrC;gBAEA,MAAMwB,YAAY,GAAGhC,IAAI,CAACU,IAAI,CAACY,EAAE;gBACjC,IAAIW,GAAwB;gBAC5B,IAAI,CAACD,YAAY,IAAI,CAAC7B,sBAAsB,EAAE;oBACqB;wBAAA,IAAA+B,qBAAA;wBAE/D,CAAAA,qBAAA,GAAAlC,IAAI,CAACmC,kBAAkB,KAAA,OAAAD,qBAAA,GAAvBlC,IAAI,CAACmC,kBAAkB,GAErBlF,OAAO,CAAC,iBAAiB,CAAC,6EAACmF,QAAQ,CAACC,SAAS,CAACF,kBAAkB;oBACpE;oBACCnC,IAAI,CAAiCmC,kBAAkB,CAAC,KAAK,CAAC;oBAC/DF,GAAG,GAAGjC,IAAI,CAACsC,KAAK,CAACC,qBAAqB,CAAC,CAAAP,YAAY,IAAA,OAAA,KAAA,IAAZA,YAAY,CAAErE,IAAI,KAAI,OAAO,CAAC;gBACvE;gBACA,MAAM6E,iBAAiB,GAAA,CAAAvC,IAAA,GAAGgC,GAAG,KAAA,OAAAhC,IAAA,GAAIwC,MAAAA,KAAC,CAACC,SAAS,CAACV,YAAY,CAAC;gBAE1D,MAAMW,eAAe,GAAG,CAAA,GAAAC,QAAAA,oBAAoB,EAC1CJ,iBAAiB,CAAC7E,IAAI,EACtBoB,kCAAkC,IAAA,OAAlCA,kCAAkC,GAAIlB,KAAK,EAC3C8C,KAAK,EACLnB,IACF,CAAC;gBACD,MAAMqD,iBAAiB,GAAG,CAAA,GAAAC,QAAAA,sBAAsB,EAC9CH,eAAe,EACfjE,yBAAyB,IAAA,OAAzBA,yBAAyB,GAAIb,KAAK,EAClCY,sBAAsB,IAAA,OAAtBA,sBAAsB,GAAI,KAAK,EAC/Be,IACF,CAAC;gBAED,CAAA,GAAAuD,QAAAA,0BAA0B,EACxBP,iBAAiB,EACjBxC,IAAI,EACJ2C,eAAe,EACf;oBACEjE,yBAAyB,EACvBK,kCAAkC,IAAA,OAAlCA,kCAAkC,GAAIlB,KAAK;oBAC7Cc,iCAAiC;oBACjCE,aAAa;oBACbmD;gBACF,CAAC,EACDxC,IACF,CAAC;gBAED,IAAIwD,SAAwB,EAC1BC,WAA0B,EAC1BC,aAAsC,EACtCC,2BAAoC,EACpCC,eAAwC,EACxCC,gBAAoC,EACpCC,SAAgD;gBAEf;oBACjC,IAAI9C,WAAW,EAAE;wBACfyC,WAAW,GAAGG,eAAe,GAAGJ,SAAS,GAAG,EAAE;wBAC9C,CAAC,EAAEE,aAAa,EAAEI,SAAAA,EAAW,GAAG,CAAA,GAAAC,aAAAA,mBAAmB,EACjDf,iBAAiB,EACjBxC,IAAI,EACJY,QAAQ,EACRpB,IACF,CAAC;oBACH,CAAC,MAAM;wBACLwD,SAAS,GAAG,CAAA,GAAAQ,MAAAA,mBAAmB,EAACxD,IAAI,EAAEa,aAAa,EAAErB,IAAI,CAAC;wBAC1D,CAAC,EACCyD,WAAW,EACXG,eAAe,EACfF,aAAa,EACbC,2BAA2B,EAC3BE,gBAAgB,EAChBC,SAAAA,EACD,GAAG,CAAA,GAAAG,QAAAA,oBAAoB,EACtBxB,GAAG,EACHjC,IAAI,CAACU,IAAI,CAACgD,UAAU,EACpB/C,KAAK,EACLgC,eAAe,EACfnD,IAAI,EACJhB,oBAAoB,IAAA,OAApBA,oBAAoB,GAAIX,KAAK,EAC7BkB,kCAAkC,IAAA,OAAlCA,kCAAkC,GAAIlB,KAAK,EAC3Cc,iCAAiC,EACjCC,aAAa,IAAA,OAAbA,aAAa,GAAIf,KAAK,EACtBmE,YACF,CAAC;oBACH;gBACF;gBAuBA,IAAIkB,aAAa,CAAC/D,MAAM,GAAG,CAAC,EAAE;oBAC5B,CAAA,GAAAwE,MAAAA,oBAAoB,EAClB3D,IAAI,EACJO,WAAW,EACX2C,aAAa,EACb,CAACU,gBAAgB,EAAEC,KAAK,KAAK;wBACQ;4BACjC,IAAIrD,WAAW,EAAE;wBACnB;wBACA,KAAK,MAAMsD,IAAI,IAAInD,KAAK,CAAE;4BAExB,IAAI8B,MAAAA,KAAC,CAACV,aAAa,IAAA,QAAfU,MAAAA,KAAC,CAACV,aAAa,CAAG+B,IAAI,CAACpD,IAAI,CAAC,IAAIoD,IAAI,CAACpD,IAAI,CAACqD,MAAM,EAAE;4BACtDD,IAAI,CAACE,QAAQ,CAACJ,gBAAgB,EAAEC,KAAK,CAAC;wBACxC;oBACF,CAAC,EACDV,2BACF,CAAC;gBACH;gBAGA,MAAMc,WAAW,GAAGX,SAAS,CAACtD,IAAI,CAAC;gBACnCiE,WAAW,CAACC,YAAY,CAAC,CAAC;uBAAGrB,iBAAiB,EAAE;uBAAGG,SAAS;iBAAC,CAAC;gBAC9D,IAAIC,WAAW,CAAC9D,MAAM,GAAG,CAAC,EAAE;oBAC1B8E,WAAW,CAACE,WAAW,CAAClB,WAAW,CAAC;gBACtC;gBACA,IAAIG,eAAe,CAACjE,MAAM,GAAG,CAAC,EAAE;oBAC9B8E,WAAW,CACRG,IAAI,EAACC,MAAM,GAAIA,MAAM,CAACC,WAAW,CAAC,CAAC,IAAID,MAAM,CAACE,aAAa,CAAC,CAAC,CAAC,CAC9DJ,WAAW,CAACf,eAAe,CAAC;gBACjC;gBACA,IAAIC,gBAAgB,IAAI,IAAI,IAAIlD,sBAAsB,EAAE;oBACtD8D,WAAW,CAACE,WAAW,CAACd,gBAAgB,CAAC;gBAC3C;YACF,CAAC;YAEDmB,wBAAwBA,EAACxE,IAAI,EAAE,EAAER,IAAAA,EAAM,EAAE;gBACJ;oBACjC,IAAIA,IAAI,CAACE,GAAG,CAACjC,UAAU,CAAC,KAAA,QAAyB,EAAE;oBAEnD,MAAMgH,IAAI,GAAGzE,IAAI,CAACN,GAAG,CAAC,aAAa,CAAC;oBAEpC,IAAI+E,IAAI,CAACrE,kBAAkB,CAAC,CAAC,IAAI,CAAA,GAAAK,aAAAA,aAAa,EAACgE,IAAI,CAAC/D,IAAI,CAAC,EAAE;wBACzD,IAAI+D,IAAI,CAAC/D,IAAI,CAACY,EAAE,EAAE;4BAIiD;gCAAA,IAAAoD,qBAAA;gCAE/D,CAAAA,qBAAA,GAAA1E,IAAI,CAAC2E,sBAAsB,KAAA,OAAAD,qBAAA,GAA3B1E,IAAI,CAAC2E,sBAAsB,GAEzB1H,OAAO,CAAC,iBAAiB,CAAC,6EAACmF,QAAQ,CAACC,SAAS,CAACsC,sBAAsB;4BACxE;4BACA3E,IAAI,CAAC2E,sBAAsB,CAAC,CAAC;wBAC/B,CAAC,MAAM;4BAGLF,IAAI,CAAC/D,IAAI,CAACkE,IAAI,GAAG,iBAAiB;wBACpC;oBACF;gBACF;YACF;QACF;IACF,CAAC;AACH","ignoreList":[0]}},
    {"offset": {"line": 3121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}