module.exports = {

"[project]/node_modules/@babel/core/node_modules/json5/dist/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: __turbopack_require_stub__ } = __turbopack_context__;
{
// This is a generated file. Do not edit.
__turbopack_esm__({
    "default": (()=>__TURBOPACK__default__export__)
});
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
    Space_Separator: Space_Separator,
    ID_Start: ID_Start,
    ID_Continue: ID_Continue
};
var util = {
    isSpaceSeparator (c) {
        return typeof c === 'string' && unicode.Space_Separator.test(c);
    },
    isIdStartChar (c) {
        return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c === '$' || c === '_' || unicode.ID_Start.test(c));
    },
    isIdContinueChar (c) {
        return typeof c === 'string' && (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' || c === '$' || c === '_' || c === '\u200C' || c === '\u200D' || unicode.ID_Continue.test(c));
    },
    isDigit (c) {
        return typeof c === 'string' && /[0-9]/.test(c);
    },
    isHexDigit (c) {
        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c);
    }
};
let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;
var parse = function parse(text, reviver) {
    source = String(text);
    parseState = 'start';
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root = undefined;
    do {
        token = lex();
        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }
        parseStates[parseState]();
    }while (token.type !== 'eof')
    if (typeof reviver === 'function') {
        return internalize({
            '': root
        }, '', reviver);
    }
    return root;
};
function internalize(holder, name, reviver) {
    const value = holder[name];
    if (value != null && typeof value === 'object') {
        if (Array.isArray(value)) {
            for(let i = 0; i < value.length; i++){
                const key = String(i);
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
        } else {
            for(const key in value){
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true
                    });
                }
            }
        }
    }
    return reviver.call(holder, name, value);
}
let lexState;
let buffer;
let doubleQuote;
let sign;
let c;
function lex() {
    lexState = 'default';
    buffer = '';
    doubleQuote = false;
    sign = 1;
    for(;;){
        c = peek();
        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }
        const token = lexStates[lexState]();
        if (token) {
            return token;
        }
    }
}
function peek() {
    if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
    }
}
function read() {
    const c = peek();
    if (c === '\n') {
        line++;
        column = 0;
    } else if (c) {
        column += c.length;
    } else {
        column++;
    }
    if (c) {
        pos += c.length;
    }
    return c;
}
const lexStates = {
    default () {
        switch(c){
            case '\t':
            case '\v':
            case '\f':
            case ' ':
            case '\u00A0':
            case '\uFEFF':
            case '\n':
            case '\r':
            case '\u2028':
            case '\u2029':
                read();
                return;
            case '/':
                read();
                lexState = 'comment';
                return;
            case undefined:
                read();
                return newToken('eof');
        }
        if (util.isSpaceSeparator(c)) {
            read();
            return;
        }
        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }
        return lexStates[parseState]();
    },
    comment () {
        switch(c){
            case '*':
                read();
                lexState = 'multiLineComment';
                return;
            case '/':
                read();
                lexState = 'singleLineComment';
                return;
        }
        throw invalidChar(read());
    },
    multiLineComment () {
        switch(c){
            case '*':
                read();
                lexState = 'multiLineCommentAsterisk';
                return;
            case undefined:
                throw invalidChar(read());
        }
        read();
    },
    multiLineCommentAsterisk () {
        switch(c){
            case '*':
                read();
                return;
            case '/':
                read();
                lexState = 'default';
                return;
            case undefined:
                throw invalidChar(read());
        }
        read();
        lexState = 'multiLineComment';
    },
    singleLineComment () {
        switch(c){
            case '\n':
            case '\r':
            case '\u2028':
            case '\u2029':
                read();
                lexState = 'default';
                return;
            case undefined:
                read();
                return newToken('eof');
        }
        read();
    },
    value () {
        switch(c){
            case '{':
            case '[':
                return newToken('punctuator', read());
            case 'n':
                read();
                literal('ull');
                return newToken('null', null);
            case 't':
                read();
                literal('rue');
                return newToken('boolean', true);
            case 'f':
                read();
                literal('alse');
                return newToken('boolean', false);
            case '-':
            case '+':
                if (read() === '-') {
                    sign = -1;
                }
                lexState = 'sign';
                return;
            case '.':
                buffer = read();
                lexState = 'decimalPointLeading';
                return;
            case '0':
                buffer = read();
                lexState = 'zero';
                return;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                buffer = read();
                lexState = 'decimalInteger';
                return;
            case 'I':
                read();
                literal('nfinity');
                return newToken('numeric', Infinity);
            case 'N':
                read();
                literal('aN');
                return newToken('numeric', NaN);
            case '"':
            case "'":
                doubleQuote = read() === '"';
                buffer = '';
                lexState = 'string';
                return;
        }
        throw invalidChar(read());
    },
    identifierNameStartEscape () {
        if (c !== 'u') {
            throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch(u){
            case '$':
            case '_':
                break;
            default:
                if (!util.isIdStartChar(u)) {
                    throw invalidIdentifier();
                }
                break;
        }
        buffer += u;
        lexState = 'identifierName';
    },
    identifierName () {
        switch(c){
            case '$':
            case '_':
            case '\u200C':
            case '\u200D':
                buffer += read();
                return;
            case '\\':
                read();
                lexState = 'identifierNameEscape';
                return;
        }
        if (util.isIdContinueChar(c)) {
            buffer += read();
            return;
        }
        return newToken('identifier', buffer);
    },
    identifierNameEscape () {
        if (c !== 'u') {
            throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch(u){
            case '$':
            case '_':
            case '\u200C':
            case '\u200D':
                break;
            default:
                if (!util.isIdContinueChar(u)) {
                    throw invalidIdentifier();
                }
                break;
        }
        buffer += u;
        lexState = 'identifierName';
    },
    sign () {
        switch(c){
            case '.':
                buffer = read();
                lexState = 'decimalPointLeading';
                return;
            case '0':
                buffer = read();
                lexState = 'zero';
                return;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                buffer = read();
                lexState = 'decimalInteger';
                return;
            case 'I':
                read();
                literal('nfinity');
                return newToken('numeric', sign * Infinity);
            case 'N':
                read();
                literal('aN');
                return newToken('numeric', NaN);
        }
        throw invalidChar(read());
    },
    zero () {
        switch(c){
            case '.':
                buffer += read();
                lexState = 'decimalPoint';
                return;
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
            case 'x':
            case 'X':
                buffer += read();
                lexState = 'hexadecimal';
                return;
        }
        return newToken('numeric', sign * 0);
    },
    decimalInteger () {
        switch(c){
            case '.':
                buffer += read();
                lexState = 'decimalPoint';
                return;
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalPointLeading () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return;
        }
        throw invalidChar(read());
    },
    decimalPoint () {
        switch(c){
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalFraction () {
        switch(c){
            case 'e':
            case 'E':
                buffer += read();
                lexState = 'decimalExponent';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    decimalExponent () {
        switch(c){
            case '+':
            case '-':
                buffer += read();
                lexState = 'decimalExponentSign';
                return;
        }
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return;
        }
        throw invalidChar(read());
    },
    decimalExponentSign () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return;
        }
        throw invalidChar(read());
    },
    decimalExponentInteger () {
        if (util.isDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    hexadecimal () {
        if (util.isHexDigit(c)) {
            buffer += read();
            lexState = 'hexadecimalInteger';
            return;
        }
        throw invalidChar(read());
    },
    hexadecimalInteger () {
        if (util.isHexDigit(c)) {
            buffer += read();
            return;
        }
        return newToken('numeric', sign * Number(buffer));
    },
    string () {
        switch(c){
            case '\\':
                read();
                buffer += escape();
                return;
            case '"':
                if (doubleQuote) {
                    read();
                    return newToken('string', buffer);
                }
                buffer += read();
                return;
            case "'":
                if (!doubleQuote) {
                    read();
                    return newToken('string', buffer);
                }
                buffer += read();
                return;
            case '\n':
            case '\r':
                throw invalidChar(read());
            case '\u2028':
            case '\u2029':
                separatorChar(c);
                break;
            case undefined:
                throw invalidChar(read());
        }
        buffer += read();
    },
    start () {
        switch(c){
            case '{':
            case '[':
                return newToken('punctuator', read());
        }
        lexState = 'value';
    },
    beforePropertyName () {
        switch(c){
            case '$':
            case '_':
                buffer = read();
                lexState = 'identifierName';
                return;
            case '\\':
                read();
                lexState = 'identifierNameStartEscape';
                return;
            case '}':
                return newToken('punctuator', read());
            case '"':
            case "'":
                doubleQuote = read() === '"';
                lexState = 'string';
                return;
        }
        if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = 'identifierName';
            return;
        }
        throw invalidChar(read());
    },
    afterPropertyName () {
        if (c === ':') {
            return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    beforePropertyValue () {
        lexState = 'value';
    },
    afterPropertyValue () {
        switch(c){
            case ',':
            case '}':
                return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    beforeArrayValue () {
        if (c === ']') {
            return newToken('punctuator', read());
        }
        lexState = 'value';
    },
    afterArrayValue () {
        switch(c){
            case ',':
            case ']':
                return newToken('punctuator', read());
        }
        throw invalidChar(read());
    },
    end () {
        // This code is unreachable since it's handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken('eof')
        // }
        throw invalidChar(read());
    }
};
function newToken(type, value) {
    return {
        type,
        value,
        line,
        column
    };
}
function literal(s) {
    for (const c of s){
        const p = peek();
        if (p !== c) {
            throw invalidChar(read());
        }
        read();
    }
}
function escape() {
    const c = peek();
    switch(c){
        case 'b':
            read();
            return '\b';
        case 'f':
            read();
            return '\f';
        case 'n':
            read();
            return '\n';
        case 'r':
            read();
            return '\r';
        case 't':
            read();
            return '\t';
        case 'v':
            read();
            return '\v';
        case '0':
            read();
            if (util.isDigit(peek())) {
                throw invalidChar(read());
            }
            return '\0';
        case 'x':
            read();
            return hexEscape();
        case 'u':
            read();
            return unicodeEscape();
        case '\n':
        case '\u2028':
        case '\u2029':
            read();
            return '';
        case '\r':
            read();
            if (peek() === '\n') {
                read();
            }
            return '';
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            throw invalidChar(read());
        case undefined:
            throw invalidChar(read());
    }
    return read();
}
function hexEscape() {
    let buffer = '';
    let c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read());
    }
    buffer += read();
    c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read());
    }
    buffer += read();
    return String.fromCodePoint(parseInt(buffer, 16));
}
function unicodeEscape() {
    let buffer = '';
    let count = 4;
    while(count-- > 0){
        const c = peek();
        if (!util.isHexDigit(c)) {
            throw invalidChar(read());
        }
        buffer += read();
    }
    return String.fromCodePoint(parseInt(buffer, 16));
}
const parseStates = {
    start () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        push();
    },
    beforePropertyName () {
        switch(token.type){
            case 'identifier':
            case 'string':
                key = token.value;
                parseState = 'afterPropertyName';
                return;
            case 'punctuator':
                // This code is unreachable since it's handled by the lexState.
                // if (token.value !== '}') {
                //     throw invalidToken()
                // }
                pop();
                return;
            case 'eof':
                throw invalidEOF();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    afterPropertyName () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator' || token.value !== ':') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        parseState = 'beforePropertyValue';
    },
    beforePropertyValue () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        push();
    },
    beforeArrayValue () {
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        if (token.type === 'punctuator' && token.value === ']') {
            pop();
            return;
        }
        push();
    },
    afterPropertyValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        switch(token.value){
            case ',':
                parseState = 'beforePropertyName';
                return;
            case '}':
                pop();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    afterArrayValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }
        if (token.type === 'eof') {
            throw invalidEOF();
        }
        switch(token.value){
            case ',':
                parseState = 'beforeArrayValue';
                return;
            case ']':
                pop();
        }
    // This code is unreachable since it's handled by the lexState.
    // throw invalidToken()
    },
    end () {
    // This code is unreachable since it's handled by the lexState.
    // if (token.type !== 'eof') {
    //     throw invalidToken()
    // }
    }
};
function push() {
    let value;
    switch(token.type){
        case 'punctuator':
            switch(token.value){
                case '{':
                    value = {};
                    break;
                case '[':
                    value = [];
                    break;
            }
            break;
        case 'null':
        case 'boolean':
        case 'numeric':
        case 'string':
            value = token.value;
            break;
    }
    if (root === undefined) {
        root = value;
    } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
            parent.push(value);
        } else {
            Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    if (value !== null && typeof value === 'object') {
        stack.push(value);
        if (Array.isArray(value)) {
            parseState = 'beforeArrayValue';
        } else {
            parseState = 'beforePropertyName';
        }
    } else {
        const current = stack[stack.length - 1];
        if (current == null) {
            parseState = 'end';
        } else if (Array.isArray(current)) {
            parseState = 'afterArrayValue';
        } else {
            parseState = 'afterPropertyValue';
        }
    }
}
function pop() {
    stack.pop();
    const current = stack[stack.length - 1];
    if (current == null) {
        parseState = 'end';
    } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue';
    } else {
        parseState = 'afterPropertyValue';
    }
}
// This code is unreachable.
// function invalidParseState () {
//     return new Error(`JSON5: invalid parse state '${parseState}'`)
// }
// This code is unreachable.
// function invalidLexState (state) {
//     return new Error(`JSON5: invalid lex state '${state}'`)
// }
function invalidChar(c) {
    if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`);
}
function invalidEOF() {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
// This code is unreachable.
// function invalidToken () {
//     if (token.type === 'eof') {
//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
//     }
//     const c = String.fromCodePoint(token.value.codePointAt(0))
//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
// }
function invalidIdentifier() {
    column -= 5;
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c) {
    console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c) {
    const replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029'
    };
    if (replacements[c]) {
        return replacements[c];
    }
    if (c < ' ') {
        const hexString = c.charCodeAt(0).toString(16);
        return '\\x' + ('00' + hexString).substring(hexString.length);
    }
    return c;
}
function syntaxError(message) {
    const err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err;
}
var stringify = function stringify(value, replacer, space) {
    const stack = [];
    let indent = '';
    let propertyList;
    let replacerFunc;
    let gap = '';
    let quote;
    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
    }
    if (typeof replacer === 'function') {
        replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer){
            let item;
            if (typeof v === 'string') {
                item = v;
            } else if (typeof v === 'number' || v instanceof String || v instanceof Number) {
                item = String(v);
            }
            if (item !== undefined && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
            }
        }
    }
    if (space instanceof Number) {
        space = Number(space);
    } else if (space instanceof String) {
        space = String(space);
    }
    if (typeof space === 'number') {
        if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = '          '.substr(0, space);
        }
    } else if (typeof space === 'string') {
        gap = space.substr(0, 10);
    }
    return serializeProperty('', {
        '': value
    });
    "TURBOPACK unreachable";
    function serializeProperty(key, holder) {
        let value = holder[key];
        if (value != null) {
            if (typeof value.toJSON5 === 'function') {
                value = value.toJSON5(key);
            } else if (typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
        }
        if (replacerFunc) {
            value = replacerFunc.call(holder, key, value);
        }
        if (value instanceof Number) {
            value = Number(value);
        } else if (value instanceof String) {
            value = String(value);
        } else if (value instanceof Boolean) {
            value = value.valueOf();
        }
        switch(value){
            case null:
                return 'null';
            case true:
                return 'true';
            case false:
                return 'false';
        }
        if (typeof value === 'string') {
            return quoteString(value, false);
        }
        if (typeof value === 'number') {
            return String(value);
        }
        if (typeof value === 'object') {
            return Array.isArray(value) ? serializeArray(value) : serializeObject(value);
        }
        return undefined;
    }
    function quoteString(value) {
        const quotes = {
            "'": 0.1,
            '"': 0.2
        };
        const replacements = {
            "'": "\\'",
            '"': '\\"',
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\v': '\\v',
            '\0': '\\0',
            '\u2028': '\\u2028',
            '\u2029': '\\u2029'
        };
        let product = '';
        for(let i = 0; i < value.length; i++){
            const c = value[i];
            switch(c){
                case "'":
                case '"':
                    quotes[c]++;
                    product += c;
                    continue;
                case '\0':
                    if (util.isDigit(value[i + 1])) {
                        product += '\\x00';
                        continue;
                    }
            }
            if (replacements[c]) {
                product += replacements[c];
                continue;
            }
            if (c < ' ') {
                let hexString = c.charCodeAt(0).toString(16);
                product += '\\x' + ('00' + hexString).substring(hexString.length);
                continue;
            }
            product += c;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b)=>quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
    }
    function serializeObject(value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5');
        }
        stack.push(value);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value);
        let partial = [];
        for (const key of keys){
            const propertyString = serializeProperty(key, value);
            if (propertyString !== undefined) {
                let member = serializeKey(key) + ':';
                if (gap !== '') {
                    member += ' ';
                }
                member += propertyString;
                partial.push(member);
            }
        }
        let final;
        if (partial.length === 0) {
            final = '{}';
        } else {
            let properties;
            if (gap === '') {
                properties = partial.join(',');
                final = '{' + properties + '}';
            } else {
                let separator = ',\n' + indent;
                properties = partial.join(separator);
                final = '{\n' + indent + properties + ',\n' + stepback + '}';
            }
        }
        stack.pop();
        indent = stepback;
        return final;
    }
    function serializeKey(key) {
        if (key.length === 0) {
            return quoteString(key, true);
        }
        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
            return quoteString(key, true);
        }
        for(let i = firstChar.length; i < key.length; i++){
            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
                return quoteString(key, true);
            }
        }
        return key;
    }
    function serializeArray(value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5');
        }
        stack.push(value);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for(let i = 0; i < value.length; i++){
            const propertyString = serializeProperty(String(i), value);
            partial.push(propertyString !== undefined ? propertyString : 'null');
        }
        let final;
        if (partial.length === 0) {
            final = '[]';
        } else {
            if (gap === '') {
                let properties = partial.join(',');
                final = '[' + properties + ']';
            } else {
                let separator = ',\n' + indent;
                let properties = partial.join(separator);
                final = '[\n' + indent + properties + ',\n' + stepback + ']';
            }
        }
        stack.pop();
        indent = stepback;
        return final;
    }
};
const JSON5 = {
    parse,
    stringify
};
var lib = JSON5;
const __TURBOPACK__default__export__ = lib;
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/identifier.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIdentifierChar = isIdentifierChar;
exports.isIdentifierName = isIdentifierName;
exports.isIdentifierStart = isIdentifierStart;
let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
let nonASCIIidentifierChars = "\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    4,
    51,
    13,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    39,
    27,
    10,
    22,
    251,
    41,
    7,
    1,
    17,
    2,
    60,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    20,
    1,
    64,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    31,
    9,
    2,
    0,
    3,
    0,
    2,
    37,
    2,
    0,
    26,
    0,
    2,
    0,
    45,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    200,
    32,
    32,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    16,
    0,
    2,
    12,
    2,
    33,
    125,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1071,
    18,
    5,
    26,
    3994,
    6,
    582,
    6842,
    29,
    1763,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    433,
    44,
    212,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    42,
    9,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    16,
    0,
    30,
    2,
    3,
    0,
    15,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    7,
    5,
    262,
    61,
    147,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    485,
    27,
    229,
    29,
    3,
    0,
    496,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4153,
    7,
    221,
    3,
    5761,
    15,
    7472,
    16,
    621,
    2467,
    541,
    1507,
    4938,
    6,
    4191
];
const astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    7,
    9,
    32,
    4,
    318,
    1,
    80,
    3,
    71,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    3,
    0,
    158,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    68,
    8,
    2,
    0,
    3,
    0,
    2,
    3,
    2,
    4,
    2,
    0,
    15,
    1,
    83,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    7,
    19,
    58,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    343,
    9,
    54,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    10,
    1,
    2,
    0,
    49,
    6,
    4,
    4,
    14,
    10,
    5350,
    0,
    7,
    14,
    11465,
    27,
    2343,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    535,
    9,
    470,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4178,
    9,
    519,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    101,
    0,
    161,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    499,
    13,
    245,
    1,
    2,
    9,
    726,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
];
function isInAstralSet(code, set) {
    let pos = 0x10000;
    for(let i = 0, length = set.length; i < length; i += 2){
        pos += set[i];
        if (pos > code) return false;
        pos += set[i + 1];
        if (pos >= code) return true;
    }
    return false;
}
function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function isIdentifierName(name) {
    let isFirst = true;
    for(let i = 0; i < name.length; i++){
        let cp = name.charCodeAt(i);
        if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
            const trail = name.charCodeAt(++i);
            if ((trail & 0xfc00) === 0xdc00) {
                cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
            }
        }
        if (isFirst) {
            isFirst = false;
            if (!isIdentifierStart(cp)) {
                return false;
            }
        } else if (!isIdentifierChar(cp)) {
            return false;
        }
    }
    return !isFirst;
} //# sourceMappingURL=identifier.js.map
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/keyword.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isKeyword = isKeyword;
exports.isReservedWord = isReservedWord;
exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
exports.isStrictBindReservedWord = isStrictBindReservedWord;
exports.isStrictReservedWord = isStrictReservedWord;
const reservedWords = {
    keyword: [
        "break",
        "case",
        "catch",
        "continue",
        "debugger",
        "default",
        "do",
        "else",
        "finally",
        "for",
        "function",
        "if",
        "return",
        "switch",
        "throw",
        "try",
        "var",
        "const",
        "while",
        "with",
        "new",
        "this",
        "super",
        "class",
        "extends",
        "export",
        "import",
        "null",
        "true",
        "false",
        "in",
        "instanceof",
        "typeof",
        "void",
        "delete"
    ],
    strict: [
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "yield"
    ],
    strictBind: [
        "eval",
        "arguments"
    ]
};
const keywords = new Set(reservedWords.keyword);
const reservedWordsStrictSet = new Set(reservedWords.strict);
const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
}
function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
}
function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
}
function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
}
function isKeyword(word) {
    return keywords.has(word);
} //# sourceMappingURL=keyword.js.map
}}),
"[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierChar;
    }
});
Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierName;
    }
});
Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function() {
        return _identifier.isIdentifierStart;
    }
});
Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function() {
        return _keyword.isKeyword;
    }
});
Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
    }
});
Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictBindReservedWord;
    }
});
Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function() {
        return _keyword.isStrictReservedWord;
    }
});
var _identifier = __turbopack_require__("[project]/node_modules/@babel/helper-validator-identifier/lib/identifier.js [app-ssr] (ecmascript)");
var _keyword = __turbopack_require__("[project]/node_modules/@babel/helper-validator-identifier/lib/keyword.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-string-parser/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readCodePoint = readCodePoint;
exports.readInt = readInt;
exports.readStringContents = readStringContents;
var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
};
const forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([
        46,
        66,
        69,
        79,
        95,
        98,
        101,
        111
    ]),
    hex: new Set([
        46,
        88,
        95,
        120
    ])
};
const isAllowedNumericSeparatorSibling = {
    bin: (ch)=>ch === 48 || ch === 49,
    oct: (ch)=>ch >= 48 && ch <= 55,
    dec: (ch)=>ch >= 48 && ch <= 57,
    hex: (ch)=>ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
};
function readStringContents(type, input, pos, lineStart, curLine, errors) {
    const initialPos = pos;
    const initialLineStart = lineStart;
    const initialCurLine = curLine;
    let out = "";
    let firstInvalidLoc = null;
    let chunkStart = pos;
    const { length } = input;
    for(;;){
        if (pos >= length) {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
            out += input.slice(chunkStart, pos);
            break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
            out += input.slice(chunkStart, pos);
            break;
        }
        if (ch === 92) {
            out += input.slice(chunkStart, pos);
            const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
            if (res.ch === null && !firstInvalidLoc) {
                firstInvalidLoc = {
                    pos,
                    lineStart,
                    curLine
                };
            } else {
                out += res.ch;
            }
            ({ pos, lineStart, curLine } = res);
            chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
            ++pos;
            ++curLine;
            lineStart = pos;
        } else if (ch === 10 || ch === 13) {
            if (type === "template") {
                out += input.slice(chunkStart, pos) + "\n";
                ++pos;
                if (ch === 13 && input.charCodeAt(pos) === 10) {
                    ++pos;
                }
                ++curLine;
                chunkStart = lineStart = pos;
            } else {
                errors.unterminated(initialPos, initialLineStart, initialCurLine);
            }
        } else {
            ++pos;
        }
    }
    return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
    };
}
function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
}
function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    const throwOnInvalid = !inTemplate;
    pos++;
    const res = (ch)=>({
            pos,
            ch,
            lineStart,
            curLine
        });
    const ch = input.charCodeAt(pos++);
    switch(ch){
        case 110:
            return res("\n");
        case 114:
            return res("\r");
        case 120:
            {
                let code;
                ({ code, pos } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCharCode(code));
            }
        case 117:
            {
                let code;
                ({ code, pos } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
                return res(code === null ? null : String.fromCodePoint(code));
            }
        case 116:
            return res("\t");
        case 98:
            return res("\b");
        case 118:
            return res("\u000b");
        case 102:
            return res("\f");
        case 13:
            if (input.charCodeAt(pos) === 10) {
                ++pos;
            }
        case 10:
            lineStart = pos;
            ++curLine;
        case 8232:
        case 8233:
            return res("");
        case 56:
        case 57:
            if (inTemplate) {
                return res(null);
            } else {
                errors.strictNumericEscape(pos - 1, lineStart, curLine);
            }
        default:
            if (ch >= 48 && ch <= 55) {
                const startPos = pos - 1;
                const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
                let octalStr = match[0];
                let octal = parseInt(octalStr, 8);
                if (octal > 255) {
                    octalStr = octalStr.slice(0, -1);
                    octal = parseInt(octalStr, 8);
                }
                pos += octalStr.length - 1;
                const next = input.charCodeAt(pos);
                if (octalStr !== "0" || next === 56 || next === 57) {
                    if (inTemplate) {
                        return res(null);
                    } else {
                        errors.strictNumericEscape(startPos, lineStart, curLine);
                    }
                }
                return res(String.fromCharCode(octal));
            }
            return res(String.fromCharCode(ch));
    }
}
function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    const initialPos = pos;
    let n;
    ({ n, pos } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
    if (n === null) {
        if (throwOnInvalid) {
            errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
            pos = initialPos - 1;
        }
    }
    return {
        code: n,
        pos
    };
}
function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    const start = pos;
    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    let invalid = false;
    let total = 0;
    for(let i = 0, e = len == null ? Infinity : len; i < e; ++i){
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
            const prev = input.charCodeAt(pos - 1);
            const next = input.charCodeAt(pos + 1);
            if (!allowNumSeparator) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
            } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
                if (bailOnError) return {
                    n: null,
                    pos
                };
                errors.unexpectedNumericSeparator(pos, lineStart, curLine);
            }
            ++pos;
            continue;
        }
        if (code >= 97) {
            val = code - 97 + 10;
        } else if (code >= 65) {
            val = code - 65 + 10;
        } else if (_isDigit(code)) {
            val = code - 48;
        } else {
            val = Infinity;
        }
        if (val >= radix) {
            if (val <= 9 && bailOnError) {
                return {
                    n: null,
                    pos
                };
            } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
                val = 0;
            } else if (forceLen) {
                val = 0;
                invalid = true;
            } else {
                break;
            }
        }
        ++pos;
        total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
        return {
            n: null,
            pos
        };
    }
    return {
        n: total,
        pos
    };
}
function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    const ch = input.charCodeAt(pos);
    let code;
    if (ch === 123) {
        ++pos;
        ({ code, pos } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 0x10ffff) {
            if (throwOnInvalid) {
                errors.invalidCodePoint(pos, lineStart, curLine);
            } else {
                return {
                    code: null,
                    pos
                };
            }
        }
    } else {
        ({ code, pos } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
    }
    return {
        code,
        pos
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/traverse/node_modules/globals/globals.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"builtin\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"BigInt\":false,\"BigInt64Array\":false,\"BigUint64Array\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"globalThis\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es5\":{\"Array\":false,\"Boolean\":false,\"constructor\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"propertyIsEnumerable\":false,\"RangeError\":false,\"ReferenceError\":false,\"RegExp\":false,\"String\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false},\"es2015\":{\"Array\":false,\"ArrayBuffer\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es2017\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"browser\":{\"AbortController\":false,\"AbortSignal\":false,\"addEventListener\":false,\"alert\":false,\"AnalyserNode\":false,\"Animation\":false,\"AnimationEffectReadOnly\":false,\"AnimationEffectTiming\":false,\"AnimationEffectTimingReadOnly\":false,\"AnimationEvent\":false,\"AnimationPlaybackEvent\":false,\"AnimationTimeline\":false,\"applicationCache\":false,\"ApplicationCache\":false,\"ApplicationCacheErrorEvent\":false,\"atob\":false,\"Attr\":false,\"Audio\":false,\"AudioBuffer\":false,\"AudioBufferSourceNode\":false,\"AudioContext\":false,\"AudioDestinationNode\":false,\"AudioListener\":false,\"AudioNode\":false,\"AudioParam\":false,\"AudioProcessingEvent\":false,\"AudioScheduledSourceNode\":false,\"AudioWorkletGlobalScope \":false,\"AudioWorkletNode\":false,\"AudioWorkletProcessor\":false,\"BarProp\":false,\"BaseAudioContext\":false,\"BatteryManager\":false,\"BeforeUnloadEvent\":false,\"BiquadFilterNode\":false,\"Blob\":false,\"BlobEvent\":false,\"blur\":false,\"BroadcastChannel\":false,\"btoa\":false,\"BudgetService\":false,\"ByteLengthQueuingStrategy\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"cancelAnimationFrame\":false,\"cancelIdleCallback\":false,\"CanvasCaptureMediaStreamTrack\":false,\"CanvasGradient\":false,\"CanvasPattern\":false,\"CanvasRenderingContext2D\":false,\"ChannelMergerNode\":false,\"ChannelSplitterNode\":false,\"CharacterData\":false,\"clearInterval\":false,\"clearTimeout\":false,\"clientInformation\":false,\"ClipboardEvent\":false,\"close\":false,\"closed\":false,\"CloseEvent\":false,\"Comment\":false,\"CompositionEvent\":false,\"confirm\":false,\"console\":false,\"ConstantSourceNode\":false,\"ConvolverNode\":false,\"CountQueuingStrategy\":false,\"createImageBitmap\":false,\"Credential\":false,\"CredentialsContainer\":false,\"crypto\":false,\"Crypto\":false,\"CryptoKey\":false,\"CSS\":false,\"CSSConditionRule\":false,\"CSSFontFaceRule\":false,\"CSSGroupingRule\":false,\"CSSImportRule\":false,\"CSSKeyframeRule\":false,\"CSSKeyframesRule\":false,\"CSSMediaRule\":false,\"CSSNamespaceRule\":false,\"CSSPageRule\":false,\"CSSRule\":false,\"CSSRuleList\":false,\"CSSStyleDeclaration\":false,\"CSSStyleRule\":false,\"CSSStyleSheet\":false,\"CSSSupportsRule\":false,\"CustomElementRegistry\":false,\"customElements\":false,\"CustomEvent\":false,\"DataTransfer\":false,\"DataTransferItem\":false,\"DataTransferItemList\":false,\"defaultstatus\":false,\"defaultStatus\":false,\"DelayNode\":false,\"DeviceMotionEvent\":false,\"DeviceOrientationEvent\":false,\"devicePixelRatio\":false,\"dispatchEvent\":false,\"document\":false,\"Document\":false,\"DocumentFragment\":false,\"DocumentType\":false,\"DOMError\":false,\"DOMException\":false,\"DOMImplementation\":false,\"DOMMatrix\":false,\"DOMMatrixReadOnly\":false,\"DOMParser\":false,\"DOMPoint\":false,\"DOMPointReadOnly\":false,\"DOMQuad\":false,\"DOMRect\":false,\"DOMRectReadOnly\":false,\"DOMStringList\":false,\"DOMStringMap\":false,\"DOMTokenList\":false,\"DragEvent\":false,\"DynamicsCompressorNode\":false,\"Element\":false,\"ErrorEvent\":false,\"event\":false,\"Event\":false,\"EventSource\":false,\"EventTarget\":false,\"external\":false,\"fetch\":false,\"File\":false,\"FileList\":false,\"FileReader\":false,\"find\":false,\"focus\":false,\"FocusEvent\":false,\"FontFace\":false,\"FontFaceSetLoadEvent\":false,\"FormData\":false,\"frameElement\":false,\"frames\":false,\"GainNode\":false,\"Gamepad\":false,\"GamepadButton\":false,\"GamepadEvent\":false,\"getComputedStyle\":false,\"getSelection\":false,\"HashChangeEvent\":false,\"Headers\":false,\"history\":false,\"History\":false,\"HTMLAllCollection\":false,\"HTMLAnchorElement\":false,\"HTMLAreaElement\":false,\"HTMLAudioElement\":false,\"HTMLBaseElement\":false,\"HTMLBodyElement\":false,\"HTMLBRElement\":false,\"HTMLButtonElement\":false,\"HTMLCanvasElement\":false,\"HTMLCollection\":false,\"HTMLContentElement\":false,\"HTMLDataElement\":false,\"HTMLDataListElement\":false,\"HTMLDetailsElement\":false,\"HTMLDialogElement\":false,\"HTMLDirectoryElement\":false,\"HTMLDivElement\":false,\"HTMLDListElement\":false,\"HTMLDocument\":false,\"HTMLElement\":false,\"HTMLEmbedElement\":false,\"HTMLFieldSetElement\":false,\"HTMLFontElement\":false,\"HTMLFormControlsCollection\":false,\"HTMLFormElement\":false,\"HTMLFrameElement\":false,\"HTMLFrameSetElement\":false,\"HTMLHeadElement\":false,\"HTMLHeadingElement\":false,\"HTMLHRElement\":false,\"HTMLHtmlElement\":false,\"HTMLIFrameElement\":false,\"HTMLImageElement\":false,\"HTMLInputElement\":false,\"HTMLLabelElement\":false,\"HTMLLegendElement\":false,\"HTMLLIElement\":false,\"HTMLLinkElement\":false,\"HTMLMapElement\":false,\"HTMLMarqueeElement\":false,\"HTMLMediaElement\":false,\"HTMLMenuElement\":false,\"HTMLMetaElement\":false,\"HTMLMeterElement\":false,\"HTMLModElement\":false,\"HTMLObjectElement\":false,\"HTMLOListElement\":false,\"HTMLOptGroupElement\":false,\"HTMLOptionElement\":false,\"HTMLOptionsCollection\":false,\"HTMLOutputElement\":false,\"HTMLParagraphElement\":false,\"HTMLParamElement\":false,\"HTMLPictureElement\":false,\"HTMLPreElement\":false,\"HTMLProgressElement\":false,\"HTMLQuoteElement\":false,\"HTMLScriptElement\":false,\"HTMLSelectElement\":false,\"HTMLShadowElement\":false,\"HTMLSlotElement\":false,\"HTMLSourceElement\":false,\"HTMLSpanElement\":false,\"HTMLStyleElement\":false,\"HTMLTableCaptionElement\":false,\"HTMLTableCellElement\":false,\"HTMLTableColElement\":false,\"HTMLTableElement\":false,\"HTMLTableRowElement\":false,\"HTMLTableSectionElement\":false,\"HTMLTemplateElement\":false,\"HTMLTextAreaElement\":false,\"HTMLTimeElement\":false,\"HTMLTitleElement\":false,\"HTMLTrackElement\":false,\"HTMLUListElement\":false,\"HTMLUnknownElement\":false,\"HTMLVideoElement\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"IdleDeadline\":false,\"IIRFilterNode\":false,\"Image\":false,\"ImageBitmap\":false,\"ImageBitmapRenderingContext\":false,\"ImageCapture\":false,\"ImageData\":false,\"indexedDB\":false,\"innerHeight\":false,\"innerWidth\":false,\"InputEvent\":false,\"IntersectionObserver\":false,\"IntersectionObserverEntry\":false,\"Intl\":false,\"isSecureContext\":false,\"KeyboardEvent\":false,\"KeyframeEffect\":false,\"KeyframeEffectReadOnly\":false,\"length\":false,\"localStorage\":false,\"location\":true,\"Location\":false,\"locationbar\":false,\"matchMedia\":false,\"MediaDeviceInfo\":false,\"MediaDevices\":false,\"MediaElementAudioSourceNode\":false,\"MediaEncryptedEvent\":false,\"MediaError\":false,\"MediaKeyMessageEvent\":false,\"MediaKeySession\":false,\"MediaKeyStatusMap\":false,\"MediaKeySystemAccess\":false,\"MediaList\":false,\"MediaQueryList\":false,\"MediaQueryListEvent\":false,\"MediaRecorder\":false,\"MediaSettingsRange\":false,\"MediaSource\":false,\"MediaStream\":false,\"MediaStreamAudioDestinationNode\":false,\"MediaStreamAudioSourceNode\":false,\"MediaStreamEvent\":false,\"MediaStreamTrack\":false,\"MediaStreamTrackEvent\":false,\"menubar\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"MIDIAccess\":false,\"MIDIConnectionEvent\":false,\"MIDIInput\":false,\"MIDIInputMap\":false,\"MIDIMessageEvent\":false,\"MIDIOutput\":false,\"MIDIOutputMap\":false,\"MIDIPort\":false,\"MimeType\":false,\"MimeTypeArray\":false,\"MouseEvent\":false,\"moveBy\":false,\"moveTo\":false,\"MutationEvent\":false,\"MutationObserver\":false,\"MutationRecord\":false,\"name\":false,\"NamedNodeMap\":false,\"NavigationPreloadManager\":false,\"navigator\":false,\"Navigator\":false,\"NetworkInformation\":false,\"Node\":false,\"NodeFilter\":false,\"NodeIterator\":false,\"NodeList\":false,\"Notification\":false,\"OfflineAudioCompletionEvent\":false,\"OfflineAudioContext\":false,\"offscreenBuffering\":false,\"OffscreenCanvas\":true,\"onabort\":true,\"onafterprint\":true,\"onanimationend\":true,\"onanimationiteration\":true,\"onanimationstart\":true,\"onappinstalled\":true,\"onauxclick\":true,\"onbeforeinstallprompt\":true,\"onbeforeprint\":true,\"onbeforeunload\":true,\"onblur\":true,\"oncancel\":true,\"oncanplay\":true,\"oncanplaythrough\":true,\"onchange\":true,\"onclick\":true,\"onclose\":true,\"oncontextmenu\":true,\"oncuechange\":true,\"ondblclick\":true,\"ondevicemotion\":true,\"ondeviceorientation\":true,\"ondeviceorientationabsolute\":true,\"ondrag\":true,\"ondragend\":true,\"ondragenter\":true,\"ondragleave\":true,\"ondragover\":true,\"ondragstart\":true,\"ondrop\":true,\"ondurationchange\":true,\"onemptied\":true,\"onended\":true,\"onerror\":true,\"onfocus\":true,\"ongotpointercapture\":true,\"onhashchange\":true,\"oninput\":true,\"oninvalid\":true,\"onkeydown\":true,\"onkeypress\":true,\"onkeyup\":true,\"onlanguagechange\":true,\"onload\":true,\"onloadeddata\":true,\"onloadedmetadata\":true,\"onloadstart\":true,\"onlostpointercapture\":true,\"onmessage\":true,\"onmessageerror\":true,\"onmousedown\":true,\"onmouseenter\":true,\"onmouseleave\":true,\"onmousemove\":true,\"onmouseout\":true,\"onmouseover\":true,\"onmouseup\":true,\"onmousewheel\":true,\"onoffline\":true,\"ononline\":true,\"onpagehide\":true,\"onpageshow\":true,\"onpause\":true,\"onplay\":true,\"onplaying\":true,\"onpointercancel\":true,\"onpointerdown\":true,\"onpointerenter\":true,\"onpointerleave\":true,\"onpointermove\":true,\"onpointerout\":true,\"onpointerover\":true,\"onpointerup\":true,\"onpopstate\":true,\"onprogress\":true,\"onratechange\":true,\"onrejectionhandled\":true,\"onreset\":true,\"onresize\":true,\"onscroll\":true,\"onsearch\":true,\"onseeked\":true,\"onseeking\":true,\"onselect\":true,\"onstalled\":true,\"onstorage\":true,\"onsubmit\":true,\"onsuspend\":true,\"ontimeupdate\":true,\"ontoggle\":true,\"ontransitionend\":true,\"onunhandledrejection\":true,\"onunload\":true,\"onvolumechange\":true,\"onwaiting\":true,\"onwheel\":true,\"open\":false,\"openDatabase\":false,\"opener\":false,\"Option\":false,\"origin\":false,\"OscillatorNode\":false,\"outerHeight\":false,\"outerWidth\":false,\"PageTransitionEvent\":false,\"pageXOffset\":false,\"pageYOffset\":false,\"PannerNode\":false,\"parent\":false,\"Path2D\":false,\"PaymentAddress\":false,\"PaymentRequest\":false,\"PaymentRequestUpdateEvent\":false,\"PaymentResponse\":false,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceLongTaskTiming\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceNavigationTiming\":false,\"PerformanceObserver\":false,\"PerformanceObserverEntryList\":false,\"PerformancePaintTiming\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"PeriodicWave\":false,\"Permissions\":false,\"PermissionStatus\":false,\"personalbar\":false,\"PhotoCapabilities\":false,\"Plugin\":false,\"PluginArray\":false,\"PointerEvent\":false,\"PopStateEvent\":false,\"postMessage\":false,\"Presentation\":false,\"PresentationAvailability\":false,\"PresentationConnection\":false,\"PresentationConnectionAvailableEvent\":false,\"PresentationConnectionCloseEvent\":false,\"PresentationConnectionList\":false,\"PresentationReceiver\":false,\"PresentationRequest\":false,\"print\":false,\"ProcessingInstruction\":false,\"ProgressEvent\":false,\"PromiseRejectionEvent\":false,\"prompt\":false,\"PushManager\":false,\"PushSubscription\":false,\"PushSubscriptionOptions\":false,\"queueMicrotask\":false,\"RadioNodeList\":false,\"Range\":false,\"ReadableStream\":false,\"registerProcessor\":false,\"RemotePlayback\":false,\"removeEventListener\":false,\"Request\":false,\"requestAnimationFrame\":false,\"requestIdleCallback\":false,\"resizeBy\":false,\"ResizeObserver\":false,\"ResizeObserverEntry\":false,\"resizeTo\":false,\"Response\":false,\"RTCCertificate\":false,\"RTCDataChannel\":false,\"RTCDataChannelEvent\":false,\"RTCDtlsTransport\":false,\"RTCIceCandidate\":false,\"RTCIceGatherer\":false,\"RTCIceTransport\":false,\"RTCPeerConnection\":false,\"RTCPeerConnectionIceEvent\":false,\"RTCRtpContributingSource\":false,\"RTCRtpReceiver\":false,\"RTCRtpSender\":false,\"RTCSctpTransport\":false,\"RTCSessionDescription\":false,\"RTCStatsReport\":false,\"RTCTrackEvent\":false,\"screen\":false,\"Screen\":false,\"screenLeft\":false,\"ScreenOrientation\":false,\"screenTop\":false,\"screenX\":false,\"screenY\":false,\"ScriptProcessorNode\":false,\"scroll\":false,\"scrollbars\":false,\"scrollBy\":false,\"scrollTo\":false,\"scrollX\":false,\"scrollY\":false,\"SecurityPolicyViolationEvent\":false,\"Selection\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerRegistration\":false,\"sessionStorage\":false,\"setInterval\":false,\"setTimeout\":false,\"ShadowRoot\":false,\"SharedWorker\":false,\"SourceBuffer\":false,\"SourceBufferList\":false,\"speechSynthesis\":false,\"SpeechSynthesisEvent\":false,\"SpeechSynthesisUtterance\":false,\"StaticRange\":false,\"status\":false,\"statusbar\":false,\"StereoPannerNode\":false,\"stop\":false,\"Storage\":false,\"StorageEvent\":false,\"StorageManager\":false,\"styleMedia\":false,\"StyleSheet\":false,\"StyleSheetList\":false,\"SubtleCrypto\":false,\"SVGAElement\":false,\"SVGAngle\":false,\"SVGAnimatedAngle\":false,\"SVGAnimatedBoolean\":false,\"SVGAnimatedEnumeration\":false,\"SVGAnimatedInteger\":false,\"SVGAnimatedLength\":false,\"SVGAnimatedLengthList\":false,\"SVGAnimatedNumber\":false,\"SVGAnimatedNumberList\":false,\"SVGAnimatedPreserveAspectRatio\":false,\"SVGAnimatedRect\":false,\"SVGAnimatedString\":false,\"SVGAnimatedTransformList\":false,\"SVGAnimateElement\":false,\"SVGAnimateMotionElement\":false,\"SVGAnimateTransformElement\":false,\"SVGAnimationElement\":false,\"SVGCircleElement\":false,\"SVGClipPathElement\":false,\"SVGComponentTransferFunctionElement\":false,\"SVGDefsElement\":false,\"SVGDescElement\":false,\"SVGDiscardElement\":false,\"SVGElement\":false,\"SVGEllipseElement\":false,\"SVGFEBlendElement\":false,\"SVGFEColorMatrixElement\":false,\"SVGFEComponentTransferElement\":false,\"SVGFECompositeElement\":false,\"SVGFEConvolveMatrixElement\":false,\"SVGFEDiffuseLightingElement\":false,\"SVGFEDisplacementMapElement\":false,\"SVGFEDistantLightElement\":false,\"SVGFEDropShadowElement\":false,\"SVGFEFloodElement\":false,\"SVGFEFuncAElement\":false,\"SVGFEFuncBElement\":false,\"SVGFEFuncGElement\":false,\"SVGFEFuncRElement\":false,\"SVGFEGaussianBlurElement\":false,\"SVGFEImageElement\":false,\"SVGFEMergeElement\":false,\"SVGFEMergeNodeElement\":false,\"SVGFEMorphologyElement\":false,\"SVGFEOffsetElement\":false,\"SVGFEPointLightElement\":false,\"SVGFESpecularLightingElement\":false,\"SVGFESpotLightElement\":false,\"SVGFETileElement\":false,\"SVGFETurbulenceElement\":false,\"SVGFilterElement\":false,\"SVGForeignObjectElement\":false,\"SVGGElement\":false,\"SVGGeometryElement\":false,\"SVGGradientElement\":false,\"SVGGraphicsElement\":false,\"SVGImageElement\":false,\"SVGLength\":false,\"SVGLengthList\":false,\"SVGLinearGradientElement\":false,\"SVGLineElement\":false,\"SVGMarkerElement\":false,\"SVGMaskElement\":false,\"SVGMatrix\":false,\"SVGMetadataElement\":false,\"SVGMPathElement\":false,\"SVGNumber\":false,\"SVGNumberList\":false,\"SVGPathElement\":false,\"SVGPatternElement\":false,\"SVGPoint\":false,\"SVGPointList\":false,\"SVGPolygonElement\":false,\"SVGPolylineElement\":false,\"SVGPreserveAspectRatio\":false,\"SVGRadialGradientElement\":false,\"SVGRect\":false,\"SVGRectElement\":false,\"SVGScriptElement\":false,\"SVGSetElement\":false,\"SVGStopElement\":false,\"SVGStringList\":false,\"SVGStyleElement\":false,\"SVGSVGElement\":false,\"SVGSwitchElement\":false,\"SVGSymbolElement\":false,\"SVGTextContentElement\":false,\"SVGTextElement\":false,\"SVGTextPathElement\":false,\"SVGTextPositioningElement\":false,\"SVGTitleElement\":false,\"SVGTransform\":false,\"SVGTransformList\":false,\"SVGTSpanElement\":false,\"SVGUnitTypes\":false,\"SVGUseElement\":false,\"SVGViewElement\":false,\"TaskAttributionTiming\":false,\"Text\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"TextEvent\":false,\"TextMetrics\":false,\"TextTrack\":false,\"TextTrackCue\":false,\"TextTrackCueList\":false,\"TextTrackList\":false,\"TimeRanges\":false,\"toolbar\":false,\"top\":false,\"Touch\":false,\"TouchEvent\":false,\"TouchList\":false,\"TrackEvent\":false,\"TransitionEvent\":false,\"TreeWalker\":false,\"UIEvent\":false,\"URL\":false,\"URLSearchParams\":false,\"ValidityState\":false,\"visualViewport\":false,\"VisualViewport\":false,\"VTTCue\":false,\"WaveShaperNode\":false,\"WebAssembly\":false,\"WebGL2RenderingContext\":false,\"WebGLActiveInfo\":false,\"WebGLBuffer\":false,\"WebGLContextEvent\":false,\"WebGLFramebuffer\":false,\"WebGLProgram\":false,\"WebGLQuery\":false,\"WebGLRenderbuffer\":false,\"WebGLRenderingContext\":false,\"WebGLSampler\":false,\"WebGLShader\":false,\"WebGLShaderPrecisionFormat\":false,\"WebGLSync\":false,\"WebGLTexture\":false,\"WebGLTransformFeedback\":false,\"WebGLUniformLocation\":false,\"WebGLVertexArrayObject\":false,\"WebSocket\":false,\"WheelEvent\":false,\"window\":false,\"Window\":false,\"Worker\":false,\"WritableStream\":false,\"XMLDocument\":false,\"XMLHttpRequest\":false,\"XMLHttpRequestEventTarget\":false,\"XMLHttpRequestUpload\":false,\"XMLSerializer\":false,\"XPathEvaluator\":false,\"XPathExpression\":false,\"XPathResult\":false,\"XSLTProcessor\":false},\"worker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"clearInterval\":false,\"clearTimeout\":false,\"close\":true,\"console\":false,\"fetch\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":true,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onoffline\":true,\"ononline\":true,\"onrejectionhandled\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":true,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"node\":{\"__dirname\":false,\"__filename\":false,\"Buffer\":false,\"clearImmediate\":false,\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"exports\":true,\"global\":false,\"Intl\":false,\"module\":false,\"process\":false,\"queueMicrotask\":false,\"require\":false,\"setImmediate\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false},\"commonjs\":{\"exports\":true,\"global\":false,\"module\":false,\"require\":false},\"amd\":{\"define\":false,\"require\":false},\"mocha\":{\"after\":false,\"afterEach\":false,\"before\":false,\"beforeEach\":false,\"context\":false,\"describe\":false,\"it\":false,\"mocha\":false,\"run\":false,\"setup\":false,\"specify\":false,\"suite\":false,\"suiteSetup\":false,\"suiteTeardown\":false,\"teardown\":false,\"test\":false,\"xcontext\":false,\"xdescribe\":false,\"xit\":false,\"xspecify\":false},\"jasmine\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"fail\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jasmine\":false,\"pending\":false,\"runs\":false,\"spyOn\":false,\"spyOnProperty\":false,\"waits\":false,\"waitsFor\":false,\"xdescribe\":false,\"xit\":false},\"jest\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jest\":false,\"pit\":false,\"require\":false,\"test\":false,\"xdescribe\":false,\"xit\":false,\"xtest\":false},\"qunit\":{\"asyncTest\":false,\"deepEqual\":false,\"equal\":false,\"expect\":false,\"module\":false,\"notDeepEqual\":false,\"notEqual\":false,\"notOk\":false,\"notPropEqual\":false,\"notStrictEqual\":false,\"ok\":false,\"propEqual\":false,\"QUnit\":false,\"raises\":false,\"start\":false,\"stop\":false,\"strictEqual\":false,\"test\":false,\"throws\":false},\"phantomjs\":{\"console\":true,\"exports\":true,\"phantom\":true,\"require\":true,\"WebPage\":true},\"couch\":{\"emit\":false,\"exports\":false,\"getRow\":false,\"log\":false,\"module\":false,\"provides\":false,\"require\":false,\"respond\":false,\"send\":false,\"start\":false,\"sum\":false},\"rhino\":{\"defineClass\":false,\"deserialize\":false,\"gc\":false,\"help\":false,\"importClass\":false,\"importPackage\":false,\"java\":false,\"load\":false,\"loadClass\":false,\"Packages\":false,\"print\":false,\"quit\":false,\"readFile\":false,\"readUrl\":false,\"runCommand\":false,\"seal\":false,\"serialize\":false,\"spawn\":false,\"sync\":false,\"toint32\":false,\"version\":false},\"nashorn\":{\"__DIR__\":false,\"__FILE__\":false,\"__LINE__\":false,\"com\":false,\"edu\":false,\"exit\":false,\"java\":false,\"Java\":false,\"javafx\":false,\"JavaImporter\":false,\"javax\":false,\"JSAdapter\":false,\"load\":false,\"loadWithNewGlobal\":false,\"org\":false,\"Packages\":false,\"print\":false,\"quit\":false},\"wsh\":{\"ActiveXObject\":true,\"Enumerator\":true,\"GetObject\":true,\"ScriptEngine\":true,\"ScriptEngineBuildVersion\":true,\"ScriptEngineMajorVersion\":true,\"ScriptEngineMinorVersion\":true,\"VBArray\":true,\"WScript\":true,\"WSH\":true,\"XDomainRequest\":true},\"jquery\":{\"$\":false,\"jQuery\":false},\"yui\":{\"YAHOO\":false,\"YAHOO_config\":false,\"YUI\":false,\"YUI_config\":false},\"shelljs\":{\"cat\":false,\"cd\":false,\"chmod\":false,\"config\":false,\"cp\":false,\"dirs\":false,\"echo\":false,\"env\":false,\"error\":false,\"exec\":false,\"exit\":false,\"find\":false,\"grep\":false,\"ln\":false,\"ls\":false,\"mkdir\":false,\"mv\":false,\"popd\":false,\"pushd\":false,\"pwd\":false,\"rm\":false,\"sed\":false,\"set\":false,\"target\":false,\"tempdir\":false,\"test\":false,\"touch\":false,\"which\":false},\"prototypejs\":{\"$\":false,\"$$\":false,\"$A\":false,\"$break\":false,\"$continue\":false,\"$F\":false,\"$H\":false,\"$R\":false,\"$w\":false,\"Abstract\":false,\"Ajax\":false,\"Autocompleter\":false,\"Builder\":false,\"Class\":false,\"Control\":false,\"Draggable\":false,\"Draggables\":false,\"Droppables\":false,\"Effect\":false,\"Element\":false,\"Enumerable\":false,\"Event\":false,\"Field\":false,\"Form\":false,\"Hash\":false,\"Insertion\":false,\"ObjectRange\":false,\"PeriodicalExecuter\":false,\"Position\":false,\"Prototype\":false,\"Scriptaculous\":false,\"Selector\":false,\"Sortable\":false,\"SortableObserver\":false,\"Sound\":false,\"Template\":false,\"Toggle\":false,\"Try\":false},\"meteor\":{\"_\":false,\"$\":false,\"Accounts\":false,\"AccountsClient\":false,\"AccountsCommon\":false,\"AccountsServer\":false,\"App\":false,\"Assets\":false,\"Blaze\":false,\"check\":false,\"Cordova\":false,\"DDP\":false,\"DDPRateLimiter\":false,\"DDPServer\":false,\"Deps\":false,\"EJSON\":false,\"Email\":false,\"HTTP\":false,\"Log\":false,\"Match\":false,\"Meteor\":false,\"Mongo\":false,\"MongoInternals\":false,\"Npm\":false,\"Package\":false,\"Plugin\":false,\"process\":false,\"Random\":false,\"ReactiveDict\":false,\"ReactiveVar\":false,\"Router\":false,\"ServiceConfiguration\":false,\"Session\":false,\"share\":false,\"Spacebars\":false,\"Template\":false,\"Tinytest\":false,\"Tracker\":false,\"UI\":false,\"Utils\":false,\"WebApp\":false,\"WebAppInternals\":false},\"mongo\":{\"_isWindows\":false,\"_rand\":false,\"BulkWriteResult\":false,\"cat\":false,\"cd\":false,\"connect\":false,\"db\":false,\"getHostName\":false,\"getMemInfo\":false,\"hostname\":false,\"ISODate\":false,\"listFiles\":false,\"load\":false,\"ls\":false,\"md5sumFile\":false,\"mkdir\":false,\"Mongo\":false,\"NumberInt\":false,\"NumberLong\":false,\"ObjectId\":false,\"PlanCache\":false,\"print\":false,\"printjson\":false,\"pwd\":false,\"quit\":false,\"removeFile\":false,\"rs\":false,\"sh\":false,\"UUID\":false,\"version\":false,\"WriteResult\":false},\"applescript\":{\"$\":false,\"Application\":false,\"Automation\":false,\"console\":false,\"delay\":false,\"Library\":false,\"ObjC\":false,\"ObjectSpecifier\":false,\"Path\":false,\"Progress\":false,\"Ref\":false},\"serviceworker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"clearInterval\":false,\"clearTimeout\":false,\"Client\":false,\"clients\":false,\"Clients\":false,\"close\":true,\"console\":false,\"ExtendableEvent\":false,\"ExtendableMessageEvent\":false,\"fetch\":false,\"FetchEvent\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":false,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onfetch\":true,\"oninstall\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onmessageerror\":true,\"onnotificationclick\":true,\"onnotificationclose\":true,\"onoffline\":true,\"ononline\":true,\"onpush\":true,\"onpushsubscriptionchange\":true,\"onrejectionhandled\":true,\"onsync\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"registration\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerGlobalScope\":false,\"ServiceWorkerMessageEvent\":false,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"skipWaiting\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"WindowClient\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"atomtest\":{\"advanceClock\":false,\"fakeClearInterval\":false,\"fakeClearTimeout\":false,\"fakeSetInterval\":false,\"fakeSetTimeout\":false,\"resetTimeouts\":false,\"waitsForPromise\":false},\"embertest\":{\"andThen\":false,\"click\":false,\"currentPath\":false,\"currentRouteName\":false,\"currentURL\":false,\"fillIn\":false,\"find\":false,\"findAll\":false,\"findWithAssert\":false,\"keyEvent\":false,\"pauseTest\":false,\"resumeTest\":false,\"triggerEvent\":false,\"visit\":false,\"wait\":false},\"protractor\":{\"$\":false,\"$$\":false,\"browser\":false,\"by\":false,\"By\":false,\"DartObject\":false,\"element\":false,\"protractor\":false},\"shared-node-browser\":{\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"setInterval\":false,\"setTimeout\":false,\"URL\":false,\"URLSearchParams\":false},\"webextensions\":{\"browser\":false,\"chrome\":false,\"opr\":false},\"greasemonkey\":{\"cloneInto\":false,\"createObjectIn\":false,\"exportFunction\":false,\"GM\":false,\"GM_addStyle\":false,\"GM_deleteValue\":false,\"GM_getResourceText\":false,\"GM_getResourceURL\":false,\"GM_getValue\":false,\"GM_info\":false,\"GM_listValues\":false,\"GM_log\":false,\"GM_openInTab\":false,\"GM_registerMenuCommand\":false,\"GM_setClipboard\":false,\"GM_setValue\":false,\"GM_xmlhttpRequest\":false,\"unsafeWindow\":false},\"devtools\":{\"$\":false,\"$_\":false,\"$$\":false,\"$0\":false,\"$1\":false,\"$2\":false,\"$3\":false,\"$4\":false,\"$x\":false,\"chrome\":false,\"clear\":false,\"copy\":false,\"debug\":false,\"dir\":false,\"dirxml\":false,\"getEventListeners\":false,\"inspect\":false,\"keys\":false,\"monitor\":false,\"monitorEvents\":false,\"profile\":false,\"profileEnd\":false,\"queryObjects\":false,\"table\":false,\"undebug\":false,\"unmonitor\":false,\"unmonitorEvents\":false,\"values\":false}}"));}}),
"[project]/node_modules/@babel/traverse/node_modules/globals/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = __turbopack_require__("[project]/node_modules/@babel/traverse/node_modules/globals/globals.json (json)");
}}),
"[project]/node_modules/@babel/plugin-transform-classes/node_modules/globals/globals.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"builtin\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"BigInt\":false,\"BigInt64Array\":false,\"BigUint64Array\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"globalThis\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es5\":{\"Array\":false,\"Boolean\":false,\"constructor\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"propertyIsEnumerable\":false,\"RangeError\":false,\"ReferenceError\":false,\"RegExp\":false,\"String\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false},\"es2015\":{\"Array\":false,\"ArrayBuffer\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"es2017\":{\"Array\":false,\"ArrayBuffer\":false,\"Atomics\":false,\"Boolean\":false,\"constructor\":false,\"DataView\":false,\"Date\":false,\"decodeURI\":false,\"decodeURIComponent\":false,\"encodeURI\":false,\"encodeURIComponent\":false,\"Error\":false,\"escape\":false,\"eval\":false,\"EvalError\":false,\"Float32Array\":false,\"Float64Array\":false,\"Function\":false,\"hasOwnProperty\":false,\"Infinity\":false,\"Int16Array\":false,\"Int32Array\":false,\"Int8Array\":false,\"isFinite\":false,\"isNaN\":false,\"isPrototypeOf\":false,\"JSON\":false,\"Map\":false,\"Math\":false,\"NaN\":false,\"Number\":false,\"Object\":false,\"parseFloat\":false,\"parseInt\":false,\"Promise\":false,\"propertyIsEnumerable\":false,\"Proxy\":false,\"RangeError\":false,\"ReferenceError\":false,\"Reflect\":false,\"RegExp\":false,\"Set\":false,\"SharedArrayBuffer\":false,\"String\":false,\"Symbol\":false,\"SyntaxError\":false,\"toLocaleString\":false,\"toString\":false,\"TypeError\":false,\"Uint16Array\":false,\"Uint32Array\":false,\"Uint8Array\":false,\"Uint8ClampedArray\":false,\"undefined\":false,\"unescape\":false,\"URIError\":false,\"valueOf\":false,\"WeakMap\":false,\"WeakSet\":false},\"browser\":{\"AbortController\":false,\"AbortSignal\":false,\"addEventListener\":false,\"alert\":false,\"AnalyserNode\":false,\"Animation\":false,\"AnimationEffectReadOnly\":false,\"AnimationEffectTiming\":false,\"AnimationEffectTimingReadOnly\":false,\"AnimationEvent\":false,\"AnimationPlaybackEvent\":false,\"AnimationTimeline\":false,\"applicationCache\":false,\"ApplicationCache\":false,\"ApplicationCacheErrorEvent\":false,\"atob\":false,\"Attr\":false,\"Audio\":false,\"AudioBuffer\":false,\"AudioBufferSourceNode\":false,\"AudioContext\":false,\"AudioDestinationNode\":false,\"AudioListener\":false,\"AudioNode\":false,\"AudioParam\":false,\"AudioProcessingEvent\":false,\"AudioScheduledSourceNode\":false,\"AudioWorkletGlobalScope \":false,\"AudioWorkletNode\":false,\"AudioWorkletProcessor\":false,\"BarProp\":false,\"BaseAudioContext\":false,\"BatteryManager\":false,\"BeforeUnloadEvent\":false,\"BiquadFilterNode\":false,\"Blob\":false,\"BlobEvent\":false,\"blur\":false,\"BroadcastChannel\":false,\"btoa\":false,\"BudgetService\":false,\"ByteLengthQueuingStrategy\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"cancelAnimationFrame\":false,\"cancelIdleCallback\":false,\"CanvasCaptureMediaStreamTrack\":false,\"CanvasGradient\":false,\"CanvasPattern\":false,\"CanvasRenderingContext2D\":false,\"ChannelMergerNode\":false,\"ChannelSplitterNode\":false,\"CharacterData\":false,\"clearInterval\":false,\"clearTimeout\":false,\"clientInformation\":false,\"ClipboardEvent\":false,\"close\":false,\"closed\":false,\"CloseEvent\":false,\"Comment\":false,\"CompositionEvent\":false,\"confirm\":false,\"console\":false,\"ConstantSourceNode\":false,\"ConvolverNode\":false,\"CountQueuingStrategy\":false,\"createImageBitmap\":false,\"Credential\":false,\"CredentialsContainer\":false,\"crypto\":false,\"Crypto\":false,\"CryptoKey\":false,\"CSS\":false,\"CSSConditionRule\":false,\"CSSFontFaceRule\":false,\"CSSGroupingRule\":false,\"CSSImportRule\":false,\"CSSKeyframeRule\":false,\"CSSKeyframesRule\":false,\"CSSMediaRule\":false,\"CSSNamespaceRule\":false,\"CSSPageRule\":false,\"CSSRule\":false,\"CSSRuleList\":false,\"CSSStyleDeclaration\":false,\"CSSStyleRule\":false,\"CSSStyleSheet\":false,\"CSSSupportsRule\":false,\"CustomElementRegistry\":false,\"customElements\":false,\"CustomEvent\":false,\"DataTransfer\":false,\"DataTransferItem\":false,\"DataTransferItemList\":false,\"defaultstatus\":false,\"defaultStatus\":false,\"DelayNode\":false,\"DeviceMotionEvent\":false,\"DeviceOrientationEvent\":false,\"devicePixelRatio\":false,\"dispatchEvent\":false,\"document\":false,\"Document\":false,\"DocumentFragment\":false,\"DocumentType\":false,\"DOMError\":false,\"DOMException\":false,\"DOMImplementation\":false,\"DOMMatrix\":false,\"DOMMatrixReadOnly\":false,\"DOMParser\":false,\"DOMPoint\":false,\"DOMPointReadOnly\":false,\"DOMQuad\":false,\"DOMRect\":false,\"DOMRectReadOnly\":false,\"DOMStringList\":false,\"DOMStringMap\":false,\"DOMTokenList\":false,\"DragEvent\":false,\"DynamicsCompressorNode\":false,\"Element\":false,\"ErrorEvent\":false,\"event\":false,\"Event\":false,\"EventSource\":false,\"EventTarget\":false,\"external\":false,\"fetch\":false,\"File\":false,\"FileList\":false,\"FileReader\":false,\"find\":false,\"focus\":false,\"FocusEvent\":false,\"FontFace\":false,\"FontFaceSetLoadEvent\":false,\"FormData\":false,\"frameElement\":false,\"frames\":false,\"GainNode\":false,\"Gamepad\":false,\"GamepadButton\":false,\"GamepadEvent\":false,\"getComputedStyle\":false,\"getSelection\":false,\"HashChangeEvent\":false,\"Headers\":false,\"history\":false,\"History\":false,\"HTMLAllCollection\":false,\"HTMLAnchorElement\":false,\"HTMLAreaElement\":false,\"HTMLAudioElement\":false,\"HTMLBaseElement\":false,\"HTMLBodyElement\":false,\"HTMLBRElement\":false,\"HTMLButtonElement\":false,\"HTMLCanvasElement\":false,\"HTMLCollection\":false,\"HTMLContentElement\":false,\"HTMLDataElement\":false,\"HTMLDataListElement\":false,\"HTMLDetailsElement\":false,\"HTMLDialogElement\":false,\"HTMLDirectoryElement\":false,\"HTMLDivElement\":false,\"HTMLDListElement\":false,\"HTMLDocument\":false,\"HTMLElement\":false,\"HTMLEmbedElement\":false,\"HTMLFieldSetElement\":false,\"HTMLFontElement\":false,\"HTMLFormControlsCollection\":false,\"HTMLFormElement\":false,\"HTMLFrameElement\":false,\"HTMLFrameSetElement\":false,\"HTMLHeadElement\":false,\"HTMLHeadingElement\":false,\"HTMLHRElement\":false,\"HTMLHtmlElement\":false,\"HTMLIFrameElement\":false,\"HTMLImageElement\":false,\"HTMLInputElement\":false,\"HTMLLabelElement\":false,\"HTMLLegendElement\":false,\"HTMLLIElement\":false,\"HTMLLinkElement\":false,\"HTMLMapElement\":false,\"HTMLMarqueeElement\":false,\"HTMLMediaElement\":false,\"HTMLMenuElement\":false,\"HTMLMetaElement\":false,\"HTMLMeterElement\":false,\"HTMLModElement\":false,\"HTMLObjectElement\":false,\"HTMLOListElement\":false,\"HTMLOptGroupElement\":false,\"HTMLOptionElement\":false,\"HTMLOptionsCollection\":false,\"HTMLOutputElement\":false,\"HTMLParagraphElement\":false,\"HTMLParamElement\":false,\"HTMLPictureElement\":false,\"HTMLPreElement\":false,\"HTMLProgressElement\":false,\"HTMLQuoteElement\":false,\"HTMLScriptElement\":false,\"HTMLSelectElement\":false,\"HTMLShadowElement\":false,\"HTMLSlotElement\":false,\"HTMLSourceElement\":false,\"HTMLSpanElement\":false,\"HTMLStyleElement\":false,\"HTMLTableCaptionElement\":false,\"HTMLTableCellElement\":false,\"HTMLTableColElement\":false,\"HTMLTableElement\":false,\"HTMLTableRowElement\":false,\"HTMLTableSectionElement\":false,\"HTMLTemplateElement\":false,\"HTMLTextAreaElement\":false,\"HTMLTimeElement\":false,\"HTMLTitleElement\":false,\"HTMLTrackElement\":false,\"HTMLUListElement\":false,\"HTMLUnknownElement\":false,\"HTMLVideoElement\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"IdleDeadline\":false,\"IIRFilterNode\":false,\"Image\":false,\"ImageBitmap\":false,\"ImageBitmapRenderingContext\":false,\"ImageCapture\":false,\"ImageData\":false,\"indexedDB\":false,\"innerHeight\":false,\"innerWidth\":false,\"InputEvent\":false,\"IntersectionObserver\":false,\"IntersectionObserverEntry\":false,\"Intl\":false,\"isSecureContext\":false,\"KeyboardEvent\":false,\"KeyframeEffect\":false,\"KeyframeEffectReadOnly\":false,\"length\":false,\"localStorage\":false,\"location\":true,\"Location\":false,\"locationbar\":false,\"matchMedia\":false,\"MediaDeviceInfo\":false,\"MediaDevices\":false,\"MediaElementAudioSourceNode\":false,\"MediaEncryptedEvent\":false,\"MediaError\":false,\"MediaKeyMessageEvent\":false,\"MediaKeySession\":false,\"MediaKeyStatusMap\":false,\"MediaKeySystemAccess\":false,\"MediaList\":false,\"MediaQueryList\":false,\"MediaQueryListEvent\":false,\"MediaRecorder\":false,\"MediaSettingsRange\":false,\"MediaSource\":false,\"MediaStream\":false,\"MediaStreamAudioDestinationNode\":false,\"MediaStreamAudioSourceNode\":false,\"MediaStreamEvent\":false,\"MediaStreamTrack\":false,\"MediaStreamTrackEvent\":false,\"menubar\":false,\"MessageChannel\":false,\"MessageEvent\":false,\"MessagePort\":false,\"MIDIAccess\":false,\"MIDIConnectionEvent\":false,\"MIDIInput\":false,\"MIDIInputMap\":false,\"MIDIMessageEvent\":false,\"MIDIOutput\":false,\"MIDIOutputMap\":false,\"MIDIPort\":false,\"MimeType\":false,\"MimeTypeArray\":false,\"MouseEvent\":false,\"moveBy\":false,\"moveTo\":false,\"MutationEvent\":false,\"MutationObserver\":false,\"MutationRecord\":false,\"name\":false,\"NamedNodeMap\":false,\"NavigationPreloadManager\":false,\"navigator\":false,\"Navigator\":false,\"NetworkInformation\":false,\"Node\":false,\"NodeFilter\":false,\"NodeIterator\":false,\"NodeList\":false,\"Notification\":false,\"OfflineAudioCompletionEvent\":false,\"OfflineAudioContext\":false,\"offscreenBuffering\":false,\"OffscreenCanvas\":true,\"onabort\":true,\"onafterprint\":true,\"onanimationend\":true,\"onanimationiteration\":true,\"onanimationstart\":true,\"onappinstalled\":true,\"onauxclick\":true,\"onbeforeinstallprompt\":true,\"onbeforeprint\":true,\"onbeforeunload\":true,\"onblur\":true,\"oncancel\":true,\"oncanplay\":true,\"oncanplaythrough\":true,\"onchange\":true,\"onclick\":true,\"onclose\":true,\"oncontextmenu\":true,\"oncuechange\":true,\"ondblclick\":true,\"ondevicemotion\":true,\"ondeviceorientation\":true,\"ondeviceorientationabsolute\":true,\"ondrag\":true,\"ondragend\":true,\"ondragenter\":true,\"ondragleave\":true,\"ondragover\":true,\"ondragstart\":true,\"ondrop\":true,\"ondurationchange\":true,\"onemptied\":true,\"onended\":true,\"onerror\":true,\"onfocus\":true,\"ongotpointercapture\":true,\"onhashchange\":true,\"oninput\":true,\"oninvalid\":true,\"onkeydown\":true,\"onkeypress\":true,\"onkeyup\":true,\"onlanguagechange\":true,\"onload\":true,\"onloadeddata\":true,\"onloadedmetadata\":true,\"onloadstart\":true,\"onlostpointercapture\":true,\"onmessage\":true,\"onmessageerror\":true,\"onmousedown\":true,\"onmouseenter\":true,\"onmouseleave\":true,\"onmousemove\":true,\"onmouseout\":true,\"onmouseover\":true,\"onmouseup\":true,\"onmousewheel\":true,\"onoffline\":true,\"ononline\":true,\"onpagehide\":true,\"onpageshow\":true,\"onpause\":true,\"onplay\":true,\"onplaying\":true,\"onpointercancel\":true,\"onpointerdown\":true,\"onpointerenter\":true,\"onpointerleave\":true,\"onpointermove\":true,\"onpointerout\":true,\"onpointerover\":true,\"onpointerup\":true,\"onpopstate\":true,\"onprogress\":true,\"onratechange\":true,\"onrejectionhandled\":true,\"onreset\":true,\"onresize\":true,\"onscroll\":true,\"onsearch\":true,\"onseeked\":true,\"onseeking\":true,\"onselect\":true,\"onstalled\":true,\"onstorage\":true,\"onsubmit\":true,\"onsuspend\":true,\"ontimeupdate\":true,\"ontoggle\":true,\"ontransitionend\":true,\"onunhandledrejection\":true,\"onunload\":true,\"onvolumechange\":true,\"onwaiting\":true,\"onwheel\":true,\"open\":false,\"openDatabase\":false,\"opener\":false,\"Option\":false,\"origin\":false,\"OscillatorNode\":false,\"outerHeight\":false,\"outerWidth\":false,\"PageTransitionEvent\":false,\"pageXOffset\":false,\"pageYOffset\":false,\"PannerNode\":false,\"parent\":false,\"Path2D\":false,\"PaymentAddress\":false,\"PaymentRequest\":false,\"PaymentRequestUpdateEvent\":false,\"PaymentResponse\":false,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceLongTaskTiming\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceNavigationTiming\":false,\"PerformanceObserver\":false,\"PerformanceObserverEntryList\":false,\"PerformancePaintTiming\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"PeriodicWave\":false,\"Permissions\":false,\"PermissionStatus\":false,\"personalbar\":false,\"PhotoCapabilities\":false,\"Plugin\":false,\"PluginArray\":false,\"PointerEvent\":false,\"PopStateEvent\":false,\"postMessage\":false,\"Presentation\":false,\"PresentationAvailability\":false,\"PresentationConnection\":false,\"PresentationConnectionAvailableEvent\":false,\"PresentationConnectionCloseEvent\":false,\"PresentationConnectionList\":false,\"PresentationReceiver\":false,\"PresentationRequest\":false,\"print\":false,\"ProcessingInstruction\":false,\"ProgressEvent\":false,\"PromiseRejectionEvent\":false,\"prompt\":false,\"PushManager\":false,\"PushSubscription\":false,\"PushSubscriptionOptions\":false,\"queueMicrotask\":false,\"RadioNodeList\":false,\"Range\":false,\"ReadableStream\":false,\"registerProcessor\":false,\"RemotePlayback\":false,\"removeEventListener\":false,\"Request\":false,\"requestAnimationFrame\":false,\"requestIdleCallback\":false,\"resizeBy\":false,\"ResizeObserver\":false,\"ResizeObserverEntry\":false,\"resizeTo\":false,\"Response\":false,\"RTCCertificate\":false,\"RTCDataChannel\":false,\"RTCDataChannelEvent\":false,\"RTCDtlsTransport\":false,\"RTCIceCandidate\":false,\"RTCIceGatherer\":false,\"RTCIceTransport\":false,\"RTCPeerConnection\":false,\"RTCPeerConnectionIceEvent\":false,\"RTCRtpContributingSource\":false,\"RTCRtpReceiver\":false,\"RTCRtpSender\":false,\"RTCSctpTransport\":false,\"RTCSessionDescription\":false,\"RTCStatsReport\":false,\"RTCTrackEvent\":false,\"screen\":false,\"Screen\":false,\"screenLeft\":false,\"ScreenOrientation\":false,\"screenTop\":false,\"screenX\":false,\"screenY\":false,\"ScriptProcessorNode\":false,\"scroll\":false,\"scrollbars\":false,\"scrollBy\":false,\"scrollTo\":false,\"scrollX\":false,\"scrollY\":false,\"SecurityPolicyViolationEvent\":false,\"Selection\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerRegistration\":false,\"sessionStorage\":false,\"setInterval\":false,\"setTimeout\":false,\"ShadowRoot\":false,\"SharedWorker\":false,\"SourceBuffer\":false,\"SourceBufferList\":false,\"speechSynthesis\":false,\"SpeechSynthesisEvent\":false,\"SpeechSynthesisUtterance\":false,\"StaticRange\":false,\"status\":false,\"statusbar\":false,\"StereoPannerNode\":false,\"stop\":false,\"Storage\":false,\"StorageEvent\":false,\"StorageManager\":false,\"styleMedia\":false,\"StyleSheet\":false,\"StyleSheetList\":false,\"SubtleCrypto\":false,\"SVGAElement\":false,\"SVGAngle\":false,\"SVGAnimatedAngle\":false,\"SVGAnimatedBoolean\":false,\"SVGAnimatedEnumeration\":false,\"SVGAnimatedInteger\":false,\"SVGAnimatedLength\":false,\"SVGAnimatedLengthList\":false,\"SVGAnimatedNumber\":false,\"SVGAnimatedNumberList\":false,\"SVGAnimatedPreserveAspectRatio\":false,\"SVGAnimatedRect\":false,\"SVGAnimatedString\":false,\"SVGAnimatedTransformList\":false,\"SVGAnimateElement\":false,\"SVGAnimateMotionElement\":false,\"SVGAnimateTransformElement\":false,\"SVGAnimationElement\":false,\"SVGCircleElement\":false,\"SVGClipPathElement\":false,\"SVGComponentTransferFunctionElement\":false,\"SVGDefsElement\":false,\"SVGDescElement\":false,\"SVGDiscardElement\":false,\"SVGElement\":false,\"SVGEllipseElement\":false,\"SVGFEBlendElement\":false,\"SVGFEColorMatrixElement\":false,\"SVGFEComponentTransferElement\":false,\"SVGFECompositeElement\":false,\"SVGFEConvolveMatrixElement\":false,\"SVGFEDiffuseLightingElement\":false,\"SVGFEDisplacementMapElement\":false,\"SVGFEDistantLightElement\":false,\"SVGFEDropShadowElement\":false,\"SVGFEFloodElement\":false,\"SVGFEFuncAElement\":false,\"SVGFEFuncBElement\":false,\"SVGFEFuncGElement\":false,\"SVGFEFuncRElement\":false,\"SVGFEGaussianBlurElement\":false,\"SVGFEImageElement\":false,\"SVGFEMergeElement\":false,\"SVGFEMergeNodeElement\":false,\"SVGFEMorphologyElement\":false,\"SVGFEOffsetElement\":false,\"SVGFEPointLightElement\":false,\"SVGFESpecularLightingElement\":false,\"SVGFESpotLightElement\":false,\"SVGFETileElement\":false,\"SVGFETurbulenceElement\":false,\"SVGFilterElement\":false,\"SVGForeignObjectElement\":false,\"SVGGElement\":false,\"SVGGeometryElement\":false,\"SVGGradientElement\":false,\"SVGGraphicsElement\":false,\"SVGImageElement\":false,\"SVGLength\":false,\"SVGLengthList\":false,\"SVGLinearGradientElement\":false,\"SVGLineElement\":false,\"SVGMarkerElement\":false,\"SVGMaskElement\":false,\"SVGMatrix\":false,\"SVGMetadataElement\":false,\"SVGMPathElement\":false,\"SVGNumber\":false,\"SVGNumberList\":false,\"SVGPathElement\":false,\"SVGPatternElement\":false,\"SVGPoint\":false,\"SVGPointList\":false,\"SVGPolygonElement\":false,\"SVGPolylineElement\":false,\"SVGPreserveAspectRatio\":false,\"SVGRadialGradientElement\":false,\"SVGRect\":false,\"SVGRectElement\":false,\"SVGScriptElement\":false,\"SVGSetElement\":false,\"SVGStopElement\":false,\"SVGStringList\":false,\"SVGStyleElement\":false,\"SVGSVGElement\":false,\"SVGSwitchElement\":false,\"SVGSymbolElement\":false,\"SVGTextContentElement\":false,\"SVGTextElement\":false,\"SVGTextPathElement\":false,\"SVGTextPositioningElement\":false,\"SVGTitleElement\":false,\"SVGTransform\":false,\"SVGTransformList\":false,\"SVGTSpanElement\":false,\"SVGUnitTypes\":false,\"SVGUseElement\":false,\"SVGViewElement\":false,\"TaskAttributionTiming\":false,\"Text\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"TextEvent\":false,\"TextMetrics\":false,\"TextTrack\":false,\"TextTrackCue\":false,\"TextTrackCueList\":false,\"TextTrackList\":false,\"TimeRanges\":false,\"toolbar\":false,\"top\":false,\"Touch\":false,\"TouchEvent\":false,\"TouchList\":false,\"TrackEvent\":false,\"TransitionEvent\":false,\"TreeWalker\":false,\"UIEvent\":false,\"URL\":false,\"URLSearchParams\":false,\"ValidityState\":false,\"visualViewport\":false,\"VisualViewport\":false,\"VTTCue\":false,\"WaveShaperNode\":false,\"WebAssembly\":false,\"WebGL2RenderingContext\":false,\"WebGLActiveInfo\":false,\"WebGLBuffer\":false,\"WebGLContextEvent\":false,\"WebGLFramebuffer\":false,\"WebGLProgram\":false,\"WebGLQuery\":false,\"WebGLRenderbuffer\":false,\"WebGLRenderingContext\":false,\"WebGLSampler\":false,\"WebGLShader\":false,\"WebGLShaderPrecisionFormat\":false,\"WebGLSync\":false,\"WebGLTexture\":false,\"WebGLTransformFeedback\":false,\"WebGLUniformLocation\":false,\"WebGLVertexArrayObject\":false,\"WebSocket\":false,\"WheelEvent\":false,\"window\":false,\"Window\":false,\"Worker\":false,\"WritableStream\":false,\"XMLDocument\":false,\"XMLHttpRequest\":false,\"XMLHttpRequestEventTarget\":false,\"XMLHttpRequestUpload\":false,\"XMLSerializer\":false,\"XPathEvaluator\":false,\"XPathExpression\":false,\"XPathResult\":false,\"XSLTProcessor\":false},\"worker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"clearInterval\":false,\"clearTimeout\":false,\"close\":true,\"console\":false,\"fetch\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":true,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onoffline\":true,\"ononline\":true,\"onrejectionhandled\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":true,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"node\":{\"__dirname\":false,\"__filename\":false,\"Buffer\":false,\"clearImmediate\":false,\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"exports\":true,\"global\":false,\"Intl\":false,\"module\":false,\"process\":false,\"queueMicrotask\":false,\"require\":false,\"setImmediate\":false,\"setInterval\":false,\"setTimeout\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false},\"commonjs\":{\"exports\":true,\"global\":false,\"module\":false,\"require\":false},\"amd\":{\"define\":false,\"require\":false},\"mocha\":{\"after\":false,\"afterEach\":false,\"before\":false,\"beforeEach\":false,\"context\":false,\"describe\":false,\"it\":false,\"mocha\":false,\"run\":false,\"setup\":false,\"specify\":false,\"suite\":false,\"suiteSetup\":false,\"suiteTeardown\":false,\"teardown\":false,\"test\":false,\"xcontext\":false,\"xdescribe\":false,\"xit\":false,\"xspecify\":false},\"jasmine\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"fail\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jasmine\":false,\"pending\":false,\"runs\":false,\"spyOn\":false,\"spyOnProperty\":false,\"waits\":false,\"waitsFor\":false,\"xdescribe\":false,\"xit\":false},\"jest\":{\"afterAll\":false,\"afterEach\":false,\"beforeAll\":false,\"beforeEach\":false,\"describe\":false,\"expect\":false,\"fdescribe\":false,\"fit\":false,\"it\":false,\"jest\":false,\"pit\":false,\"require\":false,\"test\":false,\"xdescribe\":false,\"xit\":false,\"xtest\":false},\"qunit\":{\"asyncTest\":false,\"deepEqual\":false,\"equal\":false,\"expect\":false,\"module\":false,\"notDeepEqual\":false,\"notEqual\":false,\"notOk\":false,\"notPropEqual\":false,\"notStrictEqual\":false,\"ok\":false,\"propEqual\":false,\"QUnit\":false,\"raises\":false,\"start\":false,\"stop\":false,\"strictEqual\":false,\"test\":false,\"throws\":false},\"phantomjs\":{\"console\":true,\"exports\":true,\"phantom\":true,\"require\":true,\"WebPage\":true},\"couch\":{\"emit\":false,\"exports\":false,\"getRow\":false,\"log\":false,\"module\":false,\"provides\":false,\"require\":false,\"respond\":false,\"send\":false,\"start\":false,\"sum\":false},\"rhino\":{\"defineClass\":false,\"deserialize\":false,\"gc\":false,\"help\":false,\"importClass\":false,\"importPackage\":false,\"java\":false,\"load\":false,\"loadClass\":false,\"Packages\":false,\"print\":false,\"quit\":false,\"readFile\":false,\"readUrl\":false,\"runCommand\":false,\"seal\":false,\"serialize\":false,\"spawn\":false,\"sync\":false,\"toint32\":false,\"version\":false},\"nashorn\":{\"__DIR__\":false,\"__FILE__\":false,\"__LINE__\":false,\"com\":false,\"edu\":false,\"exit\":false,\"java\":false,\"Java\":false,\"javafx\":false,\"JavaImporter\":false,\"javax\":false,\"JSAdapter\":false,\"load\":false,\"loadWithNewGlobal\":false,\"org\":false,\"Packages\":false,\"print\":false,\"quit\":false},\"wsh\":{\"ActiveXObject\":true,\"Enumerator\":true,\"GetObject\":true,\"ScriptEngine\":true,\"ScriptEngineBuildVersion\":true,\"ScriptEngineMajorVersion\":true,\"ScriptEngineMinorVersion\":true,\"VBArray\":true,\"WScript\":true,\"WSH\":true,\"XDomainRequest\":true},\"jquery\":{\"$\":false,\"jQuery\":false},\"yui\":{\"YAHOO\":false,\"YAHOO_config\":false,\"YUI\":false,\"YUI_config\":false},\"shelljs\":{\"cat\":false,\"cd\":false,\"chmod\":false,\"config\":false,\"cp\":false,\"dirs\":false,\"echo\":false,\"env\":false,\"error\":false,\"exec\":false,\"exit\":false,\"find\":false,\"grep\":false,\"ln\":false,\"ls\":false,\"mkdir\":false,\"mv\":false,\"popd\":false,\"pushd\":false,\"pwd\":false,\"rm\":false,\"sed\":false,\"set\":false,\"target\":false,\"tempdir\":false,\"test\":false,\"touch\":false,\"which\":false},\"prototypejs\":{\"$\":false,\"$$\":false,\"$A\":false,\"$break\":false,\"$continue\":false,\"$F\":false,\"$H\":false,\"$R\":false,\"$w\":false,\"Abstract\":false,\"Ajax\":false,\"Autocompleter\":false,\"Builder\":false,\"Class\":false,\"Control\":false,\"Draggable\":false,\"Draggables\":false,\"Droppables\":false,\"Effect\":false,\"Element\":false,\"Enumerable\":false,\"Event\":false,\"Field\":false,\"Form\":false,\"Hash\":false,\"Insertion\":false,\"ObjectRange\":false,\"PeriodicalExecuter\":false,\"Position\":false,\"Prototype\":false,\"Scriptaculous\":false,\"Selector\":false,\"Sortable\":false,\"SortableObserver\":false,\"Sound\":false,\"Template\":false,\"Toggle\":false,\"Try\":false},\"meteor\":{\"_\":false,\"$\":false,\"Accounts\":false,\"AccountsClient\":false,\"AccountsCommon\":false,\"AccountsServer\":false,\"App\":false,\"Assets\":false,\"Blaze\":false,\"check\":false,\"Cordova\":false,\"DDP\":false,\"DDPRateLimiter\":false,\"DDPServer\":false,\"Deps\":false,\"EJSON\":false,\"Email\":false,\"HTTP\":false,\"Log\":false,\"Match\":false,\"Meteor\":false,\"Mongo\":false,\"MongoInternals\":false,\"Npm\":false,\"Package\":false,\"Plugin\":false,\"process\":false,\"Random\":false,\"ReactiveDict\":false,\"ReactiveVar\":false,\"Router\":false,\"ServiceConfiguration\":false,\"Session\":false,\"share\":false,\"Spacebars\":false,\"Template\":false,\"Tinytest\":false,\"Tracker\":false,\"UI\":false,\"Utils\":false,\"WebApp\":false,\"WebAppInternals\":false},\"mongo\":{\"_isWindows\":false,\"_rand\":false,\"BulkWriteResult\":false,\"cat\":false,\"cd\":false,\"connect\":false,\"db\":false,\"getHostName\":false,\"getMemInfo\":false,\"hostname\":false,\"ISODate\":false,\"listFiles\":false,\"load\":false,\"ls\":false,\"md5sumFile\":false,\"mkdir\":false,\"Mongo\":false,\"NumberInt\":false,\"NumberLong\":false,\"ObjectId\":false,\"PlanCache\":false,\"print\":false,\"printjson\":false,\"pwd\":false,\"quit\":false,\"removeFile\":false,\"rs\":false,\"sh\":false,\"UUID\":false,\"version\":false,\"WriteResult\":false},\"applescript\":{\"$\":false,\"Application\":false,\"Automation\":false,\"console\":false,\"delay\":false,\"Library\":false,\"ObjC\":false,\"ObjectSpecifier\":false,\"Path\":false,\"Progress\":false,\"Ref\":false},\"serviceworker\":{\"addEventListener\":false,\"applicationCache\":false,\"atob\":false,\"Blob\":false,\"BroadcastChannel\":false,\"btoa\":false,\"Cache\":false,\"caches\":false,\"CacheStorage\":false,\"clearInterval\":false,\"clearTimeout\":false,\"Client\":false,\"clients\":false,\"Clients\":false,\"close\":true,\"console\":false,\"ExtendableEvent\":false,\"ExtendableMessageEvent\":false,\"fetch\":false,\"FetchEvent\":false,\"FileReaderSync\":false,\"FormData\":false,\"Headers\":false,\"IDBCursor\":false,\"IDBCursorWithValue\":false,\"IDBDatabase\":false,\"IDBFactory\":false,\"IDBIndex\":false,\"IDBKeyRange\":false,\"IDBObjectStore\":false,\"IDBOpenDBRequest\":false,\"IDBRequest\":false,\"IDBTransaction\":false,\"IDBVersionChangeEvent\":false,\"ImageData\":false,\"importScripts\":false,\"indexedDB\":false,\"location\":false,\"MessageChannel\":false,\"MessagePort\":false,\"name\":false,\"navigator\":false,\"Notification\":false,\"onclose\":true,\"onconnect\":true,\"onerror\":true,\"onfetch\":true,\"oninstall\":true,\"onlanguagechange\":true,\"onmessage\":true,\"onmessageerror\":true,\"onnotificationclick\":true,\"onnotificationclose\":true,\"onoffline\":true,\"ononline\":true,\"onpush\":true,\"onpushsubscriptionchange\":true,\"onrejectionhandled\":true,\"onsync\":true,\"onunhandledrejection\":true,\"performance\":false,\"Performance\":false,\"PerformanceEntry\":false,\"PerformanceMark\":false,\"PerformanceMeasure\":false,\"PerformanceNavigation\":false,\"PerformanceResourceTiming\":false,\"PerformanceTiming\":false,\"postMessage\":true,\"Promise\":false,\"queueMicrotask\":false,\"registration\":false,\"removeEventListener\":false,\"Request\":false,\"Response\":false,\"self\":false,\"ServiceWorker\":false,\"ServiceWorkerContainer\":false,\"ServiceWorkerGlobalScope\":false,\"ServiceWorkerMessageEvent\":false,\"ServiceWorkerRegistration\":false,\"setInterval\":false,\"setTimeout\":false,\"skipWaiting\":false,\"TextDecoder\":false,\"TextEncoder\":false,\"URL\":false,\"URLSearchParams\":false,\"WebSocket\":false,\"WindowClient\":false,\"Worker\":false,\"WorkerGlobalScope\":false,\"XMLHttpRequest\":false},\"atomtest\":{\"advanceClock\":false,\"fakeClearInterval\":false,\"fakeClearTimeout\":false,\"fakeSetInterval\":false,\"fakeSetTimeout\":false,\"resetTimeouts\":false,\"waitsForPromise\":false},\"embertest\":{\"andThen\":false,\"click\":false,\"currentPath\":false,\"currentRouteName\":false,\"currentURL\":false,\"fillIn\":false,\"find\":false,\"findAll\":false,\"findWithAssert\":false,\"keyEvent\":false,\"pauseTest\":false,\"resumeTest\":false,\"triggerEvent\":false,\"visit\":false,\"wait\":false},\"protractor\":{\"$\":false,\"$$\":false,\"browser\":false,\"by\":false,\"By\":false,\"DartObject\":false,\"element\":false,\"protractor\":false},\"shared-node-browser\":{\"clearInterval\":false,\"clearTimeout\":false,\"console\":false,\"setInterval\":false,\"setTimeout\":false,\"URL\":false,\"URLSearchParams\":false},\"webextensions\":{\"browser\":false,\"chrome\":false,\"opr\":false},\"greasemonkey\":{\"cloneInto\":false,\"createObjectIn\":false,\"exportFunction\":false,\"GM\":false,\"GM_addStyle\":false,\"GM_deleteValue\":false,\"GM_getResourceText\":false,\"GM_getResourceURL\":false,\"GM_getValue\":false,\"GM_info\":false,\"GM_listValues\":false,\"GM_log\":false,\"GM_openInTab\":false,\"GM_registerMenuCommand\":false,\"GM_setClipboard\":false,\"GM_setValue\":false,\"GM_xmlhttpRequest\":false,\"unsafeWindow\":false},\"devtools\":{\"$\":false,\"$_\":false,\"$$\":false,\"$0\":false,\"$1\":false,\"$2\":false,\"$3\":false,\"$4\":false,\"$x\":false,\"chrome\":false,\"clear\":false,\"copy\":false,\"debug\":false,\"dir\":false,\"dirxml\":false,\"getEventListeners\":false,\"inspect\":false,\"keys\":false,\"monitor\":false,\"monitorEvents\":false,\"profile\":false,\"profileEnd\":false,\"queryObjects\":false,\"table\":false,\"undebug\":false,\"unmonitor\":false,\"unmonitorEvents\":false,\"values\":false}}"));}}),
"[project]/node_modules/@babel/plugin-transform-classes/node_modules/globals/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
module.exports = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-classes/node_modules/globals/globals.json (json)");
}}),
"[project]/node_modules/@babel/code-frame/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var picocolors = __turbopack_require__("[project]/node_modules/picocolors/picocolors.js [app-ssr] (ecmascript)");
var jsTokens = __turbopack_require__("[project]/node_modules/js-tokens/index.js [app-ssr] (ecmascript)");
var helperValidatorIdentifier = __turbopack_require__("[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-ssr] (ecmascript)");
function isColorSupported() {
    return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
}
const compose = (f, g)=>(v)=>f(g(v));
function buildDefs(colors) {
    return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
    };
}
const defsOn = buildDefs(picocolors.createColors(true));
const defsOff = buildDefs(picocolors.createColors(false));
function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
}
const sometimesKeywords = new Set([
    "as",
    "async",
    "from",
    "get",
    "of",
    "set"
]);
const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
const BRACKET = /^[()[\]{}]$/;
let tokenize;
{
    const JSX_TAG = /^[a-z][\w-]*$/i;
    const getTokenType = function(token, offset, text) {
        if (token.type === "name") {
            if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
                return "keyword";
            }
            if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
                return "jsxIdentifier";
            }
            if (token.value[0] !== token.value[0].toLowerCase()) {
                return "capitalized";
            }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
            return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
            return "punctuator";
        }
        return token.type;
    };
    tokenize = function*(text) {
        let match;
        while(match = jsTokens.default.exec(text)){
            const token = jsTokens.matchToToken(match);
            yield {
                type: getTokenType(token, match.index, text),
                value: token.value
            };
        }
    };
}function highlight(text) {
    if (text === "") return "";
    const defs = getDefs(true);
    let highlighted = "";
    for (const { type, value } of tokenize(text)){
        if (type in defs) {
            highlighted += value.split(NEWLINE$1).map((str)=>defs[type](str)).join("\n");
        } else {
            highlighted += value;
        }
    }
    return highlighted;
}
let deprecationWarningShown = false;
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
        column: 0,
        line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const { linesAbove = 2, linesBelow = 3 } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
        start = 0;
    }
    if (endLine === -1) {
        end = source.length;
    }
    const lineDiff = endLine - startLine;
    const markerLines = {};
    if (lineDiff) {
        for(let i = 0; i <= lineDiff; i++){
            const lineNumber = i + startLine;
            if (!startColumn) {
                markerLines[lineNumber] = true;
            } else if (i === 0) {
                const sourceLength = source[lineNumber - 1].length;
                markerLines[lineNumber] = [
                    startColumn,
                    sourceLength - startColumn + 1
                ];
            } else if (i === lineDiff) {
                markerLines[lineNumber] = [
                    0,
                    endColumn
                ];
            } else {
                const sourceLength = source[lineNumber - i].length;
                markerLines[lineNumber] = [
                    0,
                    sourceLength
                ];
            }
        }
    } else {
        if (startColumn === endColumn) {
            if (startColumn) {
                markerLines[startLine] = [
                    startColumn,
                    0
                ];
            } else {
                markerLines[startLine] = true;
            }
        } else {
            markerLines[startLine] = [
                startColumn,
                endColumn - startColumn
            ];
        }
    }
    return {
        start,
        end,
        markerLines
    };
}
function codeFrameColumns(rawLines, loc, opts = {}) {
    const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    const defs = getDefs(shouldHighlight);
    const lines = rawLines.split(NEWLINE);
    const { start, end, markerLines } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index)=>{
        const number = start + 1 + index;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
            let markerLine = "";
            if (Array.isArray(hasMarker)) {
                const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
                const numberOfMarkers = hasMarker[1] || 1;
                markerLine = [
                    "\n ",
                    defs.gutter(gutter.replace(/\d/g, " ")),
                    " ",
                    markerSpacing,
                    defs.marker("^").repeat(numberOfMarkers)
                ].join("");
                if (lastMarkerLine && opts.message) {
                    markerLine += " " + defs.message(opts.message);
                }
            }
            return [
                defs.marker(">"),
                defs.gutter(gutter),
                line.length > 0 ? ` ${line}` : "",
                markerLine
            ].join("");
        } else {
            return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
    }).join("\n");
    if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }
    if (shouldHighlight) {
        return defs.reset(frame);
    } else {
        return frame;
    }
}
function index(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
            process.emitWarning(message, "DeprecationWarning");
        } else {
            const deprecationError = new Error(message);
            deprecationError.name = "DeprecationWarning";
            console.warn(new Error(message));
        }
    }
    colNumber = Math.max(colNumber, 0);
    const location = {
        start: {
            column: colNumber,
            line: lineNumber
        }
    };
    return codeFrameColumns(rawLines, location, opts);
}
exports.codeFrameColumns = codeFrameColumns;
exports.default = index;
exports.highlight = highlight; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/template/lib/formatters.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { assertExpressionStatement } = _t;
function makeStatementFormatter(fn) {
    return {
        code: (str)=>`/* @babel/template */;\n${str}`,
        validate: ()=>{},
        unwrap: (ast)=>{
            return fn(ast.program.body.slice(1));
        }
    };
}
const smart = exports.smart = makeStatementFormatter((body)=>{
    if (body.length > 1) {
        return body;
    } else {
        return body[0];
    }
});
const statements = exports.statements = makeStatementFormatter((body)=>body);
const statement = exports.statement = makeStatementFormatter((body)=>{
    if (body.length === 0) {
        throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
});
const expression = exports.expression = {
    code: (str)=>`(\n${str}\n)`,
    validate: (ast)=>{
        if (ast.program.body.length > 1) {
            throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
            throw new Error("Parse result included parens.");
        }
    },
    unwrap: ({ program })=>{
        const [stmt] = program.body;
        assertExpressionStatement(stmt);
        return stmt.expression;
    }
};
const program = exports.program = {
    code: (str)=>str,
    validate: ()=>{},
    unwrap: (ast)=>ast.program
}; //# sourceMappingURL=formatters.js.map
}}),
"[project]/node_modules/@babel/template/lib/options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.merge = merge;
exports.normalizeReplacements = normalizeReplacements;
exports.validate = validate;
const _excluded = [
    "placeholderWhitelist",
    "placeholderPattern",
    "preserveComments",
    "syntacticPlaceholders"
];
function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
    }
    return t;
}
function merge(a, b) {
    const { placeholderWhitelist = a.placeholderWhitelist, placeholderPattern = a.placeholderPattern, preserveComments = a.preserveComments, syntacticPlaceholders = a.syntacticPlaceholders } = b;
    return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
    };
}
function validate(opts) {
    if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
    }
    const _ref = opts || {}, { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = _ref, parser = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    return {
        parser,
        placeholderWhitelist: placeholderWhitelist || undefined,
        placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
        preserveComments: preserveComments == null ? undefined : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
}
function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i)=>{
            acc["$" + i] = replacement;
            return acc;
        }, {});
    } else if (typeof replacements === "object" || replacements == null) {
        return replacements || undefined;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
} //# sourceMappingURL=options.js.map
}}),
"[project]/node_modules/@babel/template/lib/parse.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = parseAndBuildMetadata;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
var _parser = __turbopack_require__("[project]/node_modules/@babel/parser/lib/index.js [app-ssr] (ecmascript)");
var _codeFrame = __turbopack_require__("[project]/node_modules/@babel/code-frame/lib/index.js [app-ssr] (ecmascript)");
const { isCallExpression, isExpressionStatement, isFunction, isIdentifier, isJSXIdentifier, isNewExpression, isPlaceholder, isStatement, isStringLiteral, removePropertiesDeep, traverse } = _t;
const PATTERN = /^[_$A-Z0-9]+$/;
function parseAndBuildMetadata(formatter, code, opts) {
    const { placeholderWhitelist, placeholderPattern, preserveComments, syntacticPlaceholders } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
        preserveComments
    });
    formatter.validate(ast);
    const state = {
        syntactic: {
            placeholders: [],
            placeholderNames: new Set()
        },
        legacy: {
            placeholders: [],
            placeholderNames: new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
    };
    traverse(ast, placeholderVisitorHandler, state);
    return Object.assign({
        ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
}
function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;
    let name;
    let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node)) {
        if (state.syntacticPlaceholders === false) {
            throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
        }
        name = node.name.name;
        hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
        name = node.name;
    } else if (isStringLiteral(node)) {
        name = node.value;
    } else {
        return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
        return;
    }
    ancestors = ancestors.slice();
    const { node: parent, key } = ancestors[ancestors.length - 1];
    let type;
    if (isStringLiteral(node) || isPlaceholder(node, {
        expectedNode: "StringLiteral"
    })) {
        type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
        type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
        type = "statement";
    } else {
        type = "other";
    }
    const { placeholders, placeholderNames } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
    placeholders.push({
        name,
        type,
        resolve: (ast)=>resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
}
function resolveAncestors(ast, ancestors) {
    let parent = ast;
    for(let i = 0; i < ancestors.length - 1; i++){
        const { key, index } = ancestors[i];
        if (index === undefined) {
            parent = parent[key];
        } else {
            parent = parent[key][index];
        }
    }
    const { key, index } = ancestors[ancestors.length - 1];
    return {
        parent,
        key,
        index
    };
}
function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
        plugins.push("placeholders");
    }
    parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
    }, parserOpts, {
        plugins
    });
    try {
        return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
        const loc = err.loc;
        if (loc) {
            err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
                start: loc
            });
            err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
    }
} //# sourceMappingURL=parse.js.map
}}),
"[project]/node_modules/@babel/template/lib/populate.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = populatePlaceholders;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { blockStatement, cloneNode, emptyStatement, expressionStatement, identifier, isStatement, isStringLiteral, stringLiteral, validate } = _t;
function populatePlaceholders(metadata, replacements) {
    const ast = cloneNode(metadata.ast);
    if (replacements) {
        metadata.placeholders.forEach((placeholder)=>{
            if (!hasOwnProperty.call(replacements, placeholder.name)) {
                const placeholderName = placeholder.name;
                throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
            }
        });
        Object.keys(replacements).forEach((key)=>{
            if (!metadata.placeholderNames.has(key)) {
                throw new Error(`Unknown substitution "${key}" given`);
            }
        });
    }
    metadata.placeholders.slice().reverse().forEach((placeholder)=>{
        try {
            applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
            e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
            throw e;
        }
    });
    return ast;
}
function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
            replacement = replacement.map((node)=>cloneNode(node));
        } else if (typeof replacement === "object") {
            replacement = cloneNode(replacement);
        }
    }
    const { parent, key, index } = placeholder.resolve(ast);
    if (placeholder.type === "string") {
        if (typeof replacement === "string") {
            replacement = stringLiteral(replacement);
        }
        if (!replacement || !isStringLiteral(replacement)) {
            throw new Error("Expected string substitution");
        }
    } else if (placeholder.type === "statement") {
        if (index === undefined) {
            if (!replacement) {
                replacement = emptyStatement();
            } else if (Array.isArray(replacement)) {
                replacement = blockStatement(replacement);
            } else if (typeof replacement === "string") {
                replacement = expressionStatement(identifier(replacement));
            } else if (!isStatement(replacement)) {
                replacement = expressionStatement(replacement);
            }
        } else {
            if (replacement && !Array.isArray(replacement)) {
                if (typeof replacement === "string") {
                    replacement = identifier(replacement);
                }
                if (!isStatement(replacement)) {
                    replacement = expressionStatement(replacement);
                }
            }
        }
    } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
            replacement = identifier(replacement);
        }
        if (index === undefined) throw new Error("Assertion failure.");
    } else {
        if (typeof replacement === "string") {
            replacement = identifier(replacement);
        }
        if (Array.isArray(replacement)) {
            throw new Error("Cannot replace single expression with an array.");
        }
    }
    function set(parent, key, value) {
        const node = parent[key];
        parent[key] = value;
        if (node.type === "Identifier" || node.type === "Placeholder") {
            if (node.typeAnnotation) {
                value.typeAnnotation = node.typeAnnotation;
            }
            if (node.optional) {
                value.optional = node.optional;
            }
            if (node.decorators) {
                value.decorators = node.decorators;
            }
        }
    }
    if (index === undefined) {
        validate(parent, key, replacement);
        set(parent, key, replacement);
    } else {
        const items = parent[key].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
            if (replacement == null) {
                items.splice(index, 1);
            } else if (Array.isArray(replacement)) {
                items.splice(index, 1, ...replacement);
            } else {
                set(items, index, replacement);
            }
        } else {
            set(items, index, replacement);
        }
        validate(parent, key, items);
        parent[key] = items;
    }
} //# sourceMappingURL=populate.js.map
}}),
"[project]/node_modules/@babel/template/lib/string.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = stringTemplate;
var _options = __turbopack_require__("[project]/node_modules/@babel/template/lib/options.js [app-ssr] (ecmascript)");
var _parse = __turbopack_require__("[project]/node_modules/@babel/template/lib/parse.js [app-ssr] (ecmascript)");
var _populate = __turbopack_require__("[project]/node_modules/@babel/template/lib/populate.js [app-ssr] (ecmascript)");
function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return (arg)=>{
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);
        return formatter.unwrap((0, _populate.default)(metadata, replacements));
    };
} //# sourceMappingURL=string.js.map
}}),
"[project]/node_modules/@babel/template/lib/literal.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = literalTemplate;
var _options = __turbopack_require__("[project]/node_modules/@babel/template/lib/options.js [app-ssr] (ecmascript)");
var _parse = __turbopack_require__("[project]/node_modules/@babel/template/lib/parse.js [app-ssr] (ecmascript)");
var _populate = __turbopack_require__("[project]/node_modules/@babel/template/lib/populate.js [app-ssr] (ecmascript)");
function literalTemplate(formatter, tpl, opts) {
    const { metadata, names } = buildLiteralData(formatter, tpl, opts);
    return (arg)=>{
        const defaultReplacements = {};
        arg.forEach((replacement, i)=>{
            defaultReplacements[names[i]] = replacement;
        });
        return (arg)=>{
            const replacements = (0, _options.normalizeReplacements)(arg);
            if (replacements) {
                Object.keys(replacements).forEach((key)=>{
                    if (hasOwnProperty.call(defaultReplacements, key)) {
                        throw new Error("Unexpected replacement overlap.");
                    }
                });
            }
            return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
    };
}
function buildLiteralData(formatter, tpl, opts) {
    let prefix = "BABEL_TPL$";
    const raw = tpl.join("");
    do {
        prefix = "$$" + prefix;
    }while (raw.includes(prefix))
    const { names, code } = buildTemplateCode(tpl, prefix);
    const metadata = (0, _parse.default)(formatter, formatter.code(code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
        metadata,
        names
    };
}
function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];
    for(let i = 1; i < tpl.length; i++){
        const value = `${prefix}${i - 1}`;
        names.push(value);
        code += value + tpl[i];
    }
    return {
        names,
        code
    };
} //# sourceMappingURL=literal.js.map
}}),
"[project]/node_modules/@babel/template/lib/builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createTemplateBuilder;
var _options = __turbopack_require__("[project]/node_modules/@babel/template/lib/options.js [app-ssr] (ecmascript)");
var _string = __turbopack_require__("[project]/node_modules/@babel/template/lib/string.js [app-ssr] (ecmascript)");
var _literal = __turbopack_require__("[project]/node_modules/@babel/template/lib/literal.js [app-ssr] (ecmascript)");
const NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
});
function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = new WeakMap();
    const templateAstCache = new WeakMap();
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args)=>{
        if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
            let builder = templateFnCache.get(tpl);
            if (!builder) {
                builder = (0, _literal.default)(formatter, tpl, cachedOpts);
                templateFnCache.set(tpl, builder);
            }
            return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
            if (args.length > 0) throw new Error("Unexpected extra params.");
            return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
        ast: (tpl, ...args)=>{
            if (typeof tpl === "string") {
                if (args.length > 1) throw new Error("Unexpected extra params.");
                return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
            } else if (Array.isArray(tpl)) {
                let builder = templateAstCache.get(tpl);
                if (!builder) {
                    builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
                    templateAstCache.set(tpl, builder);
                }
                return builder(args)();
            }
            throw new Error(`Unexpected template param ${typeof tpl}`);
        }
    });
}
function extendedTrace(fn) {
    let rootStack = "";
    try {
        throw new Error();
    } catch (error) {
        if (error.stack) {
            rootStack = error.stack.split("\n").slice(3).join("\n");
        }
    }
    return (arg)=>{
        try {
            return fn(arg);
        } catch (err) {
            err.stack += `\n    =============\n${rootStack}`;
            throw err;
        }
    };
} //# sourceMappingURL=builder.js.map
}}),
"[project]/node_modules/@babel/template/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports.default = void 0;
var formatters = __turbopack_require__("[project]/node_modules/@babel/template/lib/formatters.js [app-ssr] (ecmascript)");
var _builder = __turbopack_require__("[project]/node_modules/@babel/template/lib/builder.js [app-ssr] (ecmascript)");
const smart = exports.smart = (0, _builder.default)(formatters.smart);
const statement = exports.statement = (0, _builder.default)(formatters.statement);
const statements = exports.statements = (0, _builder.default)(formatters.statements);
const expression = exports.expression = (0, _builder.default)(formatters.expression);
const program = exports.program = (0, _builder.default)(formatters.program);
var _default = exports.default = Object.assign(smart.bind(undefined), {
    smart,
    statement,
    statements,
    expression,
    program,
    ast: smart.ast
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-module-imports/lib/import-builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _assert = __turbopack_require__("[externals]/assert [external] (assert, cjs)");
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { callExpression, cloneNode, expressionStatement, identifier, importDeclaration, importDefaultSpecifier, importNamespaceSpecifier, importSpecifier, memberExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;
class ImportBuilder {
    constructor(importedSource, scope, hub){
        this._statements = [];
        this._resultName = null;
        this._importedSource = void 0;
        this._scope = scope;
        this._hub = hub;
        this._importedSource = importedSource;
    }
    done() {
        return {
            statements: this._statements,
            resultName: this._resultName
        };
    }
    import() {
        this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
        return this;
    }
    require() {
        this._statements.push(expressionStatement(callExpression(identifier("require"), [
            stringLiteral(this._importedSource)
        ])));
        return this;
    }
    namespace(name = "namespace") {
        const local = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importNamespaceSpecifier(local)
        ];
        this._resultName = cloneNode(local);
        return this;
    }
    default(name) {
        const id = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importDefaultSpecifier(id)
        ];
        this._resultName = cloneNode(id);
        return this;
    }
    named(name, importName) {
        if (importName === "default") return this.default(name);
        const id = this._scope.generateUidIdentifier(name);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [
            importSpecifier(id, identifier(importName))
        ];
        this._resultName = cloneNode(id);
        return this;
    }
    var(name) {
        const id = this._scope.generateUidIdentifier(name);
        let statement = this._statements[this._statements.length - 1];
        if (statement.type !== "ExpressionStatement") {
            _assert(this._resultName);
            statement = expressionStatement(this._resultName);
            this._statements.push(statement);
        }
        this._statements[this._statements.length - 1] = variableDeclaration("var", [
            variableDeclarator(id, statement.expression)
        ]);
        this._resultName = cloneNode(id);
        return this;
    }
    defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(callee) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
            statement.expression = callExpression(callee, [
                statement.expression
            ]);
        } else if (statement.type === "VariableDeclaration") {
            _assert(statement.declarations.length === 1);
            statement.declarations[0].init = callExpression(callee, [
                statement.declarations[0].init
            ]);
        } else {
            _assert.fail("Unexpected type.");
        }
        return this;
    }
    prop(name) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
            statement.expression = memberExpression(statement.expression, identifier(name));
        } else if (statement.type === "VariableDeclaration") {
            _assert(statement.declarations.length === 1);
            statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
        } else {
            _assert.fail("Unexpected type:" + statement.type);
        }
        return this;
    }
    read(name) {
        this._resultName = memberExpression(this._resultName, identifier(name));
    }
}
exports.default = ImportBuilder; //# sourceMappingURL=import-builder.js.map
}}),
"[project]/node_modules/@babel/helper-module-imports/lib/is-module.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isModule;
function isModule(path) {
    return path.node.sourceType === "module";
} //# sourceMappingURL=is-module.js.map
}}),
"[project]/node_modules/@babel/helper-module-imports/lib/import-injector.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _assert = __turbopack_require__("[externals]/assert [external] (assert, cjs)");
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
var _importBuilder = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/import-builder.js [app-ssr] (ecmascript)");
var _isModule = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/is-module.js [app-ssr] (ecmascript)");
const { identifier, importSpecifier, numericLiteral, sequenceExpression, isImportDeclaration } = _t;
class ImportInjector {
    constructor(path, importedSource, opts){
        this._defaultOpts = {
            importedSource: null,
            importedType: "commonjs",
            importedInterop: "babel",
            importingInterop: "babel",
            ensureLiveReference: false,
            ensureNoContext: false,
            importPosition: "before"
        };
        const programPath = path.find((p)=>p.isProgram());
        this._programPath = programPath;
        this._programScope = programPath.scope;
        this._hub = programPath.hub;
        this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }
    addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
    }
    addNamed(importName, importedSourceIn, opts) {
        _assert(typeof importName === "string");
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    }
    addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    }
    addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
    }
    _applyDefaults(importedSource, opts, isInit = false) {
        let newOpts;
        if (typeof importedSource === "string") {
            newOpts = Object.assign({}, this._defaultOpts, {
                importedSource
            }, opts);
        } else {
            _assert(!opts, "Unexpected secondary arguments.");
            newOpts = Object.assign({}, this._defaultOpts, importedSource);
        }
        if (!isInit && opts) {
            if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
            if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
        }
        return newOpts;
    }
    _generateImport(opts, importName) {
        const isDefault = importName === "default";
        const isNamed = !!importName && !isDefault;
        const isNamespace = importName === null;
        const { importedSource, importedType, importedInterop, importingInterop, ensureLiveReference, ensureNoContext, nameHint, importPosition, blockHoist } = opts;
        let name = nameHint || importName;
        const isMod = (0, _isModule.default)(this._programPath);
        const isModuleForNode = isMod && importingInterop === "node";
        const isModuleForBabel = isMod && importingInterop === "babel";
        if (importPosition === "after" && !isMod) {
            throw new Error(`"importPosition": "after" is only supported in modules`);
        }
        const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
        if (importedType === "es6") {
            if (!isModuleForNode && !isModuleForBabel) {
                throw new Error("Cannot import an ES6 module from CommonJS");
            }
            builder.import();
            if (isNamespace) {
                builder.namespace(nameHint || importedSource);
            } else if (isDefault || isNamed) {
                builder.named(name, importName);
            }
        } else if (importedType !== "commonjs") {
            throw new Error(`Unexpected interopType "${importedType}"`);
        } else if (importedInterop === "babel") {
            if (isModuleForNode) {
                name = name !== "default" ? name : importedSource;
                const es6Default = `${importedSource}$es6Default`;
                builder.import();
                if (isNamespace) {
                    builder.default(es6Default).var(name || importedSource).wildcardInterop();
                } else if (isDefault) {
                    if (ensureLiveReference) {
                        builder.default(es6Default).var(name || importedSource).defaultInterop().read("default");
                    } else {
                        builder.default(es6Default).var(name).defaultInterop().prop(importName);
                    }
                } else if (isNamed) {
                    builder.default(es6Default).read(importName);
                }
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) {
                    builder.namespace(name || importedSource);
                } else if (isDefault || isNamed) {
                    builder.named(name, importName);
                }
            } else {
                builder.require();
                if (isNamespace) {
                    builder.var(name || importedSource).wildcardInterop();
                } else if ((isDefault || isNamed) && ensureLiveReference) {
                    if (isDefault) {
                        name = name !== "default" ? name : importedSource;
                        builder.var(name).read(importName);
                        builder.defaultInterop();
                    } else {
                        builder.var(importedSource).read(importName);
                    }
                } else if (isDefault) {
                    builder.var(name).defaultInterop().prop(importName);
                } else if (isNamed) {
                    builder.var(name).prop(importName);
                }
            }
        } else if (importedInterop === "compiled") {
            if (isModuleForNode) {
                builder.import();
                if (isNamespace) {
                    builder.default(name || importedSource);
                } else if (isDefault || isNamed) {
                    builder.default(importedSource).read(name);
                }
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) {
                    builder.namespace(name || importedSource);
                } else if (isDefault || isNamed) {
                    builder.named(name, importName);
                }
            } else {
                builder.require();
                if (isNamespace) {
                    builder.var(name || importedSource);
                } else if (isDefault || isNamed) {
                    if (ensureLiveReference) {
                        builder.var(importedSource).read(name);
                    } else {
                        builder.prop(importName).var(name);
                    }
                }
            }
        } else if (importedInterop === "uncompiled") {
            if (isDefault && ensureLiveReference) {
                throw new Error("No live reference for commonjs default");
            }
            if (isModuleForNode) {
                builder.import();
                if (isNamespace) {
                    builder.default(name || importedSource);
                } else if (isDefault) {
                    builder.default(name);
                } else if (isNamed) {
                    builder.default(importedSource).read(name);
                }
            } else if (isModuleForBabel) {
                builder.import();
                if (isNamespace) {
                    builder.default(name || importedSource);
                } else if (isDefault) {
                    builder.default(name);
                } else if (isNamed) {
                    builder.named(name, importName);
                }
            } else {
                builder.require();
                if (isNamespace) {
                    builder.var(name || importedSource);
                } else if (isDefault) {
                    builder.var(name);
                } else if (isNamed) {
                    if (ensureLiveReference) {
                        builder.var(importedSource).read(name);
                    } else {
                        builder.var(name).prop(importName);
                    }
                }
            }
        } else {
            throw new Error(`Unknown importedInterop "${importedInterop}".`);
        }
        const { statements, resultName } = builder.done();
        this._insertStatements(statements, importPosition, blockHoist);
        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
            return sequenceExpression([
                numericLiteral(0),
                resultName
            ]);
        }
        return resultName;
    }
    _insertStatements(statements, importPosition = "before", blockHoist = 3) {
        if (importPosition === "after") {
            if (this._insertStatementsAfter(statements)) return;
        } else {
            if (this._insertStatementsBefore(statements, blockHoist)) return;
        }
        this._programPath.unshiftContainer("body", statements);
    }
    _insertStatementsBefore(statements, blockHoist) {
        if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {
            const firstImportDecl = this._programPath.get("body").find((p)=>{
                return p.isImportDeclaration() && isValueImport(p.node);
            });
            if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {
                return true;
            }
        }
        statements.forEach((node)=>{
            node._blockHoist = blockHoist;
        });
        const targetPath = this._programPath.get("body").find((p)=>{
            const val = p.node._blockHoist;
            return Number.isFinite(val) && val < 4;
        });
        if (targetPath) {
            targetPath.insertBefore(statements);
            return true;
        }
        return false;
    }
    _insertStatementsAfter(statements) {
        const statementsSet = new Set(statements);
        const importDeclarations = new Map();
        for (const statement of statements){
            if (isImportDeclaration(statement) && isValueImport(statement)) {
                const source = statement.source.value;
                if (!importDeclarations.has(source)) importDeclarations.set(source, []);
                importDeclarations.get(source).push(statement);
            }
        }
        let lastImportPath = null;
        for (const bodyStmt of this._programPath.get("body")){
            if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {
                lastImportPath = bodyStmt;
                const source = bodyStmt.node.source.value;
                const newImports = importDeclarations.get(source);
                if (!newImports) continue;
                for (const decl of newImports){
                    if (!statementsSet.has(decl)) continue;
                    if (maybeAppendImportSpecifiers(bodyStmt.node, decl)) {
                        statementsSet.delete(decl);
                    }
                }
            }
        }
        if (statementsSet.size === 0) return true;
        if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));
        return !!lastImportPath;
    }
}
exports.default = ImportInjector;
function isValueImport(node) {
    return node.importKind !== "type" && node.importKind !== "typeof";
}
function hasNamespaceImport(node) {
    return node.specifiers.length === 1 && node.specifiers[0].type === "ImportNamespaceSpecifier" || node.specifiers.length === 2 && node.specifiers[1].type === "ImportNamespaceSpecifier";
}
function hasDefaultImport(node) {
    return node.specifiers.length > 0 && node.specifiers[0].type === "ImportDefaultSpecifier";
}
function maybeAppendImportSpecifiers(target, source) {
    if (!target.specifiers.length) {
        target.specifiers = source.specifiers;
        return true;
    }
    if (!source.specifiers.length) return true;
    if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;
    if (hasDefaultImport(source)) {
        if (hasDefaultImport(target)) {
            source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier("default"));
        } else {
            target.specifiers.unshift(source.specifiers.shift());
        }
    }
    target.specifiers.push(...source.specifiers);
    return true;
} //# sourceMappingURL=import-injector.js.map
}}),
"[project]/node_modules/@babel/helper-module-imports/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ImportInjector", {
    enumerable: true,
    get: function() {
        return _importInjector.default;
    }
});
exports.addDefault = addDefault;
exports.addNamed = addNamed;
exports.addNamespace = addNamespace;
exports.addSideEffect = addSideEffect;
Object.defineProperty(exports, "isModule", {
    enumerable: true,
    get: function() {
        return _isModule.default;
    }
});
var _importInjector = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/import-injector.js [app-ssr] (ecmascript)");
var _isModule = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/is-module.js [app-ssr] (ecmascript)");
function addDefault(path, importedSource, opts) {
    return new _importInjector.default(path).addDefault(importedSource, opts);
}
function addNamed(path, name, importedSource, opts) {
    return new _importInjector.default(path).addNamed(name, importedSource, opts);
}
function addNamespace(path, importedSource, opts) {
    return new _importInjector.default(path).addNamespace(importedSource, opts);
}
function addSideEffect(path, importedSource, opts) {
    return new _importInjector.default(path).addSideEffect(importedSource, opts);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = rewriteThis;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
let rewriteThisVisitor;
function rewriteThis(programPath) {
    if (!rewriteThisVisitor) {
        rewriteThisVisitor = _traverse.visitors.environmentVisitor({
            ThisExpression (path) {
                path.replaceWith(_core.types.unaryExpression("void", _core.types.numericLiteral(0), true));
            }
        });
        rewriteThisVisitor.noScope = true;
    }
    (0, _traverse.default)(programPath.node, rewriteThisVisitor);
} //# sourceMappingURL=rewrite-this.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = rewriteLiveReferences;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function isInType(path) {
    do {
        switch(path.parent.type){
            case "TSTypeAnnotation":
            case "TSTypeAliasDeclaration":
            case "TSTypeReference":
            case "TypeAnnotation":
            case "TypeAlias":
                return true;
            case "ExportSpecifier":
                return path.parentPath.parent.exportKind === "type";
            default:
                if (path.parentPath.isStatement() || path.parentPath.isExpression()) {
                    return false;
                }
        }
    }while (path = path.parentPath)
}
function rewriteLiveReferences(programPath, metadata, wrapReference) {
    const imported = new Map();
    const exported = new Map();
    const requeueInParent = (path)=>{
        programPath.requeue(path);
    };
    for (const [source, data] of metadata.source){
        for (const [localName, importName] of data.imports){
            imported.set(localName, [
                source,
                importName,
                null
            ]);
        }
        for (const localName of data.importsNamespace){
            imported.set(localName, [
                source,
                null,
                localName
            ]);
        }
    }
    for (const [local, data] of metadata.local){
        let exportMeta = exported.get(local);
        if (!exportMeta) {
            exportMeta = [];
            exported.set(local, exportMeta);
        }
        exportMeta.push(...data.names);
    }
    const rewriteBindingInitVisitorState = {
        metadata,
        requeueInParent,
        scope: programPath.scope,
        exported
    };
    programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
    const rewriteReferencesVisitorState = {
        seen: new WeakSet(),
        metadata,
        requeueInParent,
        scope: programPath.scope,
        imported,
        exported,
        buildImportReference ([source, importName, localName], identNode) {
            const meta = metadata.source.get(source);
            meta.referenced = true;
            if (localName) {
                if (meta.wrap) {
                    var _wrapReference;
                    identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
                }
                return identNode;
            }
            let namespace = _core.types.identifier(meta.name);
            if (meta.wrap) {
                var _wrapReference2;
                namespace = (_wrapReference2 = wrapReference(namespace, meta.wrap)) != null ? _wrapReference2 : namespace;
            }
            if (importName === "default" && meta.interop === "node-default") {
                return namespace;
            }
            const computed = metadata.stringSpecifiers.has(importName);
            return _core.types.memberExpression(namespace, computed ? _core.types.stringLiteral(importName) : _core.types.identifier(importName), computed);
        }
    };
    programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
}
const rewriteBindingInitVisitor = {
    Scope (path) {
        path.skip();
    },
    ClassDeclaration (path) {
        const { requeueInParent, exported, metadata } = this;
        const { id } = path.node;
        if (!id) throw new Error("Expected class to have a name");
        const localName = id.name;
        const exportNames = exported.get(localName) || [];
        if (exportNames.length > 0) {
            const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, _core.types.identifier(localName), path.scope));
            statement._blockHoist = path.node._blockHoist;
            requeueInParent(path.insertAfter(statement)[0]);
        }
    },
    VariableDeclaration (path) {
        const { requeueInParent, exported, metadata } = this;
        const isVar = path.node.kind === "var";
        for (const decl of path.get("declarations")){
            const { id } = decl.node;
            let { init } = decl.node;
            if (_core.types.isIdentifier(id) && exported.has(id.name) && !_core.types.isArrowFunctionExpression(init) && (!_core.types.isFunctionExpression(init) || init.id) && (!_core.types.isClassExpression(init) || init.id)) {
                if (!init) {
                    if (isVar) {
                        continue;
                    } else {
                        init = path.scope.buildUndefinedNode();
                    }
                }
                decl.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id.name), init, path.scope);
                requeueInParent(decl.get("init"));
            } else {
                for (const localName of Object.keys(decl.getOuterBindingIdentifiers())){
                    if (exported.has(localName)) {
                        const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), _core.types.identifier(localName), path.scope));
                        statement._blockHoist = path.node._blockHoist;
                        requeueInParent(path.insertAfter(statement)[0]);
                    }
                }
            }
        }
    }
};
const buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope)=>{
    const exportsObjectName = metadata.exportName;
    for(let currentScope = scope; currentScope != null; currentScope = currentScope.parent){
        if (currentScope.hasOwnBinding(exportsObjectName)) {
            currentScope.rename(exportsObjectName);
        }
    }
    return (exportNames || []).reduce((expr, exportName)=>{
        const { stringSpecifiers } = metadata;
        const computed = stringSpecifiers.has(exportName);
        return _core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportsObjectName), computed ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), computed), expr);
    }, localExpr);
};
const buildImportThrow = (localName)=>{
    return _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `;
};
const rewriteReferencesVisitor = {
    ReferencedIdentifier (path) {
        const { seen, buildImportReference, scope, imported, requeueInParent } = this;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        const localName = path.node.name;
        const importData = imported.get(localName);
        if (importData) {
            if (isInType(path)) {
                throw path.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            }
            const localBinding = path.scope.getBinding(localName);
            const rootBinding = scope.getBinding(localName);
            if (rootBinding !== localBinding) return;
            const ref = buildImportReference(importData, path.node);
            ref.loc = path.node.loc;
            if ((path.parentPath.isCallExpression({
                callee: path.node
            }) || path.parentPath.isOptionalCallExpression({
                callee: path.node
            }) || path.parentPath.isTaggedTemplateExpression({
                tag: path.node
            })) && _core.types.isMemberExpression(ref)) {
                path.replaceWith(_core.types.sequenceExpression([
                    _core.types.numericLiteral(0),
                    ref
                ]));
            } else if (path.isJSXIdentifier() && _core.types.isMemberExpression(ref)) {
                const { object, property } = ref;
                path.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object.name), _core.types.jsxIdentifier(property.name)));
            } else {
                path.replaceWith(ref);
            }
            requeueInParent(path);
            path.skip();
        }
    },
    UpdateExpression (path) {
        const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        const arg = path.get("argument");
        if (arg.isMemberExpression()) return;
        const update = path.node;
        if (arg.isIdentifier()) {
            const localName = arg.node.name;
            if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
                return;
            }
            const exportedNames = exported.get(localName);
            const importData = imported.get(localName);
            if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
                if (importData) {
                    path.replaceWith(_core.types.assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
                } else if (update.prefix) {
                    path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.cloneNode(update), path.scope));
                } else {
                    const ref = scope.generateDeclaredUidIdentifier(localName);
                    path.replaceWith(_core.types.sequenceExpression([
                        _core.types.assignmentExpression("=", _core.types.cloneNode(ref), _core.types.cloneNode(update)),
                        buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope),
                        _core.types.cloneNode(ref)
                    ]));
                }
            }
        }
        requeueInParent(path);
        path.skip();
    },
    AssignmentExpression: {
        exit (path) {
            const { scope, seen, imported, exported, requeueInParent, buildImportReference } = this;
            if (seen.has(path.node)) return;
            seen.add(path.node);
            const left = path.get("left");
            if (left.isMemberExpression()) return;
            if (left.isIdentifier()) {
                const localName = left.node.name;
                if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
                    return;
                }
                const exportedNames = exported.get(localName);
                const importData = imported.get(localName);
                if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
                    const assignment = path.node;
                    if (importData) {
                        assignment.left = buildImportReference(importData, left.node);
                        assignment.right = _core.types.sequenceExpression([
                            assignment.right,
                            buildImportThrow(localName)
                        ]);
                    }
                    const { operator } = assignment;
                    let newExpr;
                    if (operator === "=") {
                        newExpr = assignment;
                    } else if (operator === "&&=" || operator === "||=" || operator === "??=") {
                        newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.logicalExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
                    } else {
                        newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.binaryExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
                    }
                    path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, newExpr, path.scope));
                    requeueInParent(path);
                    path.skip();
                }
            } else {
                const ids = left.getOuterBindingIdentifiers();
                const programScopeIds = Object.keys(ids).filter((localName)=>scope.getBinding(localName) === path.scope.getBinding(localName));
                const id = programScopeIds.find((localName)=>imported.has(localName));
                if (id) {
                    path.node.right = _core.types.sequenceExpression([
                        path.node.right,
                        buildImportThrow(id)
                    ]);
                }
                const items = [];
                programScopeIds.forEach((localName)=>{
                    const exportedNames = exported.get(localName) || [];
                    if (exportedNames.length > 0) {
                        items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path.scope));
                    }
                });
                if (items.length > 0) {
                    let node = _core.types.sequenceExpression(items);
                    if (path.parentPath.isExpressionStatement()) {
                        node = _core.types.expressionStatement(node);
                        node._blockHoist = path.parentPath.node._blockHoist;
                    }
                    const statement = path.insertAfter(node)[0];
                    requeueInParent(statement);
                }
            }
        }
    },
    ForXStatement (path) {
        const { scope, node } = path;
        const { left } = node;
        const { exported, imported, scope: programScope } = this;
        if (!_core.types.isVariableDeclaration(left)) {
            let didTransformExport = false, importConstViolationName;
            const loopBodyScope = path.get("body").scope;
            for (const name of Object.keys(_core.types.getOuterBindingIdentifiers(left))){
                if (programScope.getBinding(name) === scope.getBinding(name)) {
                    if (exported.has(name)) {
                        didTransformExport = true;
                        if (loopBodyScope.hasOwnBinding(name)) {
                            loopBodyScope.rename(name);
                        }
                    }
                    if (imported.has(name) && !importConstViolationName) {
                        importConstViolationName = name;
                    }
                }
            }
            if (!didTransformExport && !importConstViolationName) {
                return;
            }
            path.ensureBlock();
            const bodyPath = path.get("body");
            const newLoopId = scope.generateUidIdentifierBasedOnNode(left);
            path.get("left").replaceWith(_core.types.variableDeclaration("let", [
                _core.types.variableDeclarator(_core.types.cloneNode(newLoopId))
            ]));
            scope.registerDeclaration(path.get("left"));
            if (didTransformExport) {
                bodyPath.unshiftContainer("body", _core.types.expressionStatement(_core.types.assignmentExpression("=", left, newLoopId)));
            }
            if (importConstViolationName) {
                bodyPath.unshiftContainer("body", _core.types.expressionStatement(buildImportThrow(importConstViolationName)));
            }
        }
    }
}; //# sourceMappingURL=rewrite-live-references.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = normalizeModuleAndLoadMetadata;
exports.hasExports = hasExports;
exports.isSideEffectImport = isSideEffectImport;
exports.validateImportInteropOption = validateImportInteropOption;
var _path = __turbopack_require__("[externals]/path [external] (path, cjs)");
var _helperValidatorIdentifier = __turbopack_require__("[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-ssr] (ecmascript)");
function hasExports(metadata) {
    return metadata.hasExports;
}
function isSideEffectImport(source) {
    return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
}
function validateImportInteropOption(importInterop) {
    if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
        throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
    }
    return importInterop;
}
function resolveImportInterop(importInterop, source, filename) {
    if (typeof importInterop === "function") {
        return validateImportInteropOption(importInterop(source, filename));
    }
    return importInterop;
}
function normalizeModuleAndLoadMetadata(programPath, exportName, { importInterop, initializeReexports = false, getWrapperPayload, esNamespaceOnly = false, filename }) {
    if (!exportName) {
        exportName = programPath.scope.generateUidIdentifier("exports").name;
    }
    const stringSpecifiers = new Set();
    nameAnonymousExports(programPath);
    const { local, sources, hasExports } = getModuleMetadata(programPath, {
        initializeReexports,
        getWrapperPayload
    }, stringSpecifiers);
    removeImportExportDeclarations(programPath);
    for (const [source, metadata] of sources){
        const { importsNamespace, imports } = metadata;
        if (importsNamespace.size > 0 && imports.size === 0) {
            const [nameOfnamespace] = importsNamespace;
            metadata.name = nameOfnamespace;
        }
        const resolvedInterop = resolveImportInterop(importInterop, source, filename);
        if (resolvedInterop === "none") {
            metadata.interop = "none";
        } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
            metadata.interop = "node-namespace";
        } else if (resolvedInterop === "node" && metadata.interop === "default") {
            metadata.interop = "node-default";
        } else if (esNamespaceOnly && metadata.interop === "namespace") {
            metadata.interop = "default";
        }
    }
    return {
        exportName,
        exportNameListName: null,
        hasExports,
        local,
        source: sources,
        stringSpecifiers
    };
}
function getExportSpecifierName(path, stringSpecifiers) {
    if (path.isIdentifier()) {
        return path.node.name;
    } else if (path.isStringLiteral()) {
        const stringValue = path.node.value;
        if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
            stringSpecifiers.add(stringValue);
        }
        return stringValue;
    } else {
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);
    }
}
function assertExportSpecifier(path) {
    if (path.isExportSpecifier()) {
        return;
    } else if (path.isExportNamespaceSpecifier()) {
        throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
    } else {
        throw path.buildCodeFrameError("Unexpected export specifier type");
    }
}
function getModuleMetadata(programPath, { getWrapperPayload, initializeReexports }, stringSpecifiers) {
    const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
    const importNodes = new Map();
    const sourceData = new Map();
    const getData = (sourceNode, node)=>{
        const source = sourceNode.value;
        let data = sourceData.get(source);
        if (!data) {
            data = {
                name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
                interop: "none",
                loc: null,
                imports: new Map(),
                importsNamespace: new Set(),
                reexports: new Map(),
                reexportNamespace: new Set(),
                reexportAll: null,
                wrap: null,
                get lazy () {
                    return this.wrap === "lazy";
                },
                referenced: false
            };
            sourceData.set(source, data);
            importNodes.set(source, [
                node
            ]);
        } else {
            importNodes.get(source).push(node);
        }
        return data;
    };
    let hasExports = false;
    programPath.get("body").forEach((child)=>{
        if (child.isImportDeclaration()) {
            const data = getData(child.node.source, child.node);
            if (!data.loc) data.loc = child.node.loc;
            child.get("specifiers").forEach((spec)=>{
                if (spec.isImportDefaultSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data.imports.set(localName, "default");
                    const reexport = localData.get(localName);
                    if (reexport) {
                        localData.delete(localName);
                        reexport.names.forEach((name)=>{
                            data.reexports.set(name, "default");
                        });
                        data.referenced = true;
                    }
                } else if (spec.isImportNamespaceSpecifier()) {
                    const localName = spec.get("local").node.name;
                    data.importsNamespace.add(localName);
                    const reexport = localData.get(localName);
                    if (reexport) {
                        localData.delete(localName);
                        reexport.names.forEach((name)=>{
                            data.reexportNamespace.add(name);
                        });
                        data.referenced = true;
                    }
                } else if (spec.isImportSpecifier()) {
                    const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
                    const localName = spec.get("local").node.name;
                    data.imports.set(localName, importName);
                    const reexport = localData.get(localName);
                    if (reexport) {
                        localData.delete(localName);
                        reexport.names.forEach((name)=>{
                            data.reexports.set(name, importName);
                        });
                        data.referenced = true;
                    }
                }
            });
        } else if (child.isExportAllDeclaration()) {
            hasExports = true;
            const data = getData(child.node.source, child.node);
            if (!data.loc) data.loc = child.node.loc;
            data.reexportAll = {
                loc: child.node.loc
            };
            data.referenced = true;
        } else if (child.isExportNamedDeclaration() && child.node.source) {
            hasExports = true;
            const data = getData(child.node.source, child.node);
            if (!data.loc) data.loc = child.node.loc;
            child.get("specifiers").forEach((spec)=>{
                assertExportSpecifier(spec);
                const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
                const exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
                data.reexports.set(exportName, importName);
                data.referenced = true;
                if (exportName === "__esModule") {
                    throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                }
            });
        } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
            hasExports = true;
        }
    });
    for (const metadata of sourceData.values()){
        let needsDefault = false;
        let needsNamed = false;
        if (metadata.importsNamespace.size > 0) {
            needsDefault = true;
            needsNamed = true;
        }
        if (metadata.reexportAll) {
            needsNamed = true;
        }
        for (const importName of metadata.imports.values()){
            if (importName === "default") needsDefault = true;
            else needsNamed = true;
        }
        for (const importName of metadata.reexports.values()){
            if (importName === "default") needsDefault = true;
            else needsNamed = true;
        }
        if (needsDefault && needsNamed) {
            metadata.interop = "namespace";
        } else if (needsDefault) {
            metadata.interop = "default";
        }
    }
    if (getWrapperPayload) {
        for (const [source, metadata] of sourceData){
            metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
        }
    }
    return {
        hasExports,
        local: localData,
        sources: sourceData
    };
}
function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
    const bindingKindLookup = new Map();
    programPath.get("body").forEach((child)=>{
        let kind;
        if (child.isImportDeclaration()) {
            kind = "import";
        } else {
            if (child.isExportDefaultDeclaration()) {
                child = child.get("declaration");
            }
            if (child.isExportNamedDeclaration()) {
                if (child.node.declaration) {
                    child = child.get("declaration");
                } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
                    child.get("specifiers").forEach((spec)=>{
                        assertExportSpecifier(spec);
                        bindingKindLookup.set(spec.get("local").node.name, "block");
                    });
                    return;
                }
            }
            if (child.isFunctionDeclaration()) {
                kind = "hoisted";
            } else if (child.isClassDeclaration()) {
                kind = "block";
            } else if (child.isVariableDeclaration({
                kind: "var"
            })) {
                kind = "var";
            } else if (child.isVariableDeclaration()) {
                kind = "block";
            } else {
                return;
            }
        }
        Object.keys(child.getOuterBindingIdentifiers()).forEach((name)=>{
            bindingKindLookup.set(name, kind);
        });
    });
    const localMetadata = new Map();
    const getLocalMetadata = (idPath)=>{
        const localName = idPath.node.name;
        let metadata = localMetadata.get(localName);
        if (!metadata) {
            const kind = bindingKindLookup.get(localName);
            if (kind === undefined) {
                throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
            }
            metadata = {
                names: [],
                kind
            };
            localMetadata.set(localName, metadata);
        }
        return metadata;
    };
    programPath.get("body").forEach((child)=>{
        if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
            if (child.node.declaration) {
                const declaration = child.get("declaration");
                const ids = declaration.getOuterBindingIdentifierPaths();
                Object.keys(ids).forEach((name)=>{
                    if (name === "__esModule") {
                        throw declaration.buildCodeFrameError('Illegal export "__esModule".');
                    }
                    getLocalMetadata(ids[name]).names.push(name);
                });
            } else {
                child.get("specifiers").forEach((spec)=>{
                    const local = spec.get("local");
                    const exported = spec.get("exported");
                    const localMetadata = getLocalMetadata(local);
                    const exportName = getExportSpecifierName(exported, stringSpecifiers);
                    if (exportName === "__esModule") {
                        throw exported.buildCodeFrameError('Illegal export "__esModule".');
                    }
                    localMetadata.names.push(exportName);
                });
            }
        } else if (child.isExportDefaultDeclaration()) {
            const declaration = child.get("declaration");
            if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
                getLocalMetadata(declaration.get("id")).names.push("default");
            } else {
                throw declaration.buildCodeFrameError("Unexpected default expression export.");
            }
        }
    });
    return localMetadata;
}
function nameAnonymousExports(programPath) {
    programPath.get("body").forEach((child)=>{
        if (!child.isExportDefaultDeclaration()) return;
        {
            var _child$splitExportDec;
            (_child$splitExportDec = child.splitExportDeclaration) != null ? _child$splitExportDec : child.splitExportDeclaration = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.splitExportDeclaration;
        }
        child.splitExportDeclaration();
    });
}
function removeImportExportDeclarations(programPath) {
    programPath.get("body").forEach((child)=>{
        if (child.isImportDeclaration()) {
            child.remove();
        } else if (child.isExportNamedDeclaration()) {
            if (child.node.declaration) {
                child.node.declaration._blockHoist = child.node._blockHoist;
                child.replaceWith(child.node.declaration);
            } else {
                child.remove();
            }
        } else if (child.isExportDefaultDeclaration()) {
            const declaration = child.get("declaration");
            if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
                declaration._blockHoist = child.node._blockHoist;
                child.replaceWith(declaration);
            } else {
                throw declaration.buildCodeFrameError("Unexpected default expression export.");
            }
        } else if (child.isExportAllDeclaration()) {
            child.remove();
        }
    });
} //# sourceMappingURL=normalize-and-load-metadata.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toGetWrapperPayload = toGetWrapperPayload;
exports.wrapReference = wrapReference;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _normalizeAndLoadMetadata = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js [app-ssr] (ecmascript)");
function toGetWrapperPayload(lazy) {
    return (source, metadata)=>{
        if (lazy === false) return null;
        if ((0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) || metadata.reexportAll) return null;
        if (lazy === true) {
            return source.includes(".") ? null : "lazy";
        }
        if (Array.isArray(lazy)) {
            return !lazy.includes(source) ? null : "lazy";
        }
        if (typeof lazy === "function") {
            return lazy(source) ? "lazy" : null;
        }
        throw new Error(`.lazy must be a boolean, string array, or function`);
    };
}
function wrapReference(ref, payload) {
    if (payload === "lazy") return _core.types.callExpression(ref, []);
    return null;
} //# sourceMappingURL=lazy-modules.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildDynamicImport = buildDynamicImport;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
{
    exports.getDynamicImportSource = function getDynamicImportSource(node) {
        const [source] = node.arguments;
        return _core.types.isStringLiteral(source) || _core.types.isTemplateLiteral(source) ? source : _core.template.expression.ast`\`\${${source}}\``;
    };
}function buildDynamicImport(node, deferToThen, wrapWithPromise, builder) {
    const specifier = _core.types.isCallExpression(node) ? node.arguments[0] : node.source;
    if (_core.types.isStringLiteral(specifier) || _core.types.isTemplateLiteral(specifier) && specifier.quasis.length === 0) {
        if (deferToThen) {
            return _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `;
        } else return builder(specifier);
    }
    const specifierToString = _core.types.isTemplateLiteral(specifier) ? _core.types.identifier("specifier") : _core.types.templateLiteral([
        _core.types.templateElement({
            raw: ""
        }),
        _core.types.templateElement({
            raw: ""
        })
    ], [
        _core.types.identifier("specifier")
    ]);
    if (deferToThen) {
        return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    `;
    } else if (wrapWithPromise) {
        return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `;
    } else {
        return _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
    }
} //# sourceMappingURL=dynamic-import.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/get-module-name.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = getModuleName;
{
    const originalGetModuleName = getModuleName;
    exports.default = getModuleName = function getModuleName(rootOpts, pluginOpts) {
        var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
        return originalGetModuleName(rootOpts, {
            moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
            moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
            getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
            moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
        });
    };
}function getModuleName(rootOpts, pluginOpts) {
    const { filename, filenameRelative = filename, sourceRoot = pluginOpts.moduleRoot } = rootOpts;
    const { moduleId, moduleIds = !!moduleId, getModuleId, moduleRoot = sourceRoot } = pluginOpts;
    if (!moduleIds) return null;
    if (moduleId != null && !getModuleId) {
        return moduleId;
    }
    let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
    if (filenameRelative) {
        const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
        moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.\w*$/, "");
    }
    moduleName = moduleName.replace(/\\/g, "/");
    if (getModuleId) {
        return getModuleId(moduleName) || moduleName;
    } else {
        return moduleName;
    }
} //# sourceMappingURL=get-module-name.js.map
}}),
"[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "buildDynamicImport", {
    enumerable: true,
    get: function() {
        return _dynamicImport.buildDynamicImport;
    }
});
exports.buildNamespaceInitStatements = buildNamespaceInitStatements;
exports.ensureStatementsHoisted = ensureStatementsHoisted;
Object.defineProperty(exports, "getModuleName", {
    enumerable: true,
    get: function() {
        return _getModuleName.default;
    }
});
Object.defineProperty(exports, "hasExports", {
    enumerable: true,
    get: function() {
        return _normalizeAndLoadMetadata.hasExports;
    }
});
Object.defineProperty(exports, "isModule", {
    enumerable: true,
    get: function() {
        return _helperModuleImports.isModule;
    }
});
Object.defineProperty(exports, "isSideEffectImport", {
    enumerable: true,
    get: function() {
        return _normalizeAndLoadMetadata.isSideEffectImport;
    }
});
exports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
Object.defineProperty(exports, "rewriteThis", {
    enumerable: true,
    get: function() {
        return _rewriteThis.default;
    }
});
exports.wrapInterop = wrapInterop;
var _assert = __turbopack_require__("[externals]/assert [external] (assert, cjs)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleImports = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/index.js [app-ssr] (ecmascript)");
var _rewriteThis = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js [app-ssr] (ecmascript)");
var _rewriteLiveReferences = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js [app-ssr] (ecmascript)");
var _normalizeAndLoadMetadata = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js [app-ssr] (ecmascript)");
var Lazy = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js [app-ssr] (ecmascript)");
var _dynamicImport = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js [app-ssr] (ecmascript)");
var _getModuleName = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/get-module-name.js [app-ssr] (ecmascript)");
{
    exports.getDynamicImportSource = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js [app-ssr] (ecmascript)").getDynamicImportSource;
}function rewriteModuleStatementsAndPrepareHeader(path, { exportName, strict, allowTopLevelThis, strictMode, noInterop, importInterop = noInterop ? "none" : "babel", lazy, getWrapperPayload = Lazy.toGetWrapperPayload(lazy != null ? lazy : false), wrapReference = Lazy.wrapReference, esNamespaceOnly, filename, constantReexports = arguments[1].loose, enumerableModuleMeta = arguments[1].loose, noIncompleteNsImportDetection }) {
    (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);
    _assert((0, _helperModuleImports.isModule)(path), "Cannot process module statements in a script");
    path.node.sourceType = "script";
    const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {
        importInterop,
        initializeReexports: constantReexports,
        getWrapperPayload,
        esNamespaceOnly,
        filename
    });
    if (!allowTopLevelThis) {
        (0, _rewriteThis.default)(path);
    }
    (0, _rewriteLiveReferences.default)(path, meta, wrapReference);
    if (strictMode !== false) {
        const hasStrict = path.node.directives.some((directive)=>{
            return directive.value.value === "use strict";
        });
        if (!hasStrict) {
            path.unshiftContainer("directives", _core.types.directive(_core.types.directiveLiteral("use strict")));
        }
    }
    const headers = [];
    if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
        headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
    }
    const nameList = buildExportNameListDeclaration(path, meta);
    if (nameList) {
        meta.exportNameListName = nameList.name;
        headers.push(nameList.statement);
    }
    headers.push(...buildExportInitializationStatements(path, meta, wrapReference, constantReexports, noIncompleteNsImportDetection));
    return {
        meta,
        headers
    };
}
function ensureStatementsHoisted(statements) {
    statements.forEach((header)=>{
        header._blockHoist = 3;
    });
}
function wrapInterop(programPath, expr, type) {
    if (type === "none") {
        return null;
    }
    if (type === "node-namespace") {
        return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"), [
            expr,
            _core.types.booleanLiteral(true)
        ]);
    } else if (type === "node-default") {
        return null;
    }
    let helper;
    if (type === "default") {
        helper = "interopRequireDefault";
    } else if (type === "namespace") {
        helper = "interopRequireWildcard";
    } else {
        throw new Error(`Unknown interop: ${type}`);
    }
    return _core.types.callExpression(programPath.hub.addHelper(helper), [
        expr
    ]);
}
function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false, wrapReference = Lazy.wrapReference) {
    var _wrapReference;
    const statements = [];
    const srcNamespaceId = _core.types.identifier(sourceMetadata.name);
    for (const localName of sourceMetadata.importsNamespace){
        if (localName === sourceMetadata.name) continue;
        statements.push(_core.template.statement`var NAME = SOURCE;`({
            NAME: localName,
            SOURCE: _core.types.cloneNode(srcNamespaceId)
        }));
    }
    const srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
    if (constantReexports) {
        statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference));
    }
    for (const exportName of sourceMetadata.reexportNamespace){
        statements.push((!_core.types.isIdentifier(srcNamespace) ? _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _core.template.statement`EXPORTS.NAME = NAMESPACE;`)({
            EXPORTS: metadata.exportName,
            NAME: exportName,
            NAMESPACE: _core.types.cloneNode(srcNamespace)
        }));
    }
    if (sourceMetadata.reexportAll) {
        const statement = buildNamespaceReexport(metadata, _core.types.cloneNode(srcNamespace), constantReexports);
        statement.loc = sourceMetadata.reexportAll.loc;
        statements.push(statement);
    }
    return statements;
}
const ReexportTemplate = {
    constant: ({ exports: exports1, exportName, namespaceImport })=>_core.template.statement.ast`
      ${exports1}.${exportName} = ${namespaceImport};
    `,
    constantComputed: ({ exports: exports1, exportName, namespaceImport })=>_core.template.statement.ast`
      ${exports1}["${exportName}"] = ${namespaceImport};
    `,
    spec: ({ exports: exports1, exportName, namespaceImport })=>_core.template.statement.ast`
      Object.defineProperty(${exports1}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `
};
function buildReexportsFromMeta(meta, metadata, constantReexports, wrapReference) {
    var _wrapReference2;
    let namespace = _core.types.identifier(metadata.name);
    namespace = (_wrapReference2 = wrapReference(namespace, metadata.wrap)) != null ? _wrapReference2 : namespace;
    const { stringSpecifiers } = meta;
    return Array.from(metadata.reexports, ([exportName, importName])=>{
        let namespaceImport = _core.types.cloneNode(namespace);
        if (importName === "default" && metadata.interop === "node-default") {} else if (stringSpecifiers.has(importName)) {
            namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.stringLiteral(importName), true);
        } else {
            namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.identifier(importName));
        }
        const astNodes = {
            exports: meta.exportName,
            exportName,
            namespaceImport
        };
        if (constantReexports || _core.types.isIdentifier(namespaceImport)) {
            if (stringSpecifiers.has(exportName)) {
                return ReexportTemplate.constantComputed(astNodes);
            } else {
                return ReexportTemplate.constant(astNodes);
            }
        } else {
            return ReexportTemplate.spec(astNodes);
        }
    });
}
function buildESModuleHeader(metadata, enumerableModuleMeta = false) {
    return (enumerableModuleMeta ? _core.template.statement`
        EXPORTS.__esModule = true;
      ` : _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
        EXPORTS: metadata.exportName
    });
}
function buildNamespaceReexport(metadata, namespace, constantReexports) {
    return (constantReexports ? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
        NAMESPACE: namespace,
        EXPORTS: metadata.exportName,
        VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
            EXPORTS_LIST: metadata.exportNameListName
        }) : null
    });
}
function buildExportNameListDeclaration(programPath, metadata) {
    const exportedVars = Object.create(null);
    for (const data of metadata.local.values()){
        for (const name of data.names){
            exportedVars[name] = true;
        }
    }
    let hasReexport = false;
    for (const data of metadata.source.values()){
        for (const exportName of data.reexports.keys()){
            exportedVars[exportName] = true;
        }
        for (const exportName of data.reexportNamespace){
            exportedVars[exportName] = true;
        }
        hasReexport = hasReexport || !!data.reexportAll;
    }
    if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
    const name = programPath.scope.generateUidIdentifier("exportNames");
    delete exportedVars.default;
    return {
        name: name.name,
        statement: _core.types.variableDeclaration("var", [
            _core.types.variableDeclarator(name, _core.types.valueToNode(exportedVars))
        ])
    };
}
function buildExportInitializationStatements(programPath, metadata, wrapReference, constantReexports = false, noIncompleteNsImportDetection = false) {
    const initStatements = [];
    for (const [localName, data] of metadata.local){
        if (data.kind === "import") {} else if (data.kind === "hoisted") {
            initStatements.push([
                data.names[0],
                buildInitStatement(metadata, data.names, _core.types.identifier(localName))
            ]);
        } else if (!noIncompleteNsImportDetection) {
            for (const exportName of data.names){
                initStatements.push([
                    exportName,
                    null
                ]);
            }
        }
    }
    for (const data of metadata.source.values()){
        if (!constantReexports) {
            const reexportsStatements = buildReexportsFromMeta(metadata, data, false, wrapReference);
            const reexports = [
                ...data.reexports.keys()
            ];
            for(let i = 0; i < reexportsStatements.length; i++){
                initStatements.push([
                    reexports[i],
                    reexportsStatements[i]
                ]);
            }
        }
        if (!noIncompleteNsImportDetection) {
            for (const exportName of data.reexportNamespace){
                initStatements.push([
                    exportName,
                    null
                ]);
            }
        }
    }
    initStatements.sort(([a], [b])=>{
        if (a < b) return -1;
        if (b < a) return 1;
        return 0;
    });
    const results = [];
    if (noIncompleteNsImportDetection) {
        for (const [, initStatement] of initStatements){
            results.push(initStatement);
        }
    } else {
        const chunkSize = 100;
        for(let i = 0; i < initStatements.length; i += chunkSize){
            let uninitializedExportNames = [];
            for(let j = 0; j < chunkSize && i + j < initStatements.length; j++){
                const [exportName, initStatement] = initStatements[i + j];
                if (initStatement !== null) {
                    if (uninitializedExportNames.length > 0) {
                        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
                        uninitializedExportNames = [];
                    }
                    results.push(initStatement);
                } else {
                    uninitializedExportNames.push(exportName);
                }
            }
            if (uninitializedExportNames.length > 0) {
                results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
            }
        }
    }
    return results;
}
const InitTemplate = {
    computed: ({ exports: exports1, name, value })=>_core.template.expression.ast`${exports1}["${name}"] = ${value}`,
    default: ({ exports: exports1, name, value })=>_core.template.expression.ast`${exports1}.${name} = ${value}`,
    define: ({ exports: exports1, name, value })=>_core.template.expression.ast`
      Object.defineProperty(${exports1}, "${name}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name}"] = ${value}`
};
function buildInitStatement(metadata, exportNames, initExpr) {
    const { stringSpecifiers, exportName: exports1 } = metadata;
    return _core.types.expressionStatement(exportNames.reduce((value, name)=>{
        const params = {
            exports: exports1,
            name,
            value
        };
        if (name === "__proto__") {
            return InitTemplate.define(params);
        }
        if (stringSpecifiers.has(name)) {
            return InitTemplate.computed(params);
        }
        return InitTemplate.default(params);
    }, initExpr));
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/preset-typescript/package.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"name\":\"@babel/preset-typescript\",\"version\":\"7.26.0\",\"description\":\"Babel preset for TypeScript.\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/babel/babel.git\",\"directory\":\"packages/babel-preset-typescript\"},\"license\":\"MIT\",\"publishConfig\":{\"access\":\"public\"},\"main\":\"./lib/index.js\",\"keywords\":[\"babel-preset\",\"typescript\"],\"dependencies\":{\"@babel/helper-plugin-utils\":\"^7.25.9\",\"@babel/helper-validator-option\":\"^7.25.9\",\"@babel/plugin-syntax-jsx\":\"^7.25.9\",\"@babel/plugin-transform-modules-commonjs\":\"^7.25.9\",\"@babel/plugin-transform-typescript\":\"^7.25.9\"},\"peerDependencies\":{\"@babel/core\":\"^7.0.0-0\"},\"devDependencies\":{\"@babel/core\":\"^7.26.0\",\"@babel/helper-plugin-test-runner\":\"^7.25.9\"},\"homepage\":\"https://babel.dev/docs/en/next/babel-preset-typescript\",\"bugs\":\"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen\",\"engines\":{\"node\":\">=6.9.0\"},\"author\":\"The Babel Team (https://babel.dev/team)\",\"type\":\"commonjs\"}"));}}),
"[project]/node_modules/@babel/preset-typescript/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var transformTypeScript = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/index.js [app-ssr] (ecmascript)");
__turbopack_require__("[project]/node_modules/@babel/plugin-syntax-jsx/lib/index.js [app-ssr] (ecmascript)");
var transformModulesCommonJS = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js [app-ssr] (ecmascript)");
var helperValidatorOption = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)");
function _interopDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
var transformTypeScript__default = /*#__PURE__*/ _interopDefault(transformTypeScript);
var transformModulesCommonJS__default = /*#__PURE__*/ _interopDefault(transformModulesCommonJS);
const v = new helperValidatorOption.OptionValidator("@babel/preset-typescript");
function normalizeOptions(options = {}) {
    let { allowNamespaces = true, jsxPragma, onlyRemoveTypeImports } = options;
    const TopLevelOptions = {
        ignoreExtensions: "ignoreExtensions",
        allowNamespaces: "allowNamespaces",
        disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
        jsxPragma: "jsxPragma",
        jsxPragmaFrag: "jsxPragmaFrag",
        onlyRemoveTypeImports: "onlyRemoveTypeImports",
        optimizeConstEnums: "optimizeConstEnums",
        rewriteImportExtensions: "rewriteImportExtensions",
        allExtensions: "allExtensions",
        isTSX: "isTSX"
    };
    const jsxPragmaFrag = v.validateStringOption(TopLevelOptions.jsxPragmaFrag, options.jsxPragmaFrag, "React.Fragment");
    {
        var allExtensions = v.validateBooleanOption(TopLevelOptions.allExtensions, options.allExtensions, false);
        var isTSX = v.validateBooleanOption(TopLevelOptions.isTSX, options.isTSX, false);
        if (isTSX) {
            v.invariant(allExtensions, "isTSX:true requires allExtensions:true");
        }
    }
    const ignoreExtensions = v.validateBooleanOption(TopLevelOptions.ignoreExtensions, options.ignoreExtensions, false);
    const disallowAmbiguousJSXLike = v.validateBooleanOption(TopLevelOptions.disallowAmbiguousJSXLike, options.disallowAmbiguousJSXLike, false);
    if (disallowAmbiguousJSXLike) {
        {
            v.invariant(allExtensions, "disallowAmbiguousJSXLike:true requires allExtensions:true");
        }
    }
    const optimizeConstEnums = v.validateBooleanOption(TopLevelOptions.optimizeConstEnums, options.optimizeConstEnums, false);
    const rewriteImportExtensions = v.validateBooleanOption(TopLevelOptions.rewriteImportExtensions, options.rewriteImportExtensions, false);
    const normalized = {
        ignoreExtensions,
        allowNamespaces,
        disallowAmbiguousJSXLike,
        jsxPragma,
        jsxPragmaFrag,
        onlyRemoveTypeImports,
        optimizeConstEnums,
        rewriteImportExtensions
    };
    {
        normalized.allExtensions = allExtensions;
        normalized.isTSX = isTSX;
    }
    return normalized;
}
var pluginRewriteTSImports = helperPluginUtils.declare(function({ types: t, template }) {
    function maybeReplace(source, path) {
        if (!source) return;
        if (t.isStringLiteral(source)) {
            if (/[\\/]/.test(source.value)) {
                source.value = source.value.replace(/(\.[mc]?)ts$/, "$1js").replace(/\.tsx$/, ".js");
            }
            return;
        }
        path.replaceWith(template.expression.ast`(${source} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`);
    }
    return {
        name: "preset-typescript/plugin-rewrite-ts-imports",
        visitor: {
            "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration" (path) {
                const node = path.node;
                const kind = t.isImportDeclaration(node) ? node.importKind : node.exportKind;
                if (kind === "value") {
                    maybeReplace(node.source, path.get("source"));
                }
            },
            CallExpression (path) {
                if (t.isImport(path.node.callee)) {
                    maybeReplace(path.node.arguments[0], path.get("arguments.0"));
                }
            },
            ImportExpression (path) {
                maybeReplace(path.node.source, path.get("source"));
            }
        }
    };
});
var index = helperPluginUtils.declarePreset((api, opts)=>{
    api.assertVersion(7);
    const { allExtensions, ignoreExtensions, allowNamespaces, disallowAmbiguousJSXLike, isTSX, jsxPragma, jsxPragmaFrag, onlyRemoveTypeImports, optimizeConstEnums, rewriteImportExtensions } = normalizeOptions(opts);
    const pluginOptions = (disallowAmbiguousJSXLike)=>({
            allowDeclareFields: opts.allowDeclareFields,
            allowNamespaces,
            disallowAmbiguousJSXLike,
            jsxPragma,
            jsxPragmaFrag,
            onlyRemoveTypeImports,
            optimizeConstEnums
        });
    const getPlugins = (isTSX, disallowAmbiguousJSXLike)=>{
        {
            return [
                [
                    transformTypeScript__default.default,
                    Object.assign({
                        isTSX
                    }, pluginOptions(disallowAmbiguousJSXLike))
                ]
            ];
        }
    };
    const disableExtensionDetect = allExtensions || ignoreExtensions;
    return {
        plugins: rewriteImportExtensions ? [
            pluginRewriteTSImports
        ] : [],
        overrides: disableExtensionDetect ? [
            {
                plugins: getPlugins(isTSX, disallowAmbiguousJSXLike)
            }
        ] : [
            {
                test: /\.ts$/,
                plugins: getPlugins(false, false)
            },
            {
                test: /\.mts$/,
                sourceType: "module",
                plugins: getPlugins(false, true)
            },
            {
                test: /\.cts$/,
                sourceType: "unambiguous",
                plugins: [
                    [
                        transformModulesCommonJS__default.default,
                        {
                            allowTopLevelThis: true
                        }
                    ],
                    [
                        transformTypeScript__default.default,
                        pluginOptions(true)
                    ]
                ]
            },
            {
                test: /\.tsx$/,
                plugins: getPlugins(true, false)
            }
        ]
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.declare = declare;
exports.declarePreset = void 0;
const apiPolyfills = {
    assertVersion: (api)=>(range)=>{
            throwVersionError(range, api.version);
        }
};
{
    Object.assign(apiPolyfills, {
        targets: ()=>()=>{
                return {};
            },
        assumption: ()=>()=>{
                return undefined;
            },
        addExternalDependency: ()=>()=>{}
    });
}function declare(builder) {
    return (api, options, dirname)=>{
        var _clonedApi2;
        let clonedApi;
        for (const name of Object.keys(apiPolyfills)){
            var _clonedApi;
            if (api[name]) continue;
            (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);
            clonedApi[name] = apiPolyfills[name](clonedApi);
        }
        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
    };
}
const declarePreset = exports.declarePreset = declare;
function copyApiObject(api) {
    let proto = null;
    if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);
        if (proto && (!hasOwnProperty.call(proto, "version") || !hasOwnProperty.call(proto, "transform") || !hasOwnProperty.call(proto, "template") || !hasOwnProperty.call(proto, "types"))) {
            proto = null;
        }
    }
    return Object.assign({}, proto, api);
}
function throwVersionError(range, version) {
    if (typeof range === "number") {
        if (!Number.isInteger(range)) {
            throw new Error("Expected string or integer value.");
        }
        range = `^${range}.0.0-0`;
    }
    if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
    }
    const limit = Error.stackTraceLimit;
    if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
    }
    let err;
    if (version.slice(0, 2) === "7.") {
        err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". ` + `You'll need to update your @babel/core version.`);
    } else {
        err = new Error(`Requires Babel "${range}", but was loaded with "${version}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);
    }
    if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
    }
    throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version,
        range
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-syntax-typescript/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
{
    var removePlugin = function(plugins, name) {
        const indices = [];
        plugins.forEach((plugin, i)=>{
            const n = Array.isArray(plugin) ? plugin[0] : plugin;
            if (n === name) {
                indices.unshift(i);
            }
        });
        for (const i of indices){
            plugins.splice(i, 1);
        }
    };
}var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts)=>{
    api.assertVersion(7);
    const { disallowAmbiguousJSXLike, dts } = opts;
    {
        var { isTSX } = opts;
    }
    return {
        name: "syntax-typescript",
        manipulateOptions (opts, parserOpts) {
            {
                const { plugins } = parserOpts;
                removePlugin(plugins, "flow");
                removePlugin(plugins, "jsx");
                {
                    plugins.push("objectRestSpread", "classProperties");
                }
                if (isTSX) {
                    plugins.push("jsx");
                }
            }
            parserOpts.plugins.push([
                "typescript",
                {
                    disallowAmbiguousJSXLike,
                    dts
                }
            ]);
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-member-expression-to-functions/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function(k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}
var _t__namespace = /*#__PURE__*/ _interopNamespace(_t);
function willPathCastToBoolean(path) {
    const maybeWrapped = path;
    const { node, parentPath } = maybeWrapped;
    if (parentPath.isLogicalExpression()) {
        const { operator, right } = parentPath.node;
        if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
            return willPathCastToBoolean(parentPath);
        }
    }
    if (parentPath.isSequenceExpression()) {
        const { expressions } = parentPath.node;
        if (expressions[expressions.length - 1] === node) {
            return willPathCastToBoolean(parentPath);
        } else {
            return true;
        }
    }
    return parentPath.isConditional({
        test: node
    }) || parentPath.isUnaryExpression({
        operator: "!"
    }) || parentPath.isLoop({
        test: node
    });
}
const { LOGICAL_OPERATORS, arrowFunctionExpression, assignmentExpression, binaryExpression, booleanLiteral, callExpression, cloneNode, conditionalExpression, identifier, isMemberExpression, isOptionalCallExpression, isOptionalMemberExpression, isUpdateExpression, logicalExpression, memberExpression, nullLiteral, optionalCallExpression, optionalMemberExpression, sequenceExpression, updateExpression } = _t__namespace;
class AssignmentMemoiser {
    constructor(){
        this._map = void 0;
        this._map = new WeakMap();
    }
    has(key) {
        return this._map.has(key);
    }
    get(key) {
        if (!this.has(key)) return;
        const record = this._map.get(key);
        const { value } = record;
        record.count--;
        if (record.count === 0) {
            return assignmentExpression("=", value, key);
        }
        return value;
    }
    set(key, value, count) {
        return this._map.set(key, {
            count,
            value
        });
    }
}
function toNonOptional(path, base) {
    const { node } = path;
    if (isOptionalMemberExpression(node)) {
        return memberExpression(base, node.property, node.computed);
    }
    if (path.isOptionalCallExpression()) {
        const callee = path.get("callee");
        if (path.node.optional && callee.isOptionalMemberExpression()) {
            const object = callee.node.object;
            const context = path.scope.maybeGenerateMemoised(object);
            callee.get("object").replaceWith(assignmentExpression("=", context, object));
            return callExpression(memberExpression(base, identifier("call")), [
                context,
                ...path.node.arguments
            ]);
        }
        return callExpression(base, path.node.arguments);
    }
    return path.node;
}
function isInDetachedTree(path) {
    while(path){
        if (path.isProgram()) break;
        const { parentPath, container, listKey } = path;
        const parentNode = parentPath.node;
        if (listKey) {
            if (container !== parentNode[listKey]) {
                return true;
            }
        } else {
            if (container !== parentNode) return true;
        }
        path = parentPath;
    }
    return false;
}
const handle = {
    memoise () {},
    handle (member, noDocumentAll) {
        const { node, parent, parentPath, scope } = member;
        if (member.isOptionalMemberExpression()) {
            if (isInDetachedTree(member)) return;
            const endPath = member.find(({ node, parent })=>{
                if (isOptionalMemberExpression(parent)) {
                    return parent.optional || parent.object !== node;
                }
                if (isOptionalCallExpression(parent)) {
                    return node !== member.node && parent.optional || parent.callee !== node;
                }
                return true;
            });
            if (scope.path.isPattern()) {
                endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
                return;
            }
            const willEndPathCastToBoolean = willPathCastToBoolean(endPath);
            const rootParentPath = endPath.parentPath;
            if (rootParentPath.isUpdateExpression({
                argument: node
            })) {
                throw member.buildCodeFrameError(`can't handle update expression`);
            }
            const isAssignment = rootParentPath.isAssignmentExpression({
                left: endPath.node
            });
            const isDeleteOperation = rootParentPath.isUnaryExpression({
                operator: "delete"
            });
            if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
                throw member.buildCodeFrameError(`can't delete a private class element`);
            }
            let startingOptional = member;
            for(;;){
                if (startingOptional.isOptionalMemberExpression()) {
                    if (startingOptional.node.optional) break;
                    startingOptional = startingOptional.get("object");
                    continue;
                } else if (startingOptional.isOptionalCallExpression()) {
                    if (startingOptional.node.optional) break;
                    startingOptional = startingOptional.get("callee");
                    continue;
                }
                throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);
            }
            const startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee;
            const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
            const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
            const parentIsOptionalCall = parentPath.isOptionalCallExpression({
                callee: node
            });
            const isOptionalCall = (parent)=>parentIsOptionalCall;
            const parentIsCall = parentPath.isCallExpression({
                callee: node
            });
            startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));
            if (isOptionalCall()) {
                if (parent.optional) {
                    parentPath.replaceWith(this.optionalCall(member, parent.arguments));
                } else {
                    parentPath.replaceWith(this.call(member, parent.arguments));
                }
            } else if (parentIsCall) {
                member.replaceWith(this.boundGet(member));
            } else if (this.delete && parentPath.isUnaryExpression({
                operator: "delete"
            })) {
                parentPath.replaceWith(this.delete(member));
            } else if (parentPath.isAssignmentExpression()) {
                handleAssignment(this, member, parentPath);
            } else {
                member.replaceWith(this.get(member));
            }
            let regular = member.node;
            for(let current = member; current !== endPath;){
                const parentPath = current.parentPath;
                if (parentPath === endPath && isOptionalCall() && parent.optional) {
                    regular = parentPath.node;
                    break;
                }
                regular = toNonOptional(parentPath, regular);
                current = parentPath;
            }
            let context;
            const endParentPath = endPath.parentPath;
            if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
                callee: endPath.node,
                optional: true
            })) {
                const { object } = regular;
                context = member.scope.maybeGenerateMemoised(object);
                if (context) {
                    regular.object = assignmentExpression("=", context, object);
                }
            }
            let replacementPath = endPath;
            if (isDeleteOperation || isAssignment) {
                replacementPath = endParentPath;
                regular = endParentPath.node;
            }
            const baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);
            if (willEndPathCastToBoolean) {
                let nonNullishCheck;
                if (noDocumentAll) {
                    nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral());
                } else {
                    nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode()));
                }
                replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
            } else {
                let nullishCheck;
                if (noDocumentAll) {
                    nullishCheck = binaryExpression("==", baseMemoised, nullLiteral());
                } else {
                    nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode()));
                }
                replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
            }
            if (context) {
                const endParent = endParentPath.node;
                endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [
                    cloneNode(context),
                    ...endParent.arguments
                ], false));
            }
            return;
        }
        if (isUpdateExpression(parent, {
            argument: node
        })) {
            if (this.simpleSet) {
                member.replaceWith(this.simpleSet(member));
                return;
            }
            const { operator, prefix } = parent;
            this.memoise(member, 2);
            const ref = scope.generateUidIdentifierBasedOnNode(node);
            scope.push({
                id: ref
            });
            const seq = [
                assignmentExpression("=", cloneNode(ref), this.get(member))
            ];
            if (prefix) {
                seq.push(updateExpression(operator, cloneNode(ref), prefix));
                const value = sequenceExpression(seq);
                parentPath.replaceWith(this.set(member, value));
                return;
            } else {
                const ref2 = scope.generateUidIdentifierBasedOnNode(node);
                scope.push({
                    id: ref2
                });
                seq.push(assignmentExpression("=", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));
                const value = sequenceExpression(seq);
                parentPath.replaceWith(sequenceExpression([
                    this.set(member, value),
                    cloneNode(ref2)
                ]));
                return;
            }
        }
        if (parentPath.isAssignmentExpression({
            left: node
        })) {
            handleAssignment(this, member, parentPath);
            return;
        }
        if (parentPath.isCallExpression({
            callee: node
        })) {
            parentPath.replaceWith(this.call(member, parentPath.node.arguments));
            return;
        }
        if (parentPath.isOptionalCallExpression({
            callee: node
        })) {
            if (scope.path.isPattern()) {
                parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
                return;
            }
            parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));
            return;
        }
        if (this.delete && parentPath.isUnaryExpression({
            operator: "delete"
        })) {
            parentPath.replaceWith(this.delete(member));
            return;
        }
        if (parentPath.isForXStatement({
            left: node
        }) || parentPath.isObjectProperty({
            value: node
        }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
            left: node
        }) && parentPath.parentPath.isObjectProperty({
            value: parent
        }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
            left: node
        }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
            member.replaceWith(this.destructureSet(member));
            return;
        }
        if (parentPath.isTaggedTemplateExpression()) {
            member.replaceWith(this.boundGet(member));
        } else {
            member.replaceWith(this.get(member));
        }
    }
};
function handleAssignment(state, member, parentPath) {
    if (state.simpleSet) {
        member.replaceWith(state.simpleSet(member));
        return;
    }
    const { operator, right: value } = parentPath.node;
    if (operator === "=") {
        parentPath.replaceWith(state.set(member, value));
    } else {
        const operatorTrunc = operator.slice(0, -1);
        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
            state.memoise(member, 1);
            parentPath.replaceWith(logicalExpression(operatorTrunc, state.get(member), state.set(member, value)));
        } else {
            state.memoise(member, 2);
            parentPath.replaceWith(state.set(member, binaryExpression(operatorTrunc, state.get(member), value)));
        }
    }
}
function memberExpressionToFunctions(path, visitor, state) {
    path.traverse(visitor, Object.assign({}, handle, state, {
        memoiser: new AssignmentMemoiser()
    }));
}
exports.default = memberExpressionToFunctions; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-optimise-call-expression/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = optimiseCallExpression;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { callExpression, identifier, isIdentifier, isSpreadElement, memberExpression, optionalCallExpression, optionalMemberExpression } = _t;
function optimiseCallExpression(callee, thisNode, args, optional) {
    if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
        name: "arguments"
    })) {
        if (optional) {
            return optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [
                thisNode,
                args[0].argument
            ], false);
        }
        return callExpression(memberExpression(callee, identifier("apply")), [
            thisNode,
            args[0].argument
        ]);
    } else {
        if (optional) {
            return optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [
                thisNode,
                ...args
            ], false);
        }
        return callExpression(memberExpression(callee, identifier("call")), [
            thisNode,
            ...args
        ]);
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-replace-supers/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperMemberExpressionToFunctions = __turbopack_require__("[project]/node_modules/@babel/helper-member-expression-to-functions/lib/index.js [app-ssr] (ecmascript)");
var _helperOptimiseCallExpression = __turbopack_require__("[project]/node_modules/@babel/helper-optimise-call-expression/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
const { assignmentExpression, callExpression, cloneNode, identifier, memberExpression, sequenceExpression, stringLiteral, thisExpression } = _core.types;
{
    exports.environmentVisitor = _traverse.visitors.environmentVisitor({});
    exports.skipAllButComputedKey = function skipAllButComputedKey(path) {
        path.skip();
        if (path.node.computed) {
            path.context.maybeQueue(path.get("key"));
        }
    };
}const visitor = _traverse.visitors.environmentVisitor({
    Super (path, state) {
        const { node, parentPath } = path;
        if (!parentPath.isMemberExpression({
            object: node
        })) return;
        state.handle(parentPath);
    }
});
const unshadowSuperBindingVisitor = _traverse.visitors.environmentVisitor({
    Scopable (path, { refName }) {
        const binding = path.scope.getOwnBinding(refName);
        if (binding && binding.identifier.name === refName) {
            path.scope.rename(refName);
        }
    }
});
const specHandlers = {
    memoise (superMember, count) {
        const { scope, node } = superMember;
        const { computed, property } = node;
        if (!computed) {
            return;
        }
        const memo = scope.maybeGenerateMemoised(property);
        if (!memo) {
            return;
        }
        this.memoiser.set(property, memo, count);
    },
    prop (superMember) {
        const { computed, property } = superMember.node;
        if (this.memoiser.has(property)) {
            return cloneNode(this.memoiser.get(property));
        }
        if (computed) {
            return cloneNode(property);
        }
        return stringLiteral(property.name);
    },
    _getPrototypeOfExpression () {
        const objectRef = cloneNode(this.getObjectRef());
        const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
        return callExpression(this.file.addHelper("getPrototypeOf"), [
            targetRef
        ]);
    },
    get (superMember) {
        const objectRef = cloneNode(this.getObjectRef());
        return callExpression(this.file.addHelper("superPropGet"), [
            this.isDerivedConstructor ? sequenceExpression([
                thisExpression(),
                objectRef
            ]) : objectRef,
            this.prop(superMember),
            thisExpression(),
            ...this.isStatic || this.isPrivateMethod ? [] : [
                _core.types.numericLiteral(1)
            ]
        ]);
    },
    _call (superMember, args, optional) {
        const objectRef = cloneNode(this.getObjectRef());
        let argsNode;
        if (args.length === 1 && _core.types.isSpreadElement(args[0]) && (_core.types.isIdentifier(args[0].argument) || _core.types.isArrayExpression(args[0].argument))) {
            argsNode = args[0].argument;
        } else {
            argsNode = _core.types.arrayExpression(args);
        }
        const call = _core.types.callExpression(this.file.addHelper("superPropGet"), [
            this.isDerivedConstructor ? sequenceExpression([
                thisExpression(),
                objectRef
            ]) : objectRef,
            this.prop(superMember),
            thisExpression(),
            _core.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))
        ]);
        if (optional) {
            return _core.types.optionalCallExpression(call, [
                argsNode
            ], true);
        }
        return callExpression(call, [
            argsNode
        ]);
    },
    set (superMember, value) {
        const objectRef = cloneNode(this.getObjectRef());
        return callExpression(this.file.addHelper("superPropSet"), [
            this.isDerivedConstructor ? sequenceExpression([
                thisExpression(),
                objectRef
            ]) : objectRef,
            this.prop(superMember),
            value,
            thisExpression(),
            _core.types.numericLiteral(superMember.isInStrictMode() ? 1 : 0),
            ...this.isStatic || this.isPrivateMethod ? [] : [
                _core.types.numericLiteral(1)
            ]
        ]);
    },
    destructureSet (superMember) {
        throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
    },
    call (superMember, args) {
        return this._call(superMember, args, false);
    },
    optionalCall (superMember, args) {
        return this._call(superMember, args, true);
    },
    delete (superMember) {
        if (superMember.node.computed) {
            return sequenceExpression([
                callExpression(this.file.addHelper("toPropertyKey"), [
                    cloneNode(superMember.node.property)
                ]),
                _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `
            ]);
        } else {
            return _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        }
    }
};
const specHandlers_old = {
    memoise (superMember, count) {
        const { scope, node } = superMember;
        const { computed, property } = node;
        if (!computed) {
            return;
        }
        const memo = scope.maybeGenerateMemoised(property);
        if (!memo) {
            return;
        }
        this.memoiser.set(property, memo, count);
    },
    prop (superMember) {
        const { computed, property } = superMember.node;
        if (this.memoiser.has(property)) {
            return cloneNode(this.memoiser.get(property));
        }
        if (computed) {
            return cloneNode(property);
        }
        return stringLiteral(property.name);
    },
    _getPrototypeOfExpression () {
        const objectRef = cloneNode(this.getObjectRef());
        const targetRef = this.isStatic || this.isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
        return callExpression(this.file.addHelper("getPrototypeOf"), [
            targetRef
        ]);
    },
    get (superMember) {
        return this._get(superMember);
    },
    _get (superMember) {
        const proto = this._getPrototypeOfExpression();
        return callExpression(this.file.addHelper("get"), [
            this.isDerivedConstructor ? sequenceExpression([
                thisExpression(),
                proto
            ]) : proto,
            this.prop(superMember),
            thisExpression()
        ]);
    },
    set (superMember, value) {
        const proto = this._getPrototypeOfExpression();
        return callExpression(this.file.addHelper("set"), [
            this.isDerivedConstructor ? sequenceExpression([
                thisExpression(),
                proto
            ]) : proto,
            this.prop(superMember),
            value,
            thisExpression(),
            _core.types.booleanLiteral(superMember.isInStrictMode())
        ]);
    },
    destructureSet (superMember) {
        throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);
    },
    call (superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this._get(superMember), thisExpression(), args, false);
    },
    optionalCall (superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this._get(superMember), cloneNode(thisExpression()), args, true);
    },
    delete (superMember) {
        if (superMember.node.computed) {
            return sequenceExpression([
                callExpression(this.file.addHelper("toPropertyKey"), [
                    cloneNode(superMember.node.property)
                ]),
                _core.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `
            ]);
        } else {
            return _core.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        }
    }
};
const looseHandlers = Object.assign({}, specHandlers, {
    prop (superMember) {
        const { property } = superMember.node;
        if (this.memoiser.has(property)) {
            return cloneNode(this.memoiser.get(property));
        }
        return cloneNode(property);
    },
    get (superMember) {
        const { isStatic, getSuperRef } = this;
        const { computed } = superMember.node;
        const prop = this.prop(superMember);
        let object;
        if (isStatic) {
            var _getSuperRef;
            object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
        } else {
            var _getSuperRef2;
            object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
        }
        return memberExpression(object, prop, computed);
    },
    set (superMember, value) {
        const { computed } = superMember.node;
        const prop = this.prop(superMember);
        return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
    },
    destructureSet (superMember) {
        const { computed } = superMember.node;
        const prop = this.prop(superMember);
        return memberExpression(thisExpression(), prop, computed);
    },
    call (superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, false);
    },
    optionalCall (superMember, args) {
        return (0, _helperOptimiseCallExpression.default)(this.get(superMember), thisExpression(), args, true);
    }
});
class ReplaceSupers {
    constructor(opts){
        var _opts$constantSuper;
        const path = opts.methodPath;
        this.methodPath = path;
        this.isDerivedConstructor = path.isClassMethod({
            kind: "constructor"
        }) && !!opts.superRef;
        this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
        this.isPrivateMethod = path.isPrivate() && path.isMethod();
        this.file = opts.file;
        this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
        this.opts = opts;
    }
    getObjectRef() {
        return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
        if (this.opts.superRef) return cloneNode(this.opts.superRef);
        if (this.opts.getSuperRef) {
            return cloneNode(this.opts.getSuperRef());
        }
    }
    replace() {
        const { methodPath } = this;
        if (this.opts.refToPreserve) {
            methodPath.traverse(unshadowSuperBindingVisitor, {
                refName: this.opts.refToPreserve.name
            });
        }
        const handler = this.constantSuper ? looseHandlers : this.file.availableHelper("superPropSet") ? specHandlers : specHandlers_old;
        visitor.shouldSkip = (path)=>{
            if (path.parentPath === methodPath) {
                if (path.parentKey === "decorators" || path.parentKey === "key") {
                    return true;
                }
            }
        };
        (0, _helperMemberExpressionToFunctions.default)(methodPath, visitor, Object.assign({
            file: this.file,
            scope: this.methodPath.scope,
            isDerivedConstructor: this.isDerivedConstructor,
            isStatic: this.isStatic,
            isPrivateMethod: this.isPrivateMethod,
            getObjectRef: this.getObjectRef.bind(this),
            getSuperRef: this.getSuperRef.bind(this),
            boundGet: handler.get
        }, handler));
    }
}
exports.default = ReplaceSupers; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTransparentExprWrapper = isTransparentExprWrapper;
exports.skipTransparentExprWrapperNodes = skipTransparentExprWrapperNodes;
exports.skipTransparentExprWrappers = skipTransparentExprWrappers;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { isParenthesizedExpression, isTSAsExpression, isTSNonNullExpression, isTSSatisfiesExpression, isTSTypeAssertion, isTypeCastExpression } = _t;
function isTransparentExprWrapper(node) {
    return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
}
function skipTransparentExprWrappers(path) {
    while(isTransparentExprWrapper(path.node)){
        path = path.get("expression");
    }
    return path;
}
function skipTransparentExprWrapperNodes(node) {
    while(isTransparentExprWrapper(node)){
        node = node.expression;
    }
    return node;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = annotateAsPure;
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { addComment } = _t;
const PURE_ANNOTATION = "#__PURE__";
const isPureAnnotated = ({ leadingComments })=>!!leadingComments && leadingComments.some((comment)=>/[@#]__PURE__/.test(comment.value));
function annotateAsPure(pathOrNode) {
    const node = pathOrNode["node"] || pathOrNode;
    if (isPureAnnotated(node)) {
        return;
    }
    addComment(node, "leading", PURE_ANNOTATION);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typescript/lib/enum.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = transpileEnum;
exports.isSyntacticallyString = isSyntacticallyString;
exports.translateEnumValues = translateEnumValues;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _assert = __turbopack_require__("[externals]/assert [external] (assert, cjs)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _helperSkipTransparentExpressionWrappers = __turbopack_require__("[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)");
const ENUMS = new WeakMap();
const buildEnumWrapper = _core.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
function transpileEnum(path, t) {
    const { node, parentPath } = path;
    if (node.declare) {
        path.remove();
        return;
    }
    const name = node.id.name;
    const { fill, data, isPure } = enumFill(path, t, node.id);
    switch(parentPath.type){
        case "BlockStatement":
        case "ExportNamedDeclaration":
        case "Program":
            {
                const isGlobal = t.isProgram(path.parent);
                const isSeen = seen(parentPath);
                let init = t.objectExpression([]);
                if (isSeen || isGlobal) {
                    init = t.logicalExpression("||", t.cloneNode(fill.ID), init);
                }
                const enumIIFE = buildEnumWrapper(Object.assign({}, fill, {
                    INIT: init
                }));
                if (isPure) (0, _helperAnnotateAsPure.default)(enumIIFE);
                if (isSeen) {
                    const toReplace = parentPath.isExportDeclaration() ? parentPath : path;
                    toReplace.replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(node.id), enumIIFE)));
                } else {
                    path.scope.registerDeclaration(path.replaceWith(t.variableDeclaration(isGlobal ? "var" : "let", [
                        t.variableDeclarator(node.id, enumIIFE)
                    ]))[0]);
                }
                ENUMS.set(path.scope.getBindingIdentifier(name), data);
                break;
            }
        default:
            throw new Error(`Unexpected enum parent '${path.parent.type}`);
    }
    function seen(parentPath) {
        if (parentPath.isExportDeclaration()) {
            return seen(parentPath.parentPath);
        }
        if (parentPath.getData(name)) {
            return true;
        } else {
            parentPath.setData(name, true);
            return false;
        }
    }
}
const buildStringAssignment = (0, _core.template)(`
  ENUM["NAME"] = VALUE;
`);
const buildNumericAssignment = (0, _core.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`);
const buildEnumMember = (isString, options)=>(isString ? buildStringAssignment : buildNumericAssignment)(options);
function enumFill(path, t, id) {
    const { enumValues: x, data, isPure } = translateEnumValues(path, t);
    const assignments = x.map(([memberName, memberValue])=>buildEnumMember(isSyntacticallyString(memberValue), {
            ENUM: t.cloneNode(id),
            NAME: memberName,
            VALUE: memberValue
        }));
    return {
        fill: {
            ID: t.cloneNode(id),
            ASSIGNMENTS: assignments
        },
        data,
        isPure
    };
}
function isSyntacticallyString(expr) {
    expr = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(expr);
    switch(expr.type){
        case "BinaryExpression":
            {
                const left = expr.left;
                const right = expr.right;
                return expr.operator === "+" && (isSyntacticallyString(left) || isSyntacticallyString(right));
            }
        case "TemplateLiteral":
        case "StringLiteral":
            return true;
    }
    return false;
}
function ReferencedIdentifier(expr, state) {
    const { seen, path, t } = state;
    const name = expr.node.name;
    if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {
        expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));
        expr.skip();
    }
}
const enumSelfReferenceVisitor = {
    ReferencedIdentifier
};
function translateEnumValues(path, t) {
    var _ENUMS$get;
    const bindingIdentifier = path.scope.getBindingIdentifier(path.node.id.name);
    const seen = (_ENUMS$get = ENUMS.get(bindingIdentifier)) != null ? _ENUMS$get : new Map();
    let constValue = -1;
    let lastName;
    let isPure = true;
    const enumValues = path.get("members").map((memberPath)=>{
        const member = memberPath.node;
        const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
        const initializerPath = memberPath.get("initializer");
        const initializer = member.initializer;
        let value;
        if (initializer) {
            constValue = computeConstantValue(initializerPath, seen);
            if (constValue !== undefined) {
                seen.set(name, constValue);
                _assert(typeof constValue === "number" || typeof constValue === "string");
                if (constValue === Infinity || Number.isNaN(constValue)) {
                    value = t.identifier(String(constValue));
                } else if (constValue === -Infinity) {
                    value = t.unaryExpression("-", t.identifier("Infinity"));
                } else {
                    value = t.valueToNode(constValue);
                }
            } else {
                isPure && (isPure = initializerPath.isPure());
                if (initializerPath.isReferencedIdentifier()) {
                    ReferencedIdentifier(initializerPath, {
                        t,
                        seen,
                        path
                    });
                } else {
                    initializerPath.traverse(enumSelfReferenceVisitor, {
                        t,
                        seen,
                        path
                    });
                }
                value = initializerPath.node;
                seen.set(name, undefined);
            }
        } else if (typeof constValue === "number") {
            constValue += 1;
            value = t.numericLiteral(constValue);
            seen.set(name, constValue);
        } else if (typeof constValue === "string") {
            throw path.buildCodeFrameError("Enum member must have initializer.");
        } else {
            const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);
            value = t.binaryExpression("+", t.numericLiteral(1), lastRef);
            seen.set(name, undefined);
        }
        lastName = name;
        return [
            name,
            value
        ];
    });
    return {
        isPure,
        data: seen,
        enumValues
    };
}
function computeConstantValue(path, prevMembers, seen = new Set()) {
    return evaluate(path);
    "TURBOPACK unreachable";
    function evaluate(path) {
        const expr = path.node;
        switch(expr.type){
            case "MemberExpression":
                return evaluateRef(path, prevMembers, seen);
            case "StringLiteral":
                return expr.value;
            case "UnaryExpression":
                return evalUnaryExpression(path);
            case "BinaryExpression":
                return evalBinaryExpression(path);
            case "NumericLiteral":
                return expr.value;
            case "ParenthesizedExpression":
                return evaluate(path.get("expression"));
            case "Identifier":
                return evaluateRef(path, prevMembers, seen);
            case "TemplateLiteral":
                {
                    if (expr.quasis.length === 1) {
                        return expr.quasis[0].value.cooked;
                    }
                    const paths = path.get("expressions");
                    const quasis = expr.quasis;
                    let str = "";
                    for(let i = 0; i < quasis.length; i++){
                        str += quasis[i].value.cooked;
                        if (i + 1 < quasis.length) {
                            const value = evaluateRef(paths[i], prevMembers, seen);
                            if (value === undefined) return undefined;
                            str += value;
                        }
                    }
                    return str;
                }
            default:
                return undefined;
        }
    }
    function evaluateRef(path, prevMembers, seen) {
        if (path.isMemberExpression()) {
            const expr = path.node;
            const obj = expr.object;
            const prop = expr.property;
            if (!_core.types.isIdentifier(obj) || (expr.computed ? !_core.types.isStringLiteral(prop) : !_core.types.isIdentifier(prop))) {
                return;
            }
            const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);
            const data = ENUMS.get(bindingIdentifier);
            if (!data) return;
            return data.get(prop.computed ? prop.value : prop.name);
        } else if (path.isIdentifier()) {
            const name = path.node.name;
            if ([
                "Infinity",
                "NaN"
            ].includes(name)) {
                return Number(name);
            }
            let value = prevMembers == null ? void 0 : prevMembers.get(name);
            if (value !== undefined) {
                return value;
            }
            if (seen.has(path.node)) return;
            seen.add(path.node);
            value = computeConstantValue(path.resolve(), prevMembers, seen);
            prevMembers == null || prevMembers.set(name, value);
            return value;
        }
    }
    function evalUnaryExpression(path) {
        const value = evaluate(path.get("argument"));
        if (value === undefined) {
            return undefined;
        }
        switch(path.node.operator){
            case "+":
                return value;
            case "-":
                return -value;
            case "~":
                return ~value;
            default:
                return undefined;
        }
    }
    function evalBinaryExpression(path) {
        const left = evaluate(path.get("left"));
        if (left === undefined) {
            return undefined;
        }
        const right = evaluate(path.get("right"));
        if (right === undefined) {
            return undefined;
        }
        switch(path.node.operator){
            case "|":
                return left | right;
            case "&":
                return left & right;
            case ">>":
                return left >> right;
            case ">>>":
                return left >>> right;
            case "<<":
                return left << right;
            case "^":
                return left ^ right;
            case "*":
                return left * right;
            case "/":
                return left / right;
            case "+":
                return left + right;
            case "-":
                return left - right;
            case "%":
                return left % right;
            case "**":
                return Math.pow(left, right);
            default:
                return undefined;
        }
    }
} //# sourceMappingURL=enum.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = transpileConstEnum;
var _enum = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/enum.js [app-ssr] (ecmascript)");
function transpileConstEnum(path, t) {
    const { name } = path.node.id;
    const parentIsExport = path.parentPath.isExportNamedDeclaration();
    let isExported = parentIsExport;
    if (!isExported && t.isProgram(path.parent)) {
        isExported = path.parent.body.some((stmt)=>t.isExportNamedDeclaration(stmt) && stmt.exportKind !== "type" && !stmt.source && stmt.specifiers.some((spec)=>t.isExportSpecifier(spec) && spec.exportKind !== "type" && spec.local.name === name));
    }
    const { enumValues: entries } = (0, _enum.translateEnumValues)(path, t);
    if (isExported) {
        const obj = t.objectExpression(entries.map(([name, value])=>t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value)));
        if (path.scope.hasOwnBinding(name)) {
            (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), [
                path.node.id,
                obj
            ])));
        } else {
            path.replaceWith(t.variableDeclaration("var", [
                t.variableDeclarator(path.node.id, obj)
            ]));
            path.scope.registerDeclaration(path);
        }
        return;
    }
    const entriesMap = new Map(entries);
    path.scope.path.traverse({
        Scope (path) {
            if (path.scope.hasOwnBinding(name)) path.skip();
        },
        MemberExpression (path) {
            if (!t.isIdentifier(path.node.object, {
                name
            })) return;
            let key;
            if (path.node.computed) {
                if (t.isStringLiteral(path.node.property)) {
                    key = path.node.property.value;
                } else {
                    return;
                }
            } else if (t.isIdentifier(path.node.property)) {
                key = path.node.property.name;
            } else {
                return;
            }
            if (!entriesMap.has(key)) return;
            path.replaceWith(t.cloneNode(entriesMap.get(key)));
        }
    });
    path.remove();
} //# sourceMappingURL=const-enum.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typescript/lib/global-types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GLOBAL_TYPES = void 0;
exports.isGlobalType = isGlobalType;
exports.registerGlobalType = registerGlobalType;
const GLOBAL_TYPES = exports.GLOBAL_TYPES = new WeakMap();
function isGlobalType({ scope }, name) {
    if (scope.hasBinding(name)) return false;
    if (GLOBAL_TYPES.get(scope).has(name)) return true;
    console.warn(`The exported identifier "${name}" is not declared in Babel's scope tracker\n` + `as a JavaScript value binding, and "@babel/plugin-transform-typescript"\n` + `never encountered it as a TypeScript type declaration.\n` + `It will be treated as a JavaScript value.\n\n` + `This problem is likely caused by another plugin injecting\n` + `"${name}" without registering it in the scope tracker. If you are the author\n` + ` of that plugin, please use "scope.registerDeclaration(declarationPath)".`);
    return false;
}
function registerGlobalType(programScope, name) {
    GLOBAL_TYPES.get(programScope).add(name);
} //# sourceMappingURL=global-types.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typescript/lib/namespace.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = transpileNamespace;
exports.getFirstIdentifier = getFirstIdentifier;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _globalTypes = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/global-types.js [app-ssr] (ecmascript)");
function getFirstIdentifier(node) {
    if (_core.types.isIdentifier(node)) {
        return node;
    }
    return getFirstIdentifier(node.left);
}
function transpileNamespace(path, allowNamespaces) {
    if (path.node.declare || path.node.id.type === "StringLiteral") {
        path.remove();
        return;
    }
    if (!allowNamespaces) {
        throw path.get("id").buildCodeFrameError("Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }
    const name = getFirstIdentifier(path.node.id).name;
    const value = handleNested(path, path.node);
    if (value === null) {
        const program = path.findParent((p)=>p.isProgram());
        (0, _globalTypes.registerGlobalType)(program.scope, name);
        path.remove();
    } else if (path.scope.hasOwnBinding(name)) {
        path.replaceWith(value);
    } else {
        path.scope.registerDeclaration(path.replaceWithMultiple([
            getDeclaration(name),
            value
        ])[0]);
    }
}
function getDeclaration(name) {
    return _core.types.variableDeclaration("let", [
        _core.types.variableDeclarator(_core.types.identifier(name))
    ]);
}
function getMemberExpression(name, itemName) {
    return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));
}
function handleVariableDeclaration(node, name, hub) {
    if (node.kind !== "const") {
        throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }
    const { declarations } = node;
    if (declarations.every((declarator)=>_core.types.isIdentifier(declarator.id))) {
        for (const declarator of declarations){
            declarator.init = _core.types.assignmentExpression("=", getMemberExpression(name, declarator.id.name), declarator.init);
        }
        return [
            node
        ];
    }
    const bindingIdentifiers = _core.types.getBindingIdentifiers(node);
    const assignments = [];
    for(const idName in bindingIdentifiers){
        assignments.push(_core.types.assignmentExpression("=", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));
    }
    return [
        node,
        _core.types.expressionStatement(_core.types.sequenceExpression(assignments))
    ];
}
function buildNestedAmbientModuleError(path, node) {
    return path.hub.buildError(node, "Ambient modules cannot be nested in other modules or namespaces.", Error);
}
function handleNested(path, node, parentExport) {
    const names = new Set();
    const realName = node.id;
    const name = path.scope.generateUid(realName.name);
    const body = node.body;
    let id = node.id;
    let namespaceTopLevel;
    {
        namespaceTopLevel = _core.types.isTSModuleBlock(body) ? body.body : [
            _core.types.exportNamedDeclaration(body)
        ];
    }
    let isEmpty = true;
    for(let i = 0; i < namespaceTopLevel.length; i++){
        const subNode = namespaceTopLevel[i];
        switch(subNode.type){
            case "TSModuleDeclaration":
                {
                    if (!_core.types.isIdentifier(subNode.id)) {
                        throw buildNestedAmbientModuleError(path, subNode);
                    }
                    const transformed = handleNested(path, subNode);
                    if (transformed !== null) {
                        isEmpty = false;
                        const moduleName = subNode.id.name;
                        if (names.has(moduleName)) {
                            namespaceTopLevel[i] = transformed;
                        } else {
                            names.add(moduleName);
                            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
                        }
                    }
                    continue;
                }
            case "TSEnumDeclaration":
            case "FunctionDeclaration":
            case "ClassDeclaration":
                isEmpty = false;
                names.add(subNode.id.name);
                continue;
            case "VariableDeclaration":
                {
                    isEmpty = false;
                    for(const name in _core.types.getBindingIdentifiers(subNode)){
                        names.add(name);
                    }
                    continue;
                }
            default:
                isEmpty && (isEmpty = _core.types.isTypeScript(subNode));
                continue;
            case "ExportNamedDeclaration":
        }
        if ("declare" in subNode.declaration && subNode.declaration.declare) {
            continue;
        }
        switch(subNode.declaration.type){
            case "TSEnumDeclaration":
            case "FunctionDeclaration":
            case "ClassDeclaration":
                {
                    isEmpty = false;
                    const itemName = subNode.declaration.id.name;
                    names.add(itemName);
                    namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression("=", getMemberExpression(name, itemName), _core.types.identifier(itemName))));
                    break;
                }
            case "VariableDeclaration":
                {
                    isEmpty = false;
                    const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
                    namespaceTopLevel.splice(i, nodes.length, ...nodes);
                    i += nodes.length - 1;
                    break;
                }
            case "TSModuleDeclaration":
                {
                    if (!_core.types.isIdentifier(subNode.declaration.id)) {
                        throw buildNestedAmbientModuleError(path, subNode.declaration);
                    }
                    const transformed = handleNested(path, subNode.declaration, _core.types.identifier(name));
                    if (transformed !== null) {
                        isEmpty = false;
                        const moduleName = subNode.declaration.id.name;
                        if (names.has(moduleName)) {
                            namespaceTopLevel[i] = transformed;
                        } else {
                            names.add(moduleName);
                            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);
                        }
                    } else {
                        namespaceTopLevel.splice(i, 1);
                        i--;
                    }
                }
        }
    }
    if (isEmpty) return null;
    let fallthroughValue = _core.types.objectExpression([]);
    if (parentExport) {
        const memberExpr = _core.types.memberExpression(parentExport, realName);
        fallthroughValue = _core.template.expression.ast`
      ${_core.types.cloneNode(memberExpr)} ||
        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})
    `;
    }
    return _core.template.statement.ast`
    (function (${_core.types.identifier(name)}) {
      ${namespaceTopLevel}
    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));
  `;
} //# sourceMappingURL=namespace.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typescript/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _pluginSyntaxTypescript = __turbopack_require__("[project]/node_modules/@babel/plugin-syntax-typescript/lib/index.js [app-ssr] (ecmascript)");
var _helperCreateClassFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-class-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _constEnum = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js [app-ssr] (ecmascript)");
var _enum = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/enum.js [app-ssr] (ecmascript)");
var _globalTypes = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/global-types.js [app-ssr] (ecmascript)");
var _namespace = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typescript/lib/namespace.js [app-ssr] (ecmascript)");
function isInType(path) {
    switch(path.parent.type){
        case "TSTypeReference":
        case "TSExpressionWithTypeArguments":
        case "TSExpressionWithTypeArguments":
        case "TSTypeQuery":
            return true;
        case "TSQualifiedName":
            return path.parentPath.findParent((path)=>path.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
        case "ExportSpecifier":
            return path.parent.exportKind === "type" || path.parentPath.parent.exportKind === "type";
        default:
            return false;
    }
}
const NEEDS_EXPLICIT_ESM = new WeakMap();
const PARSED_PARAMS = new WeakSet();
function safeRemove(path) {
    const ids = path.getBindingIdentifiers();
    for (const name of Object.keys(ids)){
        const binding = path.scope.getBinding(name);
        if (binding && binding.identifier === ids[name]) {
            binding.scope.removeBinding(name);
        }
    }
    path.opts.noScope = true;
    path.remove();
    path.opts.noScope = false;
}
function assertCjsTransformEnabled(path, pass, wrong, suggestion, extra = "") {
    if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
        throw path.buildCodeFrameError(`\`${wrong}\` is only supported when compiling modules to CommonJS.\n` + `Please consider using \`${suggestion}\`${extra}, or add ` + `@babel/plugin-transform-modules-commonjs to your Babel config.`);
    }
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts)=>{
    const { types: t, template } = api;
    api.assertVersion(7);
    const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/;
    const { allowNamespaces = true, jsxPragma = "React.createElement", jsxPragmaFrag = "React.Fragment", onlyRemoveTypeImports = false, optimizeConstEnums = false } = opts;
    {
        var { allowDeclareFields = false } = opts;
    }
    const classMemberVisitors = {
        field (path) {
            const { node } = path;
            {
                if (!allowDeclareFields && node.declare) {
                    throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);
                }
            }
            if (node.declare) {
                if (node.value) {
                    throw path.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);
                }
                if (!node.decorators) {
                    path.remove();
                }
            } else if (node.definite) {
                if (node.value) {
                    throw path.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);
                }
                {
                    if (!allowDeclareFields && !node.decorators && !t.isClassPrivateProperty(node)) {
                        path.remove();
                    }
                }
            } else if (node.abstract) {
                path.remove();
            } else {
                if (!allowDeclareFields && !node.value && !node.decorators && !t.isClassPrivateProperty(node)) {
                    path.remove();
                }
            }
            if (node.accessibility) node.accessibility = null;
            if (node.abstract) node.abstract = null;
            if (node.readonly) node.readonly = null;
            if (node.optional) node.optional = null;
            if (node.typeAnnotation) node.typeAnnotation = null;
            if (node.definite) node.definite = null;
            if (node.declare) node.declare = null;
            if (node.override) node.override = null;
        },
        method ({ node }) {
            if (node.accessibility) node.accessibility = null;
            if (node.abstract) node.abstract = null;
            if (node.optional) node.optional = null;
            if (node.override) node.override = null;
        },
        constructor (path, classPath) {
            if (path.node.accessibility) path.node.accessibility = null;
            const assigns = [];
            const { scope } = path;
            for (const paramPath of path.get("params")){
                const param = paramPath.node;
                if (param.type === "TSParameterProperty") {
                    const parameter = param.parameter;
                    if (PARSED_PARAMS.has(parameter)) continue;
                    PARSED_PARAMS.add(parameter);
                    let id;
                    if (t.isIdentifier(parameter)) {
                        id = parameter;
                    } else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) {
                        id = parameter.left;
                    } else {
                        throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                    }
                    assigns.push(template.statement.ast`
              this.${t.cloneNode(id)} = ${t.cloneNode(id)}
            `);
                    paramPath.replaceWith(paramPath.get("parameter"));
                    scope.registerBinding("param", paramPath);
                }
            }
            (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);
        }
    };
    return {
        name: "transform-typescript",
        inherits: _pluginSyntaxTypescript.default,
        visitor: {
            Pattern: visitPattern,
            Identifier: visitPattern,
            RestElement: visitPattern,
            Program: {
                enter (path, state) {
                    const { file } = state;
                    let fileJsxPragma = null;
                    let fileJsxPragmaFrag = null;
                    const programScope = path.scope;
                    if (!_globalTypes.GLOBAL_TYPES.has(programScope)) {
                        _globalTypes.GLOBAL_TYPES.set(programScope, new Set());
                    }
                    if (file.ast.comments) {
                        for (const comment of file.ast.comments){
                            const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
                            if (jsxMatches) {
                                if (jsxMatches[1]) {
                                    fileJsxPragmaFrag = jsxMatches[2];
                                } else {
                                    fileJsxPragma = jsxMatches[2];
                                }
                            }
                        }
                    }
                    let pragmaImportName = fileJsxPragma || jsxPragma;
                    if (pragmaImportName) {
                        [pragmaImportName] = pragmaImportName.split(".");
                    }
                    let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
                    if (pragmaFragImportName) {
                        [pragmaFragImportName] = pragmaFragImportName.split(".");
                    }
                    for (let stmt of path.get("body")){
                        if (stmt.isImportDeclaration()) {
                            if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                            }
                            if (stmt.node.importKind === "type") {
                                for (const specifier of stmt.node.specifiers){
                                    (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                                }
                                stmt.remove();
                                continue;
                            }
                            const importsToRemove = new Set();
                            const specifiersLength = stmt.node.specifiers.length;
                            const isAllSpecifiersElided = ()=>specifiersLength > 0 && specifiersLength === importsToRemove.size;
                            for (const specifier of stmt.node.specifiers){
                                if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                                    (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                                    const binding = stmt.scope.getBinding(specifier.local.name);
                                    if (binding) {
                                        importsToRemove.add(binding.path);
                                    }
                                }
                            }
                            if (onlyRemoveTypeImports) {
                                NEEDS_EXPLICIT_ESM.set(path.node, false);
                            } else {
                                if (stmt.node.specifiers.length === 0) {
                                    NEEDS_EXPLICIT_ESM.set(path.node, false);
                                    continue;
                                }
                                for (const specifier of stmt.node.specifiers){
                                    const binding = stmt.scope.getBinding(specifier.local.name);
                                    if (binding && !importsToRemove.has(binding.path)) {
                                        if (isImportTypeOnly({
                                            binding,
                                            programPath: path,
                                            pragmaImportName,
                                            pragmaFragImportName
                                        })) {
                                            importsToRemove.add(binding.path);
                                        } else {
                                            NEEDS_EXPLICIT_ESM.set(path.node, false);
                                        }
                                    }
                                }
                            }
                            if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {
                                stmt.remove();
                            } else {
                                for (const importPath of importsToRemove){
                                    importPath.remove();
                                }
                            }
                            continue;
                        }
                        if (stmt.isExportDeclaration()) {
                            stmt = stmt.get("declaration");
                        }
                        if (stmt.isVariableDeclaration({
                            declare: true
                        })) {
                            for (const name of Object.keys(stmt.getBindingIdentifiers())){
                                (0, _globalTypes.registerGlobalType)(programScope, name);
                            }
                        } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                            declare: true
                        }) || stmt.isTSEnumDeclaration({
                            declare: true
                        }) || stmt.isTSModuleDeclaration({
                            declare: true
                        }) && stmt.get("id").isIdentifier()) {
                            (0, _globalTypes.registerGlobalType)(programScope, stmt.node.id.name);
                        }
                    }
                },
                exit (path) {
                    if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
                        path.pushContainer("body", t.exportNamedDeclaration());
                    }
                }
            },
            ExportNamedDeclaration (path, state) {
                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                    NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                }
                if (path.node.exportKind === "type") {
                    path.remove();
                    return;
                }
                if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier)=>specifier.type === "ExportSpecifier" && specifier.exportKind === "type")) {
                    path.remove();
                    return;
                }
                if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every((specifier)=>t.isExportSpecifier(specifier) && (0, _globalTypes.isGlobalType)(path, specifier.local.name))) {
                    path.remove();
                    return;
                }
                if (t.isTSModuleDeclaration(path.node.declaration)) {
                    const namespace = path.node.declaration;
                    if (!t.isStringLiteral(namespace.id)) {
                        const id = (0, _namespace.getFirstIdentifier)(namespace.id);
                        if (path.scope.hasOwnBinding(id.name)) {
                            path.replaceWith(namespace);
                        } else {
                            const [newExport] = path.replaceWithMultiple([
                                t.exportNamedDeclaration(t.variableDeclaration("let", [
                                    t.variableDeclarator(t.cloneNode(id))
                                ])),
                                namespace
                            ]);
                            path.scope.registerDeclaration(newExport);
                        }
                    }
                }
                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
            },
            ExportAllDeclaration (path) {
                if (path.node.exportKind === "type") path.remove();
            },
            ExportSpecifier (path) {
                const parent = path.parent;
                if (!parent.source && (0, _globalTypes.isGlobalType)(path, path.node.local.name) || path.node.exportKind === "type") {
                    path.remove();
                }
            },
            ExportDefaultDeclaration (path, state) {
                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                    NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                }
                if (t.isIdentifier(path.node.declaration) && (0, _globalTypes.isGlobalType)(path, path.node.declaration.name)) {
                    path.remove();
                    return;
                }
                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
            },
            TSDeclareFunction (path) {
                safeRemove(path);
            },
            TSDeclareMethod (path) {
                safeRemove(path);
            },
            VariableDeclaration (path) {
                if (path.node.declare) {
                    safeRemove(path);
                }
            },
            VariableDeclarator ({ node }) {
                if (node.definite) node.definite = null;
            },
            TSIndexSignature (path) {
                path.remove();
            },
            ClassDeclaration (path) {
                const { node } = path;
                if (node.declare) {
                    safeRemove(path);
                }
            },
            Class (path) {
                const { node } = path;
                if (node.typeParameters) node.typeParameters = null;
                if (node.superTypeParameters) node.superTypeParameters = null;
                if (node.implements) node.implements = null;
                if (node.abstract) node.abstract = null;
                path.get("body.body").forEach((child)=>{
                    if (child.isClassMethod() || child.isClassPrivateMethod()) {
                        if (child.node.kind === "constructor") {
                            classMemberVisitors.constructor(child, path);
                        } else {
                            classMemberVisitors.method(child);
                        }
                    } else if (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) {
                        classMemberVisitors.field(child);
                    }
                });
            },
            Function (path) {
                const { node } = path;
                if (node.typeParameters) node.typeParameters = null;
                if (node.returnType) node.returnType = null;
                const params = node.params;
                if (params.length > 0 && t.isIdentifier(params[0], {
                    name: "this"
                })) {
                    params.shift();
                }
            },
            TSModuleDeclaration (path) {
                (0, _namespace.default)(path, allowNamespaces);
            },
            TSInterfaceDeclaration (path) {
                path.remove();
            },
            TSTypeAliasDeclaration (path) {
                path.remove();
            },
            TSEnumDeclaration (path) {
                if (optimizeConstEnums && path.node.const) {
                    (0, _constEnum.default)(path, t);
                } else {
                    (0, _enum.default)(path, t);
                }
            },
            TSImportEqualsDeclaration (path, pass) {
                const { id, moduleReference, isExport } = path.node;
                let init;
                let varKind;
                if (t.isTSExternalModuleReference(moduleReference)) {
                    assertCjsTransformEnabled(path, pass, `import ${id.name} = require(...);`, `import ${id.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option");
                    init = t.callExpression(t.identifier("require"), [
                        moduleReference.expression
                    ]);
                    varKind = "const";
                } else {
                    init = entityNameToExpr(moduleReference);
                    varKind = "var";
                }
                const newNode = t.variableDeclaration(varKind, [
                    t.variableDeclarator(id, init)
                ]);
                path.replaceWith(isExport ? t.exportNamedDeclaration(newNode) : newNode);
                path.scope.registerDeclaration(path);
            },
            TSExportAssignment (path, pass) {
                assertCjsTransformEnabled(path, pass, `export = <value>;`, `export default <value>;`);
                path.replaceWith(template.statement.ast`module.exports = ${path.node.expression}`);
            },
            TSTypeAssertion (path) {
                path.replaceWith(path.node.expression);
            },
            [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`] (path) {
                let { node } = path;
                do {
                    node = node.expression;
                }while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node))
                path.replaceWith(node);
            },
            [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"] (path) {
                path.replaceWith(path.node.expression);
            },
            CallExpression (path) {
                path.node.typeParameters = null;
            },
            OptionalCallExpression (path) {
                path.node.typeParameters = null;
            },
            NewExpression (path) {
                path.node.typeParameters = null;
            },
            JSXOpeningElement (path) {
                path.node.typeParameters = null;
            },
            TaggedTemplateExpression (path) {
                path.node.typeParameters = null;
            }
        }
    };
    "TURBOPACK unreachable";
    function entityNameToExpr(node) {
        if (t.isTSQualifiedName(node)) {
            return t.memberExpression(entityNameToExpr(node.left), node.right);
        }
        return node;
    }
    function visitPattern({ node }) {
        if (node.typeAnnotation) node.typeAnnotation = null;
        if (t.isIdentifier(node) && node.optional) node.optional = null;
    }
    function isImportTypeOnly({ binding, programPath, pragmaImportName, pragmaFragImportName }) {
        for (const path of binding.referencePaths){
            if (!isInType(path)) {
                return false;
            }
        }
        if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
            return true;
        }
        let sourceFileHasJsx = false;
        programPath.traverse({
            "JSXElement|JSXFragment" (path) {
                sourceFileHasJsx = true;
                path.stop();
            }
        });
        return !sourceFileHasJsx;
    }
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-syntax-jsx/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "syntax-jsx",
        manipulateOptions (opts, parserOpts) {
            {
                if (parserOpts.plugins.some((p)=>(Array.isArray(p) ? p[0] : p) === "typescript")) {
                    return;
                }
            }
            parserOpts.plugins.push("jsx");
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transformDynamicImport = transformDynamicImport;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
const requireNoInterop = (source)=>_core.template.expression.ast`require(${source})`;
const requireInterop = (source, file)=>_core.types.callExpression(file.addHelper("interopRequireWildcard"), [
        requireNoInterop(source)
    ]);
function transformDynamicImport(path, noInterop, file) {
    const buildRequire = noInterop ? requireNoInterop : requireInterop;
    path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, true, false, (specifier)=>buildRequire(specifier, file)));
} //# sourceMappingURL=dynamic-import.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lazyImportsHook = void 0;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
const lazyImportsHook = (lazy)=>({
        name: `${"@babel/plugin-transform-modules-commonjs"}/lazy`,
        version: "7.26.3",
        getWrapperPayload (source, metadata) {
            if ((0, _helperModuleTransforms.isSideEffectImport)(metadata) || metadata.reexportAll) {
                return null;
            }
            if (lazy === true) {
                return source.includes(".") ? null : "lazy/function";
            }
            if (Array.isArray(lazy)) {
                return !lazy.includes(source) ? null : "lazy/function";
            }
            if (typeof lazy === "function") {
                return lazy(source) ? "lazy/function" : null;
            }
        },
        buildRequireWrapper (name, init, payload, referenced) {
            if (payload === "lazy/function") {
                if (!referenced) return false;
                return _core.template.statement.ast`
        function ${name}() {
          const data = ${init};
          ${name} = function(){ return data; };
          return data;
        }
      `;
            }
        },
        wrapReference (ref, payload) {
            if (payload === "lazy/function") return _core.types.callExpression(ref, []);
        }
    });
exports.lazyImportsHook = lazyImportsHook; //# sourceMappingURL=lazy.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defineCommonJSHook = defineCommonJSHook;
exports.makeInvokers = makeInvokers;
const commonJSHooksKey = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
function defineCommonJSHook(file, hook) {
    let hooks = file.get(commonJSHooksKey);
    if (!hooks) file.set(commonJSHooksKey, hooks = []);
    hooks.push(hook);
}
function findMap(arr, cb) {
    if (arr) {
        for (const el of arr){
            const res = cb(el);
            if (res != null) return res;
        }
    }
}
function makeInvokers(file) {
    const hooks = file.get(commonJSHooksKey);
    return {
        getWrapperPayload (...args) {
            return findMap(hooks, (hook)=>hook.getWrapperPayload == null ? void 0 : hook.getWrapperPayload(...args));
        },
        wrapReference (...args) {
            return findMap(hooks, (hook)=>hook.wrapReference == null ? void 0 : hook.wrapReference(...args));
        },
        buildRequireWrapper (...args) {
            return findMap(hooks, (hook)=>hook.buildRequireWrapper == null ? void 0 : hook.buildRequireWrapper(...args));
        }
    };
} //# sourceMappingURL=hooks.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
Object.defineProperty(exports, "defineCommonJSHook", {
    enumerable: true,
    get: function() {
        return _hooks.defineCommonJSHook;
    }
});
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _dynamicImport = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js [app-ssr] (ecmascript)");
var _lazy = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js [app-ssr] (ecmascript)");
var _hooks = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2, _api$assumption3;
    api.assertVersion(7);
    const { strictNamespace = false, mjsStrictNamespace = strictNamespace, allowTopLevelThis, strict, strictMode, noInterop, importInterop, lazy = false, allowCommonJSExports = true, loose = false } = options;
    const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : loose;
    const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : loose;
    const noIncompleteNsImportDetection = (_api$assumption3 = api.assumption("noIncompleteNsImportDetection")) != null ? _api$assumption3 : false;
    if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every((item)=>typeof item === "string"))) {
        throw new Error(`.lazy must be a boolean, array of strings, or a function`);
    }
    if (typeof strictNamespace !== "boolean") {
        throw new Error(`.strictNamespace must be a boolean, or undefined`);
    }
    if (typeof mjsStrictNamespace !== "boolean") {
        throw new Error(`.mjsStrictNamespace must be a boolean, or undefined`);
    }
    const getAssertion = (localName)=>_core.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${localName}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `;
    const moduleExportsVisitor = {
        ReferencedIdentifier (path) {
            const localName = path.node.name;
            if (localName !== "module" && localName !== "exports") return;
            const localBinding = path.scope.getBinding(localName);
            const rootBinding = this.scope.getBinding(localName);
            if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
                value: path.node
            }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
                left: path.node
            }) || path.isAssignmentExpression({
                left: path.node
            })) {
                return;
            }
            path.replaceWith(getAssertion(localName));
        },
        UpdateExpression (path) {
            const arg = path.get("argument");
            if (!arg.isIdentifier()) return;
            const localName = arg.node.name;
            if (localName !== "module" && localName !== "exports") return;
            const localBinding = path.scope.getBinding(localName);
            const rootBinding = this.scope.getBinding(localName);
            if (rootBinding !== localBinding) return;
            path.replaceWith(_core.types.assignmentExpression(path.node.operator[0] + "=", arg.node, getAssertion(localName)));
        },
        AssignmentExpression (path) {
            const left = path.get("left");
            if (left.isIdentifier()) {
                const localName = left.node.name;
                if (localName !== "module" && localName !== "exports") return;
                const localBinding = path.scope.getBinding(localName);
                const rootBinding = this.scope.getBinding(localName);
                if (rootBinding !== localBinding) return;
                const right = path.get("right");
                right.replaceWith(_core.types.sequenceExpression([
                    right.node,
                    getAssertion(localName)
                ]));
            } else if (left.isPattern()) {
                const ids = left.getOuterBindingIdentifiers();
                const localName = Object.keys(ids).find((localName)=>{
                    if (localName !== "module" && localName !== "exports") return false;
                    return this.scope.getBinding(localName) === path.scope.getBinding(localName);
                });
                if (localName) {
                    const right = path.get("right");
                    right.replaceWith(_core.types.sequenceExpression([
                        right.node,
                        getAssertion(localName)
                    ]));
                }
            }
        }
    };
    return {
        name: "transform-modules-commonjs",
        pre () {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs");
            if (lazy) (0, _hooks.defineCommonJSHook)(this.file, (0, _lazy.lazyImportsHook)(lazy));
        },
        visitor: {
            ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")] (path) {
                if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
                if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
                let { scope } = path;
                do {
                    scope.rename("require");
                }while (scope = scope.parent)
                (0, _dynamicImport.transformDynamicImport)(path, noInterop, this.file);
            },
            Program: {
                exit (path, state) {
                    if (!(0, _helperModuleTransforms.isModule)(path)) return;
                    path.scope.rename("exports");
                    path.scope.rename("module");
                    path.scope.rename("require");
                    path.scope.rename("__filename");
                    path.scope.rename("__dirname");
                    if (!allowCommonJSExports) {
                        path.traverse(moduleExportsVisitor, {
                            scope: path.scope
                        });
                    }
                    let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                    if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
                    const hooks = (0, _hooks.makeInvokers)(this.file);
                    const { meta, headers } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                        exportName: "exports",
                        constantReexports,
                        enumerableModuleMeta,
                        strict,
                        strictMode,
                        allowTopLevelThis,
                        noInterop,
                        importInterop,
                        wrapReference: hooks.wrapReference,
                        getWrapperPayload: hooks.getWrapperPayload,
                        esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace,
                        noIncompleteNsImportDetection,
                        filename: this.file.opts.filename
                    });
                    for (const [source, metadata] of meta.source){
                        const loadExpr = _core.types.callExpression(_core.types.identifier("require"), [
                            _core.types.stringLiteral(source)
                        ]);
                        let header;
                        if ((0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                            if (lazy && metadata.wrap === "function") {
                                throw new Error("Assertion failure");
                            }
                            header = _core.types.expressionStatement(loadExpr);
                        } else {
                            var _header;
                            const init = (0, _helperModuleTransforms.wrapInterop)(path, loadExpr, metadata.interop) || loadExpr;
                            if (metadata.wrap) {
                                const res = hooks.buildRequireWrapper(metadata.name, init, metadata.wrap, metadata.referenced);
                                if (res === false) continue;
                                else header = res;
                            }
                            (_header = header) != null ? _header : header = _core.template.statement.ast`
                var ${metadata.name} = ${init};
              `;
                        }
                        header.loc = metadata.loc;
                        headers.push(header);
                        headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports, hooks.wrapReference));
                    }
                    (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
                    path.unshiftContainer("body", headers);
                    path.get("body").forEach((path)=>{
                        if (!headers.includes(path.node)) return;
                        if (path.isVariableDeclaration()) {
                            path.scope.registerDeclaration(path);
                        }
                    });
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-validator-option/lib/find-suggestion.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findSuggestion = findSuggestion;
const { min } = Math;
function levenshtein(a, b) {
    let t = [], u = [], i, j;
    const m = a.length, n = b.length;
    if (!m) {
        return n;
    }
    if (!n) {
        return m;
    }
    for(j = 0; j <= n; j++){
        t[j] = j;
    }
    for(i = 1; i <= m; i++){
        for(u = [
            i
        ], j = 1; j <= n; j++){
            u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
        }
        t = u;
    }
    return u[n];
}
function findSuggestion(str, arr) {
    const distances = arr.map((el)=>levenshtein(el, str));
    return arr[distances.indexOf(min(...distances))];
} //# sourceMappingURL=find-suggestion.js.map
}}),
"[project]/node_modules/@babel/helper-validator-option/lib/validator.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OptionValidator = void 0;
var _findSuggestion = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/find-suggestion.js [app-ssr] (ecmascript)");
class OptionValidator {
    constructor(descriptor){
        this.descriptor = descriptor;
    }
    validateTopLevelOptions(options, TopLevelOptionShape) {
        const validOptionNames = Object.keys(TopLevelOptionShape);
        for (const option of Object.keys(options)){
            if (!validOptionNames.includes(option)) {
                throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
            }
        }
    }
    validateBooleanOption(name, value, defaultValue) {
        if (value === undefined) {
            return defaultValue;
        } else {
            this.invariant(typeof value === "boolean", `'${name}' option must be a boolean.`);
        }
        return value;
    }
    validateStringOption(name, value, defaultValue) {
        if (value === undefined) {
            return defaultValue;
        } else {
            this.invariant(typeof value === "string", `'${name}' option must be a string.`);
        }
        return value;
    }
    invariant(condition, message) {
        if (!condition) {
            throw new Error(this.formatMessage(message));
        }
    }
    formatMessage(message) {
        return `${this.descriptor}: ${message}`;
    }
}
exports.OptionValidator = OptionValidator; //# sourceMappingURL=validator.js.map
}}),
"[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "OptionValidator", {
    enumerable: true,
    get: function() {
        return _validator.OptionValidator;
    }
});
Object.defineProperty(exports, "findSuggestion", {
    enumerable: true,
    get: function() {
        return _findSuggestion.findSuggestion;
    }
});
var _validator = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/validator.js [app-ssr] (ecmascript)");
var _findSuggestion = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/find-suggestion.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/compat-data/data/native-modules.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"es6.module\":{\"chrome\":\"61\",\"and_chr\":\"61\",\"edge\":\"16\",\"firefox\":\"60\",\"and_ff\":\"60\",\"node\":\"13.2.0\",\"opera\":\"48\",\"op_mob\":\"45\",\"safari\":\"10.1\",\"ios\":\"10.3\",\"samsung\":\"8.2\",\"android\":\"61\",\"electron\":\"2.0\",\"ios_saf\":\"10.3\"}}"));}}),
"[project]/node_modules/@babel/compat-data/native-modules.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/@babel/compat-data/data/native-modules.json (json)");
}}),
"[project]/node_modules/@babel/compat-data/data/plugins.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"transform-duplicate-named-capturing-groups-regex\":{\"chrome\":\"126\",\"opera\":\"112\",\"edge\":\"126\",\"firefox\":\"129\",\"safari\":\"17.4\",\"node\":\"23\",\"ios\":\"17.4\",\"electron\":\"31.0\"},\"transform-regexp-modifiers\":{\"chrome\":\"125\",\"opera\":\"111\",\"edge\":\"125\",\"firefox\":\"132\",\"node\":\"23\",\"electron\":\"31.0\"},\"transform-unicode-sets-regex\":{\"chrome\":\"112\",\"opera\":\"98\",\"edge\":\"112\",\"firefox\":\"116\",\"safari\":\"17\",\"node\":\"20\",\"deno\":\"1.32\",\"ios\":\"17\",\"opera_mobile\":\"75\",\"electron\":\"24.0\"},\"bugfix/transform-v8-static-class-fields-redefine-readonly\":{\"chrome\":\"98\",\"opera\":\"84\",\"edge\":\"98\",\"firefox\":\"75\",\"safari\":\"15\",\"node\":\"12\",\"deno\":\"1.18\",\"ios\":\"15\",\"samsung\":\"11\",\"opera_mobile\":\"52\",\"electron\":\"17.0\"},\"bugfix/transform-firefox-class-in-computed-class-key\":{\"chrome\":\"74\",\"opera\":\"62\",\"edge\":\"79\",\"safari\":\"16\",\"node\":\"12\",\"deno\":\"1\",\"ios\":\"16\",\"samsung\":\"11\",\"opera_mobile\":\"53\",\"electron\":\"6.0\"},\"bugfix/transform-safari-class-field-initializer-scope\":{\"chrome\":\"74\",\"opera\":\"62\",\"edge\":\"79\",\"firefox\":\"69\",\"safari\":\"16\",\"node\":\"12\",\"deno\":\"1\",\"ios\":\"16\",\"samsung\":\"11\",\"opera_mobile\":\"53\",\"electron\":\"6.0\"},\"transform-class-static-block\":{\"chrome\":\"94\",\"opera\":\"80\",\"edge\":\"94\",\"firefox\":\"93\",\"safari\":\"16.4\",\"node\":\"16.11\",\"deno\":\"1.14\",\"ios\":\"16.4\",\"samsung\":\"17\",\"opera_mobile\":\"66\",\"electron\":\"15.0\"},\"proposal-class-static-block\":{\"chrome\":\"94\",\"opera\":\"80\",\"edge\":\"94\",\"firefox\":\"93\",\"safari\":\"16.4\",\"node\":\"16.11\",\"deno\":\"1.14\",\"ios\":\"16.4\",\"samsung\":\"17\",\"opera_mobile\":\"66\",\"electron\":\"15.0\"},\"transform-private-property-in-object\":{\"chrome\":\"91\",\"opera\":\"77\",\"edge\":\"91\",\"firefox\":\"90\",\"safari\":\"15\",\"node\":\"16.9\",\"deno\":\"1.9\",\"ios\":\"15\",\"samsung\":\"16\",\"opera_mobile\":\"64\",\"electron\":\"13.0\"},\"proposal-private-property-in-object\":{\"chrome\":\"91\",\"opera\":\"77\",\"edge\":\"91\",\"firefox\":\"90\",\"safari\":\"15\",\"node\":\"16.9\",\"deno\":\"1.9\",\"ios\":\"15\",\"samsung\":\"16\",\"opera_mobile\":\"64\",\"electron\":\"13.0\"},\"transform-class-properties\":{\"chrome\":\"74\",\"opera\":\"62\",\"edge\":\"79\",\"firefox\":\"90\",\"safari\":\"14.1\",\"node\":\"12\",\"deno\":\"1\",\"ios\":\"14.5\",\"samsung\":\"11\",\"opera_mobile\":\"53\",\"electron\":\"6.0\"},\"proposal-class-properties\":{\"chrome\":\"74\",\"opera\":\"62\",\"edge\":\"79\",\"firefox\":\"90\",\"safari\":\"14.1\",\"node\":\"12\",\"deno\":\"1\",\"ios\":\"14.5\",\"samsung\":\"11\",\"opera_mobile\":\"53\",\"electron\":\"6.0\"},\"transform-private-methods\":{\"chrome\":\"84\",\"opera\":\"70\",\"edge\":\"84\",\"firefox\":\"90\",\"safari\":\"15\",\"node\":\"14.6\",\"deno\":\"1\",\"ios\":\"15\",\"samsung\":\"14\",\"opera_mobile\":\"60\",\"electron\":\"10.0\"},\"proposal-private-methods\":{\"chrome\":\"84\",\"opera\":\"70\",\"edge\":\"84\",\"firefox\":\"90\",\"safari\":\"15\",\"node\":\"14.6\",\"deno\":\"1\",\"ios\":\"15\",\"samsung\":\"14\",\"opera_mobile\":\"60\",\"electron\":\"10.0\"},\"transform-numeric-separator\":{\"chrome\":\"75\",\"opera\":\"62\",\"edge\":\"79\",\"firefox\":\"70\",\"safari\":\"13\",\"node\":\"12.5\",\"deno\":\"1\",\"ios\":\"13\",\"samsung\":\"11\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"54\",\"electron\":\"6.0\"},\"proposal-numeric-separator\":{\"chrome\":\"75\",\"opera\":\"62\",\"edge\":\"79\",\"firefox\":\"70\",\"safari\":\"13\",\"node\":\"12.5\",\"deno\":\"1\",\"ios\":\"13\",\"samsung\":\"11\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"54\",\"electron\":\"6.0\"},\"transform-logical-assignment-operators\":{\"chrome\":\"85\",\"opera\":\"71\",\"edge\":\"85\",\"firefox\":\"79\",\"safari\":\"14\",\"node\":\"15\",\"deno\":\"1.2\",\"ios\":\"14\",\"samsung\":\"14\",\"opera_mobile\":\"60\",\"electron\":\"10.0\"},\"proposal-logical-assignment-operators\":{\"chrome\":\"85\",\"opera\":\"71\",\"edge\":\"85\",\"firefox\":\"79\",\"safari\":\"14\",\"node\":\"15\",\"deno\":\"1.2\",\"ios\":\"14\",\"samsung\":\"14\",\"opera_mobile\":\"60\",\"electron\":\"10.0\"},\"transform-nullish-coalescing-operator\":{\"chrome\":\"80\",\"opera\":\"67\",\"edge\":\"80\",\"firefox\":\"72\",\"safari\":\"13.1\",\"node\":\"14\",\"deno\":\"1\",\"ios\":\"13.4\",\"samsung\":\"13\",\"opera_mobile\":\"57\",\"electron\":\"8.0\"},\"proposal-nullish-coalescing-operator\":{\"chrome\":\"80\",\"opera\":\"67\",\"edge\":\"80\",\"firefox\":\"72\",\"safari\":\"13.1\",\"node\":\"14\",\"deno\":\"1\",\"ios\":\"13.4\",\"samsung\":\"13\",\"opera_mobile\":\"57\",\"electron\":\"8.0\"},\"transform-optional-chaining\":{\"chrome\":\"91\",\"opera\":\"77\",\"edge\":\"91\",\"firefox\":\"74\",\"safari\":\"13.1\",\"node\":\"16.9\",\"deno\":\"1.9\",\"ios\":\"13.4\",\"samsung\":\"16\",\"opera_mobile\":\"64\",\"electron\":\"13.0\"},\"proposal-optional-chaining\":{\"chrome\":\"91\",\"opera\":\"77\",\"edge\":\"91\",\"firefox\":\"74\",\"safari\":\"13.1\",\"node\":\"16.9\",\"deno\":\"1.9\",\"ios\":\"13.4\",\"samsung\":\"16\",\"opera_mobile\":\"64\",\"electron\":\"13.0\"},\"transform-json-strings\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"62\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"9\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"proposal-json-strings\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"62\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"9\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"transform-optional-catch-binding\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"58\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"9\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"proposal-optional-catch-binding\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"58\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"9\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"transform-parameters\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"18\",\"firefox\":\"53\",\"safari\":\"16.3\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"16.3\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"transform-async-generator-functions\":{\"chrome\":\"63\",\"opera\":\"50\",\"edge\":\"79\",\"firefox\":\"57\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"proposal-async-generator-functions\":{\"chrome\":\"63\",\"opera\":\"50\",\"edge\":\"79\",\"firefox\":\"57\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"transform-object-rest-spread\":{\"chrome\":\"60\",\"opera\":\"47\",\"edge\":\"79\",\"firefox\":\"55\",\"safari\":\"11.1\",\"node\":\"8.3\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"8\",\"opera_mobile\":\"44\",\"electron\":\"2.0\"},\"proposal-object-rest-spread\":{\"chrome\":\"60\",\"opera\":\"47\",\"edge\":\"79\",\"firefox\":\"55\",\"safari\":\"11.1\",\"node\":\"8.3\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"8\",\"opera_mobile\":\"44\",\"electron\":\"2.0\"},\"transform-dotall-regex\":{\"chrome\":\"62\",\"opera\":\"49\",\"edge\":\"79\",\"firefox\":\"78\",\"safari\":\"11.1\",\"node\":\"8.10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"8\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"transform-unicode-property-regex\":{\"chrome\":\"64\",\"opera\":\"51\",\"edge\":\"79\",\"firefox\":\"78\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"9\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"proposal-unicode-property-regex\":{\"chrome\":\"64\",\"opera\":\"51\",\"edge\":\"79\",\"firefox\":\"78\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"9\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"transform-named-capturing-groups-regex\":{\"chrome\":\"64\",\"opera\":\"51\",\"edge\":\"79\",\"firefox\":\"78\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"9\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"transform-async-to-generator\":{\"chrome\":\"55\",\"opera\":\"42\",\"edge\":\"15\",\"firefox\":\"52\",\"safari\":\"11\",\"node\":\"7.6\",\"deno\":\"1\",\"ios\":\"11\",\"samsung\":\"6\",\"opera_mobile\":\"42\",\"electron\":\"1.6\"},\"transform-exponentiation-operator\":{\"chrome\":\"52\",\"opera\":\"39\",\"edge\":\"14\",\"firefox\":\"52\",\"safari\":\"10.1\",\"node\":\"7\",\"deno\":\"1\",\"ios\":\"10.3\",\"samsung\":\"6\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"41\",\"electron\":\"1.3\"},\"transform-template-literals\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"13\",\"firefox\":\"34\",\"safari\":\"13\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"13\",\"samsung\":\"3.4\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"transform-literals\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"53\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"transform-function-name\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"79\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"transform-arrow-functions\":{\"chrome\":\"47\",\"opera\":\"34\",\"edge\":\"13\",\"firefox\":\"43\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"34\",\"electron\":\"0.36\"},\"transform-block-scoped-functions\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"46\",\"safari\":\"10\",\"node\":\"4\",\"deno\":\"1\",\"ie\":\"11\",\"ios\":\"10\",\"samsung\":\"3.4\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"transform-classes\":{\"chrome\":\"46\",\"opera\":\"33\",\"edge\":\"13\",\"firefox\":\"45\",\"safari\":\"10\",\"node\":\"5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"33\",\"electron\":\"0.36\"},\"transform-object-super\":{\"chrome\":\"46\",\"opera\":\"33\",\"edge\":\"13\",\"firefox\":\"45\",\"safari\":\"10\",\"node\":\"5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"33\",\"electron\":\"0.36\"},\"transform-shorthand-properties\":{\"chrome\":\"43\",\"opera\":\"30\",\"edge\":\"12\",\"firefox\":\"33\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"30\",\"electron\":\"0.27\"},\"transform-duplicate-keys\":{\"chrome\":\"42\",\"opera\":\"29\",\"edge\":\"12\",\"firefox\":\"34\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"opera_mobile\":\"29\",\"electron\":\"0.25\"},\"transform-computed-properties\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"34\",\"safari\":\"7.1\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"4\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"transform-for-of\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"transform-sticky-regex\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"13\",\"firefox\":\"3\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"transform-unicode-escapes\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"53\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"transform-unicode-regex\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"13\",\"firefox\":\"46\",\"safari\":\"12\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"transform-spread\":{\"chrome\":\"46\",\"opera\":\"33\",\"edge\":\"13\",\"firefox\":\"45\",\"safari\":\"10\",\"node\":\"5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"33\",\"electron\":\"0.36\"},\"transform-destructuring\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"transform-block-scoping\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"14\",\"firefox\":\"53\",\"safari\":\"11\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"11\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"transform-typeof-symbol\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"36\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"transform-new-target\":{\"chrome\":\"46\",\"opera\":\"33\",\"edge\":\"14\",\"firefox\":\"41\",\"safari\":\"10\",\"node\":\"5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"33\",\"electron\":\"0.36\"},\"transform-regenerator\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"13\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"transform-member-expression-literals\":{\"chrome\":\"7\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"5.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"transform-property-literals\":{\"chrome\":\"7\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"5.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"transform-reserved-words\":{\"chrome\":\"13\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.6\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4.4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"transform-export-namespace-from\":{\"chrome\":\"72\",\"deno\":\"1.0\",\"edge\":\"79\",\"firefox\":\"80\",\"node\":\"13.2\",\"opera\":\"60\",\"opera_mobile\":\"51\",\"safari\":\"14.1\",\"ios\":\"14.5\",\"samsung\":\"11.0\",\"android\":\"72\",\"electron\":\"5.0\"},\"proposal-export-namespace-from\":{\"chrome\":\"72\",\"deno\":\"1.0\",\"edge\":\"79\",\"firefox\":\"80\",\"node\":\"13.2\",\"opera\":\"60\",\"opera_mobile\":\"51\",\"safari\":\"14.1\",\"ios\":\"14.5\",\"samsung\":\"11.0\",\"android\":\"72\",\"electron\":\"5.0\"}}"));}}),
"[project]/node_modules/@babel/compat-data/plugins.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/@babel/compat-data/data/plugins.json (json)");
}}),
"[project]/node_modules/@babel/compat-data/data/plugin-bugfixes.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"bugfix/transform-async-arrows-in-class\":{\"chrome\":\"55\",\"opera\":\"42\",\"edge\":\"15\",\"firefox\":\"52\",\"safari\":\"11\",\"node\":\"7.6\",\"deno\":\"1\",\"ios\":\"11\",\"samsung\":\"6\",\"opera_mobile\":\"42\",\"electron\":\"1.6\"},\"bugfix/transform-edge-default-parameters\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"18\",\"firefox\":\"52\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"bugfix/transform-edge-function-name\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"79\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"bugfix/transform-safari-block-shadowing\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"44\",\"safari\":\"11\",\"node\":\"6\",\"deno\":\"1\",\"ie\":\"11\",\"ios\":\"11\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"bugfix/transform-safari-for-shadowing\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"11\",\"node\":\"6\",\"deno\":\"1\",\"ie\":\"11\",\"ios\":\"11\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"bugfix/transform-safari-id-destructuring-collision-in-function-expression\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"14\",\"firefox\":\"2\",\"safari\":\"16.3\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"16.3\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"bugfix/transform-tagged-template-caching\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"34\",\"safari\":\"13\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"13\",\"samsung\":\"3.4\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"bugfix/transform-v8-spread-parameters-in-optional-chaining\":{\"chrome\":\"91\",\"opera\":\"77\",\"edge\":\"91\",\"firefox\":\"74\",\"safari\":\"13.1\",\"node\":\"16.9\",\"deno\":\"1.9\",\"ios\":\"13.4\",\"samsung\":\"16\",\"opera_mobile\":\"64\",\"electron\":\"13.0\"},\"bugfix/transform-firefox-class-in-computed-class-key\":{\"chrome\":\"74\",\"opera\":\"62\",\"edge\":\"79\",\"safari\":\"16\",\"node\":\"12\",\"deno\":\"1\",\"ios\":\"16\",\"samsung\":\"11\",\"opera_mobile\":\"53\",\"electron\":\"6.0\"},\"transform-optional-chaining\":{\"chrome\":\"80\",\"opera\":\"67\",\"edge\":\"80\",\"firefox\":\"74\",\"safari\":\"13.1\",\"node\":\"14\",\"deno\":\"1\",\"ios\":\"13.4\",\"samsung\":\"13\",\"opera_mobile\":\"57\",\"electron\":\"8.0\"},\"proposal-optional-chaining\":{\"chrome\":\"80\",\"opera\":\"67\",\"edge\":\"80\",\"firefox\":\"74\",\"safari\":\"13.1\",\"node\":\"14\",\"deno\":\"1\",\"ios\":\"13.4\",\"samsung\":\"13\",\"opera_mobile\":\"57\",\"electron\":\"8.0\"},\"transform-parameters\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"transform-async-to-generator\":{\"chrome\":\"55\",\"opera\":\"42\",\"edge\":\"15\",\"firefox\":\"52\",\"safari\":\"10.1\",\"node\":\"7.6\",\"deno\":\"1\",\"ios\":\"10.3\",\"samsung\":\"6\",\"opera_mobile\":\"42\",\"electron\":\"1.6\"},\"transform-template-literals\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"13\",\"firefox\":\"34\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"transform-function-name\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"14\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"transform-block-scoping\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"14\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"}}"));}}),
"[project]/node_modules/@babel/compat-data/plugin-bugfixes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/@babel/compat-data/data/plugin-bugfixes.json (json)");
}}),
"[project]/node_modules/@babel/compat-data/data/overlapping-plugins.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"transform-async-to-generator\":[\"bugfix/transform-async-arrows-in-class\"],\"transform-parameters\":[\"bugfix/transform-edge-default-parameters\",\"bugfix/transform-safari-id-destructuring-collision-in-function-expression\"],\"transform-function-name\":[\"bugfix/transform-edge-function-name\"],\"transform-block-scoping\":[\"bugfix/transform-safari-block-shadowing\",\"bugfix/transform-safari-for-shadowing\"],\"transform-template-literals\":[\"bugfix/transform-tagged-template-caching\"],\"transform-optional-chaining\":[\"bugfix/transform-v8-spread-parameters-in-optional-chaining\"],\"proposal-optional-chaining\":[\"bugfix/transform-v8-spread-parameters-in-optional-chaining\"],\"transform-class-properties\":[\"bugfix/transform-v8-static-class-fields-redefine-readonly\",\"bugfix/transform-firefox-class-in-computed-class-key\",\"bugfix/transform-safari-class-field-initializer-scope\"],\"proposal-class-properties\":[\"bugfix/transform-v8-static-class-fields-redefine-readonly\",\"bugfix/transform-firefox-class-in-computed-class-key\",\"bugfix/transform-safari-class-field-initializer-scope\"]}"));}}),
"[project]/node_modules/@babel/compat-data/overlapping-plugins.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
module.exports = __turbopack_require__("[project]/node_modules/@babel/compat-data/data/overlapping-plugins.json (json)");
}}),
"[project]/node_modules/@babel/compat-data/data/corejs2-built-ins.json (json)": ((__turbopack_context__) => {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, t: __turbopack_require_real__ } = __turbopack_context__;
{
__turbopack_export_value__(JSON.parse("{\"es6.array.copy-within\":{\"chrome\":\"45\",\"opera\":\"32\",\"edge\":\"12\",\"firefox\":\"32\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.31\"},\"es6.array.every\":{\"chrome\":\"5\",\"opera\":\"10.10\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.fill\":{\"chrome\":\"45\",\"opera\":\"32\",\"edge\":\"12\",\"firefox\":\"31\",\"safari\":\"7.1\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.31\"},\"es6.array.filter\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.array.find\":{\"chrome\":\"45\",\"opera\":\"32\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.31\"},\"es6.array.find-index\":{\"chrome\":\"45\",\"opera\":\"32\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.31\"},\"es7.array.flat-map\":{\"chrome\":\"69\",\"opera\":\"56\",\"edge\":\"79\",\"firefox\":\"62\",\"safari\":\"12\",\"node\":\"11\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"10\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"48\",\"electron\":\"4.0\"},\"es6.array.for-each\":{\"chrome\":\"5\",\"opera\":\"10.10\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.from\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"36\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es7.array.includes\":{\"chrome\":\"47\",\"opera\":\"34\",\"edge\":\"14\",\"firefox\":\"102\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"34\",\"electron\":\"0.36\"},\"es6.array.index-of\":{\"chrome\":\"5\",\"opera\":\"10.10\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.is-array\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.iterator\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"12\",\"firefox\":\"60\",\"safari\":\"9\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"9\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"es6.array.last-index-of\":{\"chrome\":\"5\",\"opera\":\"10.10\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.map\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.array.of\":{\"chrome\":\"45\",\"opera\":\"32\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.31\"},\"es6.array.reduce\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"3\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.reduce-right\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"3\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.slice\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.array.some\":{\"chrome\":\"5\",\"opera\":\"10.10\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.array.sort\":{\"chrome\":\"63\",\"opera\":\"50\",\"edge\":\"12\",\"firefox\":\"5\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ie\":\"9\",\"ios\":\"12\",\"samsung\":\"8\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es6.array.species\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.date.now\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.date.to-iso-string\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"3.5\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.date.to-json\":{\"chrome\":\"5\",\"opera\":\"12.10\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"10\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"10\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12.1\",\"electron\":\"0.20\"},\"es6.date.to-primitive\":{\"chrome\":\"47\",\"opera\":\"34\",\"edge\":\"15\",\"firefox\":\"44\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"34\",\"electron\":\"0.36\"},\"es6.date.to-string\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"2\",\"safari\":\"3.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"10\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.function.bind\":{\"chrome\":\"7\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"5.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"es6.function.has-instance\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"50\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.function.name\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"14\",\"firefox\":\"2\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es6.map\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.math.acosh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.asinh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.atanh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.cbrt\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.clz32\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"31\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.cosh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.expm1\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.fround\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"26\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.hypot\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"27\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.imul\":{\"chrome\":\"30\",\"opera\":\"17\",\"edge\":\"12\",\"firefox\":\"23\",\"safari\":\"7\",\"node\":\"0.12\",\"deno\":\"1\",\"android\":\"4.4\",\"ios\":\"7\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"18\",\"electron\":\"0.20\"},\"es6.math.log1p\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.log10\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.log2\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.sign\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.sinh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.tanh\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.math.trunc\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"7.1\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"8\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.number.constructor\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"36\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.number.epsilon\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.is-finite\":{\"chrome\":\"19\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"16\",\"safari\":\"9\",\"node\":\"0.8\",\"deno\":\"1\",\"android\":\"4.1\",\"ios\":\"9\",\"samsung\":\"1.5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.number.is-integer\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"16\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.is-nan\":{\"chrome\":\"19\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"15\",\"safari\":\"9\",\"node\":\"0.8\",\"deno\":\"1\",\"android\":\"4.1\",\"ios\":\"9\",\"samsung\":\"1.5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.number.is-safe-integer\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"32\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.max-safe-integer\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"31\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.min-safe-integer\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"31\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.parse-float\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.number.parse-int\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"25\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es6.object.assign\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"13\",\"firefox\":\"36\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.object.create\":{\"chrome\":\"5\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"es7.object.define-getter\":{\"chrome\":\"62\",\"opera\":\"49\",\"edge\":\"16\",\"firefox\":\"48\",\"safari\":\"9\",\"node\":\"8.10\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es7.object.define-setter\":{\"chrome\":\"62\",\"opera\":\"49\",\"edge\":\"16\",\"firefox\":\"48\",\"safari\":\"9\",\"node\":\"8.10\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es6.object.define-property\":{\"chrome\":\"5\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"5.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"es6.object.define-properties\":{\"chrome\":\"5\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"4\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"es7.object.entries\":{\"chrome\":\"54\",\"opera\":\"41\",\"edge\":\"14\",\"firefox\":\"47\",\"safari\":\"10.1\",\"node\":\"7\",\"deno\":\"1\",\"ios\":\"10.3\",\"samsung\":\"6\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"41\",\"electron\":\"1.4\"},\"es6.object.freeze\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.get-own-property-descriptor\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es7.object.get-own-property-descriptors\":{\"chrome\":\"54\",\"opera\":\"41\",\"edge\":\"15\",\"firefox\":\"50\",\"safari\":\"10.1\",\"node\":\"7\",\"deno\":\"1\",\"ios\":\"10.3\",\"samsung\":\"6\",\"opera_mobile\":\"41\",\"electron\":\"1.4\"},\"es6.object.get-own-property-names\":{\"chrome\":\"40\",\"opera\":\"27\",\"edge\":\"12\",\"firefox\":\"33\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"27\",\"electron\":\"0.21\"},\"es6.object.get-prototype-of\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es7.object.lookup-getter\":{\"chrome\":\"62\",\"opera\":\"49\",\"edge\":\"79\",\"firefox\":\"36\",\"safari\":\"9\",\"node\":\"8.10\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es7.object.lookup-setter\":{\"chrome\":\"62\",\"opera\":\"49\",\"edge\":\"79\",\"firefox\":\"36\",\"safari\":\"9\",\"node\":\"8.10\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es6.object.prevent-extensions\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.to-string\":{\"chrome\":\"57\",\"opera\":\"44\",\"edge\":\"15\",\"firefox\":\"51\",\"safari\":\"10\",\"node\":\"8\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"7\",\"opera_mobile\":\"43\",\"electron\":\"1.7\"},\"es6.object.is\":{\"chrome\":\"19\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"22\",\"safari\":\"9\",\"node\":\"0.8\",\"deno\":\"1\",\"android\":\"4.1\",\"ios\":\"9\",\"samsung\":\"1.5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.object.is-frozen\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.is-sealed\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.is-extensible\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.keys\":{\"chrome\":\"40\",\"opera\":\"27\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"27\",\"electron\":\"0.21\"},\"es6.object.seal\":{\"chrome\":\"44\",\"opera\":\"31\",\"edge\":\"12\",\"firefox\":\"35\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"32\",\"electron\":\"0.30\"},\"es6.object.set-prototype-of\":{\"chrome\":\"34\",\"opera\":\"21\",\"edge\":\"12\",\"firefox\":\"31\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ie\":\"11\",\"ios\":\"9\",\"samsung\":\"2\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"21\",\"electron\":\"0.20\"},\"es7.object.values\":{\"chrome\":\"54\",\"opera\":\"41\",\"edge\":\"14\",\"firefox\":\"47\",\"safari\":\"10.1\",\"node\":\"7\",\"deno\":\"1\",\"ios\":\"10.3\",\"samsung\":\"6\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"41\",\"electron\":\"1.4\"},\"es6.promise\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"14\",\"firefox\":\"45\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es7.promise.finally\":{\"chrome\":\"63\",\"opera\":\"50\",\"edge\":\"18\",\"firefox\":\"58\",\"safari\":\"11.1\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"11.3\",\"samsung\":\"8\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es6.reflect.apply\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.construct\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"13\",\"firefox\":\"49\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.define-property\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"13\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.delete-property\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.get\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.get-own-property-descriptor\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.get-prototype-of\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.has\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.is-extensible\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.own-keys\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.prevent-extensions\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.set\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.reflect.set-prototype-of\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"12\",\"firefox\":\"42\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.regexp.constructor\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"40\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.regexp.flags\":{\"chrome\":\"49\",\"opera\":\"36\",\"edge\":\"79\",\"firefox\":\"37\",\"safari\":\"9\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"36\",\"electron\":\"0.37\"},\"es6.regexp.match\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"49\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.regexp.replace\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"49\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.regexp.split\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"49\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.regexp.search\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"49\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.regexp.to-string\":{\"chrome\":\"50\",\"opera\":\"37\",\"edge\":\"79\",\"firefox\":\"39\",\"safari\":\"10\",\"node\":\"6\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"37\",\"electron\":\"1.1\"},\"es6.set\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.symbol\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"79\",\"firefox\":\"51\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es7.symbol.async-iterator\":{\"chrome\":\"63\",\"opera\":\"50\",\"edge\":\"79\",\"firefox\":\"57\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"8\",\"opera_mobile\":\"46\",\"electron\":\"3.0\"},\"es6.string.anchor\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.big\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.blink\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.bold\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.code-point-at\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"29\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.ends-with\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"29\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.fixed\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.fontcolor\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.fontsize\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.from-code-point\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"29\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.includes\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"40\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.italics\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.iterator\":{\"chrome\":\"38\",\"opera\":\"25\",\"edge\":\"12\",\"firefox\":\"36\",\"safari\":\"9\",\"node\":\"0.12\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"25\",\"electron\":\"0.20\"},\"es6.string.link\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es7.string.pad-start\":{\"chrome\":\"57\",\"opera\":\"44\",\"edge\":\"15\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"8\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"7\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"43\",\"electron\":\"1.7\"},\"es7.string.pad-end\":{\"chrome\":\"57\",\"opera\":\"44\",\"edge\":\"15\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"8\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"7\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"43\",\"electron\":\"1.7\"},\"es6.string.raw\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"34\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.repeat\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"24\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.small\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.starts-with\":{\"chrome\":\"41\",\"opera\":\"28\",\"edge\":\"12\",\"firefox\":\"29\",\"safari\":\"9\",\"node\":\"4\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"3.4\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"28\",\"electron\":\"0.21\"},\"es6.string.strike\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.sub\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.sup\":{\"chrome\":\"5\",\"opera\":\"15\",\"edge\":\"12\",\"firefox\":\"17\",\"safari\":\"6\",\"node\":\"0.4\",\"deno\":\"1\",\"android\":\"4\",\"ios\":\"7\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.14\",\"opera_mobile\":\"14\",\"electron\":\"0.20\"},\"es6.string.trim\":{\"chrome\":\"5\",\"opera\":\"10.50\",\"edge\":\"12\",\"firefox\":\"3.5\",\"safari\":\"4\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"9\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"10.1\",\"electron\":\"0.20\"},\"es7.string.trim-left\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"61\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"9\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"es7.string.trim-right\":{\"chrome\":\"66\",\"opera\":\"53\",\"edge\":\"79\",\"firefox\":\"61\",\"safari\":\"12\",\"node\":\"10\",\"deno\":\"1\",\"ios\":\"12\",\"samsung\":\"9\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"47\",\"electron\":\"3.0\"},\"es6.typed.array-buffer\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.data-view\":{\"chrome\":\"5\",\"opera\":\"12\",\"edge\":\"12\",\"firefox\":\"15\",\"safari\":\"5.1\",\"node\":\"0.4\",\"deno\":\"1\",\"ie\":\"10\",\"android\":\"4\",\"ios\":\"6\",\"phantom\":\"1.9\",\"samsung\":\"1\",\"rhino\":\"1.7.13\",\"opera_mobile\":\"12\",\"electron\":\"0.20\"},\"es6.typed.int8-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.uint8-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.uint8-clamped-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.int16-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.uint16-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.int32-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.uint32-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.float32-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.typed.float64-array\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"13\",\"firefox\":\"48\",\"safari\":\"10\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"10\",\"samsung\":\"5\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.weak-map\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"9\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"},\"es6.weak-set\":{\"chrome\":\"51\",\"opera\":\"38\",\"edge\":\"15\",\"firefox\":\"53\",\"safari\":\"9\",\"node\":\"6.5\",\"deno\":\"1\",\"ios\":\"9\",\"samsung\":\"5\",\"rhino\":\"1.7.15\",\"opera_mobile\":\"41\",\"electron\":\"1.2\"}}"));}}),
"[project]/node_modules/@babel/compat-data/corejs2-built-ins.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
// Todo (Babel 8): remove this file as Babel 8 drop support of core-js 2
module.exports = __turbopack_require__("[project]/node_modules/@babel/compat-data/data/corejs2-built-ins.json (json)");
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/targets.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unreleasedLabels = exports.browserNameMap = void 0;
const unreleasedLabels = exports.unreleasedLabels = {
    safari: "tp"
};
const browserNameMap = exports.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
}; //# sourceMappingURL=targets.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHighestUnreleased = getHighestUnreleased;
exports.getLowestImplementedVersion = getLowestImplementedVersion;
exports.getLowestUnreleased = getLowestUnreleased;
exports.isUnreleasedVersion = isUnreleasedVersion;
exports.semverMin = semverMin;
exports.semverify = semverify;
var _semver = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _helperValidatorOption = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)");
var _targets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/targets.js [app-ssr] (ecmascript)");
const versionRegExp = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/;
const v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
function semverMin(first, second) {
    return first && _semver.lt(first, second) ? first : second;
}
function semverify(version) {
    if (typeof version === "string" && _semver.valid(version)) {
        return version;
    }
    v.invariant(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), `'${version}' is not a valid version`);
    version = version.toString();
    let pos = 0;
    let num = 0;
    while((pos = version.indexOf(".", pos + 1)) > 0){
        num++;
    }
    return version + ".0".repeat(2 - num);
}
function isUnreleasedVersion(version, env) {
    const unreleasedLabel = _targets.unreleasedLabels[env];
    return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
}
function getLowestUnreleased(a, b, env) {
    const unreleasedLabel = _targets.unreleasedLabels[env];
    if (a === unreleasedLabel) {
        return b;
    }
    if (b === unreleasedLabel) {
        return a;
    }
    return semverMin(a, b);
}
function getHighestUnreleased(a, b, env) {
    return getLowestUnreleased(a, b, env) === a ? b : a;
}
function getLowestImplementedVersion(plugin, environment) {
    const result = plugin[environment];
    if (!result && environment === "android") {
        return plugin.chrome;
    }
    return result;
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TargetNames = void 0;
const TargetNames = exports.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
}; //# sourceMappingURL=options.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/pretty.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.prettifyTargets = prettifyTargets;
exports.prettifyVersion = prettifyVersion;
var _semver = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _targets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/targets.js [app-ssr] (ecmascript)");
function prettifyVersion(version) {
    if (typeof version !== "string") {
        return version;
    }
    const { major, minor, patch } = _semver.parse(version);
    const parts = [
        major
    ];
    if (minor || patch) {
        parts.push(minor);
    }
    if (patch) {
        parts.push(patch);
    }
    return parts.join(".");
}
function prettifyTargets(targets) {
    return Object.keys(targets).reduce((results, target)=>{
        let value = targets[target];
        const unreleasedLabel = _targets.unreleasedLabels[target];
        if (typeof value === "string" && unreleasedLabel !== value) {
            value = prettifyVersion(value);
        }
        results[target] = value;
        return results;
    }, {});
} //# sourceMappingURL=pretty.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/debug.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getInclusionReasons = getInclusionReasons;
var _semver = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _pretty = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/pretty.js [app-ssr] (ecmascript)");
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/utils.js [app-ssr] (ecmascript)");
function getInclusionReasons(item, targetVersions, list) {
    const minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce((result, env)=>{
        const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env);
        const targetVersion = targetVersions[env];
        if (!minVersion) {
            result[env] = (0, _pretty.prettifyVersion)(targetVersion);
        } else {
            const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env);
            const targetIsUnreleased = (0, _utils.isUnreleasedVersion)(targetVersion, env);
            if (!targetIsUnreleased && (minIsUnreleased || _semver.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion)))) {
                result[env] = (0, _pretty.prettifyVersion)(targetVersion);
            }
        }
        return result;
    }, {});
} //# sourceMappingURL=debug.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/filter-items.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = filterItems;
exports.isRequired = isRequired;
exports.targetsSupported = targetsSupported;
var _semver = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _plugins = __turbopack_require__("[project]/node_modules/@babel/compat-data/plugins.js [app-ssr] (ecmascript)");
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/utils.js [app-ssr] (ecmascript)");
function targetsSupported(target, support) {
    const targetEnvironments = Object.keys(target);
    if (targetEnvironments.length === 0) {
        return false;
    }
    const unsupportedEnvironments = targetEnvironments.filter((environment)=>{
        const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
        if (!lowestImplementedVersion) {
            return true;
        }
        const lowestTargetedVersion = target[environment];
        if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
            return false;
        }
        if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
            return true;
        }
        if (!_semver.valid(lowestTargetedVersion.toString())) {
            throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". ` + "Versions must be in semver format (major.minor.patch)");
        }
        return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
    });
    return unsupportedEnvironments.length === 0;
}
function isRequired(name, targets, { compatData = _plugins, includes, excludes } = {}) {
    if (excludes != null && excludes.has(name)) return false;
    if (includes != null && includes.has(name)) return true;
    return !targetsSupported(targets, compatData[name]);
}
function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    const result = new Set();
    const options = {
        compatData: list,
        includes,
        excludes
    };
    for(const item in list){
        if (isRequired(item, targets, options)) {
            result.add(item);
        } else if (pluginSyntaxMap) {
            const shippedProposalsSyntax = pluginSyntaxMap.get(item);
            if (shippedProposalsSyntax) {
                result.add(shippedProposalsSyntax);
            }
        }
    }
    defaultIncludes == null || defaultIncludes.forEach((item)=>!excludes.has(item) && result.add(item));
    defaultExcludes == null || defaultExcludes.forEach((item)=>!includes.has(item) && result.delete(item));
    return result;
} //# sourceMappingURL=filter-items.js.map
}}),
"[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "TargetNames", {
    enumerable: true,
    get: function() {
        return _options.TargetNames;
    }
});
exports.default = getTargets;
Object.defineProperty(exports, "filterItems", {
    enumerable: true,
    get: function() {
        return _filterItems.default;
    }
});
Object.defineProperty(exports, "getInclusionReasons", {
    enumerable: true,
    get: function() {
        return _debug.getInclusionReasons;
    }
});
exports.isBrowsersQueryValid = isBrowsersQueryValid;
Object.defineProperty(exports, "isRequired", {
    enumerable: true,
    get: function() {
        return _filterItems.isRequired;
    }
});
Object.defineProperty(exports, "prettifyTargets", {
    enumerable: true,
    get: function() {
        return _pretty.prettifyTargets;
    }
});
Object.defineProperty(exports, "unreleasedLabels", {
    enumerable: true,
    get: function() {
        return _targets.unreleasedLabels;
    }
});
var _browserslist = __turbopack_require__("[project]/node_modules/browserslist/index.js [app-ssr] (ecmascript)");
var _helperValidatorOption = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)");
var _nativeModules = __turbopack_require__("[project]/node_modules/@babel/compat-data/native-modules.js [app-ssr] (ecmascript)");
var _lruCache = __turbopack_require__("[project]/node_modules/lru-cache/index.js [app-ssr] (ecmascript)");
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/utils.js [app-ssr] (ecmascript)");
var _targets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/targets.js [app-ssr] (ecmascript)");
var _options = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/options.js [app-ssr] (ecmascript)");
var _pretty = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/pretty.js [app-ssr] (ecmascript)");
var _debug = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/debug.js [app-ssr] (ecmascript)");
var _filterItems = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/filter-items.js [app-ssr] (ecmascript)");
const ESM_SUPPORT = _nativeModules["es6.module"];
const v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
function validateTargetNames(targets) {
    const validTargets = Object.keys(_options.TargetNames);
    for (const target of Object.keys(targets)){
        if (!(target in _options.TargetNames)) {
            throw new Error(v.formatMessage(`'${target}' is not a valid target
- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
        }
    }
    return targets;
}
function isBrowsersQueryValid(browsers) {
    return typeof browsers === "string" || Array.isArray(browsers) && browsers.every((b)=>typeof b === "string");
}
function validateBrowsers(browsers) {
    v.invariant(browsers === undefined || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);
    return browsers;
}
function getLowestVersions(browsers) {
    return browsers.reduce((all, browser)=>{
        const [browserName, browserVersion] = browser.split(" ");
        const target = _targets.browserNameMap[browserName];
        if (!target) {
            return all;
        }
        try {
            const splitVersion = browserVersion.split("-")[0].toLowerCase();
            const isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);
            if (!all[target]) {
                all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);
                return all;
            }
            const version = all[target];
            const isUnreleased = (0, _utils.isUnreleasedVersion)(version, target);
            if (isUnreleased && isSplitUnreleased) {
                all[target] = (0, _utils.getLowestUnreleased)(version, splitVersion, target);
            } else if (isUnreleased) {
                all[target] = (0, _utils.semverify)(splitVersion);
            } else if (!isUnreleased && !isSplitUnreleased) {
                const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
                all[target] = (0, _utils.semverMin)(version, parsedBrowserVersion);
            }
        } catch (_) {}
        return all;
    }, {});
}
function outputDecimalWarning(decimalTargets) {
    if (!decimalTargets.length) {
        return;
    }
    console.warn("Warning, the following targets are using a decimal version:\n");
    decimalTargets.forEach(({ target, value })=>console.warn(`  ${target}: ${value}`));
    console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`);
}
function semverifyTarget(target, value) {
    try {
        return (0, _utils.semverify)(value);
    } catch (_) {
        throw new Error(v.formatMessage(`'${value}' is not a valid value for 'targets.${target}'.`));
    }
}
function nodeTargetParser(value) {
    const parsed = value === true || value === "current" ? process.versions.node : semverifyTarget("node", value);
    return [
        "node",
        parsed
    ];
}
function defaultTargetParser(target, value) {
    const version = (0, _utils.isUnreleasedVersion)(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
    return [
        target,
        version
    ];
}
function generateTargets(inputTargets) {
    const input = Object.assign({}, inputTargets);
    delete input.esmodules;
    delete input.browsers;
    return input;
}
function resolveTargets(queries, env) {
    const resolved = _browserslist(queries, {
        mobileToDesktop: true,
        env
    });
    return getLowestVersions(resolved);
}
const targetsCache = new _lruCache({
    max: 64
});
function resolveTargetsCached(queries, env) {
    const cacheKey = typeof queries === "string" ? queries : queries.join() + env;
    let cached = targetsCache.get(cacheKey);
    if (!cached) {
        cached = resolveTargets(queries, env);
        targetsCache.set(cacheKey, cached);
    }
    return Object.assign({}, cached);
}
function getTargets(inputTargets = {}, options = {}) {
    var _browsers, _browsers2;
    let { browsers, esmodules } = inputTargets;
    const { configPath = ".", onBrowserslistConfigFound } = options;
    validateBrowsers(browsers);
    const input = generateTargets(inputTargets);
    let targets = validateTargetNames(input);
    const shouldParseBrowsers = !!browsers;
    const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
    const shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;
    if (!browsers && shouldSearchForConfig) {
        browsers = process.env.BROWSERSLIST;
        if (!browsers) {
            const configFile = options.configFile || process.env.BROWSERSLIST_CONFIG || _browserslist.findConfigFile(configPath);
            if (configFile != null) {
                onBrowserslistConfigFound == null || onBrowserslistConfigFound(configFile);
                browsers = _browserslist.loadConfig({
                    config: configFile,
                    env: options.browserslistEnv
                });
            }
        }
        if (browsers == null) {
            {
                browsers = [];
            }
        }
    }
    if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
        browsers = Object.keys(ESM_SUPPORT).map((browser)=>`${browser} >= ${ESM_SUPPORT[browser]}`).join(", ");
        esmodules = false;
    }
    if ((_browsers2 = browsers) != null && _browsers2.length) {
        const queryBrowsers = resolveTargetsCached(browsers, options.browserslistEnv);
        if (esmodules === "intersect") {
            for (const browser of Object.keys(queryBrowsers)){
                if (browser !== "deno" && browser !== "ie") {
                    const esmSupportVersion = ESM_SUPPORT[browser === "opera_mobile" ? "op_mob" : browser];
                    if (esmSupportVersion) {
                        const version = queryBrowsers[browser];
                        queryBrowsers[browser] = (0, _utils.getHighestUnreleased)(version, (0, _utils.semverify)(esmSupportVersion), browser);
                    } else {
                        delete queryBrowsers[browser];
                    }
                } else {
                    delete queryBrowsers[browser];
                }
            }
        }
        targets = Object.assign(queryBrowsers, targets);
    }
    const result = {};
    const decimalWarnings = [];
    for (const target of Object.keys(targets).sort()){
        const value = targets[target];
        if (typeof value === "number" && value % 1 !== 0) {
            decimalWarnings.push({
                target,
                value
            });
        }
        const [parsedTarget, parsedValue] = target === "node" ? nodeTargetParser(value) : defaultTargetParser(target, value);
        if (parsedValue) {
            result[parsedTarget] = parsedValue;
        }
    }
    outputDecimalWarning(decimalWarnings);
    return result;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createPlugin;
var _pluginSyntaxJsx = __turbopack_require__("[project]/node_modules/@babel/plugin-syntax-jsx/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleImports = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
const DEFAULT = {
    importSource: "react",
    runtime: "automatic",
    pragma: "React.createElement",
    pragmaFrag: "React.Fragment"
};
const JSX_SOURCE_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxImportSource\s+(\S+)\s*$/m;
const JSX_RUNTIME_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxRuntime\s+(\S+)\s*$/m;
const JSX_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsx\s+(\S+)\s*$/m;
const JSX_FRAG_ANNOTATION_REGEX = /^\s*(?:\*\s*)?@jsxFrag\s+(\S+)\s*$/m;
const get = (pass, name)=>pass.get(`@babel/plugin-react-jsx/${name}`);
const set = (pass, name, v)=>pass.set(`@babel/plugin-react-jsx/${name}`, v);
function hasProto(node) {
    return node.properties.some((value)=>_core.types.isObjectProperty(value, {
            computed: false,
            shorthand: false
        }) && (_core.types.isIdentifier(value.key, {
            name: "__proto__"
        }) || _core.types.isStringLiteral(value.key, {
            value: "__proto__"
        })));
}
function createPlugin({ name, development }) {
    return (0, _helperPluginUtils.declare)((_, options)=>{
        const { pure: PURE_ANNOTATION, throwIfNamespace = true, filter, runtime: RUNTIME_DEFAULT = development ? "automatic" : "classic", importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource, pragma: PRAGMA_DEFAULT = DEFAULT.pragma, pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag } = options;
        {
            var { useSpread = false, useBuiltIns = false } = options;
            if (RUNTIME_DEFAULT === "classic") {
                if (typeof useSpread !== "boolean") {
                    throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
                }
                if (typeof useBuiltIns !== "boolean") {
                    throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
                }
                if (useSpread && useBuiltIns) {
                    throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
                }
            }
        }
        const injectMetaPropertiesVisitor = {
            JSXOpeningElement (path, state) {
                const attributes = [];
                if (isThisAllowed(path.scope)) {
                    attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__self"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));
                }
                attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier("__source"), _core.types.jsxExpressionContainer(makeSource(path, state))));
                path.pushContainer("attributes", attributes);
            }
        };
        return {
            name,
            inherits: _pluginSyntaxJsx.default,
            visitor: {
                JSXNamespacedName (path) {
                    if (throwIfNamespace) {
                        throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \
You can set \`throwIfNamespace: false\` to bypass this warning.`);
                    }
                },
                JSXSpreadChild (path) {
                    throw path.buildCodeFrameError("Spread children are not supported in React.");
                },
                Program: {
                    enter (path, state) {
                        const { file } = state;
                        let runtime = RUNTIME_DEFAULT;
                        let source = IMPORT_SOURCE_DEFAULT;
                        let pragma = PRAGMA_DEFAULT;
                        let pragmaFrag = PRAGMA_FRAG_DEFAULT;
                        let sourceSet = !!options.importSource;
                        let pragmaSet = !!options.pragma;
                        let pragmaFragSet = !!options.pragmaFrag;
                        if (file.ast.comments) {
                            for (const comment of file.ast.comments){
                                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);
                                if (sourceMatches) {
                                    source = sourceMatches[1];
                                    sourceSet = true;
                                }
                                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);
                                if (runtimeMatches) {
                                    runtime = runtimeMatches[1];
                                }
                                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);
                                if (jsxMatches) {
                                    pragma = jsxMatches[1];
                                    pragmaSet = true;
                                }
                                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);
                                if (jsxFragMatches) {
                                    pragmaFrag = jsxFragMatches[1];
                                    pragmaFragSet = true;
                                }
                            }
                        }
                        set(state, "runtime", runtime);
                        if (runtime === "classic") {
                            if (sourceSet) {
                                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);
                            }
                            const createElement = toMemberExpression(pragma);
                            const fragment = toMemberExpression(pragmaFrag);
                            set(state, "id/createElement", ()=>_core.types.cloneNode(createElement));
                            set(state, "id/fragment", ()=>_core.types.cloneNode(fragment));
                            set(state, "defaultPure", pragma === DEFAULT.pragma);
                        } else if (runtime === "automatic") {
                            if (pragmaSet || pragmaFragSet) {
                                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);
                            }
                            const define = (name, id)=>set(state, name, createImportLazily(state, path, id, source));
                            define("id/jsx", development ? "jsxDEV" : "jsx");
                            define("id/jsxs", development ? "jsxDEV" : "jsxs");
                            define("id/createElement", "createElement");
                            define("id/fragment", "Fragment");
                            set(state, "defaultPure", source === DEFAULT.importSource);
                        } else {
                            throw path.buildCodeFrameError(`Runtime must be either "classic" or "automatic".`);
                        }
                        if (development) {
                            path.traverse(injectMetaPropertiesVisitor, state);
                        }
                    }
                },
                JSXFragment: {
                    exit (path, file) {
                        let callExpr;
                        if (get(file, "runtime") === "classic") {
                            callExpr = buildCreateElementFragmentCall(path, file);
                        } else {
                            callExpr = buildJSXFragmentCall(path, file);
                        }
                        path.replaceWith(_core.types.inherits(callExpr, path.node));
                    }
                },
                JSXElement: {
                    exit (path, file) {
                        let callExpr;
                        if (get(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
                            callExpr = buildCreateElementCall(path, file);
                        } else {
                            callExpr = buildJSXElementCall(path, file);
                        }
                        path.replaceWith(_core.types.inherits(callExpr, path.node));
                    }
                },
                JSXAttribute (path) {
                    if (_core.types.isJSXElement(path.node.value)) {
                        path.node.value = _core.types.jsxExpressionContainer(path.node.value);
                    }
                }
            }
        };
        "TURBOPACK unreachable";
        function isDerivedClass(classPath) {
            return classPath.node.superClass !== null;
        }
        function isThisAllowed(scope) {
            do {
                const { path } = scope;
                if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {
                    if (!path.isMethod()) {
                        return true;
                    }
                    if (path.node.kind !== "constructor") {
                        return true;
                    }
                    return !isDerivedClass(path.parentPath.parentPath);
                }
                if (path.isTSModuleBlock()) {
                    return false;
                }
            }while (scope = scope.parent)
            return true;
        }
        function call(pass, name, args) {
            const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);
            if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) (0, _helperAnnotateAsPure.default)(node);
            return node;
        }
        function shouldUseCreateElement(path) {
            const openingPath = path.get("openingElement");
            const attributes = openingPath.node.attributes;
            let seenPropsSpread = false;
            for(let i = 0; i < attributes.length; i++){
                const attr = attributes[i];
                if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === "key") {
                    return true;
                } else if (_core.types.isJSXSpreadAttribute(attr)) {
                    seenPropsSpread = true;
                }
            }
            return false;
        }
        function convertJSXIdentifier(node, parent) {
            if (_core.types.isJSXIdentifier(node)) {
                if (node.name === "this" && _core.types.isReferenced(node, parent)) {
                    return _core.types.thisExpression();
                } else if (_core.types.isValidIdentifier(node.name, false)) {
                    node.type = "Identifier";
                    return node;
                } else {
                    return _core.types.stringLiteral(node.name);
                }
            } else if (_core.types.isJSXMemberExpression(node)) {
                return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
            } else if (_core.types.isJSXNamespacedName(node)) {
                return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);
            }
            return node;
        }
        function convertAttributeValue(node) {
            if (_core.types.isJSXExpressionContainer(node)) {
                return node.expression;
            } else {
                return node;
            }
        }
        function accumulateAttribute(array, attribute) {
            if (_core.types.isJSXSpreadAttribute(attribute.node)) {
                const arg = attribute.node.argument;
                if (_core.types.isObjectExpression(arg) && !hasProto(arg)) {
                    array.push(...arg.properties);
                } else {
                    array.push(_core.types.spreadElement(arg));
                }
                return array;
            }
            const value = convertAttributeValue(attribute.node.name.name !== "key" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);
            if (attribute.node.name.name === "key" && value === null) {
                throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
            }
            if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {
                var _value$extra;
                value.value = value.value.replace(/\n\s+/g, " ");
                (_value$extra = value.extra) == null || delete _value$extra.raw;
            }
            if (_core.types.isJSXNamespacedName(attribute.node.name)) {
                attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + ":" + attribute.node.name.name.name);
            } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {
                attribute.node.name.type = "Identifier";
            } else {
                attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);
            }
            array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));
            return array;
        }
        function buildChildrenProperty(children) {
            let childrenNode;
            if (children.length === 1) {
                childrenNode = children[0];
            } else if (children.length > 1) {
                childrenNode = _core.types.arrayExpression(children);
            } else {
                return undefined;
            }
            return _core.types.objectProperty(_core.types.identifier("children"), childrenNode);
        }
        function buildJSXElementCall(path, file) {
            const openingPath = path.get("openingElement");
            const args = [
                getTag(openingPath)
            ];
            const attribsArray = [];
            const extracted = Object.create(null);
            for (const attr of openingPath.get("attributes")){
                if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {
                    const { name } = attr.node.name;
                    switch(name){
                        case "__source":
                        case "__self":
                            if (extracted[name]) throw sourceSelfError(path, name);
                        case "key":
                            {
                                const keyValue = convertAttributeValue(attr.node.value);
                                if (keyValue === null) {
                                    throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
                                }
                                extracted[name] = keyValue;
                                break;
                            }
                        default:
                            attribsArray.push(attr);
                    }
                } else {
                    attribsArray.push(attr);
                }
            }
            const children = _core.types.react.buildChildren(path.node);
            let attribs;
            if (attribsArray.length || children.length) {
                attribs = buildJSXOpeningElementAttributes(attribsArray, children);
            } else {
                attribs = _core.types.objectExpression([]);
            }
            args.push(attribs);
            if (development) {
                var _extracted$key;
                args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));
                if (extracted.__source) {
                    args.push(extracted.__source);
                    if (extracted.__self) args.push(extracted.__self);
                } else if (extracted.__self) {
                    args.push(path.scope.buildUndefinedNode(), extracted.__self);
                }
            } else if (extracted.key !== undefined) {
                args.push(extracted.key);
            }
            return call(file, children.length > 1 ? "jsxs" : "jsx", args);
        }
        function buildJSXOpeningElementAttributes(attribs, children) {
            const props = attribs.reduce(accumulateAttribute, []);
            if ((children == null ? void 0 : children.length) > 0) {
                props.push(buildChildrenProperty(children));
            }
            return _core.types.objectExpression(props);
        }
        function buildJSXFragmentCall(path, file) {
            const args = [
                get(file, "id/fragment")()
            ];
            const children = _core.types.react.buildChildren(path.node);
            args.push(_core.types.objectExpression(children.length > 0 ? [
                buildChildrenProperty(children)
            ] : []));
            if (development) {
                args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));
            }
            return call(file, children.length > 1 ? "jsxs" : "jsx", args);
        }
        function buildCreateElementFragmentCall(path, file) {
            if (filter && !filter(path.node, file)) return;
            return call(file, "createElement", [
                get(file, "id/fragment")(),
                _core.types.nullLiteral(),
                ..._core.types.react.buildChildren(path.node)
            ]);
        }
        function buildCreateElementCall(path, file) {
            const openingPath = path.get("openingElement");
            return call(file, "createElement", [
                getTag(openingPath),
                buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes")),
                ..._core.types.react.buildChildren(path.node)
            ]);
        }
        function getTag(openingPath) {
            const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
            let tagName;
            if (_core.types.isIdentifier(tagExpr)) {
                tagName = tagExpr.name;
            } else if (_core.types.isStringLiteral(tagExpr)) {
                tagName = tagExpr.value;
            }
            if (_core.types.react.isCompatTag(tagName)) {
                return _core.types.stringLiteral(tagName);
            } else {
                return tagExpr;
            }
        }
        function buildCreateElementOpeningElementAttributes(file, path, attribs) {
            const runtime = get(file, "runtime");
            {
                if (runtime !== "automatic") {
                    const objs = [];
                    const props = attribs.reduce(accumulateAttribute, []);
                    if (!useSpread) {
                        let start = 0;
                        props.forEach((prop, i)=>{
                            if (_core.types.isSpreadElement(prop)) {
                                if (i > start) {
                                    objs.push(_core.types.objectExpression(props.slice(start, i)));
                                }
                                objs.push(prop.argument);
                                start = i + 1;
                            }
                        });
                        if (props.length > start) {
                            objs.push(_core.types.objectExpression(props.slice(start)));
                        }
                    } else if (props.length) {
                        objs.push(_core.types.objectExpression(props));
                    }
                    if (!objs.length) {
                        return _core.types.nullLiteral();
                    }
                    if (objs.length === 1) {
                        if (!(_core.types.isSpreadElement(props[0]) && _core.types.isObjectExpression(props[0].argument))) {
                            return objs[0];
                        }
                    }
                    if (!_core.types.isObjectExpression(objs[0])) {
                        objs.unshift(_core.types.objectExpression([]));
                    }
                    const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")) : file.addHelper("extends");
                    return _core.types.callExpression(helper, objs);
                }
            }
            const props = [];
            const found = Object.create(null);
            for (const attr of attribs){
                const { node } = attr;
                const name = _core.types.isJSXAttribute(node) && _core.types.isJSXIdentifier(node.name) && node.name.name;
                if (runtime === "automatic" && (name === "__source" || name === "__self")) {
                    if (found[name]) throw sourceSelfError(path, name);
                    found[name] = true;
                }
                accumulateAttribute(props, attr);
            }
            return props.length === 1 && _core.types.isSpreadElement(props[0]) && !_core.types.isObjectExpression(props[0].argument) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();
        }
    });
    "TURBOPACK unreachable";
    function getSource(source, importName) {
        switch(importName){
            case "Fragment":
                return `${source}/${development ? "jsx-dev-runtime" : "jsx-runtime"}`;
            case "jsxDEV":
                return `${source}/jsx-dev-runtime`;
            case "jsx":
            case "jsxs":
                return `${source}/jsx-runtime`;
            case "createElement":
                return source;
        }
    }
    function createImportLazily(pass, path, importName, source) {
        return ()=>{
            const actualSource = getSource(source, importName);
            if ((0, _helperModuleImports.isModule)(path)) {
                let reference = get(pass, `imports/${importName}`);
                if (reference) return _core.types.cloneNode(reference);
                reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {
                    importedInterop: "uncompiled",
                    importPosition: "after"
                });
                set(pass, `imports/${importName}`, reference);
                return reference;
            } else {
                let reference = get(pass, `requires/${actualSource}`);
                if (reference) {
                    reference = _core.types.cloneNode(reference);
                } else {
                    reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {
                        importedInterop: "uncompiled"
                    });
                    set(pass, `requires/${actualSource}`, reference);
                }
                return _core.types.memberExpression(reference, _core.types.identifier(importName));
            }
        };
    }
}
function toMemberExpression(id) {
    return id.split(".").map((name)=>_core.types.identifier(name)).reduce((object, property)=>_core.types.memberExpression(object, property));
}
function makeSource(path, state) {
    const location = path.node.loc;
    if (!location) {
        return path.scope.buildUndefinedNode();
    }
    if (!state.fileNameIdentifier) {
        const { filename = "" } = state;
        const fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
        path.scope.getProgramParent().push({
            id: fileNameIdentifier,
            init: _core.types.stringLiteral(filename)
        });
        state.fileNameIdentifier = fileNameIdentifier;
    }
    return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
}
function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
    const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();
    const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();
    return _core.template.expression.ast`{
    fileName: ${fileNameIdentifier},
    lineNumber: ${fileLineLiteral},
    columnNumber: ${fileColumnLiteral},
  }`;
}
function sourceSelfError(path, name) {
    const pluginName = `transform-react-jsx-${name.slice(2)}`;
    return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);
} //# sourceMappingURL=create-plugin.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-jsx/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _createPlugin = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _createPlugin.default)({
    name: "transform-react-jsx",
    development: false
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-jsx/lib/development.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _createPlugin = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _createPlugin.default)({
    name: "transform-react-jsx/development",
    development: true
}); //# sourceMappingURL=development.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-jsx-development/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _development = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-jsx/lib/development.js [app-ssr] (ecmascript)");
var _default = exports.default = _development.default; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-display-name/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _path = __turbopack_require__("[externals]/path [external] (path, cjs)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    function addDisplayName(id, call) {
        const props = call.arguments[0].properties;
        let safe = true;
        for(let i = 0; i < props.length; i++){
            const prop = props[i];
            if (_core.types.isSpreadElement(prop)) {
                continue;
            }
            const key = _core.types.toComputedKey(prop);
            if (_core.types.isStringLiteral(key, {
                value: "displayName"
            })) {
                safe = false;
                break;
            }
        }
        if (safe) {
            props.unshift(_core.types.objectProperty(_core.types.identifier("displayName"), _core.types.stringLiteral(id)));
        }
    }
    const isCreateClassCallExpression = _core.types.buildMatchMemberExpression("React.createClass");
    const isCreateClassAddon = (callee)=>_core.types.isIdentifier(callee, {
            name: "createReactClass"
        });
    function isCreateClass(node) {
        if (!node || !_core.types.isCallExpression(node)) return false;
        if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
            return false;
        }
        const args = node.arguments;
        if (args.length !== 1) return false;
        const first = args[0];
        if (!_core.types.isObjectExpression(first)) return false;
        return true;
    }
    return {
        name: "transform-react-display-name",
        visitor: {
            ExportDefaultDeclaration ({ node }, state) {
                if (isCreateClass(node.declaration)) {
                    const filename = state.filename || "unknown";
                    let displayName = _path.basename(filename, _path.extname(filename));
                    if (displayName === "index") {
                        displayName = _path.basename(_path.dirname(filename));
                    }
                    addDisplayName(displayName, node.declaration);
                }
            },
            CallExpression (path) {
                const { node } = path;
                if (!isCreateClass(node)) return;
                let id;
                path.find(function(path) {
                    if (path.isAssignmentExpression()) {
                        id = path.node.left;
                    } else if (path.isObjectProperty()) {
                        id = path.node.key;
                    } else if (path.isVariableDeclarator()) {
                        id = path.node.id;
                    } else if (path.isStatement()) {
                        return true;
                    }
                    if (id) return true;
                });
                if (!id) return;
                if (_core.types.isMemberExpression(id)) {
                    id = id.property;
                }
                if (_core.types.isIdentifier(id)) {
                    addDisplayName(id.name, node);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-react-pure-annotations/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const PURE_CALLS = [
    [
        "react",
        new Set([
            "cloneElement",
            "createContext",
            "createElement",
            "createFactory",
            "createRef",
            "forwardRef",
            "isValidElement",
            "memo",
            "lazy"
        ])
    ],
    [
        "react-dom",
        new Set([
            "createPortal"
        ])
    ]
];
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-react-pure-annotations",
        visitor: {
            CallExpression (path) {
                if (isReactCall(path)) {
                    (0, _helperAnnotateAsPure.default)(path);
                }
            }
        }
    };
});
function isReactCall(path) {
    const calleePath = path.get("callee");
    if (!calleePath.isMemberExpression()) {
        for (const [module, methods] of PURE_CALLS){
            for (const method of methods){
                if (calleePath.referencesImport(module, method)) {
                    return true;
                }
            }
        }
        return false;
    }
    const object = calleePath.get("object");
    const callee = calleePath.node;
    if (!callee.computed && _core.types.isIdentifier(callee.property)) {
        const propertyName = callee.property.name;
        for (const [module, methods] of PURE_CALLS){
            if (object.referencesImport(module, "default") || object.referencesImport(module, "*")) {
                return methods.has(propertyName);
            }
        }
    }
    return false;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/preset-react/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var transformReactJSX = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-jsx/lib/index.js [app-ssr] (ecmascript)");
var transformReactJSXDevelopment = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-jsx-development/lib/index.js [app-ssr] (ecmascript)");
var transformReactDisplayName = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-display-name/lib/index.js [app-ssr] (ecmascript)");
var transformReactPure = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-react-pure-annotations/lib/index.js [app-ssr] (ecmascript)");
var helperValidatorOption = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)");
function _interopDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
var transformReactJSX__default = /*#__PURE__*/ _interopDefault(transformReactJSX);
var transformReactJSXDevelopment__default = /*#__PURE__*/ _interopDefault(transformReactJSXDevelopment);
var transformReactDisplayName__default = /*#__PURE__*/ _interopDefault(transformReactDisplayName);
var transformReactPure__default = /*#__PURE__*/ _interopDefault(transformReactPure);
new helperValidatorOption.OptionValidator("@babel/preset-react");
function normalizeOptions(options = {}) {
    {
        let { pragma, pragmaFrag } = options;
        const { pure, throwIfNamespace = true, runtime = "classic", importSource, useBuiltIns, useSpread } = options;
        if (runtime === "classic") {
            pragma = pragma || "React.createElement";
            pragmaFrag = pragmaFrag || "React.Fragment";
        }
        const development = options.development == null ? undefined : !!options.development;
        return {
            development,
            importSource,
            pragma,
            pragmaFrag,
            pure,
            runtime,
            throwIfNamespace,
            useBuiltIns,
            useSpread
        };
    }
}
var index = helperPluginUtils.declarePreset((api, opts)=>{
    api.assertVersion(7);
    const { development = false, importSource, pragma, pragmaFrag, pure, runtime, throwIfNamespace } = normalizeOptions(opts);
    return {
        plugins: [
            [
                development ? transformReactJSXDevelopment__default.default : transformReactJSX__default.default,
                {
                    importSource,
                    pragma,
                    pragmaFrag,
                    runtime,
                    throwIfNamespace,
                    pure,
                    useBuiltIns: !!opts.useBuiltIns,
                    useSpread: opts.useSpread
                }
            ],
            transformReactDisplayName__default.default,
            pure !== false && transformReactPure__default.default
        ].filter(Boolean)
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/debug.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.logPlugin = void 0;
var _helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
var _plugins = __turbopack_require__("[project]/node_modules/@babel/compat-data/plugins.js [app-ssr] (ecmascript)");
const logPlugin = (item, targetVersions, list)=>{
    const filteredList = (0, _helperCompilationTargets.getInclusionReasons)(item, targetVersions, list);
    const support = list[item];
    {
        if (item.startsWith("transform-")) {
            const proposalName = `proposal-${item.slice(10)}`;
            if (proposalName === "proposal-dynamic-import" || hasOwnProperty.call(_plugins, proposalName)) {
                item = proposalName;
            }
        }
    }
    if (!support) {
        console.log(`  ${item}`);
        return;
    }
    let formattedTargets = `{`;
    let first = true;
    for (const target of Object.keys(filteredList)){
        if (!first) formattedTargets += `,`;
        first = false;
        formattedTargets += ` ${target}`;
        if (support[target]) formattedTargets += ` < ${support[target]}`;
    }
    formattedTargets += ` }`;
    console.log(`  ${item} ${formattedTargets}`);
};
exports.logPlugin = logPlugin; //# sourceMappingURL=debug.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/babel-7-available-plugins.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
{
    const availablePlugins = {
        "syntax-import-assertions": ()=>__turbopack_require__("[project]/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js [app-ssr] (ecmascript)"),
        "syntax-import-attributes": ()=>__turbopack_require__("[project]/node_modules/@babel/plugin-syntax-import-attributes/lib/index.js [app-ssr] (ecmascript)")
    };
    module.exports = availablePlugins;
} //# sourceMappingURL=babel-7-available-plugins.cjs.map
}}),
"[project]/node_modules/@babel/preset-env/lib/available-plugins.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.minVersions = exports.legacyBabel7SyntaxPlugins = exports.default = void 0;
var _babel7AvailablePlugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/babel-7-available-plugins.cjs [app-ssr] (ecmascript)");
var _pluginTransformAsyncGeneratorFunctions = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-async-generator-functions/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformAsyncToGenerator = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-async-to-generator/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformArrowFunctions = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-arrow-functions/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformBlockScopedFunctions = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-block-scoped-functions/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformBlockScoping = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-block-scoping/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformClasses = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-classes/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformClassProperties = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-class-properties/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformClassStaticBlock = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-class-static-block/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformComputedProperties = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-computed-properties/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformDestructuring = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-destructuring/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformDotallRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-dotall-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformDuplicateKeys = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-duplicate-keys/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformDuplicateNamedCapturingGroupsRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-duplicate-named-capturing-groups-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformDynamicImport = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-dynamic-import/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformExponentiationOperator = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-exponentiation-operator/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformExportNamespaceFrom = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformForOf = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-for-of/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformFunctionName = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-function-name/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformJsonStrings = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-json-strings/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformLiterals = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-literals/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformLogicalAssignmentOperators = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-logical-assignment-operators/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformMemberExpressionLiterals = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-member-expression-literals/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformModulesAmd = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-amd/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformModulesCommonjs = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformModulesSystemjs = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-systemjs/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformModulesUmd = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-modules-umd/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformNamedCapturingGroupsRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-named-capturing-groups-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformNewTarget = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-new-target/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformNullishCoalescingOperator = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformNumericSeparator = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-numeric-separator/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformObjectRestSpread = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-object-rest-spread/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformObjectSuper = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-object-super/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformOptionalCatchBinding = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-optional-catch-binding/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformOptionalChaining = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformParameters = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformPrivateMethods = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-private-methods/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformPrivatePropertyInObject = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-private-property-in-object/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformPropertyLiterals = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-property-literals/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformRegenerator = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-regenerator/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformRegexpModifiers = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-regexp-modifiers/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformReservedWords = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-reserved-words/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformShorthandProperties = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-shorthand-properties/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformSpread = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-spread/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformStickyRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-sticky-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformTemplateLiterals = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-template-literals/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformTypeofSymbol = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-typeof-symbol/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformUnicodeEscapes = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-unicode-escapes/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformUnicodePropertyRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-unicode-property-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformUnicodeRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-unicode-regex/lib/index.js [app-ssr] (ecmascript)");
var _pluginTransformUnicodeSetsRegex = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-unicode-sets-regex/lib/index.js [app-ssr] (ecmascript)");
var _index = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-async-arrows-in-class/index.js [app-ssr] (ecmascript)");
var _index2 = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-edge-default-parameters/index.js [app-ssr] (ecmascript)");
var _index3 = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-edge-function-name/index.js [app-ssr] (ecmascript)");
var _pluginBugfixFirefoxClassInComputedClassKey = __turbopack_require__("[project]/node_modules/@babel/plugin-bugfix-firefox-class-in-computed-class-key/lib/index.js [app-ssr] (ecmascript)");
var _index4 = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-tagged-template-caching/index.js [app-ssr] (ecmascript)");
var _index5 = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-safari-block-shadowing/index.js [app-ssr] (ecmascript)");
var _index6 = __turbopack_require__("[project]/node_modules/@babel/preset-modules/lib/plugins/transform-safari-for-shadowing/index.js [app-ssr] (ecmascript)");
var _pluginBugfixSafariIdDestructuringCollisionInFunctionExpression = __turbopack_require__("[project]/node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/lib/index.js [app-ssr] (ecmascript)");
var _pluginBugfixSafariClassFieldInitializerScope = __turbopack_require__("[project]/node_modules/@babel/plugin-bugfix-safari-class-field-initializer-scope/lib/index.js [app-ssr] (ecmascript)");
var _pluginBugfixV8SpreadParametersInOptionalChaining = __turbopack_require__("[project]/node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/lib/index.js [app-ssr] (ecmascript)");
var _pluginBugfixV8StaticClassFieldsRedefineReadonly = __turbopack_require__("[project]/node_modules/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/lib/index.js [app-ssr] (ecmascript)");
const availablePlugins = exports.default = {
    "bugfix/transform-async-arrows-in-class": ()=>_index,
    "bugfix/transform-edge-default-parameters": ()=>_index2,
    "bugfix/transform-edge-function-name": ()=>_index3,
    "bugfix/transform-firefox-class-in-computed-class-key": ()=>_pluginBugfixFirefoxClassInComputedClassKey.default,
    "bugfix/transform-safari-block-shadowing": ()=>_index5,
    "bugfix/transform-safari-class-field-initializer-scope": ()=>_pluginBugfixSafariClassFieldInitializerScope.default,
    "bugfix/transform-safari-for-shadowing": ()=>_index6,
    "bugfix/transform-safari-id-destructuring-collision-in-function-expression": ()=>_pluginBugfixSafariIdDestructuringCollisionInFunctionExpression.default,
    "bugfix/transform-tagged-template-caching": ()=>_index4,
    "bugfix/transform-v8-spread-parameters-in-optional-chaining": ()=>_pluginBugfixV8SpreadParametersInOptionalChaining.default,
    "bugfix/transform-v8-static-class-fields-redefine-readonly": ()=>_pluginBugfixV8StaticClassFieldsRedefineReadonly.default,
    "transform-arrow-functions": ()=>_pluginTransformArrowFunctions.default,
    "transform-async-generator-functions": ()=>_pluginTransformAsyncGeneratorFunctions.default,
    "transform-async-to-generator": ()=>_pluginTransformAsyncToGenerator.default,
    "transform-block-scoped-functions": ()=>_pluginTransformBlockScopedFunctions.default,
    "transform-block-scoping": ()=>_pluginTransformBlockScoping.default,
    "transform-class-properties": ()=>_pluginTransformClassProperties.default,
    "transform-class-static-block": ()=>_pluginTransformClassStaticBlock.default,
    "transform-classes": ()=>_pluginTransformClasses.default,
    "transform-computed-properties": ()=>_pluginTransformComputedProperties.default,
    "transform-destructuring": ()=>_pluginTransformDestructuring.default,
    "transform-dotall-regex": ()=>_pluginTransformDotallRegex.default,
    "transform-duplicate-keys": ()=>_pluginTransformDuplicateKeys.default,
    "transform-duplicate-named-capturing-groups-regex": ()=>_pluginTransformDuplicateNamedCapturingGroupsRegex.default,
    "transform-dynamic-import": ()=>_pluginTransformDynamicImport.default,
    "transform-exponentiation-operator": ()=>_pluginTransformExponentiationOperator.default,
    "transform-export-namespace-from": ()=>_pluginTransformExportNamespaceFrom.default,
    "transform-for-of": ()=>_pluginTransformForOf.default,
    "transform-function-name": ()=>_pluginTransformFunctionName.default,
    "transform-json-strings": ()=>_pluginTransformJsonStrings.default,
    "transform-literals": ()=>_pluginTransformLiterals.default,
    "transform-logical-assignment-operators": ()=>_pluginTransformLogicalAssignmentOperators.default,
    "transform-member-expression-literals": ()=>_pluginTransformMemberExpressionLiterals.default,
    "transform-modules-amd": ()=>_pluginTransformModulesAmd.default,
    "transform-modules-commonjs": ()=>_pluginTransformModulesCommonjs.default,
    "transform-modules-systemjs": ()=>_pluginTransformModulesSystemjs.default,
    "transform-modules-umd": ()=>_pluginTransformModulesUmd.default,
    "transform-named-capturing-groups-regex": ()=>_pluginTransformNamedCapturingGroupsRegex.default,
    "transform-new-target": ()=>_pluginTransformNewTarget.default,
    "transform-nullish-coalescing-operator": ()=>_pluginTransformNullishCoalescingOperator.default,
    "transform-numeric-separator": ()=>_pluginTransformNumericSeparator.default,
    "transform-object-rest-spread": ()=>_pluginTransformObjectRestSpread.default,
    "transform-object-super": ()=>_pluginTransformObjectSuper.default,
    "transform-optional-catch-binding": ()=>_pluginTransformOptionalCatchBinding.default,
    "transform-optional-chaining": ()=>_pluginTransformOptionalChaining.default,
    "transform-parameters": ()=>_pluginTransformParameters.default,
    "transform-private-methods": ()=>_pluginTransformPrivateMethods.default,
    "transform-private-property-in-object": ()=>_pluginTransformPrivatePropertyInObject.default,
    "transform-property-literals": ()=>_pluginTransformPropertyLiterals.default,
    "transform-regenerator": ()=>_pluginTransformRegenerator.default,
    "transform-regexp-modifiers": ()=>_pluginTransformRegexpModifiers.default,
    "transform-reserved-words": ()=>_pluginTransformReservedWords.default,
    "transform-shorthand-properties": ()=>_pluginTransformShorthandProperties.default,
    "transform-spread": ()=>_pluginTransformSpread.default,
    "transform-sticky-regex": ()=>_pluginTransformStickyRegex.default,
    "transform-template-literals": ()=>_pluginTransformTemplateLiterals.default,
    "transform-typeof-symbol": ()=>_pluginTransformTypeofSymbol.default,
    "transform-unicode-escapes": ()=>_pluginTransformUnicodeEscapes.default,
    "transform-unicode-property-regex": ()=>_pluginTransformUnicodePropertyRegex.default,
    "transform-unicode-regex": ()=>_pluginTransformUnicodeRegex.default,
    "transform-unicode-sets-regex": ()=>_pluginTransformUnicodeSetsRegex.default
};
const minVersions = exports.minVersions = {};
let legacyBabel7SyntaxPlugins = exports.legacyBabel7SyntaxPlugins = void 0;
{
    Object.assign(minVersions, {
        "bugfix/transform-safari-id-destructuring-collision-in-function-expression": "7.16.0",
        "bugfix/transform-v8-static-class-fields-redefine-readonly": "7.12.0",
        "syntax-import-attributes": "7.22.0",
        "transform-class-static-block": "7.12.0",
        "transform-duplicate-named-capturing-groups-regex": "7.19.0",
        "transform-private-property-in-object": "7.10.0",
        "transform-regexp-modifiers": "7.19.0"
    });
    const syntax = (name)=>()=>()=>({
                    manipulateOptions: (_, p)=>p.plugins.push(name)
                });
    const legacyBabel7SyntaxPluginsLoaders = {
        "syntax-async-generators": syntax("asyncGenerators"),
        "syntax-class-properties": syntax("classProperties"),
        "syntax-class-static-block": syntax("classStaticBlock"),
        "syntax-dynamic-import": syntax("dynamicImport"),
        "syntax-export-namespace-from": syntax("exportNamespaceFrom"),
        "syntax-import-meta": syntax("importMeta"),
        "syntax-json-strings": syntax("jsonStrings"),
        "syntax-logical-assignment-operators": syntax("logicalAssignment"),
        "syntax-nullish-coalescing-operator": syntax("nullishCoalescingOperator"),
        "syntax-numeric-separator": syntax("numericSeparator"),
        "syntax-object-rest-spread": syntax("objectRestSpread"),
        "syntax-optional-catch-binding": syntax("optionalCatchBinding"),
        "syntax-optional-chaining": syntax("optionalChaining"),
        "syntax-private-property-in-object": syntax("privateIn"),
        "syntax-top-level-await": syntax("topLevelAwait"),
        "syntax-unicode-sets-regex": ()=>__turbopack_require__("[project]/node_modules/@babel/plugin-syntax-unicode-sets-regex/lib/index.js [app-ssr] (ecmascript)"),
        "syntax-import-assertions": _babel7AvailablePlugins["syntax-import-assertions"],
        "syntax-import-attributes": _babel7AvailablePlugins["syntax-import-attributes"]
    };
    Object.assign(availablePlugins, legacyBabel7SyntaxPluginsLoaders);
    exports.legacyBabel7SyntaxPlugins = legacyBabel7SyntaxPlugins = new Set(Object.keys(legacyBabel7SyntaxPluginsLoaders));
} //# sourceMappingURL=available-plugins.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/filter-items.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addProposalSyntaxPlugins = addProposalSyntaxPlugins;
exports.removeUnnecessaryItems = removeUnnecessaryItems;
exports.removeUnsupportedItems = removeUnsupportedItems;
var _semver = __turbopack_require__("[project]/node_modules/@babel/preset-env/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _availablePlugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/available-plugins.js [app-ssr] (ecmascript)");
function addProposalSyntaxPlugins(items, proposalSyntaxPlugins) {
    proposalSyntaxPlugins.forEach((plugin)=>{
        items.add(plugin);
    });
}
function removeUnnecessaryItems(items, overlapping) {
    items.forEach((item)=>{
        var _overlapping$item;
        (_overlapping$item = overlapping[item]) == null || _overlapping$item.forEach((name)=>items.delete(name));
    });
}
function removeUnsupportedItems(items, babelVersion) {
    items.forEach((item)=>{
        if (hasOwnProperty.call(_availablePlugins.minVersions, item) && _semver.lt(babelVersion, _availablePlugins.minVersions[item])) {
            items.delete(item);
        } else if (babelVersion[0] === "8" && _availablePlugins.legacyBabel7SyntaxPlugins.has(item)) {
            items.delete(item);
        }
    });
} //# sourceMappingURL=filter-items.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/module-transformations.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _default = exports.default = {
    amd: "transform-modules-amd",
    commonjs: "transform-modules-commonjs",
    cjs: "transform-modules-commonjs",
    systemjs: "transform-modules-systemjs",
    umd: "transform-modules-umd"
}; //# sourceMappingURL=module-transformations.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/plugins-compat-data.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pluginsBugfixes = exports.plugins = exports.overlappingPlugins = void 0;
var _plugins = __turbopack_require__("[project]/node_modules/@babel/compat-data/plugins.js [app-ssr] (ecmascript)");
var _pluginBugfixes = __turbopack_require__("[project]/node_modules/@babel/compat-data/plugin-bugfixes.js [app-ssr] (ecmascript)");
var _overlappingPlugins = __turbopack_require__("[project]/node_modules/@babel/compat-data/overlapping-plugins.js [app-ssr] (ecmascript)");
var _availablePlugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/available-plugins.js [app-ssr] (ecmascript)");
const keys = Object.keys;
const plugins = exports.plugins = filterAvailable(_plugins);
const pluginsBugfixes = exports.pluginsBugfixes = filterAvailable(_pluginBugfixes);
const overlappingPlugins = exports.overlappingPlugins = filterAvailable(_overlappingPlugins);
{
    overlappingPlugins["syntax-import-attributes"] = [
        "syntax-import-assertions"
    ];
}function filterAvailable(data) {
    const result = {};
    for (const plugin of keys(data)){
        if (hasOwnProperty.call(_availablePlugins.default, plugin)) {
            result[plugin] = data[plugin];
        }
    }
    return result;
} //# sourceMappingURL=plugins-compat-data.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UseBuiltInsOption = exports.TopLevelOptions = exports.ModulesOption = void 0;
const TopLevelOptions = exports.TopLevelOptions = {
    bugfixes: "bugfixes",
    configPath: "configPath",
    corejs: "corejs",
    debug: "debug",
    exclude: "exclude",
    forceAllTransforms: "forceAllTransforms",
    ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
    include: "include",
    modules: "modules",
    shippedProposals: "shippedProposals",
    targets: "targets",
    useBuiltIns: "useBuiltIns",
    browserslistEnv: "browserslistEnv"
};
{
    Object.assign(TopLevelOptions, {
        loose: "loose",
        spec: "spec"
    });
}const ModulesOption = exports.ModulesOption = {
    false: false,
    auto: "auto",
    amd: "amd",
    commonjs: "commonjs",
    cjs: "cjs",
    systemjs: "systemjs",
    umd: "umd"
};
const UseBuiltInsOption = exports.UseBuiltInsOption = {
    false: false,
    entry: "entry",
    usage: "usage"
}; //# sourceMappingURL=options.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/polyfills/utils.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
;
exports.getImportSource = function({ node }) {
    if (node.specifiers.length === 0) return node.source.value;
};
exports.getRequireSource = function({ node }) {
    if (node.type !== "ExpressionStatement") return;
    const { expression } = node;
    if (expression.type === "CallExpression" && expression.callee.type === "Identifier" && expression.callee.name === "require" && expression.arguments.length === 1 && expression.arguments[0].type === "StringLiteral") {
        return expression.arguments[0].value;
    }
};
exports.isPolyfillSource = function(source) {
    return source === "@babel/polyfill" || source === "core-js";
}; //# sourceMappingURL=utils.cjs.map
}}),
"[project]/node_modules/@babel/preset-env/lib/polyfills/babel-polyfill.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
;
const { getImportSource, getRequireSource, isPolyfillSource } = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/utils.cjs [app-ssr] (ecmascript)");
const BABEL_POLYFILL_DEPRECATION = `
  \`@babel/polyfill\` is deprecated. Please, use required parts of \`core-js\`
  and \`regenerator-runtime/runtime\` separately`;
const NO_DIRECT_POLYFILL_IMPORT = `
  When setting \`useBuiltIns: 'usage'\`, polyfills are automatically imported when needed.
  Please remove the direct import of \`SPECIFIER\` or use \`useBuiltIns: 'entry'\` instead.`;
module.exports = function({ template }, { regenerator, deprecated, usage }) {
    return {
        name: "preset-env/replace-babel-polyfill",
        visitor: {
            ImportDeclaration (path) {
                const src = getImportSource(path);
                if (usage && isPolyfillSource(src)) {
                    console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
                    if (!deprecated) path.remove();
                } else if (src === "@babel/polyfill") {
                    if (deprecated) {
                        console.warn(BABEL_POLYFILL_DEPRECATION);
                    } else if (regenerator) {
                        path.replaceWithMultiple(template.ast`
              import "core-js";
              import "regenerator-runtime/runtime.js";
            `);
                    } else {
                        path.replaceWith(template.ast`
              import "core-js";
            `);
                    }
                }
            },
            Program (path) {
                path.get("body").forEach((bodyPath)=>{
                    const src = getRequireSource(bodyPath);
                    if (usage && isPolyfillSource(src)) {
                        console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
                        if (!deprecated) bodyPath.remove();
                    } else if (src === "@babel/polyfill") {
                        if (deprecated) {
                            console.warn(BABEL_POLYFILL_DEPRECATION);
                        } else if (regenerator) {
                            bodyPath.replaceWithMultiple(template.ast`
                require("core-js");
                require("regenerator-runtime/runtime.js");
              `);
                        } else {
                            bodyPath.replaceWith(template.ast`
                require("core-js");
              `);
                        }
                    }
                });
            }
        }
    };
}; //# sourceMappingURL=babel-polyfill.cjs.map
}}),
"[project]/node_modules/@babel/preset-env/lib/polyfills/regenerator.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
;
const { getImportSource, getRequireSource } = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/utils.cjs [app-ssr] (ecmascript)");
function isRegeneratorSource(source) {
    return source === "regenerator-runtime/runtime" || source === "regenerator-runtime/runtime.js";
}
module.exports = function() {
    const visitor = {
        ImportDeclaration (path) {
            if (isRegeneratorSource(getImportSource(path))) {
                this.regeneratorImportExcluded = true;
                path.remove();
            }
        },
        Program (path) {
            path.get("body").forEach((bodyPath)=>{
                if (isRegeneratorSource(getRequireSource(bodyPath))) {
                    this.regeneratorImportExcluded = true;
                    bodyPath.remove();
                }
            });
        }
    };
    return {
        name: "preset-env/remove-regenerator",
        visitor,
        pre () {
            this.regeneratorImportExcluded = false;
        },
        post () {
            if (this.opts.debug && this.regeneratorImportExcluded) {
                let filename = this.file.opts.filename;
                if (process.env.BABEL_ENV === "test") {
                    filename = filename.replace(/\\/g, "/");
                }
                console.log(`\n[${filename}] Based on your targets, regenerator-runtime import excluded.`);
            }
        }
    };
}; //# sourceMappingURL=regenerator.cjs.map
}}),
"[project]/node_modules/@babel/preset-env/lib/polyfills/babel-7-plugins.cjs [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
{
    Object.defineProperties(exports, {
        pluginCoreJS2: {
            get: ()=>__turbopack_require__("[project]/node_modules/babel-plugin-polyfill-corejs2/lib/index.js [app-ssr] (ecmascript)").default
        },
        pluginRegenerator: {
            get: ()=>__turbopack_require__("[project]/node_modules/babel-plugin-polyfill-regenerator/lib/index.js [app-ssr] (ecmascript)").default
        },
        legacyBabelPolyfillPlugin: {
            get: ()=>__turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/babel-polyfill.cjs [app-ssr] (ecmascript)")
        },
        removeRegeneratorEntryPlugin: {
            get: ()=>__turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/regenerator.cjs [app-ssr] (ecmascript)")
        },
        corejs2Polyfills: {
            get: ()=>__turbopack_require__("[project]/node_modules/@babel/compat-data/corejs2-built-ins.js [app-ssr] (ecmascript)")
        }
    });
} //# sourceMappingURL=babel-7-plugins.cjs.map
}}),
"[project]/node_modules/@babel/preset-env/lib/normalize-options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkDuplicateIncludeExcludes = void 0;
exports.default = normalizeOptions;
exports.normalizeCoreJSOption = normalizeCoreJSOption;
exports.validateUseBuiltInsOption = exports.validateModulesOption = exports.normalizePluginName = void 0;
var _semver = __turbopack_require__("[project]/node_modules/@babel/preset-env/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _pluginsCompatData = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/plugins-compat-data.js [app-ssr] (ecmascript)");
var _moduleTransformations = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/module-transformations.js [app-ssr] (ecmascript)");
var _options = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/options.js [app-ssr] (ecmascript)");
var _helperValidatorOption = __turbopack_require__("[project]/node_modules/@babel/helper-validator-option/lib/index.js [app-ssr] (ecmascript)");
var _babel7Plugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/babel-7-plugins.cjs [app-ssr] (ecmascript)");
const corejs3Polyfills = __turbopack_require__("[project]/node_modules/core-js-compat/data.json (json)");
const v = new _helperValidatorOption.OptionValidator("@babel/preset-env");
const allPluginsList = Object.keys(_pluginsCompatData.plugins);
const modulePlugins = [
    "transform-dynamic-import",
    ...Object.keys(_moduleTransformations.default).map((m)=>_moduleTransformations.default[m])
];
const getValidIncludesAndExcludes = (type, corejs)=>{
    const set = new Set(allPluginsList);
    if (type === "exclude") modulePlugins.map(set.add, set);
    if (corejs) {
        if (corejs === 2) {
            Object.keys(_babel7Plugins.corejs2Polyfills).map(set.add, set);
            set.add("web.timers").add("web.immediate").add("web.dom.iterable");
        } else {
            Object.keys(corejs3Polyfills).map(set.add, set);
        }
    }
    return Array.from(set);
};
function flatMap(array, fn) {
    return Array.prototype.concat.apply([], array.map(fn));
}
const normalizePluginName = (plugin)=>plugin.replace(/^(?:@babel\/|babel-)(?:plugin-)?/, "");
exports.normalizePluginName = normalizePluginName;
const expandIncludesAndExcludes = (filterList = [], type, corejs)=>{
    if (filterList.length === 0) return [];
    const filterableItems = getValidIncludesAndExcludes(type, corejs);
    const invalidFilters = [];
    const selectedPlugins = flatMap(filterList, (filter)=>{
        let re;
        if (typeof filter === "string") {
            try {
                re = new RegExp(`^${normalizePluginName(filter)}$`);
            } catch (_) {
                invalidFilters.push(filter);
                return [];
            }
        } else {
            re = filter;
        }
        const items = filterableItems.filter((item)=>{
            return re.test(item) || re.test(item.replace(/^transform-/, "proposal-"));
        });
        if (items.length === 0) invalidFilters.push(filter);
        return items;
    });
    v.invariant(invalidFilters.length === 0, `The plugins/built-ins '${invalidFilters.join(", ")}' passed to the '${type}' option are not
    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env`);
    return selectedPlugins;
};
const checkDuplicateIncludeExcludes = (include = [], exclude = [])=>{
    const duplicates = include.filter((opt)=>exclude.includes(opt));
    v.invariant(duplicates.length === 0, `The plugins/built-ins '${duplicates.join(", ")}' were found in both the "include" and
    "exclude" options.`);
};
exports.checkDuplicateIncludeExcludes = checkDuplicateIncludeExcludes;
const normalizeTargets = (targets)=>{
    if (typeof targets === "string" || Array.isArray(targets)) {
        return {
            browsers: targets
        };
    }
    return Object.assign({}, targets);
};
const validateModulesOption = (modulesOpt = _options.ModulesOption.auto)=>{
    v.invariant(_options.ModulesOption[modulesOpt.toString()] || modulesOpt === _options.ModulesOption.false, `The 'modules' option must be one of \n` + ` - 'false' to indicate no module processing\n` + ` - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'` + ` - 'auto' (default) which will automatically select 'false' if the current\n` + `   process is known to support ES module syntax, or "commonjs" otherwise\n`);
    return modulesOpt;
};
exports.validateModulesOption = validateModulesOption;
const validateUseBuiltInsOption = (builtInsOpt = false)=>{
    v.invariant(_options.UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === _options.UseBuiltInsOption.false, `The 'useBuiltIns' option must be either
    'false' (default) to indicate no polyfill,
    '"entry"' to indicate replacing the entry polyfill, or
    '"usage"' to import only used polyfills per file`);
    return builtInsOpt;
};
exports.validateUseBuiltInsOption = validateUseBuiltInsOption;
function normalizeCoreJSOption(corejs, useBuiltIns) {
    let proposals = false;
    let rawVersion;
    if (useBuiltIns && corejs === undefined) {
        {
            rawVersion = 2;
            console.warn("\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a " + `core-js version. Currently, we assume version 2.x when no version ` + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n\n" + "More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\n" + "More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs");
        }
    } else if (typeof corejs === "object" && corejs !== null) {
        rawVersion = corejs.version;
        proposals = Boolean(corejs.proposals);
    } else {
        rawVersion = corejs;
    }
    const version = rawVersion ? _semver.coerce(String(rawVersion)) : false;
    if (version) {
        if (useBuiltIns) {
            {
                if (version.major < 2 || version.major > 3) {
                    throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
                }
            }
        } else {
            console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
        }
    }
    return {
        version,
        proposals
    };
}
function normalizeOptions(opts) {
    v.validateTopLevelOptions(opts, _options.TopLevelOptions);
    const useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
    const corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
    const include = expandIncludesAndExcludes(opts.include, _options.TopLevelOptions.include, !!corejs.version && corejs.version.major);
    const exclude = expandIncludesAndExcludes(opts.exclude, _options.TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
    checkDuplicateIncludeExcludes(include, exclude);
    {
        v.validateBooleanOption("loose", opts.loose);
        v.validateBooleanOption("spec", opts.spec);
    }
    return {
        bugfixes: v.validateBooleanOption(_options.TopLevelOptions.bugfixes, opts.bugfixes, false),
        configPath: v.validateStringOption(_options.TopLevelOptions.configPath, opts.configPath, process.cwd()),
        corejs,
        debug: v.validateBooleanOption(_options.TopLevelOptions.debug, opts.debug, false),
        include,
        exclude,
        forceAllTransforms: v.validateBooleanOption(_options.TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
        ignoreBrowserslistConfig: v.validateBooleanOption(_options.TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false),
        modules: validateModulesOption(opts.modules),
        shippedProposals: v.validateBooleanOption(_options.TopLevelOptions.shippedProposals, opts.shippedProposals, false),
        targets: normalizeTargets(opts.targets),
        useBuiltIns: useBuiltIns,
        browserslistEnv: v.validateStringOption(_options.TopLevelOptions.browserslistEnv, opts.browserslistEnv)
    };
} //# sourceMappingURL=normalize-options.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/shipped-proposals.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.proposalSyntaxPlugins = exports.proposalPlugins = exports.pluginSyntaxMap = void 0;
const proposalPlugins = exports.proposalPlugins = new Set([]);
const proposalSyntaxPlugins = exports.proposalSyntaxPlugins = [
    "syntax-import-assertions",
    "syntax-import-attributes"
];
const pluginSyntaxObject = {
    "transform-async-generator-functions": "syntax-async-generators",
    "transform-class-properties": "syntax-class-properties",
    "transform-class-static-block": "syntax-class-static-block",
    "transform-export-namespace-from": "syntax-export-namespace-from",
    "transform-json-strings": "syntax-json-strings",
    "transform-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
    "transform-numeric-separator": "syntax-numeric-separator",
    "transform-object-rest-spread": "syntax-object-rest-spread",
    "transform-optional-catch-binding": "syntax-optional-catch-binding",
    "transform-optional-chaining": "syntax-optional-chaining",
    "transform-private-methods": "syntax-class-properties",
    "transform-private-property-in-object": "syntax-private-property-in-object",
    "transform-unicode-property-regex": null
};
const pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function(key) {
    return [
        key,
        pluginSyntaxObject[key]
    ];
});
const pluginSyntaxMap = exports.pluginSyntaxMap = new Map(pluginSyntaxEntries); //# sourceMappingURL=shipped-proposals.js.map
}}),
"[project]/node_modules/@babel/preset-env/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
exports.isPluginRequired = isPluginRequired;
exports.transformIncludesAndExcludes = void 0;
var _semver = __turbopack_require__("[project]/node_modules/@babel/preset-env/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _debug = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/debug.js [app-ssr] (ecmascript)");
var _filterItems = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/filter-items.js [app-ssr] (ecmascript)");
var _moduleTransformations = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/module-transformations.js [app-ssr] (ecmascript)");
var _normalizeOptions = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/normalize-options.js [app-ssr] (ecmascript)");
var _shippedProposals = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/shipped-proposals.js [app-ssr] (ecmascript)");
var _pluginsCompatData = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/plugins-compat-data.js [app-ssr] (ecmascript)");
var _babelPluginPolyfillCorejs = __turbopack_require__("[project]/node_modules/babel-plugin-polyfill-corejs3/lib/index.js [app-ssr] (ecmascript)");
var _babel7Plugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/polyfills/babel-7-plugins.cjs [app-ssr] (ecmascript)");
var _helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
var _availablePlugins = __turbopack_require__("[project]/node_modules/@babel/preset-env/lib/available-plugins.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
const pluginCoreJS3 = _babelPluginPolyfillCorejs.default || _babelPluginPolyfillCorejs;
function isPluginRequired(targets, support) {
    return (0, _helperCompilationTargets.isRequired)("fake-name", targets, {
        compatData: {
            "fake-name": support
        }
    });
}
function filterStageFromList(list, stageList) {
    return Object.keys(list).reduce((result, item)=>{
        if (!stageList.has(item)) {
            result[item] = list[item];
        }
        return result;
    }, {});
}
const pluginLists = {
    withProposals: {
        withoutBugfixes: _pluginsCompatData.plugins,
        withBugfixes: Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes)
    },
    withoutProposals: {
        withoutBugfixes: filterStageFromList(_pluginsCompatData.plugins, _shippedProposals.proposalPlugins),
        withBugfixes: filterStageFromList(Object.assign({}, _pluginsCompatData.plugins, _pluginsCompatData.pluginsBugfixes), _shippedProposals.proposalPlugins)
    }
};
function getPluginList(proposals, bugfixes) {
    if (proposals) {
        if (bugfixes) return pluginLists.withProposals.withBugfixes;
        else return pluginLists.withProposals.withoutBugfixes;
    } else {
        if (bugfixes) return pluginLists.withoutProposals.withBugfixes;
        else return pluginLists.withoutProposals.withoutBugfixes;
    }
}
const getPlugin = (pluginName)=>{
    const plugin = _availablePlugins.default[pluginName]();
    if (!plugin) {
        throw new Error(`Could not find plugin "${pluginName}". Ensure there is an entry in ./available-plugins.js for it.`);
    }
    return plugin;
};
const transformIncludesAndExcludes = (opts)=>{
    return opts.reduce((result, opt)=>{
        const target = /^(?:es|es6|es7|esnext|web)\./.test(opt) ? "builtIns" : "plugins";
        result[target].add(opt);
        return result;
    }, {
        all: opts,
        plugins: new Set(),
        builtIns: new Set()
    });
};
exports.transformIncludesAndExcludes = transformIncludesAndExcludes;
function getSpecialModulesPluginNames(modules, shouldTransformDynamicImport, babelVersion) {
    const modulesPluginNames = [];
    if (modules) {
        modulesPluginNames.push(_moduleTransformations.default[modules]);
    }
    if (shouldTransformDynamicImport) {
        if (modules && modules !== "umd") {
            modulesPluginNames.push("transform-dynamic-import");
        } else {
            console.warn("Dynamic import can only be transformed when transforming ES" + " modules to AMD, CommonJS or SystemJS.");
        }
    }
    if (babelVersion[0] !== "8") {
        if (!shouldTransformDynamicImport) {
            modulesPluginNames.push("syntax-dynamic-import");
        }
        modulesPluginNames.push("syntax-top-level-await");
        modulesPluginNames.push("syntax-import-meta");
    }
    return modulesPluginNames;
}
const getCoreJSOptions = ({ useBuiltIns, corejs, polyfillTargets, include, exclude, proposals, shippedProposals, debug })=>({
        method: `${useBuiltIns}-global`,
        version: corejs ? corejs.toString() : undefined,
        targets: polyfillTargets,
        include,
        exclude,
        proposals,
        shippedProposals,
        debug,
        "#__secret_key__@babel/preset-env__compatibility": {
            noRuntimeName: true
        }
    });
{
    var getPolyfillPlugins = ({ useBuiltIns, corejs, polyfillTargets, include, exclude, proposals, shippedProposals, regenerator, debug })=>{
        const polyfillPlugins = [];
        if (useBuiltIns === "usage" || useBuiltIns === "entry") {
            const pluginOptions = getCoreJSOptions({
                useBuiltIns,
                corejs,
                polyfillTargets,
                include,
                exclude,
                proposals,
                shippedProposals,
                debug
            });
            if (corejs) {
                {
                    if (useBuiltIns === "usage") {
                        if (corejs.major === 2) {
                            polyfillPlugins.push([
                                _babel7Plugins.pluginCoreJS2,
                                pluginOptions
                            ], [
                                _babel7Plugins.legacyBabelPolyfillPlugin,
                                {
                                    usage: true
                                }
                            ]);
                        } else {
                            polyfillPlugins.push([
                                pluginCoreJS3,
                                pluginOptions
                            ], [
                                _babel7Plugins.legacyBabelPolyfillPlugin,
                                {
                                    usage: true,
                                    deprecated: true
                                }
                            ]);
                        }
                        if (regenerator) {
                            polyfillPlugins.push([
                                _babel7Plugins.pluginRegenerator,
                                {
                                    method: "usage-global",
                                    debug
                                }
                            ]);
                        }
                    } else {
                        if (corejs.major === 2) {
                            polyfillPlugins.push([
                                _babel7Plugins.legacyBabelPolyfillPlugin,
                                {
                                    regenerator
                                }
                            ], [
                                _babel7Plugins.pluginCoreJS2,
                                pluginOptions
                            ]);
                        } else {
                            polyfillPlugins.push([
                                pluginCoreJS3,
                                pluginOptions
                            ], [
                                _babel7Plugins.legacyBabelPolyfillPlugin,
                                {
                                    deprecated: true
                                }
                            ]);
                            if (!regenerator) {
                                polyfillPlugins.push([
                                    _babel7Plugins.removeRegeneratorEntryPlugin,
                                    pluginOptions
                                ]);
                            }
                        }
                    }
                }
            }
        }
        return polyfillPlugins;
    };
    {
        exports.getPolyfillPlugins = getPolyfillPlugins;
    }
}function getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv, api) {
    if (optionsTargets != null && optionsTargets.esmodules && optionsTargets.browsers) {
        console.warn(`
@babel/preset-env: esmodules and browsers targets have been specified together.
\`browsers\` target, \`${optionsTargets.browsers.toString()}\` will be ignored.
`);
    }
    return (0, _helperCompilationTargets.default)(optionsTargets, {
        ignoreBrowserslistConfig,
        configPath,
        browserslistEnv,
        onBrowserslistConfigFound (config) {
            api.addExternalDependency(config);
        }
    });
}
function supportsStaticESM(caller) {
    return !!(caller != null && caller.supportsStaticESM);
}
function supportsDynamicImport(caller) {
    return !!(caller != null && caller.supportsDynamicImport);
}
function supportsExportNamespaceFrom(caller) {
    return !!(caller != null && caller.supportsExportNamespaceFrom);
}
var _default = exports.default = (0, _helperPluginUtils.declarePreset)((api, opts)=>{
    api.assertVersion(7);
    const babelTargets = api.targets();
    ;
    const { bugfixes, configPath, debug, exclude: optionsExclude, forceAllTransforms, ignoreBrowserslistConfig, include: optionsInclude, modules: optionsModules, shippedProposals, targets: optionsTargets, useBuiltIns, corejs: { version: corejs, proposals }, browserslistEnv } = (0, _normalizeOptions.default)(opts);
    {
        var { loose, spec = false } = opts;
    }
    let targets = babelTargets;
    if (_semver.lt(api.version, "7.13.0") || opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig) {
        {
            var hasUglifyTarget = false;
            if (optionsTargets != null && optionsTargets.uglify) {
                hasUglifyTarget = true;
                delete optionsTargets.uglify;
                console.warn(`
The uglify target has been deprecated. Set the top level
option \`forceAllTransforms: true\` instead.
`);
            }
        }
        targets = getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv, api);
    }
    const transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
    const include = transformIncludesAndExcludes(optionsInclude);
    const exclude = transformIncludesAndExcludes(optionsExclude);
    const compatData = getPluginList(shippedProposals, bugfixes);
    const modules = optionsModules === "auto" ? api.caller(supportsStaticESM) ? false : "commonjs" : optionsModules;
    const shouldTransformDynamicImport = optionsModules === "auto" ? !api.caller(supportsDynamicImport) : !!modules;
    if (!exclude.plugins.has("transform-export-namespace-from") && (optionsModules === "auto" ? !api.caller(supportsExportNamespaceFrom) : !!modules)) {
        include.plugins.add("transform-export-namespace-from");
    }
    const pluginNames = (0, _helperCompilationTargets.filterItems)(compatData, include.plugins, exclude.plugins, transformTargets, getSpecialModulesPluginNames(modules, shouldTransformDynamicImport, api.version), !loose ? undefined : [
        "transform-typeof-symbol"
    ], _shippedProposals.pluginSyntaxMap);
    if (shippedProposals) {
        (0, _filterItems.addProposalSyntaxPlugins)(pluginNames, _shippedProposals.proposalSyntaxPlugins);
    }
    (0, _filterItems.removeUnsupportedItems)(pluginNames, api.version);
    (0, _filterItems.removeUnnecessaryItems)(pluginNames, _pluginsCompatData.overlappingPlugins);
    const polyfillPlugins = getPolyfillPlugins({
        useBuiltIns,
        corejs,
        polyfillTargets: targets,
        include: include.builtIns,
        exclude: exclude.builtIns,
        proposals,
        shippedProposals,
        regenerator: pluginNames.has("transform-regenerator"),
        debug
    });
    const pluginUseBuiltIns = useBuiltIns !== false;
    const plugins = Array.from(pluginNames).map((pluginName)=>{
        if (pluginName === "transform-class-properties" || pluginName === "transform-private-methods" || pluginName === "transform-private-property-in-object") {
            return [
                getPlugin(pluginName),
                {
                    loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
                }
            ];
        }
        if (pluginName === "syntax-import-attributes") {
            return [
                getPlugin(pluginName),
                {
                    deprecatedAssertSyntax: true
                }
            ];
        }
        return [
            getPlugin(pluginName),
            {
                spec,
                loose,
                useBuiltIns: pluginUseBuiltIns
            }
        ];
    }).concat(polyfillPlugins);
    if (debug) {
        console.log("@babel/preset-env: `DEBUG` option");
        console.log("\nUsing targets:");
        console.log(JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2));
        console.log(`\nUsing modules transform: ${optionsModules.toString()}`);
        console.log("\nUsing plugins:");
        pluginNames.forEach((pluginName)=>{
            (0, _debug.logPlugin)(pluginName, targets, compatData);
        });
        if (!useBuiltIns) {
            console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
        }
    }
    return {
        plugins
    };
});
{
    exports.getModulesPluginNames = ({ modules, transformations, shouldTransformESM, shouldTransformDynamicImport, shouldTransformExportNamespaceFrom })=>{
        const modulesPluginNames = [];
        if (modules !== false && transformations[modules]) {
            if (shouldTransformESM) {
                modulesPluginNames.push(transformations[modules]);
            }
            if (shouldTransformDynamicImport) {
                if (shouldTransformESM && modules !== "umd") {
                    modulesPluginNames.push("transform-dynamic-import");
                } else {
                    console.warn("Dynamic import can only be transformed when transforming ES" + " modules to AMD, CommonJS or SystemJS.");
                }
            }
        }
        if (shouldTransformExportNamespaceFrom) {
            modulesPluginNames.push("transform-export-namespace-from");
        }
        if (!shouldTransformDynamicImport) {
            modulesPluginNames.push("syntax-dynamic-import");
        }
        if (!shouldTransformExportNamespaceFrom) {
            modulesPluginNames.push("syntax-export-namespace-from");
        }
        modulesPluginNames.push("syntax-top-level-await");
        modulesPluginNames.push("syntax-import-meta");
        return modulesPluginNames;
    };
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    const isPlugin = (plugin, name)=>name === "plugin" || Array.isArray(plugin) && plugin[0] === "plugin";
    const options = (plugin)=>Array.isArray(plugin) && plugin.length > 1 ? plugin[1] : {};
    return {
        name: "syntax-import-assertions",
        manipulateOptions (opts, { plugins }) {
            for(let i = 0; i < plugins.length; i++){
                const plugin = plugins[i];
                if (isPlugin(plugin, "deprecatedImportAssert")) return;
                if (isPlugin(plugin, "importAttributes")) {
                    plugins.splice(i, 1, "deprecatedImportAssert", [
                        "importAttributes",
                        Object.assign({}, options(plugin), {
                            deprecatedAssertSyntax: true
                        })
                    ]);
                    return;
                }
            }
            plugins.push("importAssertions");
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-syntax-import-attributes/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, { deprecatedAssertSyntax })=>{
    api.assertVersion("^7.22.0 || >8.0.0-alpha <8.0.0-beta");
    if (deprecatedAssertSyntax != null && typeof deprecatedAssertSyntax !== "boolean") {
        throw new Error("'deprecatedAssertSyntax' must be a boolean, if specified.");
    }
    return {
        name: "syntax-import-attributes",
        manipulateOptions ({ parserOpts, generatorOpts }) {
            var _generatorOpts$import;
            (_generatorOpts$import = generatorOpts.importAttributesKeyword) != null ? _generatorOpts$import : generatorOpts.importAttributesKeyword = "with";
            const importAssertionsPluginIndex = parserOpts.plugins.indexOf("importAssertions");
            if (importAssertionsPluginIndex !== -1) {
                parserOpts.plugins.splice(importAssertionsPluginIndex, 1);
                deprecatedAssertSyntax = true;
            }
            if (deprecatedAssertSyntax) {
                parserOpts.plugins.push("deprecatedImportAssert", [
                    "importAttributes",
                    {
                        deprecatedAssertSyntax: true
                    }
                ]);
            } else {
                parserOpts.plugins.push("importAttributes");
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-wrap-function/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = wrapFunction;
var _template = __turbopack_require__("[project]/node_modules/@babel/template/lib/index.js [app-ssr] (ecmascript)");
var _t = __turbopack_require__("[project]/node_modules/@babel/types/lib/index.js [app-ssr] (ecmascript)");
const { blockStatement, callExpression, functionExpression, isAssignmentPattern, isFunctionDeclaration, isRestElement, returnStatement, isCallExpression } = _t;
const buildAnonymousExpressionWrapper = _template.default.expression(`
  (function () {
    var REF = FUNCTION;
    return function NAME(PARAMS) {
      return REF.apply(this, arguments);
    };
  })()
`);
const buildNamedExpressionWrapper = _template.default.expression(`
  (function () {
    var REF = FUNCTION;
    function NAME(PARAMS) {
      return REF.apply(this, arguments);
    }
    return NAME;
  })()
`);
const buildDeclarationWrapper = _template.default.statements(`
  function NAME(PARAMS) { return REF.apply(this, arguments); }
  function REF() {
    REF = FUNCTION;
    return REF.apply(this, arguments);
  }
`);
function classOrObjectMethod(path, callId) {
    const node = path.node;
    const body = node.body;
    const container = functionExpression(null, [], blockStatement(body.body), true);
    body.body = [
        returnStatement(callExpression(callExpression(callId, [
            container
        ]), []))
    ];
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
}
function plainFunction(inPath, callId, noNewArrows, ignoreFunctionLength, hadName) {
    let path = inPath;
    let node;
    let functionId = null;
    const nodeParams = inPath.node.params;
    if (path.isArrowFunctionExpression()) {
        {
            var _path$arrowFunctionTo;
            path = (_path$arrowFunctionTo = path.arrowFunctionToExpression({
                noNewArrows
            })) != null ? _path$arrowFunctionTo : path;
        }
        node = path.node;
    } else {
        node = path.node;
    }
    const isDeclaration = isFunctionDeclaration(node);
    let built = node;
    if (!isCallExpression(node)) {
        functionId = node.id;
        node.id = null;
        node.type = "FunctionExpression";
        built = callExpression(callId, [
            node
        ]);
    }
    const params = [];
    for (const param of nodeParams){
        if (isAssignmentPattern(param) || isRestElement(param)) {
            break;
        }
        params.push(path.scope.generateUidIdentifier("x"));
    }
    const wrapperArgs = {
        NAME: functionId || null,
        REF: path.scope.generateUidIdentifier(hadName ? functionId.name : "ref"),
        FUNCTION: built,
        PARAMS: params
    };
    if (isDeclaration) {
        const container = buildDeclarationWrapper(wrapperArgs);
        path.replaceWith(container[0]);
        path.insertAfter(container[1]);
    } else {
        let container;
        if (hadName) {
            container = buildNamedExpressionWrapper(wrapperArgs);
        } else {
            container = buildAnonymousExpressionWrapper(wrapperArgs);
        }
        if (functionId || !ignoreFunctionLength && params.length) {
            path.replaceWith(container);
        } else {
            path.replaceWith(built);
        }
    }
}
function wrapFunction(path, callId, noNewArrows = true, ignoreFunctionLength = false) {
    if (path.isMethod()) {
        classOrObjectMethod(path, callId);
    } else {
        const hadName = "id" in path.node && !!path.node.id;
        {
            var _path, _path$ensureFunctionN;
            (_path$ensureFunctionN = (_path = path).ensureFunctionName) != null ? _path$ensureFunctionN : _path.ensureFunctionName = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.ensureFunctionName;
        }
        path = path.ensureFunctionName(false);
        plainFunction(path, callId, noNewArrows, ignoreFunctionLength, hadName);
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-remap-async-to-generator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _helperWrapFunction = __turbopack_require__("[project]/node_modules/@babel/helper-wrap-function/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
const { callExpression, cloneNode, isIdentifier, isThisExpression, yieldExpression } = _core.types;
const awaitVisitor = _traverse.visitors.environmentVisitor({
    ArrowFunctionExpression (path) {
        path.skip();
    },
    AwaitExpression (path, { wrapAwait }) {
        const argument = path.get("argument");
        path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [
            argument.node
        ]) : argument.node));
    }
});
function _default(path, helpers, noNewArrows, ignoreFunctionLength) {
    path.traverse(awaitVisitor, {
        wrapAwait: helpers.wrapAwait
    });
    const isIIFE = checkIsIIFE(path);
    path.node.async = false;
    path.node.generator = true;
    (0, _helperWrapFunction.default)(path, cloneNode(helpers.wrapAsync), noNewArrows, ignoreFunctionLength);
    const isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();
    if (!isProperty && !isIIFE && path.isExpression()) {
        (0, _helperAnnotateAsPure.default)(path);
    }
    function checkIsIIFE(path) {
        if (path.parentPath.isCallExpression({
            callee: path.node
        })) {
            return true;
        }
        const { parentPath } = path;
        if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
            name: "bind"
        })) {
            const { parentPath: bindCall } = parentPath;
            return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
                callee: bindCall.node
            });
        }
        return false;
    }
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-async-generator-functions/lib/for-await.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _default;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const buildForAwait = (0, _core.template)(`
  async function wrapper() {
    var ITERATOR_ABRUPT_COMPLETION = false;
    var ITERATOR_HAD_ERROR_KEY = false;
    var ITERATOR_ERROR_KEY;
    try {
      for (
        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;
        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;
        ITERATOR_ABRUPT_COMPLETION = false
      ) {
      }
    } catch (err) {
      ITERATOR_HAD_ERROR_KEY = true;
      ITERATOR_ERROR_KEY = err;
    } finally {
      try {
        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {
          await ITERATOR_KEY.return();
        }
      } finally {
        if (ITERATOR_HAD_ERROR_KEY) {
          throw ITERATOR_ERROR_KEY;
        }
      }
    }
  }
`);
function _default(path, { getAsyncIterator }) {
    const { node, scope, parent } = path;
    const stepKey = scope.generateUidIdentifier("step");
    const stepValue = _core.types.memberExpression(stepKey, _core.types.identifier("value"));
    const left = node.left;
    let declar;
    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
        declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
    } else if (_core.types.isVariableDeclaration(left)) {
        declar = _core.types.variableDeclaration(left.kind, [
            _core.types.variableDeclarator(left.declarations[0].id, stepValue)
        ]);
    }
    let template = buildForAwait({
        ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
        ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier("iteratorAbruptCompletion"),
        ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
        ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
        GET_ITERATOR: getAsyncIterator,
        OBJECT: node.right,
        STEP_KEY: _core.types.cloneNode(stepKey)
    });
    template = template.body.body;
    const isLabeledParent = _core.types.isLabeledStatement(parent);
    const tryBody = template[3].block.body;
    const loop = tryBody[0];
    if (isLabeledParent) {
        tryBody[0] = _core.types.labeledStatement(parent.label, loop);
    }
    return {
        replaceParent: isLabeledParent,
        node: template,
        declar,
        loop
    };
} //# sourceMappingURL=for-await.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-async-generator-functions/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperRemapAsyncToGenerator = __turbopack_require__("[project]/node_modules/@babel/helper-remap-async-to-generator/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
var _forAwait = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-async-generator-functions/lib/for-await.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const yieldStarVisitor = _traverse.visitors.environmentVisitor({
        ArrowFunctionExpression (path) {
            path.skip();
        },
        YieldExpression ({ node }, state) {
            if (!node.delegate) return;
            const asyncIter = _core.types.callExpression(state.addHelper("asyncIterator"), [
                node.argument
            ]);
            node.argument = _core.types.callExpression(state.addHelper("asyncGeneratorDelegate"), [
                asyncIter,
                state.addHelper("awaitAsyncGenerator")
            ]);
        }
    });
    const forAwaitVisitor = _traverse.visitors.environmentVisitor({
        ArrowFunctionExpression (path) {
            path.skip();
        },
        ForOfStatement (path, { file }) {
            const { node } = path;
            if (!node.await) return;
            const build = (0, _forAwait.default)(path, {
                getAsyncIterator: file.addHelper("asyncIterator")
            });
            const { declar, loop } = build;
            const block = loop.body;
            path.ensureBlock();
            if (declar) {
                block.body.push(declar);
                if (path.node.body.body.length) {
                    block.body.push(_core.types.blockStatement(path.node.body.body));
                }
            } else {
                block.body.push(...path.node.body.body);
            }
            _core.types.inherits(loop, node);
            _core.types.inherits(loop.body, node.body);
            const p = build.replaceParent ? path.parentPath : path;
            p.replaceWithMultiple(build.node);
            p.scope.parent.crawl();
        }
    });
    const visitor = {
        Function (path, state) {
            if (!path.node.async) return;
            path.traverse(forAwaitVisitor, state);
            if (!path.node.generator) return;
            path.traverse(yieldStarVisitor, state);
            path.setData("@babel/plugin-transform-async-generator-functions/async_generator_function", true);
            (0, _helperRemapAsyncToGenerator.default)(path, {
                wrapAsync: state.addHelper("wrapAsyncGenerator"),
                wrapAwait: state.addHelper("awaitAsyncGenerator")
            });
        }
    };
    return {
        name: "transform-async-generator-functions",
        manipulateOptions: (_, parser)=>parser.plugins.push("asyncGenerators"),
        visitor: {
            Program (path, state) {
                path.traverse(visitor, state);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-async-to-generator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperRemapAsyncToGenerator = __turbopack_require__("[project]/node_modules/@babel/helper-remap-async-to-generator/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleImports = __turbopack_require__("[project]/node_modules/@babel/helper-module-imports/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const { method, module } = options;
    const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : true;
    const ignoreFunctionLength = (_api$assumption2 = api.assumption("ignoreFunctionLength")) != null ? _api$assumption2 : false;
    if (method && module) {
        return {
            name: "transform-async-to-generator",
            visitor: {
                Function (path, state) {
                    if (!path.node.async || path.node.generator) return;
                    let wrapAsync = state.methodWrapper;
                    if (wrapAsync) {
                        wrapAsync = _core.types.cloneNode(wrapAsync);
                    } else {
                        wrapAsync = state.methodWrapper = (0, _helperModuleImports.addNamed)(path, method, module);
                    }
                    (0, _helperRemapAsyncToGenerator.default)(path, {
                        wrapAsync
                    }, noNewArrows, ignoreFunctionLength);
                }
            }
        };
    }
    return {
        name: "transform-async-to-generator",
        visitor: {
            Function (path, state) {
                if (!path.node.async || path.node.generator) return;
                (0, _helperRemapAsyncToGenerator.default)(path, {
                    wrapAsync: state.addHelper("asyncToGenerator")
                }, noNewArrows, ignoreFunctionLength);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-arrow-functions/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption;
    api.assertVersion(7);
    const noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
    return {
        name: "transform-arrow-functions",
        visitor: {
            ArrowFunctionExpression (path) {
                if (!path.isArrowFunctionExpression()) return;
                {
                    path.arrowFunctionToExpression({
                        allowInsertArrow: false,
                        noNewArrows,
                        specCompliant: !noNewArrows
                    });
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-block-scoped-functions/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    function transformStatementList(parentPath, paths) {
        const isInStrictMode = parentPath.isInStrictMode();
        for (const path of paths){
            if (!path.isFunctionDeclaration()) continue;
            ;
            const func = path.node;
            const declar = _core.types.variableDeclaration("let", [
                _core.types.variableDeclarator(func.id, _core.types.toExpression(func))
            ]);
            declar._blockHoist = 2;
            func.id = null;
            path.replaceWith(declar);
        }
    }
    return {
        name: "transform-block-scoped-functions",
        visitor: {
            BlockStatement (path) {
                const { node, parent } = path;
                if (_core.types.isFunction(parent, {
                    body: node
                }) || _core.types.isExportDeclaration(parent)) {
                    return;
                }
                transformStatementList(path, path.get("body"));
            },
            SwitchCase (path) {
                transformStatementList(path, path.get("consequent"));
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-block-scoping/lib/loop.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLoopBodyBindings = getLoopBodyBindings;
exports.getUsageInBody = getUsageInBody;
exports.isVarInLoopHead = isVarInLoopHead;
exports.wrapLoopBody = wrapLoopBody;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const collectLoopBodyBindingsVisitor = {
    "Expression|Declaration|Loop" (path) {
        path.skip();
    },
    Scope (path, state) {
        if (path.isFunctionParent()) path.skip();
        const { bindings } = path.scope;
        for (const name of Object.keys(bindings)){
            const binding = bindings[name];
            if (binding.kind === "let" || binding.kind === "const" || binding.kind === "hoisted") {
                state.blockScoped.push(binding);
            }
        }
    }
};
function getLoopBodyBindings(loopPath) {
    const state = {
        blockScoped: []
    };
    loopPath.traverse(collectLoopBodyBindingsVisitor, state);
    return state.blockScoped;
}
function getUsageInBody(binding, loopPath) {
    const seen = new WeakSet();
    let capturedInClosure = false;
    const constantViolations = filterMap(binding.constantViolations, (path)=>{
        const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
        if (!inBody) return null;
        capturedInClosure || (capturedInClosure = inClosure);
        const id = path.isUpdateExpression() ? path.get("argument") : path.isAssignmentExpression() ? path.get("left") : null;
        if (id) seen.add(id.node);
        return id;
    });
    const references = filterMap(binding.referencePaths, (path)=>{
        if (seen.has(path.node)) return null;
        const { inBody, inClosure } = relativeLoopLocation(path, loopPath);
        if (!inBody) return null;
        capturedInClosure || (capturedInClosure = inClosure);
        return path;
    });
    return {
        capturedInClosure,
        hasConstantViolations: constantViolations.length > 0,
        usages: references.concat(constantViolations)
    };
}
function relativeLoopLocation(path, loopPath) {
    const bodyPath = loopPath.get("body");
    let inClosure = false;
    for(let currPath = path; currPath; currPath = currPath.parentPath){
        if (currPath.isFunction() || currPath.isClass() || currPath.isMethod()) {
            inClosure = true;
        }
        if (currPath === bodyPath) {
            return {
                inBody: true,
                inClosure
            };
        } else if (currPath === loopPath) {
            return {
                inBody: false,
                inClosure
            };
        }
    }
    throw new Error("Internal Babel error: path is not in loop. Please report this as a bug.");
}
const collectCompletionsAndVarsVisitor = {
    Function (path) {
        path.skip();
    },
    LabeledStatement: {
        enter ({ node }, state) {
            state.labelsStack.push(node.label.name);
        },
        exit ({ node }, state) {
            const popped = state.labelsStack.pop();
            if (popped !== node.label.name) {
                throw new Error("Assertion failure. Please report this bug to Babel.");
            }
        }
    },
    Loop: {
        enter (_, state) {
            state.labellessContinueTargets++;
            state.labellessBreakTargets++;
        },
        exit (_, state) {
            state.labellessContinueTargets--;
            state.labellessBreakTargets--;
        }
    },
    SwitchStatement: {
        enter (_, state) {
            state.labellessBreakTargets++;
        },
        exit (_, state) {
            state.labellessBreakTargets--;
        }
    },
    "BreakStatement|ContinueStatement" (path, state) {
        const { label } = path.node;
        if (label) {
            if (state.labelsStack.includes(label.name)) return;
        } else if (path.isBreakStatement() ? state.labellessBreakTargets > 0 : state.labellessContinueTargets > 0) {
            return;
        }
        state.breaksContinues.push(path);
    },
    ReturnStatement (path, state) {
        state.returns.push(path);
    },
    VariableDeclaration (path, state) {
        if (path.parent === state.loopNode && isVarInLoopHead(path)) return;
        if (path.node.kind === "var") state.vars.push(path);
    }
};
function wrapLoopBody(loopPath, captured, updatedBindingsUsages) {
    const loopNode = loopPath.node;
    const state = {
        breaksContinues: [],
        returns: [],
        labelsStack: [],
        labellessBreakTargets: 0,
        labellessContinueTargets: 0,
        vars: [],
        loopNode
    };
    loopPath.traverse(collectCompletionsAndVarsVisitor, state);
    const callArgs = [];
    const closureParams = [];
    const updater = [];
    for (const [name, updatedUsage] of updatedBindingsUsages){
        callArgs.push(_core.types.identifier(name));
        const innerName = loopPath.scope.generateUid(name);
        closureParams.push(_core.types.identifier(innerName));
        updater.push(_core.types.assignmentExpression("=", _core.types.identifier(name), _core.types.identifier(innerName)));
        for (const path of updatedUsage)path.replaceWith(_core.types.identifier(innerName));
    }
    for (const name of captured){
        if (updatedBindingsUsages.has(name)) continue;
        callArgs.push(_core.types.identifier(name));
        closureParams.push(_core.types.identifier(name));
    }
    const id = loopPath.scope.generateUid("loop");
    const fn = _core.types.functionExpression(null, closureParams, _core.types.toBlock(loopNode.body));
    let call = _core.types.callExpression(_core.types.identifier(id), callArgs);
    const fnParent = loopPath.findParent((p)=>p.isFunction());
    if (fnParent) {
        const { async, generator } = fnParent.node;
        fn.async = async;
        fn.generator = generator;
        if (generator) call = _core.types.yieldExpression(call, true);
        else if (async) call = _core.types.awaitExpression(call);
    }
    const updaterNode = updater.length > 0 ? _core.types.expressionStatement(_core.types.sequenceExpression(updater)) : null;
    if (updaterNode) fn.body.body.push(updaterNode);
    const [varPath] = loopPath.insertBefore(_core.types.variableDeclaration("var", [
        _core.types.variableDeclarator(_core.types.identifier(id), fn)
    ]));
    const bodyStmts = [];
    const varNames = [];
    for (const varPath of state.vars){
        const assign = [];
        for (const decl of varPath.node.declarations){
            varNames.push(...Object.keys(_core.types.getBindingIdentifiers(decl.id)));
            if (decl.init) {
                assign.push(_core.types.assignmentExpression("=", decl.id, decl.init));
            } else if (_core.types.isForXStatement(varPath.parent, {
                left: varPath.node
            })) {
                assign.push(decl.id);
            }
        }
        if (assign.length > 0) {
            const replacement = assign.length === 1 ? assign[0] : _core.types.sequenceExpression(assign);
            varPath.replaceWith(replacement);
        } else {
            varPath.remove();
        }
    }
    if (varNames.length) {
        varPath.pushContainer("declarations", varNames.map((name)=>_core.types.variableDeclarator(_core.types.identifier(name))));
    }
    const labelNum = state.breaksContinues.length;
    const returnNum = state.returns.length;
    if (labelNum + returnNum === 0) {
        bodyStmts.push(_core.types.expressionStatement(call));
    } else if (labelNum === 1 && returnNum === 0) {
        for (const path of state.breaksContinues){
            const { node } = path;
            const { type, label } = node;
            let name = type === "BreakStatement" ? "break" : "continue";
            if (label) name += " " + label.name;
            path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(1)), "trailing", " " + name, true));
            if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
            bodyStmts.push(_core.template.statement.ast`
        if (${call}) ${node}
      `);
        }
    } else {
        const completionId = loopPath.scope.generateUid("ret");
        if (varPath.isVariableDeclaration()) {
            varPath.pushContainer("declarations", [
                _core.types.variableDeclarator(_core.types.identifier(completionId))
            ]);
            bodyStmts.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(completionId), call)));
        } else {
            bodyStmts.push(_core.types.variableDeclaration("var", [
                _core.types.variableDeclarator(_core.types.identifier(completionId), call)
            ]));
        }
        const injected = [];
        for (const path of state.breaksContinues){
            const { node } = path;
            const { type, label } = node;
            let name = type === "BreakStatement" ? "break" : "continue";
            if (label) name += " " + label.name;
            let i = injected.indexOf(name);
            const hasInjected = i !== -1;
            if (!hasInjected) {
                injected.push(name);
                i = injected.length - 1;
            }
            path.replaceWith(_core.types.addComment(_core.types.returnStatement(_core.types.numericLiteral(i)), "trailing", " " + name, true));
            if (updaterNode) path.insertBefore(_core.types.cloneNode(updaterNode));
            if (hasInjected) continue;
            bodyStmts.push(_core.template.statement.ast`
        if (${_core.types.identifier(completionId)} === ${_core.types.numericLiteral(i)}) ${node}
      `);
        }
        if (returnNum) {
            for (const path of state.returns){
                const arg = path.node.argument || path.scope.buildUndefinedNode();
                path.replaceWith(_core.template.statement.ast`
          return { v: ${arg} };
        `);
            }
            bodyStmts.push(_core.template.statement.ast`
          if (${_core.types.identifier(completionId)}) return ${_core.types.identifier(completionId)}.v;
        `);
        }
    }
    loopNode.body = _core.types.blockStatement(bodyStmts);
    return varPath;
}
function isVarInLoopHead(path) {
    if (_core.types.isForStatement(path.parent)) return path.key === "init";
    if (_core.types.isForXStatement(path.parent)) return path.key === "left";
    return false;
}
function filterMap(list, fn) {
    const result = [];
    for (const item of list){
        const mapped = fn(item);
        if (mapped) result.push(mapped);
    }
    return result;
} //# sourceMappingURL=loop.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-block-scoping/lib/validation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateUsage = validateUsage;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function validateUsage(path, state, tdzEnabled) {
    const dynamicTDZNames = [];
    for (const name of Object.keys(path.getBindingIdentifiers())){
        const binding = path.scope.getBinding(name);
        if (!binding) continue;
        if (tdzEnabled) {
            if (injectTDZChecks(binding, state)) dynamicTDZNames.push(name);
        }
        if (path.node.kind === "const") {
            disallowConstantViolations(name, binding, state);
        }
    }
    return dynamicTDZNames;
}
function disallowConstantViolations(name, binding, state) {
    for (const violation of binding.constantViolations){
        const readOnlyError = state.addHelper("readOnlyError");
        const throwNode = _core.types.callExpression(readOnlyError, [
            _core.types.stringLiteral(name)
        ]);
        if (violation.isAssignmentExpression()) {
            const { operator, left, right } = violation.node;
            if (operator === "=") {
                const exprs = [
                    right
                ];
                exprs.push(throwNode);
                violation.replaceWith(_core.types.sequenceExpression(exprs));
            } else if ([
                "&&=",
                "||=",
                "??="
            ].includes(operator)) {
                violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), left, _core.types.sequenceExpression([
                    right,
                    throwNode
                ])));
            } else {
                violation.replaceWith(_core.types.sequenceExpression([
                    _core.types.binaryExpression(operator.slice(0, -1), left, right),
                    throwNode
                ]));
            }
        } else if (violation.isUpdateExpression()) {
            violation.replaceWith(_core.types.sequenceExpression([
                _core.types.unaryExpression("+", violation.get("argument").node),
                throwNode
            ]));
        } else if (violation.isForXStatement()) {
            violation.ensureBlock();
            violation.get("left").replaceWith(_core.types.variableDeclaration("var", [
                _core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))
            ]));
            violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));
        }
    }
}
function getTDZStatus(refPath, bindingPath) {
    const executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);
    if (executionStatus === "before") {
        return "outside";
    } else if (executionStatus === "after") {
        return "inside";
    } else {
        return "maybe";
    }
}
const skipTDZChecks = new WeakSet();
function buildTDZAssert(status, node, state) {
    if (status === "maybe") {
        const clone = _core.types.cloneNode(node);
        skipTDZChecks.add(clone);
        return _core.types.callExpression(state.addHelper("temporalRef"), [
            clone,
            _core.types.stringLiteral(node.name)
        ]);
    } else {
        return _core.types.callExpression(state.addHelper("tdz"), [
            _core.types.stringLiteral(node.name)
        ]);
    }
}
function getTDZReplacement(path, state, id = path.node) {
    var _path$scope$getBindin;
    if (skipTDZChecks.has(id)) return;
    skipTDZChecks.add(id);
    const bindingPath = (_path$scope$getBindin = path.scope.getBinding(id.name)) == null ? void 0 : _path$scope$getBindin.path;
    if (!bindingPath || bindingPath.isFunctionDeclaration()) return;
    const status = getTDZStatus(path, bindingPath);
    if (status === "outside") return;
    if (status === "maybe") {
        bindingPath.parent._tdzThis = true;
    }
    return {
        status,
        node: buildTDZAssert(status, id, state)
    };
}
function injectTDZChecks(binding, state) {
    const allUsages = new Set(binding.referencePaths);
    binding.constantViolations.forEach(allUsages.add, allUsages);
    let dynamicTdz = false;
    for (const path of binding.constantViolations){
        const { node } = path;
        if (skipTDZChecks.has(node)) continue;
        skipTDZChecks.add(node);
        if (path.isUpdateExpression()) {
            const arg = path.get("argument");
            const replacement = getTDZReplacement(path, state, arg.node);
            if (!replacement) continue;
            if (replacement.status === "maybe") {
                dynamicTdz = true;
                path.insertBefore(replacement.node);
            } else {
                path.replaceWith(replacement.node);
            }
        } else if (path.isAssignmentExpression()) {
            const nodes = [];
            const ids = path.getBindingIdentifiers();
            for (const name of Object.keys(ids)){
                const replacement = getTDZReplacement(path, state, ids[name]);
                if (replacement) {
                    nodes.push(_core.types.expressionStatement(replacement.node));
                    if (replacement.status === "inside") break;
                    if (replacement.status === "maybe") dynamicTdz = true;
                }
            }
            if (nodes.length > 0) path.insertBefore(nodes);
        }
    }
    for (const path of binding.referencePaths){
        if (path.parentPath.isUpdateExpression()) continue;
        if (path.parentPath.isFor({
            left: path.node
        })) continue;
        const replacement = getTDZReplacement(path, state);
        if (!replacement) continue;
        if (replacement.status === "maybe") dynamicTdz = true;
        path.replaceWith(replacement.node);
    }
    return dynamicTdz;
} //# sourceMappingURL=validation.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-block-scoping/lib/annex-B_3_3.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.annexB33FunctionsVisitor = void 0;
exports.isVarScope = isVarScope;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const annexB33FunctionsVisitor = exports.annexB33FunctionsVisitor = Object.assign({
    VariableDeclaration (path) {
        if (isStrict(path)) return;
        if (path.node.kind !== "var") return;
        const varScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
        varScope.path.traverse(functionsToVarVisitor, {
            names: Object.keys(path.getBindingIdentifiers())
        });
    }
}, {
    BlockStatement (path) {
        if (isStrict(path)) return;
        if (_core.types.isFunction(path.parent, {
            body: path.node
        })) return;
        transformStatementList(path.get("body"));
    },
    SwitchCase (path) {
        if (isStrict(path)) return;
        transformStatementList(path.get("consequent"));
    }
});
function transformStatementList(paths) {
    outer: for (const path of paths){
        if (!path.isFunctionDeclaration()) continue;
        if (path.node.async || path.node.generator) return;
        const { scope } = path.parentPath;
        if (isVarScope(scope)) return;
        const { name } = path.node.id;
        let currScope = scope;
        do {
            if (currScope.parent.hasOwnBinding(name)) continue outer;
            currScope = currScope.parent;
        }while (!isVarScope(currScope))
        maybeTransformBlockScopedFunction(path);
    }
}
function maybeTransformBlockScopedFunction(path) {
    const { node, parentPath: { scope } } = path;
    const { id } = node;
    scope.removeOwnBinding(id.name);
    node.id = null;
    const varNode = _core.types.variableDeclaration("var", [
        _core.types.variableDeclarator(id, _core.types.toExpression(node))
    ]);
    varNode._blockHoist = 2;
    const [varPath] = path.replaceWith(varNode);
    scope.registerDeclaration(varPath);
}
const functionsToVarVisitor = {
    Scope (path, { names }) {
        for (const name of names){
            const binding = path.scope.getOwnBinding(name);
            if (binding && binding.kind === "hoisted") {
                maybeTransformBlockScopedFunction(binding.path);
            }
        }
    },
    "Expression|Declaration" (path) {
        path.skip();
    }
};
function isVarScope(scope) {
    return scope.path.isFunctionParent() || scope.path.isProgram();
}
function isStrict(path) {
    return !!path.find(({ node })=>{
        var _node$directives;
        if (_core.types.isProgram(node)) {
            if (node.sourceType === "module") return true;
        } else if (_core.types.isClass(node)) {
            return true;
        } else if (!_core.types.isBlockStatement(node)) {
            return false;
        }
        return (_node$directives = node.directives) == null ? void 0 : _node$directives.some((directive)=>directive.value.value === "use strict");
    });
} //# sourceMappingURL=annex-B_3_3.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-block-scoping/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _loop = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-block-scoping/lib/loop.js [app-ssr] (ecmascript)");
var _validation = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-block-scoping/lib/validation.js [app-ssr] (ecmascript)");
var _annexB_3_ = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-block-scoping/lib/annex-B_3_3.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts)=>{
    api.assertVersion(7);
    const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;
    if (typeof throwIfClosureRequired !== "boolean") {
        throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);
    }
    if (typeof tdzEnabled !== "boolean") {
        throw new Error(`.tdz must be a boolean, or undefined`);
    }
    return {
        name: "transform-block-scoping",
        visitor: _core.traverse.visitors.merge([
            _annexB_3_.annexB33FunctionsVisitor,
            {
                Loop (path, state) {
                    const isForStatement = path.isForStatement();
                    const headPath = isForStatement ? path.get("init") : path.isForXStatement() ? path.get("left") : null;
                    let needsBodyWrap = false;
                    const markNeedsBodyWrap = ()=>{
                        if (throwIfClosureRequired) {
                            throw path.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
                        }
                        needsBodyWrap = true;
                    };
                    const body = path.get("body");
                    let bodyScope;
                    if (body.isBlockStatement()) {
                        bodyScope = body.scope;
                    }
                    const bindings = (0, _loop.getLoopBodyBindings)(path);
                    for (const binding of bindings){
                        const { capturedInClosure } = (0, _loop.getUsageInBody)(binding, path);
                        if (capturedInClosure) markNeedsBodyWrap();
                    }
                    const captured = [];
                    const updatedBindingsUsages = new Map();
                    if (headPath && isBlockScoped(headPath.node)) {
                        const names = Object.keys(headPath.getBindingIdentifiers());
                        const headScope = headPath.scope;
                        for (let name of names){
                            var _bodyScope;
                            if ((_bodyScope = bodyScope) != null && _bodyScope.hasOwnBinding(name)) continue;
                            let binding = headScope.getOwnBinding(name);
                            if (!binding) {
                                headScope.crawl();
                                binding = headScope.getOwnBinding(name);
                            }
                            const { usages, capturedInClosure, hasConstantViolations } = (0, _loop.getUsageInBody)(binding, path);
                            if (headScope.parent.hasBinding(name) || headScope.parent.hasGlobal(name)) {
                                const newName = headScope.generateUid(name);
                                headScope.rename(name, newName);
                                name = newName;
                            }
                            if (capturedInClosure) {
                                markNeedsBodyWrap();
                                captured.push(name);
                            }
                            if (isForStatement && hasConstantViolations) {
                                updatedBindingsUsages.set(name, usages);
                            }
                        }
                    }
                    if (needsBodyWrap) {
                        const varPath = (0, _loop.wrapLoopBody)(path, captured, updatedBindingsUsages);
                        if (headPath != null && headPath.isVariableDeclaration()) {
                            transformBlockScopedVariable(headPath, state, tdzEnabled);
                        }
                        varPath.get("declarations.0.init").unwrapFunctionEnvironment();
                    }
                },
                VariableDeclaration (path, state) {
                    transformBlockScopedVariable(path, state, tdzEnabled);
                },
                ClassDeclaration (path) {
                    const { id } = path.node;
                    if (!id) return;
                    const { scope } = path.parentPath;
                    if (!(0, _annexB_3_.isVarScope)(scope) && scope.parent.hasBinding(id.name, {
                        noUids: true
                    })) {
                        path.scope.rename(id.name);
                    }
                }
            }
        ])
    };
});
const conflictingFunctionsVisitor = {
    Scope (path, { names }) {
        for (const name of names){
            const binding = path.scope.getOwnBinding(name);
            if (binding && binding.kind === "hoisted") {
                path.scope.rename(name);
            }
        }
    },
    "Expression|Declaration" (path) {
        path.skip();
    }
};
function transformBlockScopedVariable(path, state, tdzEnabled) {
    if (!isBlockScoped(path.node)) return;
    const dynamicTDZNames = (0, _validation.validateUsage)(path, state, tdzEnabled);
    path.node.kind = "var";
    const bindingNames = Object.keys(path.getBindingIdentifiers());
    for (const name of bindingNames){
        const binding = path.scope.getOwnBinding(name);
        if (!binding) continue;
        binding.kind = "var";
    }
    if (isInLoop(path) && !(0, _loop.isVarInLoopHead)(path) || dynamicTDZNames.length > 0) {
        for (const decl of path.node.declarations){
            var _decl$init;
            (_decl$init = decl.init) != null ? _decl$init : decl.init = path.scope.buildUndefinedNode();
        }
    }
    const blockScope = path.scope;
    const varScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
    if (varScope !== blockScope) {
        for (const name of bindingNames){
            let newName = name;
            if (blockScope.parent.hasBinding(name, {
                noUids: true
            }) || blockScope.parent.hasGlobal(name)) {
                newName = blockScope.generateUid(name);
                blockScope.rename(name, newName);
            }
            blockScope.moveBindingTo(newName, varScope);
        }
    }
    blockScope.path.traverse(conflictingFunctionsVisitor, {
        names: bindingNames
    });
    for (const name of dynamicTDZNames){
        path.scope.push({
            id: _core.types.identifier(name),
            init: state.addHelper("temporalUndefined")
        });
    }
}
function isLetOrConst(kind) {
    return kind === "let" || kind === "const";
}
function isInLoop(path) {
    if (!path.parentPath) return false;
    if (path.parentPath.isLoop()) return true;
    if (path.parentPath.isFunctionParent()) return false;
    return isInLoop(path.parentPath);
}
function isBlockScoped(node) {
    if (!_core.types.isVariableDeclaration(node)) return false;
    if (node[_core.types.BLOCK_SCOPED_SYMBOL]) {
        return true;
    }
    if (!isLetOrConst(node.kind) && node.kind !== "using") {
        return false;
    }
    return true;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-classes/lib/inline-callSuper-helpers.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addCallSuperHelper;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const helper = _core.template.statement`
  function CALL_SUPER(
    _this,
    derived,
    args,
  ) {
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;

      // core-js@3
      if (Reflect.construct.sham) return false;

      // Proxy can't be polyfilled. Every browser implemented
      // proxies before or at the same time as Reflect.construct,
      // so if they support Proxy they also support Reflect.construct.
      if (typeof Proxy === "function") return true;

      // Since Reflect.construct can't be properly polyfilled, some
      // implementations (e.g. core-js@2) don't set the correct internal slots.
      // Those polyfills don't allow us to subclass built-ins, so we need to
      // use our fallback implementation.
      try {
        // If the internal slots aren't set, this throws an error similar to
        //   TypeError: this is not a Boolean object.
        return !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}),);
      } catch (e) {
        return false;
      }
    }

    // Super
    derived = GET_PROTOTYPE_OF(derived);
    return POSSIBLE_CONSTRUCTOR_RETURN(
      _this,
      isNativeReflectConstruct()
        ? // NOTE: This doesn't work if this.__proto__.constructor has been modified.
          Reflect.construct(
            derived,
            args || [],
            GET_PROTOTYPE_OF(_this).constructor,
          )
        : derived.apply(_this, args),
    );
  }
`;
const helperIDs = new WeakMap();
function addCallSuperHelper(file) {
    if (helperIDs.has(file)) {
        return (_core.types.cloneNode || _core.types.clone)(helperIDs.get(file));
    }
    try {
        return file.addHelper("callSuper");
    } catch (_unused) {}
    const id = file.scope.generateUidIdentifier("callSuper");
    helperIDs.set(file, id);
    const fn = helper({
        CALL_SUPER: id,
        GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
        POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
    });
    file.path.unshiftContainer("body", [
        fn
    ]);
    file.scope.registerDeclaration(file.path.get("body.0"));
    return _core.types.cloneNode(id);
} //# sourceMappingURL=inline-callSuper-helpers.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-classes/lib/transformClass.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = transformClass;
var _helperReplaceSupers = __turbopack_require__("[project]/node_modules/@babel/helper-replace-supers/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _inlineCallSuperHelpers = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-classes/lib/inline-callSuper-helpers.js [app-ssr] (ecmascript)");
function buildConstructor(classRef, constructorBody, node) {
    const func = _core.types.functionDeclaration(_core.types.cloneNode(classRef), [], constructorBody);
    _core.types.inherits(func, node);
    return func;
}
function transformClass(path, file, builtinClasses, isLoose, assumptions, supportUnicodeId) {
    const classState = {
        parent: undefined,
        scope: undefined,
        node: undefined,
        path: undefined,
        file: undefined,
        classId: undefined,
        classRef: undefined,
        superName: null,
        superReturns: [],
        isDerived: false,
        extendsNative: false,
        construct: undefined,
        constructorBody: undefined,
        userConstructor: undefined,
        userConstructorPath: undefined,
        hasConstructor: false,
        body: [],
        superThises: [],
        pushedInherits: false,
        pushedCreateClass: false,
        protoAlias: null,
        isLoose: false,
        dynamicKeys: new Map(),
        methods: {
            instance: {
                hasComputed: false,
                list: [],
                map: new Map()
            },
            static: {
                hasComputed: false,
                list: [],
                map: new Map()
            }
        }
    };
    const setState = (newState)=>{
        Object.assign(classState, newState);
    };
    const findThisesVisitor = _traverse.visitors.environmentVisitor({
        ThisExpression (path) {
            classState.superThises.push(path);
        }
    });
    function createClassHelper(args) {
        return _core.types.callExpression(classState.file.addHelper("createClass"), args);
    }
    function maybeCreateConstructor() {
        const classBodyPath = classState.path.get("body");
        for (const path of classBodyPath.get("body")){
            if (path.isClassMethod({
                kind: "constructor"
            })) return;
        }
        let params, body;
        if (classState.isDerived) {
            const constructor = _core.template.expression.ast`
        (function () {
          super(...arguments);
        })
      `;
            params = constructor.params;
            body = constructor.body;
        } else {
            params = [];
            body = _core.types.blockStatement([]);
        }
        classBodyPath.unshiftContainer("body", _core.types.classMethod("constructor", _core.types.identifier("constructor"), params, body));
    }
    function buildBody() {
        maybeCreateConstructor();
        pushBody();
        verifyConstructor();
        if (classState.userConstructor) {
            const { constructorBody, userConstructor, construct } = classState;
            constructorBody.body.push(...userConstructor.body.body);
            _core.types.inherits(construct, userConstructor);
            _core.types.inherits(constructorBody, userConstructor.body);
        }
        pushDescriptors();
    }
    function pushBody() {
        const classBodyPaths = classState.path.get("body.body");
        for (const path of classBodyPaths){
            const node = path.node;
            if (path.isClassProperty() || path.isClassPrivateProperty()) {
                throw path.buildCodeFrameError("Missing class properties transform.");
            }
            if (node.decorators) {
                throw path.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
            }
            if (_core.types.isClassMethod(node)) {
                const isConstructor = node.kind === "constructor";
                const replaceSupers = new _helperReplaceSupers.default({
                    methodPath: path,
                    objectRef: classState.classRef,
                    superRef: classState.superName,
                    constantSuper: assumptions.constantSuper,
                    file: classState.file,
                    refToPreserve: classState.classRef
                });
                replaceSupers.replace();
                const superReturns = [];
                path.traverse(_traverse.visitors.environmentVisitor({
                    ReturnStatement (path) {
                        if (!path.getFunctionParent().isArrowFunctionExpression()) {
                            superReturns.push(path);
                        }
                    }
                }));
                if (isConstructor) {
                    pushConstructor(superReturns, node, path);
                } else {
                    {
                        var _path$ensureFunctionN;
                        (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.ensureFunctionName;
                    }
                    path.ensureFunctionName(supportUnicodeId);
                    let wrapped;
                    if (node !== path.node) {
                        wrapped = path.node;
                        path.replaceWith(node);
                    }
                    pushMethod(node, wrapped);
                }
            }
        }
    }
    function pushDescriptors() {
        pushInheritsToBody();
        const { body } = classState;
        const props = {
            instance: null,
            static: null
        };
        for (const placement of [
            "static",
            "instance"
        ]){
            if (classState.methods[placement].list.length) {
                props[placement] = classState.methods[placement].list.map((desc)=>{
                    const obj = _core.types.objectExpression([
                        _core.types.objectProperty(_core.types.identifier("key"), desc.key)
                    ]);
                    for (const kind of [
                        "get",
                        "set",
                        "value"
                    ]){
                        if (desc[kind] != null) {
                            obj.properties.push(_core.types.objectProperty(_core.types.identifier(kind), desc[kind]));
                        }
                    }
                    return obj;
                });
            }
        }
        if (props.instance || props.static) {
            let args = [
                _core.types.cloneNode(classState.classRef),
                props.instance ? _core.types.arrayExpression(props.instance) : _core.types.nullLiteral(),
                props.static ? _core.types.arrayExpression(props.static) : _core.types.nullLiteral()
            ];
            let lastNonNullIndex = 0;
            for(let i = 0; i < args.length; i++){
                if (!_core.types.isNullLiteral(args[i])) lastNonNullIndex = i;
            }
            args = args.slice(0, lastNonNullIndex + 1);
            body.push(_core.types.returnStatement(createClassHelper(args)));
            classState.pushedCreateClass = true;
        }
    }
    function wrapSuperCall(bareSuper, superRef, thisRef, body) {
        const bareSuperNode = bareSuper.node;
        let call;
        if (assumptions.superIsCallableConstructor) {
            bareSuperNode.arguments.unshift(_core.types.thisExpression());
            if (bareSuperNode.arguments.length === 2 && _core.types.isSpreadElement(bareSuperNode.arguments[1]) && _core.types.isIdentifier(bareSuperNode.arguments[1].argument, {
                name: "arguments"
            })) {
                bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
                bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("apply"));
            } else {
                bareSuperNode.callee = _core.types.memberExpression(_core.types.cloneNode(superRef), _core.types.identifier("call"));
            }
            call = _core.types.logicalExpression("||", bareSuperNode, _core.types.thisExpression());
        } else {
            var _bareSuperNode$argume;
            const args = [
                _core.types.thisExpression(),
                _core.types.cloneNode(classState.classRef)
            ];
            if ((_bareSuperNode$argume = bareSuperNode.arguments) != null && _bareSuperNode$argume.length) {
                const bareSuperNodeArguments = bareSuperNode.arguments;
                if (bareSuperNodeArguments.length === 1 && _core.types.isSpreadElement(bareSuperNodeArguments[0]) && _core.types.isIdentifier(bareSuperNodeArguments[0].argument, {
                    name: "arguments"
                })) {
                    args.push(bareSuperNodeArguments[0].argument);
                } else {
                    args.push(_core.types.arrayExpression(bareSuperNodeArguments));
                }
            }
            call = _core.types.callExpression((0, _inlineCallSuperHelpers.default)(classState.file), args);
        }
        if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
            if (classState.superThises.length) {
                call = _core.types.assignmentExpression("=", thisRef(), call);
            }
            bareSuper.parentPath.replaceWith(_core.types.returnStatement(call));
        } else {
            bareSuper.replaceWith(_core.types.assignmentExpression("=", thisRef(), call));
        }
    }
    function verifyConstructor() {
        if (!classState.isDerived) return;
        const path = classState.userConstructorPath;
        const body = path.get("body");
        const constructorBody = path.get("body");
        let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;
        path.traverse(findThisesVisitor);
        let thisRef = function() {
            const ref = path.scope.generateDeclaredUidIdentifier("this");
            maxGuaranteedSuperBeforeIndex++;
            thisRef = ()=>_core.types.cloneNode(ref);
            return ref;
        };
        const buildAssertThisInitialized = function() {
            return _core.types.callExpression(classState.file.addHelper("assertThisInitialized"), [
                thisRef()
            ]);
        };
        const bareSupers = [];
        path.traverse(_traverse.visitors.environmentVisitor({
            Super (path) {
                const { node, parentPath } = path;
                if (parentPath.isCallExpression({
                    callee: node
                })) {
                    bareSupers.unshift(parentPath);
                }
            }
        }));
        for (const bareSuper of bareSupers){
            wrapSuperCall(bareSuper, classState.superName, thisRef, body);
            if (maxGuaranteedSuperBeforeIndex >= 0) {
                let lastParentPath;
                bareSuper.find(function(parentPath) {
                    if (parentPath === constructorBody) {
                        maxGuaranteedSuperBeforeIndex = Math.min(maxGuaranteedSuperBeforeIndex, lastParentPath.key);
                        return true;
                    }
                    const { type } = parentPath;
                    switch(type){
                        case "ExpressionStatement":
                        case "SequenceExpression":
                        case "AssignmentExpression":
                        case "BinaryExpression":
                        case "MemberExpression":
                        case "CallExpression":
                        case "NewExpression":
                        case "VariableDeclarator":
                        case "VariableDeclaration":
                        case "BlockStatement":
                        case "ArrayExpression":
                        case "ObjectExpression":
                        case "ObjectProperty":
                        case "TemplateLiteral":
                            lastParentPath = parentPath;
                            return false;
                        default:
                            if (type === "LogicalExpression" && parentPath.node.left === lastParentPath.node || parentPath.isConditional() && parentPath.node.test === lastParentPath.node || type === "OptionalCallExpression" && parentPath.node.callee === lastParentPath.node || type === "OptionalMemberExpression" && parentPath.node.object === lastParentPath.node) {
                                lastParentPath = parentPath;
                                return false;
                            }
                    }
                    maxGuaranteedSuperBeforeIndex = -1;
                    return true;
                });
            }
        }
        const guaranteedCalls = new Set();
        for (const thisPath of classState.superThises){
            const { node, parentPath } = thisPath;
            if (parentPath.isMemberExpression({
                object: node
            })) {
                thisPath.replaceWith(thisRef());
                continue;
            }
            let thisIndex;
            thisPath.find(function(parentPath) {
                if (parentPath.parentPath === constructorBody) {
                    thisIndex = parentPath.key;
                    return true;
                }
            });
            let exprPath = thisPath.parentPath.isSequenceExpression() ? thisPath.parentPath : thisPath;
            if (exprPath.listKey === "arguments" && (exprPath.parentPath.isCallExpression() || exprPath.parentPath.isOptionalCallExpression())) {
                exprPath = exprPath.parentPath;
            } else {
                exprPath = null;
            }
            if (maxGuaranteedSuperBeforeIndex !== -1 && thisIndex > maxGuaranteedSuperBeforeIndex || guaranteedCalls.has(exprPath)) {
                thisPath.replaceWith(thisRef());
            } else {
                if (exprPath) {
                    guaranteedCalls.add(exprPath);
                }
                thisPath.replaceWith(buildAssertThisInitialized());
            }
        }
        let wrapReturn;
        if (classState.isLoose) {
            wrapReturn = (returnArg)=>{
                const thisExpr = buildAssertThisInitialized();
                return returnArg ? _core.types.logicalExpression("||", returnArg, thisExpr) : thisExpr;
            };
        } else {
            wrapReturn = (returnArg)=>{
                const returnParams = [
                    thisRef()
                ];
                if (returnArg != null) {
                    returnParams.push(returnArg);
                }
                return _core.types.callExpression(classState.file.addHelper("possibleConstructorReturn"), returnParams);
            };
        }
        const bodyPaths = body.get("body");
        const guaranteedSuperBeforeFinish = maxGuaranteedSuperBeforeIndex !== -1 && maxGuaranteedSuperBeforeIndex < bodyPaths.length;
        if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
            body.pushContainer("body", _core.types.returnStatement(guaranteedSuperBeforeFinish ? thisRef() : buildAssertThisInitialized()));
        }
        for (const returnPath of classState.superReturns){
            returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
        }
    }
    function pushMethod(node, wrapped) {
        if (node.kind === "method") {
            if (processMethod(node)) return;
        }
        const placement = node.static ? "static" : "instance";
        const methods = classState.methods[placement];
        const descKey = node.kind === "method" ? "value" : node.kind;
        const key = _core.types.isNumericLiteral(node.key) || _core.types.isBigIntLiteral(node.key) ? _core.types.stringLiteral(String(node.key.value)) : _core.types.toComputedKey(node);
        methods.hasComputed = !_core.types.isStringLiteral(key);
        const fn = wrapped != null ? wrapped : _core.types.toExpression(node);
        let descriptor;
        if (!methods.hasComputed && methods.map.has(key.value)) {
            descriptor = methods.map.get(key.value);
            descriptor[descKey] = fn;
            if (descKey === "value") {
                descriptor.get = null;
                descriptor.set = null;
            } else {
                descriptor.value = null;
            }
        } else {
            descriptor = {
                key: key,
                [descKey]: fn
            };
            methods.list.push(descriptor);
            if (!methods.hasComputed) {
                methods.map.set(key.value, descriptor);
            }
        }
    }
    function processMethod(node) {
        if (assumptions.setClassMethods && !node.decorators) {
            let { classRef } = classState;
            if (!node.static) {
                insertProtoAliasOnce();
                classRef = classState.protoAlias;
            }
            const methodName = _core.types.memberExpression(_core.types.cloneNode(classRef), node.key, node.computed || _core.types.isLiteral(node.key));
            const func = _core.types.functionExpression(node.id, node.params, node.body, node.generator, node.async);
            _core.types.inherits(func, node);
            const expr = _core.types.expressionStatement(_core.types.assignmentExpression("=", methodName, func));
            _core.types.inheritsComments(expr, node);
            classState.body.push(expr);
            return true;
        }
        return false;
    }
    function insertProtoAliasOnce() {
        if (classState.protoAlias === null) {
            setState({
                protoAlias: classState.scope.generateUidIdentifier("proto")
            });
            const classProto = _core.types.memberExpression(classState.classRef, _core.types.identifier("prototype"));
            const protoDeclaration = _core.types.variableDeclaration("var", [
                _core.types.variableDeclarator(classState.protoAlias, classProto)
            ]);
            classState.body.push(protoDeclaration);
        }
    }
    function pushConstructor(superReturns, method, path) {
        setState({
            userConstructorPath: path,
            userConstructor: method,
            hasConstructor: true,
            superReturns
        });
        const { construct } = classState;
        _core.types.inheritsComments(construct, method);
        construct.params = method.params;
        _core.types.inherits(construct.body, method.body);
        construct.body.directives = method.body.directives;
        if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
            pushDescriptors();
        }
        pushInheritsToBody();
    }
    function pushInheritsToBody() {
        if (!classState.isDerived || classState.pushedInherits) return;
        classState.pushedInherits = true;
        classState.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [
            _core.types.cloneNode(classState.classRef),
            _core.types.cloneNode(classState.superName)
        ])));
    }
    function extractDynamicKeys() {
        const { dynamicKeys, node, scope } = classState;
        for (const elem of node.body.body){
            if (!_core.types.isClassMethod(elem) || !elem.computed) continue;
            if (scope.isPure(elem.key, true)) continue;
            const id = scope.generateUidIdentifierBasedOnNode(elem.key);
            dynamicKeys.set(id.name, elem.key);
            elem.key = id;
        }
    }
    function setupClosureParamsArgs() {
        const { superName, dynamicKeys } = classState;
        const closureParams = [];
        const closureArgs = [];
        if (classState.isDerived) {
            let arg = _core.types.cloneNode(superName);
            if (classState.extendsNative) {
                arg = _core.types.callExpression(classState.file.addHelper("wrapNativeSuper"), [
                    arg
                ]);
                (0, _helperAnnotateAsPure.default)(arg);
            }
            const param = classState.scope.generateUidIdentifierBasedOnNode(superName);
            closureParams.push(param);
            closureArgs.push(arg);
            setState({
                superName: _core.types.cloneNode(param)
            });
        }
        for (const [name, value] of dynamicKeys){
            closureParams.push(_core.types.identifier(name));
            closureArgs.push(value);
        }
        return {
            closureParams,
            closureArgs
        };
    }
    function classTransformer(path, file, builtinClasses, isLoose) {
        setState({
            parent: path.parent,
            scope: path.scope,
            node: path.node,
            path,
            file,
            isLoose
        });
        setState({
            classId: classState.node.id,
            classRef: classState.node.id ? _core.types.identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
            superName: classState.node.superClass,
            isDerived: !!classState.node.superClass,
            constructorBody: _core.types.blockStatement([])
        });
        setState({
            extendsNative: _core.types.isIdentifier(classState.superName) && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
        });
        const { classRef, node, constructorBody } = classState;
        setState({
            construct: buildConstructor(classRef, constructorBody, node)
        });
        extractDynamicKeys();
        const { body } = classState;
        const { closureParams, closureArgs } = setupClosureParamsArgs();
        buildBody();
        if (!assumptions.noClassCalls) {
            constructorBody.body.unshift(_core.types.expressionStatement(_core.types.callExpression(classState.file.addHelper("classCallCheck"), [
                _core.types.thisExpression(),
                _core.types.cloneNode(classState.classRef)
            ])));
        }
        const isStrict = path.isInStrictMode();
        let constructorOnly = body.length === 0;
        if (constructorOnly && !isStrict) {
            for (const param of classState.construct.params){
                if (!_core.types.isIdentifier(param)) {
                    constructorOnly = false;
                    break;
                }
            }
        }
        const directives = constructorOnly ? classState.construct.body.directives : [];
        if (!isStrict) {
            directives.push(_core.types.directive(_core.types.directiveLiteral("use strict")));
        }
        if (constructorOnly) {
            const expr = _core.types.toExpression(classState.construct);
            return classState.isLoose ? expr : createClassHelper([
                expr
            ]);
        }
        if (!classState.pushedCreateClass) {
            body.push(_core.types.returnStatement(classState.isLoose ? _core.types.cloneNode(classState.classRef) : createClassHelper([
                _core.types.cloneNode(classState.classRef)
            ])));
        }
        body.unshift(classState.construct);
        const container = _core.types.arrowFunctionExpression(closureParams, _core.types.blockStatement(body, directives));
        return _core.types.callExpression(container, closureArgs);
    }
    return classTransformer(path, file, builtinClasses, isLoose);
} //# sourceMappingURL=transformClass.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-classes/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _globals = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-classes/node_modules/globals/index.js [app-ssr] (ecmascript)");
var _transformClass = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-classes/lib/transformClass.js [app-ssr] (ecmascript)");
const getBuiltinClasses = (category)=>Object.keys(_globals[category]).filter((name)=>/^[A-Z]/.test(name));
const builtinClasses = new Set([
    ...getBuiltinClasses("builtin"),
    ...getBuiltinClasses("browser")
]);
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
    api.assertVersion(7);
    const { loose = false } = options;
    const setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : loose;
    const constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : loose;
    const superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : loose;
    const noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : loose;
    const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
    const VISITED = new WeakSet();
    return {
        name: "transform-classes",
        visitor: {
            ExportDefaultDeclaration (path) {
                if (!path.get("declaration").isClassDeclaration()) return;
                {
                    var _path$splitExportDecl;
                    (_path$splitExportDecl = path.splitExportDeclaration) != null ? _path$splitExportDecl : path.splitExportDeclaration = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.splitExportDeclaration;
                }
                path.splitExportDeclaration();
            },
            ClassDeclaration (path) {
                const { node } = path;
                const ref = node.id ? _core.types.cloneNode(node.id) : path.scope.generateUidIdentifier("class");
                path.replaceWith(_core.types.variableDeclaration("let", [
                    _core.types.variableDeclarator(ref, _core.types.toExpression(node))
                ]));
            },
            ClassExpression (path, state) {
                const { node } = path;
                if (VISITED.has(node)) return;
                {
                    var _path$ensureFunctionN;
                    (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.ensureFunctionName;
                }
                const replacement = path.ensureFunctionName(supportUnicodeId);
                if (replacement && replacement.node !== node) return;
                VISITED.add(node);
                const [replacedPath] = path.replaceWith((0, _transformClass.default)(path, state.file, builtinClasses, loose, {
                    setClassMethods,
                    constantSuper,
                    superIsCallableConstructor,
                    noClassCalls
                }, supportUnicodeId));
                if (replacedPath.isCallExpression()) {
                    (0, _helperAnnotateAsPure.default)(replacedPath);
                    const callee = replacedPath.get("callee");
                    if (callee.isArrowFunctionExpression()) {
                        callee.arrowFunctionToExpression();
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-class-properties/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCreateClassFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-class-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion(7);
    return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
        name: "transform-class-properties",
        api,
        feature: _helperCreateClassFeaturesPlugin.FEATURES.fields,
        loose: options.loose,
        manipulateOptions (opts, parserOpts) {
            {
                parserOpts.plugins.push("classProperties", "classPrivateProperties");
            }
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-class-static-block/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCreateClassFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-class-features-plugin/lib/index.js [app-ssr] (ecmascript)");
function generateUid(scope, denyList) {
    const name = "";
    let uid;
    let i = 1;
    do {
        uid = `_${name}`;
        if (i > 1) uid += i;
        i++;
    }while (denyList.has(uid))
    return uid;
}
var _default = exports.default = (0, _helperPluginUtils.declare)(({ types: t, template, assertVersion })=>{
    assertVersion("^7.12.0 || >8.0.0-alpha <8.0.0-beta");
    return {
        name: "transform-class-static-block",
        manipulateOptions: (_, parser)=>parser.plugins.push("classStaticBlock"),
        pre () {
            (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.staticBlocks, false);
        },
        visitor: {
            ClassBody (classBody) {
                const { scope } = classBody;
                const privateNames = new Set();
                const body = classBody.get("body");
                for (const path of body){
                    if (path.isPrivate()) {
                        privateNames.add(path.get("key.id").node.name);
                    }
                }
                for (const path of body){
                    if (!path.isStaticBlock()) continue;
                    const staticBlockPrivateId = generateUid(scope, privateNames);
                    privateNames.add(staticBlockPrivateId);
                    const staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));
                    let replacement;
                    const blockBody = path.node.body;
                    if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {
                        replacement = t.inheritsComments(blockBody[0].expression, blockBody[0]);
                    } else {
                        replacement = template.expression.ast`(() => { ${blockBody} })()`;
                    }
                    path.replaceWith(t.classPrivateProperty(staticBlockRef, replacement, [], true));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-computed-properties/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _template = __turbopack_require__("[project]/node_modules/@babel/template/lib/index.js [app-ssr] (ecmascript)");
{
    var DefineAccessorHelper = _template.default.expression.ast`
    function (type, obj, key, fn) {
      var desc = { configurable: true, enumerable: true };
      desc[type] = fn;
      return Object.defineProperty(obj, key, desc);
    }
  `;
    DefineAccessorHelper._compact = true;
}var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption;
    api.assertVersion(7);
    const setComputedProperties = (_api$assumption = api.assumption("setComputedProperties")) != null ? _api$assumption : options.loose;
    const pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;
    function buildDefineAccessor(state, obj, prop) {
        const type = prop.kind;
        const key = !prop.computed && _core.types.isIdentifier(prop.key) ? _core.types.stringLiteral(prop.key.name) : prop.key;
        const fn = getValue(prop);
        {
            let helper;
            if (state.availableHelper("defineAccessor")) {
                helper = state.addHelper("defineAccessor");
            } else {
                const file = state.file;
                helper = file.get("fallbackDefineAccessorHelper");
                if (!helper) {
                    const id = file.scope.generateUidIdentifier("defineAccessor");
                    file.scope.push({
                        id,
                        init: DefineAccessorHelper
                    });
                    file.set("fallbackDefineAccessorHelper", helper = id);
                }
                helper = _core.types.cloneNode(helper);
            }
            return _core.types.callExpression(helper, [
                _core.types.stringLiteral(type),
                obj,
                key,
                fn
            ]);
        }
    }
    function getValue(prop) {
        if (_core.types.isObjectProperty(prop)) {
            return prop.value;
        } else if (_core.types.isObjectMethod(prop)) {
            return _core.types.functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
        }
    }
    function pushAssign(objId, prop, body) {
        body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.cloneNode(objId), prop.key, prop.computed || _core.types.isLiteral(prop.key)), getValue(prop))));
    }
    function pushComputedPropsLoose(info) {
        const { computedProps, state, initPropExpression, objId, body } = info;
        for (const prop of computedProps){
            if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
                if (computedProps.length === 1) {
                    return buildDefineAccessor(state, initPropExpression, prop);
                } else {
                    body.push(_core.types.expressionStatement(buildDefineAccessor(state, _core.types.cloneNode(objId), prop)));
                }
            } else {
                pushAssign(_core.types.cloneNode(objId), prop, body);
            }
        }
    }
    function pushComputedPropsSpec(info) {
        const { objId, body, computedProps, state } = info;
        const CHUNK_LENGTH_CAP = 10;
        let currentChunk = null;
        const computedPropsChunks = [];
        for (const prop of computedProps){
            if (!currentChunk || currentChunk.length === CHUNK_LENGTH_CAP) {
                currentChunk = [];
                computedPropsChunks.push(currentChunk);
            }
            currentChunk.push(prop);
        }
        for (const chunk of computedPropsChunks){
            const single = computedPropsChunks.length === 1;
            let node = single ? info.initPropExpression : _core.types.cloneNode(objId);
            for (const prop of chunk){
                if (_core.types.isObjectMethod(prop) && (prop.kind === "get" || prop.kind === "set")) {
                    node = buildDefineAccessor(info.state, node, prop);
                } else {
                    node = _core.types.callExpression(state.addHelper("defineProperty"), [
                        node,
                        _core.types.toComputedKey(prop),
                        getValue(prop)
                    ]);
                }
            }
            if (single) return node;
            body.push(_core.types.expressionStatement(node));
        }
    }
    return {
        name: "transform-computed-properties",
        visitor: {
            ObjectExpression: {
                exit (path, state) {
                    const { node, parent, scope } = path;
                    let hasComputed = false;
                    for (const prop of node.properties){
                        hasComputed = prop.computed === true;
                        if (hasComputed) break;
                    }
                    if (!hasComputed) return;
                    const initProps = [];
                    const computedProps = [];
                    let foundComputed = false;
                    for (const prop of node.properties){
                        if (_core.types.isSpreadElement(prop)) {
                            continue;
                        }
                        if (prop.computed) {
                            foundComputed = true;
                        }
                        if (foundComputed) {
                            computedProps.push(prop);
                        } else {
                            initProps.push(prop);
                        }
                    }
                    const objId = scope.generateUidIdentifierBasedOnNode(parent);
                    const initPropExpression = _core.types.objectExpression(initProps);
                    const body = [];
                    body.push(_core.types.variableDeclaration("var", [
                        _core.types.variableDeclarator(objId, initPropExpression)
                    ]));
                    const single = pushComputedProps({
                        scope,
                        objId,
                        body,
                        computedProps,
                        initPropExpression,
                        state
                    });
                    if (single) {
                        path.replaceWith(single);
                    } else {
                        if (setComputedProperties) {
                            body.push(_core.types.expressionStatement(_core.types.cloneNode(objId)));
                        }
                        path.replaceWithMultiple(body);
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-destructuring/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function isPureVoid(node) {
    return core.types.isUnaryExpression(node) && node.operator === "void" && core.types.isPureish(node.argument);
}
function unshiftForXStatementBody(statementPath, newStatements) {
    statementPath.ensureBlock();
    const { scope, node } = statementPath;
    const bodyScopeBindings = statementPath.get("body").scope.bindings;
    const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some((name)=>scope.hasBinding(name));
    if (hasShadowedBlockScopedBindings) {
        node.body = core.types.blockStatement([
            ...newStatements,
            node.body
        ]);
    } else {
        node.body.body.unshift(...newStatements);
    }
}
function hasArrayRest(pattern) {
    return pattern.elements.some((elem)=>core.types.isRestElement(elem));
}
function hasObjectRest(pattern) {
    return pattern.properties.some((prop)=>core.types.isRestElement(prop));
}
const STOP_TRAVERSAL = {};
const arrayUnpackVisitor = (node, ancestors, state)=>{
    if (!ancestors.length) {
        return;
    }
    if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {
        state.deopt = true;
        throw STOP_TRAVERSAL;
    }
};
class DestructuringTransformer {
    constructor(opts){
        this.blockHoist = void 0;
        this.operator = void 0;
        this.arrayRefSet = void 0;
        this.nodes = void 0;
        this.scope = void 0;
        this.kind = void 0;
        this.iterableIsArray = void 0;
        this.arrayLikeIsIterable = void 0;
        this.objectRestNoSymbols = void 0;
        this.useBuiltIns = void 0;
        this.addHelper = void 0;
        this.blockHoist = opts.blockHoist;
        this.operator = opts.operator;
        this.arrayRefSet = new Set();
        this.nodes = opts.nodes || [];
        this.scope = opts.scope;
        this.kind = opts.kind;
        this.iterableIsArray = opts.iterableIsArray;
        this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
        this.objectRestNoSymbols = opts.objectRestNoSymbols;
        this.useBuiltIns = opts.useBuiltIns;
        this.addHelper = opts.addHelper;
    }
    getExtendsHelper() {
        return this.useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : this.addHelper("extends");
    }
    buildVariableAssignment(id, init) {
        let op = this.operator;
        if (core.types.isMemberExpression(id) || core.types.isOptionalMemberExpression(id)) op = "=";
        let node;
        if (op) {
            node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));
        } else {
            let nodeInit;
            if ((this.kind === "const" || this.kind === "using") && init === null) {
                nodeInit = this.scope.buildUndefinedNode();
            } else {
                nodeInit = core.types.cloneNode(init);
            }
            node = core.types.variableDeclaration(this.kind, [
                core.types.variableDeclarator(id, nodeInit)
            ]);
        }
        node._blockHoist = this.blockHoist;
        return node;
    }
    buildVariableDeclaration(id, init) {
        const declar = core.types.variableDeclaration("var", [
            core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))
        ]);
        declar._blockHoist = this.blockHoist;
        return declar;
    }
    push(id, _init) {
        const init = core.types.cloneNode(_init);
        if (core.types.isObjectPattern(id)) {
            this.pushObjectPattern(id, init);
        } else if (core.types.isArrayPattern(id)) {
            this.pushArrayPattern(id, init);
        } else if (core.types.isAssignmentPattern(id)) {
            this.pushAssignmentPattern(id, init);
        } else {
            this.nodes.push(this.buildVariableAssignment(id, init));
        }
    }
    toArray(node, count) {
        if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {
            return node;
        } else {
            const { scope, arrayLikeIsIterable } = this;
            if (core.types.isIdentifier(node)) {
                const binding = scope.getBinding(node.name);
                if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
                    return node;
                }
            }
            if (core.types.isArrayExpression(node)) {
                return node;
            }
            if (core.types.isIdentifier(node, {
                name: "arguments"
            })) {
                return core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
            }
            let helperName;
            const args = [
                node
            ];
            if (typeof count === "number") {
                args.push(core.types.numericLiteral(count));
                helperName = "slicedToArray";
            } else {
                helperName = "toArray";
            }
            if (arrayLikeIsIterable) {
                args.unshift(scope.path.hub.addHelper(helperName));
                helperName = "maybeArrayLike";
            }
            return core.types.callExpression(scope.path.hub.addHelper(helperName), args);
        }
    }
    pushAssignmentPattern({ left, right }, valueRef) {
        if (isPureVoid(valueRef)) {
            this.push(left, right);
            return;
        }
        const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
        const tempConditional = core.types.conditionalExpression(core.types.binaryExpression("===", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));
        if (core.types.isPattern(left)) {
            let patternId;
            let node;
            if (this.kind === "const" || this.kind === "let" || this.kind === "using") {
                patternId = this.scope.generateUidIdentifier(tempId.name);
                node = this.buildVariableDeclaration(patternId, tempConditional);
            } else {
                patternId = tempId;
                node = core.types.expressionStatement(core.types.assignmentExpression("=", core.types.cloneNode(tempId), tempConditional));
            }
            this.nodes.push(node);
            this.push(left, patternId);
        } else {
            this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
    }
    pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, (name)=>this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);
        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
    }
    pushObjectProperty(prop, propRef) {
        if (core.types.isLiteral(prop.key)) prop.computed = true;
        const pattern = prop.value;
        const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);
        if (core.types.isPattern(pattern)) {
            this.push(pattern, objRef);
        } else {
            this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
    }
    pushObjectPattern(pattern, objRef) {
        if (!pattern.properties.length) {
            this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), isPureVoid(objRef) ? [] : [
                objRef
            ])));
            return;
        }
        if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
            const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
            this.nodes.push(this.buildVariableDeclaration(temp, objRef));
            objRef = temp;
        }
        if (hasObjectRest(pattern)) {
            let copiedPattern;
            for(let i = 0; i < pattern.properties.length; i++){
                const prop = pattern.properties[i];
                if (core.types.isRestElement(prop)) {
                    break;
                }
                const key = prop.key;
                if (prop.computed && !this.scope.isPure(key)) {
                    const name = this.scope.generateUidIdentifierBasedOnNode(key);
                    this.nodes.push(this.buildVariableDeclaration(name, key));
                    if (!copiedPattern) {
                        copiedPattern = pattern = Object.assign({}, pattern, {
                            properties: pattern.properties.slice()
                        });
                    }
                    copiedPattern.properties[i] = Object.assign({}, prop, {
                        key: name
                    });
                }
            }
        }
        for(let i = 0; i < pattern.properties.length; i++){
            const prop = pattern.properties[i];
            if (core.types.isRestElement(prop)) {
                this.pushObjectRest(pattern, objRef, prop, i);
            } else {
                this.pushObjectProperty(prop, objRef);
            }
        }
    }
    canUnpackArrayPattern(pattern, arr) {
        if (!core.types.isArrayExpression(arr)) return false;
        if (pattern.elements.length > arr.elements.length) return;
        if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {
            return false;
        }
        for (const elem of pattern.elements){
            if (!elem) return false;
            if (core.types.isMemberExpression(elem)) return false;
        }
        for (const elem of arr.elements){
            if (core.types.isSpreadElement(elem)) return false;
            if (core.types.isCallExpression(elem)) return false;
            if (core.types.isMemberExpression(elem)) return false;
        }
        const bindings = core.types.getBindingIdentifiers(pattern);
        const state = {
            deopt: false,
            bindings
        };
        try {
            core.types.traverse(arr, arrayUnpackVisitor, state);
        } catch (e) {
            if (e !== STOP_TRAVERSAL) throw e;
        }
        return !state.deopt;
    }
    pushUnpackedArrayPattern(pattern, arr) {
        const holeToUndefined = (el)=>el != null ? el : this.scope.buildUndefinedNode();
        for(let i = 0; i < pattern.elements.length; i++){
            const elem = pattern.elements[i];
            if (core.types.isRestElement(elem)) {
                this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i).map(holeToUndefined)));
            } else {
                this.push(elem, holeToUndefined(arr.elements[i]));
            }
        }
    }
    pushArrayPattern(pattern, arrayRef) {
        if (arrayRef === null) {
            this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper("objectDestructuringEmpty"), [])));
            return;
        }
        if (!pattern.elements) return;
        if (this.canUnpackArrayPattern(pattern, arrayRef)) {
            this.pushUnpackedArrayPattern(pattern, arrayRef);
            return;
        }
        const count = !hasArrayRest(pattern) && pattern.elements.length;
        const toArray = this.toArray(arrayRef, count);
        if (core.types.isIdentifier(toArray)) {
            arrayRef = toArray;
        } else {
            arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
            this.arrayRefSet.add(arrayRef.name);
            this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
        }
        for(let i = 0; i < pattern.elements.length; i++){
            const elem = pattern.elements[i];
            if (!elem) continue;
            let elemRef;
            if (core.types.isRestElement(elem)) {
                elemRef = this.toArray(arrayRef);
                elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier("slice")), [
                    core.types.numericLiteral(i)
                ]);
                this.push(elem.argument, elemRef);
            } else {
                elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);
                this.push(elem, elemRef);
            }
        }
    }
    init(pattern, ref) {
        if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {
            const memo = this.scope.maybeGenerateMemoised(ref, true);
            if (memo) {
                this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));
                ref = memo;
            }
        }
        this.push(pattern, ref);
        return this.nodes;
    }
}
function buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {
    const keys = [];
    let allLiteral = true;
    let hasTemplateLiteral = false;
    for(let i = 0; i < excludedKeys.length; i++){
        const prop = excludedKeys[i];
        const key = prop.key;
        if (core.types.isIdentifier(key) && !prop.computed) {
            keys.push(core.types.stringLiteral(key.name));
        } else if (core.types.isTemplateLiteral(key)) {
            keys.push(core.types.cloneNode(key));
            hasTemplateLiteral = true;
        } else if (core.types.isLiteral(key)) {
            keys.push(core.types.stringLiteral(String(key.value)));
        } else if (core.types.isPrivateName(key)) ;
        else {
            keys.push(core.types.cloneNode(key));
            allLiteral = false;
        }
    }
    let value;
    if (keys.length === 0) {
        const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : addHelper("extends");
        value = core.types.callExpression(extendsHelper, [
            core.types.objectExpression([]),
            core.types.sequenceExpression([
                core.types.callExpression(addHelper("objectDestructuringEmpty"), [
                    core.types.cloneNode(objRef)
                ]),
                core.types.cloneNode(objRef)
            ])
        ]);
    } else {
        let keyExpression = core.types.arrayExpression(keys);
        if (!allLiteral) {
            keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier("map")), [
                addHelper("toPropertyKey")
            ]);
        } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {
            const programScope = scope.getProgramParent();
            const id = programScope.generateUidIdentifier("excluded");
            programScope.push({
                id,
                init: keyExpression,
                kind: "const"
            });
            keyExpression = core.types.cloneNode(id);
        }
        value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [
            core.types.cloneNode(objRef),
            keyExpression
        ]);
    }
    return value;
}
function convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
    const { node, scope } = path;
    const nodeKind = node.kind;
    const nodeLoc = node.loc;
    const nodes = [];
    for(let i = 0; i < node.declarations.length; i++){
        const declar = node.declarations[i];
        const patternId = declar.init;
        const pattern = declar.id;
        const destructuring = new DestructuringTransformer({
            blockHoist: node._blockHoist,
            nodes: nodes,
            scope: scope,
            kind: node.kind,
            iterableIsArray,
            arrayLikeIsIterable,
            useBuiltIns,
            objectRestNoSymbols,
            addHelper
        });
        if (core.types.isPattern(pattern)) {
            destructuring.init(pattern, patternId);
            if (+i !== node.declarations.length - 1) {
                core.types.inherits(nodes[nodes.length - 1], declar);
            }
        } else {
            nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));
        }
    }
    let tail = null;
    let nodesOut = [];
    for (const node of nodes){
        if (core.types.isVariableDeclaration(node)) {
            if (tail !== null) {
                tail.declarations.push(...node.declarations);
                continue;
            } else {
                node.kind = nodeKind;
                tail = node;
            }
        } else {
            tail = null;
        }
        if (!node.loc) {
            node.loc = nodeLoc;
        }
        nodesOut.push(node);
    }
    if (nodesOut.length === 2 && core.types.isVariableDeclaration(nodesOut[0]) && core.types.isExpressionStatement(nodesOut[1]) && core.types.isCallExpression(nodesOut[1].expression) && nodesOut[0].declarations.length === 1) {
        const expr = nodesOut[1].expression;
        expr.arguments = [
            nodesOut[0].declarations[0].init
        ];
        nodesOut = [
            expr
        ];
    } else {
        if (core.types.isForStatement(path.parent, {
            init: node
        }) && !nodesOut.some((v)=>core.types.isVariableDeclaration(v))) {
            for(let i = 0; i < nodesOut.length; i++){
                const node = nodesOut[i];
                if (core.types.isExpressionStatement(node)) {
                    nodesOut[i] = node.expression;
                }
            }
        }
    }
    if (nodesOut.length === 1) {
        path.replaceWith(nodesOut[0]);
    } else {
        path.replaceWithMultiple(nodesOut);
    }
    scope.crawl();
}
function convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {
    const { node, scope, parentPath } = path;
    const nodes = [];
    const destructuring = new DestructuringTransformer({
        operator: node.operator,
        scope: scope,
        nodes: nodes,
        arrayLikeIsIterable,
        iterableIsArray,
        objectRestNoSymbols,
        useBuiltIns,
        addHelper
    });
    let ref;
    if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {
        ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
        nodes.push(core.types.variableDeclaration("var", [
            core.types.variableDeclarator(ref, node.right)
        ]));
        if (core.types.isArrayExpression(node.right)) {
            destructuring.arrayRefSet.add(ref.name);
        }
    }
    destructuring.init(node.left, ref || node.right);
    if (ref) {
        if (parentPath.isArrowFunctionExpression()) {
            path.replaceWith(core.types.blockStatement([]));
            nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));
        } else {
            nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));
        }
    }
    path.replaceWithMultiple(nodes);
    scope.crawl();
}
function variableDeclarationHasPattern(node) {
    for (const declar of node.declarations){
        if (core.types.isPattern(declar.id)) {
            return true;
        }
    }
    return false;
}
var index = helperPluginUtils.declare((api, options)=>{
    var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;
    api.assertVersion(7);
    const { useBuiltIns = false } = options;
    const iterableIsArray = (_ref = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose) != null ? _ref : false;
    const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable")) != null ? _ref2 : false;
    const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;
    return {
        name: "transform-destructuring",
        visitor: {
            ExportNamedDeclaration (path) {
                const declaration = path.get("declaration");
                if (!declaration.isVariableDeclaration()) return;
                if (!variableDeclarationHasPattern(declaration.node)) return;
                const specifiers = [];
                for (const name of Object.keys(path.getOuterBindingIdentifiers())){
                    specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
                }
                path.replaceWith(declaration.node);
                path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
                path.scope.crawl();
            },
            ForXStatement (path) {
                const { node, scope } = path;
                const left = node.left;
                if (core.types.isPattern(left)) {
                    const temp = scope.generateUidIdentifier("ref");
                    node.left = core.types.variableDeclaration("var", [
                        core.types.variableDeclarator(temp)
                    ]);
                    path.ensureBlock();
                    const statementBody = path.node.body.body;
                    const nodes = [];
                    if (statementBody.length === 0 && path.isCompletionRecord()) {
                        nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
                    }
                    nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, core.types.cloneNode(temp))));
                    unshiftForXStatementBody(path, nodes);
                    scope.crawl();
                    return;
                }
                if (!core.types.isVariableDeclaration(left)) return;
                const pattern = left.declarations[0].id;
                if (!core.types.isPattern(pattern)) return;
                const key = scope.generateUidIdentifier("ref");
                node.left = core.types.variableDeclaration(left.kind, [
                    core.types.variableDeclarator(key, null)
                ]);
                const nodes = [];
                const destructuring = new DestructuringTransformer({
                    kind: left.kind,
                    scope: scope,
                    nodes: nodes,
                    arrayLikeIsIterable,
                    iterableIsArray,
                    objectRestNoSymbols,
                    useBuiltIns,
                    addHelper: (name)=>this.addHelper(name)
                });
                destructuring.init(pattern, key);
                unshiftForXStatementBody(path, nodes);
                scope.crawl();
            },
            CatchClause ({ node, scope }) {
                const pattern = node.param;
                if (!core.types.isPattern(pattern)) return;
                const ref = scope.generateUidIdentifier("ref");
                node.param = ref;
                const nodes = [];
                const destructuring = new DestructuringTransformer({
                    kind: "let",
                    scope: scope,
                    nodes: nodes,
                    arrayLikeIsIterable,
                    iterableIsArray,
                    objectRestNoSymbols,
                    useBuiltIns,
                    addHelper: (name)=>this.addHelper(name)
                });
                destructuring.init(pattern, ref);
                node.body.body = [
                    ...nodes,
                    ...node.body.body
                ];
                scope.crawl();
            },
            AssignmentExpression (path, state) {
                if (!core.types.isPattern(path.node.left)) return;
                convertAssignmentExpression(path, (name)=>state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
            },
            VariableDeclaration (path, state) {
                const { node, parent } = path;
                if (core.types.isForXStatement(parent)) return;
                if (!parent || !path.container) return;
                if (!variableDeclarationHasPattern(node)) return;
                convertVariableDeclaration(path, (name)=>state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);
            }
        }
    };
});
exports.buildObjectExcludingKeys = buildObjectExcludingKeys;
exports.default = index;
exports.unshiftForXStatementBody = unshiftForXStatementBody; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/features.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FEATURES = void 0;
exports.enableFeature = enableFeature;
exports.featuresKey = void 0;
exports.hasFeature = hasFeature;
exports.runtimeKey = void 0;
const FEATURES = exports.FEATURES = Object.freeze({
    unicodeFlag: 1 << 0,
    dotAllFlag: 1 << 1,
    unicodePropertyEscape: 1 << 2,
    namedCaptureGroups: 1 << 3,
    unicodeSetsFlag_syntax: 1 << 4,
    unicodeSetsFlag: 1 << 5,
    duplicateNamedCaptureGroups: 1 << 6,
    modifiers: 1 << 7
});
const featuresKey = exports.featuresKey = "@babel/plugin-regexp-features/featuresKey";
const runtimeKey = exports.runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
function enableFeature(features, feature) {
    return features | feature;
}
function hasFeature(features, feature) {
    return !!(features & feature);
} //# sourceMappingURL=features.js.map
}}),
"[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/util.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canSkipRegexpu = canSkipRegexpu;
exports.generateRegexpuOptions = generateRegexpuOptions;
exports.transformFlags = transformFlags;
var _features = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/features.js [app-ssr] (ecmascript)");
function generateRegexpuOptions(pattern, toTransform) {
    const feat = (name)=>{
        return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? "transform" : false;
    };
    const featDuplicateNamedGroups = ()=>{
        if (!feat("duplicateNamedCaptureGroups")) return false;
        const regex = /\(\?<([^>]+)>/g;
        const seen = new Set();
        for(let match; match = regex.exec(pattern); seen.add(match[1])){
            if (seen.has(match[1])) return "transform";
        }
        return false;
    };
    return {
        unicodeFlag: feat("unicodeFlag"),
        unicodeSetsFlag: feat("unicodeSetsFlag"),
        dotAllFlag: feat("dotAllFlag"),
        unicodePropertyEscapes: feat("unicodePropertyEscape"),
        namedGroups: feat("namedCaptureGroups") || featDuplicateNamedGroups(),
        onNamedGroup: ()=>{},
        modifiers: feat("modifiers")
    };
}
function canSkipRegexpu(node, options) {
    const { flags, pattern } = node;
    if (flags.includes("v")) {
        if (options.unicodeSetsFlag === "transform") return false;
    }
    if (flags.includes("u")) {
        if (options.unicodeFlag === "transform") return false;
        if (options.unicodePropertyEscapes === "transform" && /\\p\{/i.test(pattern)) {
            return false;
        }
    }
    if (flags.includes("s")) {
        if (options.dotAllFlag === "transform") return false;
    }
    if (options.namedGroups === "transform" && /\(\?<(?![=!])/.test(pattern)) {
        return false;
    }
    if (options.modifiers === "transform" && /\(\?[\w-]+:/.test(pattern)) {
        return false;
    }
    return true;
}
function transformFlags(regexpuOptions, flags) {
    if (regexpuOptions.unicodeSetsFlag === "transform") {
        flags = flags.replace("v", "u");
    }
    if (regexpuOptions.unicodeFlag === "transform") {
        flags = flags.replace("u", "");
    }
    if (regexpuOptions.dotAllFlag === "transform") {
        flags = flags.replace("s", "");
    }
    return flags;
} //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;
var _regexpuCore = __turbopack_require__("[project]/node_modules/regexpu-core/rewrite-pattern.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _semver = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/node_modules/semver/semver.js [app-ssr] (ecmascript)");
var _features = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/features.js [app-ssr] (ecmascript)");
var _util = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/util.js [app-ssr] (ecmascript)");
const versionKey = "@babel/plugin-regexp-features/version";
function createRegExpFeaturePlugin({ name, feature, options = {}, manipulateOptions = ()=>{} }) {
    return {
        name,
        manipulateOptions,
        pre () {
            var _file$get;
            const { file } = this;
            const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;
            let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);
            const { useUnicodeFlag, runtime } = options;
            if (useUnicodeFlag === false) {
                newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);
            }
            if (newFeatures !== features) {
                file.set(_features.featuresKey, newFeatures);
            }
            if (runtime !== undefined) {
                if (file.has(_features.runtimeKey) && file.get(_features.runtimeKey) !== runtime && (0, _features.hasFeature)(newFeatures, _features.FEATURES.duplicateNamedCaptureGroups)) {
                    throw new Error(`The 'runtime' option must be the same for ` + `'@babel/plugin-transform-named-capturing-groups-regex' and ` + `'@babel/plugin-transform-duplicate-named-capturing-groups-regex'.`);
                }
                if (feature === "namedCaptureGroups") {
                    if (!runtime || !file.has(_features.runtimeKey)) file.set(_features.runtimeKey, runtime);
                } else {
                    file.set(_features.runtimeKey, runtime);
                }
            }
            {
                if (typeof file.get(versionKey) === "number") {
                    file.set(versionKey, "7.26.3");
                    return;
                }
            }
            if (!file.get(versionKey) || _semver.lt(file.get(versionKey), "7.26.3")) {
                file.set(versionKey, "7.26.3");
            }
        },
        visitor: {
            RegExpLiteral (path) {
                var _file$get2, _newFlags;
                const { node } = path;
                const { file } = this;
                const features = file.get(_features.featuresKey);
                const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;
                const regexpuOptions = (0, _util.generateRegexpuOptions)(node.pattern, features);
                if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) {
                    return;
                }
                const namedCaptureGroups = {
                    __proto__: null
                };
                if (regexpuOptions.namedGroups === "transform") {
                    regexpuOptions.onNamedGroup = (name, index)=>{
                        const prev = namedCaptureGroups[name];
                        if (typeof prev === "number") {
                            namedCaptureGroups[name] = [
                                prev,
                                index
                            ];
                        } else if (Array.isArray(prev)) {
                            prev.push(index);
                        } else {
                            namedCaptureGroups[name] = index;
                        }
                    };
                }
                let newFlags;
                if (regexpuOptions.modifiers === "transform") {
                    regexpuOptions.onNewFlags = (flags)=>{
                        newFlags = flags;
                    };
                }
                node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);
                if (regexpuOptions.namedGroups === "transform" && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
                    const call = _core.types.callExpression(this.addHelper("wrapRegExp"), [
                        node,
                        _core.types.valueToNode(namedCaptureGroups)
                    ]);
                    (0, _helperAnnotateAsPure.default)(call);
                    path.replaceWith(call);
                }
                node.flags = (0, _util.transformFlags)(regexpuOptions, (_newFlags = newFlags) != null ? _newFlags : node.flags);
            }
        }
    };
}
function isRegExpTest(path) {
    return path.parentPath.isMemberExpression({
        object: path.node,
        computed: false
    }) && path.parentPath.get("property").isIdentifier({
        name: "test"
    });
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-dotall-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-dotall-regex",
        feature: "dotAllFlag"
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-duplicate-keys/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function getName(key) {
    if (_core.types.isIdentifier(key)) {
        return key.name;
    }
    return key.value.toString();
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-duplicate-keys",
        visitor: {
            ObjectExpression (path) {
                const { node } = path;
                const plainProps = node.properties.filter((prop)=>!_core.types.isSpreadElement(prop) && !prop.computed);
                const alreadySeenData = Object.create(null);
                const alreadySeenGetters = Object.create(null);
                const alreadySeenSetters = Object.create(null);
                for (const prop of plainProps){
                    const name = getName(prop.key);
                    let isDuplicate = false;
                    switch(prop.kind){
                        case "get":
                            if (alreadySeenData[name] || alreadySeenGetters[name]) {
                                isDuplicate = true;
                            }
                            alreadySeenGetters[name] = true;
                            break;
                        case "set":
                            if (alreadySeenData[name] || alreadySeenSetters[name]) {
                                isDuplicate = true;
                            }
                            alreadySeenSetters[name] = true;
                            break;
                        default:
                            if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                                isDuplicate = true;
                            }
                            alreadySeenData[name] = true;
                    }
                    if (isDuplicate) {
                        prop.computed = true;
                        prop.key = _core.types.stringLiteral(name);
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-duplicate-named-capturing-groups-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
    const { runtime } = options;
    if (runtime !== undefined && typeof runtime !== "boolean") {
        throw new Error("The 'runtime' option must be boolean");
    }
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-duplicate-named-capturing-groups-regex",
        feature: "duplicateNamedCaptureGroups",
        options: {
            runtime
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-dynamic-import/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
const SUPPORTED_MODULES = new Set([
    "commonjs",
    "amd",
    "systemjs"
]);
const MODULES_NOT_FOUND = `\
@babel/plugin-transform-dynamic-import depends on a modules
transform plugin. Supported plugins are:
 - @babel/plugin-transform-modules-commonjs ^7.4.0
 - @babel/plugin-transform-modules-amd ^7.4.0
 - @babel/plugin-transform-modules-systemjs ^7.4.0

If you are using Webpack or Rollup and thus don't want
Babel to transpile your imports and exports, you can use
the @babel/plugin-syntax-dynamic-import plugin and let your
bundler handle dynamic imports.
`;
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-dynamic-import",
        manipulateOptions: (_, parser)=>parser.plugins.push("dynamicImport"),
        pre () {
            this.file.set("@babel/plugin-proposal-dynamic-import", "7.25.9");
        },
        visitor: {
            Program () {
                const modules = this.file.get("@babel/plugin-transform-modules-*");
                if (!SUPPORTED_MODULES.has(modules)) {
                    throw new Error(MODULES_NOT_FOUND);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-exponentiation-operator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const { types: t, template } = api;
    function build(left, right) {
        return t.callExpression(t.memberExpression(t.identifier("Math"), t.identifier("pow")), [
            left,
            right
        ]);
    }
    function maybeMemoize(node, scope) {
        if (scope.isStatic(node)) {
            return {
                assign: node,
                ref: t.cloneNode(node)
            };
        }
        if (scope.path.isPattern()) {
            return null;
        }
        const id = scope.generateUidIdentifierBasedOnNode(node);
        scope.push({
            id
        });
        return {
            assign: t.assignmentExpression("=", t.cloneNode(id), node),
            ref: t.cloneNode(id)
        };
    }
    return {
        name: "transform-exponentiation-operator",
        visitor: {
            AssignmentExpression (path) {
                const { node, scope } = path;
                if (node.operator !== "**=") return;
                if (t.isMemberExpression(node.left)) {
                    let member1;
                    let member2;
                    const object = maybeMemoize(node.left.object, scope);
                    if (!object) {
                        path.replaceWith(template.expression.ast`(() => ${path.node})()`);
                        return;
                    }
                    const { property, computed } = node.left;
                    if (computed) {
                        const prop = maybeMemoize(property, scope);
                        member1 = t.memberExpression(object.assign, prop.assign, true);
                        member2 = t.memberExpression(object.ref, prop.ref, true);
                    } else {
                        member1 = t.memberExpression(object.assign, property, false);
                        member2 = t.memberExpression(object.ref, t.cloneNode(property), false);
                    }
                    path.replaceWith(t.assignmentExpression("=", member1, build(member2, node.right)));
                } else {
                    path.replaceWith(t.assignmentExpression("=", node.left, build(t.cloneNode(node.left), node.right)));
                }
            },
            BinaryExpression (path) {
                const { node } = path;
                if (node.operator === "**") {
                    path.replaceWith(build(node.left, node.right));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-export-namespace-from",
        manipulateOptions: (_, parser)=>parser.plugins.push("exportNamespaceFrom"),
        visitor: {
            ExportNamedDeclaration (path) {
                var _exported$name;
                const { node, scope } = path;
                const { specifiers } = node;
                const index = _core.types.isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
                if (!_core.types.isExportNamespaceSpecifier(specifiers[index])) return;
                const nodes = [];
                if (index === 1) {
                    nodes.push(_core.types.exportNamedDeclaration(null, [
                        specifiers.shift()
                    ], node.source));
                }
                const specifier = specifiers.shift();
                const { exported } = specifier;
                const uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
                nodes.push(_core.types.importDeclaration([
                    _core.types.importNamespaceSpecifier(uid)
                ], _core.types.cloneNode(node.source)), _core.types.exportNamedDeclaration(null, [
                    _core.types.exportSpecifier(_core.types.cloneNode(uid), exported)
                ]));
                if (node.specifiers.length >= 1) {
                    nodes.push(node);
                }
                const [importDeclaration] = path.replaceWithMultiple(nodes);
                path.scope.registerDeclaration(importDeclaration);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-for-of/lib/no-helper-implementation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = transformWithoutHelper;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function transformWithoutHelper(loose, path, state) {
    const pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    const { node } = path;
    const build = pushComputedProps(path, state);
    const declar = build.declar;
    const loop = build.loop;
    const block = loop.body;
    path.ensureBlock();
    if (declar) {
        block.body.push(declar);
    }
    block.body.push(...node.body.body);
    _core.types.inherits(loop, node);
    _core.types.inherits(loop.body, node.body);
    if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
        path.remove();
    } else {
        path.replaceWithMultiple(build.node);
    }
}
const buildForOfLoose = _core.template.statement(`
  for (var LOOP_OBJECT = OBJECT,
          IS_ARRAY = Array.isArray(LOOP_OBJECT),
          INDEX = 0,
          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {
    INTERMEDIATE;
    if (IS_ARRAY) {
      if (INDEX >= LOOP_OBJECT.length) break;
      ID = LOOP_OBJECT[INDEX++];
    } else {
      INDEX = LOOP_OBJECT.next();
      if (INDEX.done) break;
      ID = INDEX.value;
    }
  }
`);
const buildForOf = _core.template.statements(`
  var ITERATOR_COMPLETION = true;
  var ITERATOR_HAD_ERROR_KEY = false;
  var ITERATOR_ERROR_KEY = undefined;
  try {
    for (
      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;
      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);
      ITERATOR_COMPLETION = true
    ) {}
  } catch (err) {
    ITERATOR_HAD_ERROR_KEY = true;
    ITERATOR_ERROR_KEY = err;
  } finally {
    try {
      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {
        ITERATOR_KEY.return();
      }
    } finally {
      if (ITERATOR_HAD_ERROR_KEY) {
        throw ITERATOR_ERROR_KEY;
      }
    }
  }
`);
function pushComputedPropsLoose(path, state) {
    const { node, scope, parent } = path;
    const { left } = node;
    let declar, id, intermediate;
    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
        id = left;
        intermediate = null;
    } else if (_core.types.isVariableDeclaration(left)) {
        id = scope.generateUidIdentifier("ref");
        declar = _core.types.variableDeclaration(left.kind, [
            _core.types.variableDeclarator(left.declarations[0].id, _core.types.identifier(id.name))
        ]);
        intermediate = _core.types.variableDeclaration("var", [
            _core.types.variableDeclarator(_core.types.identifier(id.name))
        ]);
    } else {
        throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
    }
    const iteratorKey = scope.generateUidIdentifier("iterator");
    const isArrayKey = scope.generateUidIdentifier("isArray");
    const loop = buildForOfLoose({
        LOOP_OBJECT: iteratorKey,
        IS_ARRAY: isArrayKey,
        OBJECT: node.right,
        INDEX: scope.generateUidIdentifier("i"),
        ID: id,
        INTERMEDIATE: intermediate
    });
    const isLabeledParent = _core.types.isLabeledStatement(parent);
    let labeled;
    if (isLabeledParent) {
        labeled = _core.types.labeledStatement(parent.label, loop);
    }
    return {
        replaceParent: isLabeledParent,
        declar: declar,
        node: labeled || loop,
        loop: loop
    };
}
function pushComputedPropsSpec(path, state) {
    const { node, scope, parent } = path;
    const left = node.left;
    let declar;
    const stepKey = scope.generateUid("step");
    const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
    if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {
        declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
    } else if (_core.types.isVariableDeclaration(left)) {
        declar = _core.types.variableDeclaration(left.kind, [
            _core.types.variableDeclarator(left.declarations[0].id, stepValue)
        ]);
    } else {
        throw state.buildCodeFrameError(left, `Unknown node type ${left.type} in ForStatement`);
    }
    const template = buildForOf({
        ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
        ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
        ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
        ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
        STEP_KEY: _core.types.identifier(stepKey),
        OBJECT: node.right
    });
    const isLabeledParent = _core.types.isLabeledStatement(parent);
    const tryBody = template[3].block.body;
    const loop = tryBody[0];
    if (isLabeledParent) {
        tryBody[0] = _core.types.labeledStatement(parent.label, loop);
    }
    return {
        replaceParent: isLabeledParent,
        declar: declar,
        loop: loop,
        node: template
    };
} //# sourceMappingURL=no-helper-implementation.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-for-of/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _noHelperImplementation = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-for-of/lib/no-helper-implementation.js [app-ssr] (ecmascript)");
var _helperSkipTransparentExpressionWrappers = __turbopack_require__("[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)");
function buildLoopBody(path, declar, newBody) {
    let block;
    const bodyPath = path.get("body");
    const body = newBody != null ? newBody : bodyPath.node;
    if (_core.types.isBlockStatement(body) && Object.keys(path.getBindingIdentifiers()).some((id)=>bodyPath.scope.hasOwnBinding(id))) {
        block = _core.types.blockStatement([
            declar,
            body
        ]);
    } else {
        block = _core.types.toBlock(body);
        block.body.unshift(declar);
    }
    return block;
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _options$assumeArray, _options$allowArrayLi, _api$assumption;
    api.assertVersion(7);
    {
        const { assumeArray, allowArrayLike, loose } = options;
        if (loose === true && assumeArray === true) {
            throw new Error(`The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of`);
        }
        if (assumeArray === true && allowArrayLike === true) {
            throw new Error(`The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of`);
        }
        {
            if (allowArrayLike && /^7\.\d\./.test(api.version)) {
                throw new Error(`The allowArrayLike is only supported when using @babel/core@^7.10.0`);
            }
        }
    }
    const iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
    const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
    const skipIteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;
    if (iterableIsArray && arrayLikeIsIterable) {
        throw new Error(`The "iterableIsArray" and "arrayLikeIsIterable" assumptions are not compatible.`);
    }
    if (iterableIsArray) {
        return {
            name: "transform-for-of",
            visitor: {
                ForOfStatement (path) {
                    const { scope } = path;
                    const { left, await: isAwait } = path.node;
                    if (isAwait) {
                        return;
                    }
                    const right = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(path.node.right);
                    const i = scope.generateUidIdentifier("i");
                    let array = scope.maybeGenerateMemoised(right, true);
                    if (!array && _core.types.isIdentifier(right) && path.get("body").scope.hasOwnBinding(right.name)) {
                        array = scope.generateUidIdentifier("arr");
                    }
                    const inits = [
                        _core.types.variableDeclarator(i, _core.types.numericLiteral(0))
                    ];
                    if (array) {
                        inits.push(_core.types.variableDeclarator(array, right));
                    } else {
                        array = right;
                    }
                    const item = _core.types.memberExpression(_core.types.cloneNode(array), _core.types.cloneNode(i), true);
                    let assignment;
                    if (_core.types.isVariableDeclaration(left)) {
                        assignment = left;
                        assignment.declarations[0].init = item;
                    } else {
                        assignment = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, item));
                    }
                    path.replaceWith(_core.types.forStatement(_core.types.variableDeclaration("let", inits), _core.types.binaryExpression("<", _core.types.cloneNode(i), _core.types.memberExpression(_core.types.cloneNode(array), _core.types.identifier("length"))), _core.types.updateExpression("++", _core.types.cloneNode(i)), buildLoopBody(path, assignment)));
                }
            }
        };
    }
    const buildForOfArray = (0, _core.template)`
    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;
  `;
    const buildForOfNoIteratorClosing = _core.template.statements`
    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;
  `;
    const buildForOf = _core.template.statements`
    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;
    try {
      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;
    } catch (err) {
      ITERATOR_HELPER.e(err);
    } finally {
      ITERATOR_HELPER.f();
    }
  `;
    const builder = skipIteratorClosing ? {
        build: buildForOfNoIteratorClosing,
        helper: "createForOfIteratorHelperLoose",
        getContainer: (nodes)=>nodes
    } : {
        build: buildForOf,
        helper: "createForOfIteratorHelper",
        getContainer: (nodes)=>nodes[1].block.body
    };
    function _ForOfStatementArray(path) {
        const { node, scope } = path;
        const right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
        const iterationKey = scope.generateUidIdentifier("i");
        const loop = buildForOfArray({
            BODY: node.body,
            KEY: iterationKey,
            NAME: right,
            ARR: node.right
        });
        _core.types.inherits(loop, node);
        const iterationValue = _core.types.memberExpression(_core.types.cloneNode(right), _core.types.cloneNode(iterationKey), true);
        let declar;
        const left = node.left;
        if (_core.types.isVariableDeclaration(left)) {
            left.declarations[0].init = iterationValue;
            declar = left;
        } else {
            declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, iterationValue));
        }
        loop.body = buildLoopBody(path, declar, loop.body);
        return loop;
    }
    return {
        name: "transform-for-of",
        visitor: {
            ForOfStatement (path, state) {
                const right = path.get("right");
                if (right.isArrayExpression() || right.isGenericType("Array") || _core.types.isArrayTypeAnnotation(right.getTypeAnnotation())) {
                    path.replaceWith(_ForOfStatementArray(path));
                    return;
                }
                {
                    if (!state.availableHelper(builder.helper)) {
                        (0, _noHelperImplementation.default)(skipIteratorClosing, path, state);
                        return;
                    }
                }
                const { node, parent, scope } = path;
                const left = node.left;
                let declar;
                const stepKey = scope.generateUid("step");
                const stepValue = _core.types.memberExpression(_core.types.identifier(stepKey), _core.types.identifier("value"));
                if (_core.types.isVariableDeclaration(left)) {
                    declar = _core.types.variableDeclaration(left.kind, [
                        _core.types.variableDeclarator(left.declarations[0].id, stepValue)
                    ]);
                } else {
                    declar = _core.types.expressionStatement(_core.types.assignmentExpression("=", left, stepValue));
                }
                const nodes = builder.build({
                    CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
                    ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
                    ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? _core.types.booleanLiteral(true) : null,
                    STEP_KEY: _core.types.identifier(stepKey),
                    OBJECT: node.right,
                    BODY: buildLoopBody(path, declar)
                });
                const container = builder.getContainer(nodes);
                _core.types.inherits(container[0], node);
                _core.types.inherits(container[0].body, node.body);
                if (_core.types.isLabeledStatement(parent)) {
                    container[0] = _core.types.labeledStatement(parent.label, container[0]);
                    path.parentPath.replaceWithMultiple(nodes);
                    path.skip();
                } else {
                    path.replaceWithMultiple(nodes);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-function-name/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    const supportUnicodeId = !(0, _helperCompilationTargets.isRequired)("transform-unicode-escapes", api.targets());
    return {
        name: "transform-function-name",
        visitor: {
            FunctionExpression: {
                exit (path) {
                    if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
                        {
                            var _path$ensureFunctionN;
                            (_path$ensureFunctionN = path.ensureFunctionName) != null ? _path$ensureFunctionN : path.ensureFunctionName = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.ensureFunctionName;
                        }
                        path.ensureFunctionName(supportUnicodeId);
                    }
                }
            },
            ObjectProperty (path) {
                const value = path.get("value");
                if (value.isFunction()) {
                    {
                        var _value$ensureFunction;
                        (_value$ensureFunction = value.ensureFunctionName) != null ? _value$ensureFunction : value.ensureFunctionName = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.ensureFunctionName;
                    }
                    value.ensureFunctionName(supportUnicodeId);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-json-strings/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const regex = /(\\*)([\u2028\u2029])/g;
    function replace(match, escapes, separator) {
        const isEscaped = escapes.length % 2 === 1;
        if (isEscaped) return match;
        return `${escapes}\\u${separator.charCodeAt(0).toString(16)}`;
    }
    return {
        name: "transform-json-strings",
        manipulateOptions: (_, parser)=>parser.plugins.push("jsonStrings"),
        visitor: {
            "DirectiveLiteral|StringLiteral" ({ node }) {
                const { extra } = node;
                if (!(extra != null && extra.raw)) return;
                extra.raw = extra.raw.replace(regex, replace);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-literals/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-literals",
        visitor: {
            NumericLiteral ({ node }) {
                if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
                    node.extra = undefined;
                }
            },
            StringLiteral ({ node }) {
                if (node.extra && /\\u/i.test(node.extra.raw)) {
                    node.extra = undefined;
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-logical-assignment-operators/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return {
        name: "transform-logical-assignment-operators",
        manipulateOptions: (_, parser)=>parser.plugins.push("logicalAssignment"),
        visitor: {
            AssignmentExpression (path) {
                const { node, scope } = path;
                const { operator, left, right } = node;
                const operatorTrunc = operator.slice(0, -1);
                if (!_core.types.LOGICAL_OPERATORS.includes(operatorTrunc)) {
                    return;
                }
                const lhs = _core.types.cloneNode(left);
                if (_core.types.isMemberExpression(left)) {
                    const { object, property, computed } = left;
                    const memo = scope.maybeGenerateMemoised(object);
                    if (memo) {
                        left.object = memo;
                        lhs.object = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), object);
                    }
                    if (computed) {
                        const memo = scope.maybeGenerateMemoised(property);
                        if (memo) {
                            left.property = memo;
                            lhs.property = _core.types.assignmentExpression("=", _core.types.cloneNode(memo), property);
                        }
                    }
                }
                path.replaceWith(_core.types.logicalExpression(operatorTrunc, lhs, _core.types.assignmentExpression("=", left, right)));
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-member-expression-literals/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-member-expression-literals",
        visitor: {
            MemberExpression: {
                exit ({ node }) {
                    const prop = node.property;
                    if (!node.computed && _core.types.isIdentifier(prop) && !_core.types.isValidES3Identifier(prop.name)) {
                        node.property = _core.types.stringLiteral(prop.name);
                        node.computed = true;
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-amd/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const buildWrapper = _core.template.statement(`
  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {
  })
`);
const buildAnonymousWrapper = _core.template.statement(`
  define(["require"], function(REQUIRE) {
  })
`);
function injectWrapper(path, wrapper) {
    const { body, directives } = path.node;
    path.node.directives = [];
    path.node.body = [];
    const amdFactoryCall = path.pushContainer("body", wrapper)[0].get("expression");
    const amdFactoryCallArgs = amdFactoryCall.get("arguments");
    const amdFactory = amdFactoryCallArgs[amdFactoryCallArgs.length - 1].get("body");
    amdFactory.pushContainer("directives", directives);
    amdFactory.pushContainer("body", body);
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion(7);
    const { allowTopLevelThis, strict, strictMode, importInterop, noInterop } = options;
    const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
    const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
    return {
        name: "transform-modules-amd",
        pre () {
            this.file.set("@babel/plugin-transform-modules-*", "amd");
        },
        visitor: {
            ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")] (path, state) {
                if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
                if (path.isCallExpression() && !path.get("callee").isImport()) return;
                let { requireId, resolveId, rejectId } = state;
                if (!requireId) {
                    requireId = path.scope.generateUidIdentifier("require");
                    state.requireId = requireId;
                }
                if (!resolveId || !rejectId) {
                    resolveId = path.scope.generateUidIdentifier("resolve");
                    rejectId = path.scope.generateUidIdentifier("reject");
                    state.resolveId = resolveId;
                    state.rejectId = rejectId;
                }
                let result = _core.types.identifier("imported");
                if (!noInterop) {
                    result = (0, _helperModuleTransforms.wrapInterop)(this.file.path, result, "namespace");
                }
                path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, false, (specifier)=>_core.template.expression.ast`
              new Promise((${resolveId}, ${rejectId}) =>
                ${requireId}(
                  [${specifier}],
                  imported => ${_core.types.cloneNode(resolveId)}(${result}),
                  ${_core.types.cloneNode(rejectId)}
                )
              )
            `));
            },
            Program: {
                exit (path, { requireId }) {
                    if (!(0, _helperModuleTransforms.isModule)(path)) {
                        if (requireId) {
                            injectWrapper(path, buildAnonymousWrapper({
                                REQUIRE: _core.types.cloneNode(requireId)
                            }));
                        }
                        return;
                    }
                    const amdArgs = [];
                    const importNames = [];
                    if (requireId) {
                        amdArgs.push(_core.types.stringLiteral("require"));
                        importNames.push(_core.types.cloneNode(requireId));
                    }
                    let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                    if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
                    const { meta, headers } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                        enumerableModuleMeta,
                        constantReexports,
                        strict,
                        strictMode,
                        allowTopLevelThis,
                        importInterop,
                        noInterop,
                        filename: this.file.opts.filename
                    });
                    if ((0, _helperModuleTransforms.hasExports)(meta)) {
                        amdArgs.push(_core.types.stringLiteral("exports"));
                        importNames.push(_core.types.identifier(meta.exportName));
                    }
                    for (const [source, metadata] of meta.source){
                        amdArgs.push(_core.types.stringLiteral(source));
                        importNames.push(_core.types.identifier(metadata.name));
                        if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                            const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                            if (interop) {
                                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                                header.loc = metadata.loc;
                                headers.push(header);
                            }
                        }
                        headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
                    }
                    (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
                    path.unshiftContainer("body", headers);
                    injectWrapper(path, buildWrapper({
                        MODULE_NAME: moduleName,
                        AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
                        IMPORT_NAMES: importNames
                    }));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-systemjs/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
exports.getExportSpecifierName = getExportSpecifierName;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
var _helperValidatorIdentifier = __turbopack_require__("[project]/node_modules/@babel/helper-validator-identifier/lib/index.js [app-ssr] (ecmascript)");
const buildTemplate = _core.template.statement(`
  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {
    "use strict";
    BEFORE_BODY;
    return {
      setters: SETTERS,
      execute: EXECUTE,
    };
  });
`);
const buildExportAll = _core.template.statement(`
  for (var KEY in TARGET) {
    if (KEY !== "default" && KEY !== "__esModule") EXPORT_OBJ[KEY] = TARGET[KEY];
  }
`);
const MISSING_PLUGIN_WARNING = `\
WARNING: Dynamic import() transformation must be enabled using the
         @babel/plugin-transform-dynamic-import plugin. Babel 8 will
         no longer transform import() without using that plugin.
`;
const MISSING_PLUGIN_ERROR = `\
ERROR: Dynamic import() transformation must be enabled using the
       @babel/plugin-transform-dynamic-import plugin. Babel 8
       no longer transforms import() without using that plugin.
`;
function getExportSpecifierName(node, stringSpecifiers) {
    if (node.type === "Identifier") {
        return node.name;
    } else if (node.type === "StringLiteral") {
        const stringValue = node.value;
        if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
            stringSpecifiers.add(stringValue);
        }
        return stringValue;
    } else {
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);
    }
}
function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
    const statements = [];
    if (!exportStarTarget) {
        if (exportNames.length === 1) {
            statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [
                _core.types.stringLiteral(exportNames[0]),
                exportValues[0]
            ])));
        } else {
            const objectProperties = [];
            for(let i = 0; i < exportNames.length; i++){
                const exportName = exportNames[i];
                const exportValue = exportValues[i];
                objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));
            }
            statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [
                _core.types.objectExpression(objectProperties)
            ])));
        }
    } else {
        const exportObj = path.scope.generateUid("exportObj");
        statements.push(_core.types.variableDeclaration("var", [
            _core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))
        ]));
        statements.push(buildExportAll({
            KEY: path.scope.generateUidIdentifier("key"),
            EXPORT_OBJ: _core.types.identifier(exportObj),
            TARGET: exportStarTarget
        }));
        for(let i = 0; i < exportNames.length; i++){
            const exportName = exportNames[i];
            const exportValue = exportValues[i];
            statements.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));
        }
        statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [
            _core.types.identifier(exportObj)
        ])));
    }
    return statements;
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion(7);
    const { systemGlobal = "System", allowTopLevelThis = false } = options;
    const reassignmentVisited = new WeakSet();
    const reassignmentVisitor = {
        "AssignmentExpression|UpdateExpression" (path) {
            if (reassignmentVisited.has(path.node)) return;
            reassignmentVisited.add(path.node);
            const arg = path.isAssignmentExpression() ? path.get("left") : path.get("argument");
            if (arg.isObjectPattern() || arg.isArrayPattern()) {
                const exprs = [
                    path.node
                ];
                for (const name of Object.keys(arg.getBindingIdentifiers())){
                    if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {
                        return;
                    }
                    const exportedNames = this.exports[name];
                    if (!exportedNames) continue;
                    for (const exportedName of exportedNames){
                        exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);
                    }
                }
                path.replaceWith(_core.types.sequenceExpression(exprs));
                return;
            }
            if (!arg.isIdentifier()) return;
            const name = arg.node.name;
            if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
            const exportedNames = this.exports[name];
            if (!exportedNames) return;
            let node = path.node;
            const isPostUpdateExpression = _core.types.isUpdateExpression(node, {
                prefix: false
            });
            if (isPostUpdateExpression) {
                node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression("+", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));
            }
            for (const exportedName of exportedNames){
                node = this.buildCall(exportedName, node).expression;
            }
            if (isPostUpdateExpression) {
                node = _core.types.sequenceExpression([
                    node,
                    path.node
                ]);
            }
            path.replaceWith(node);
        }
    };
    return {
        name: "transform-modules-systemjs",
        pre () {
            this.file.set("@babel/plugin-transform-modules-*", "systemjs");
        },
        visitor: {
            ["CallExpression" + (api.types.importExpression ? "|ImportExpression" : "")] (path, state) {
                if (path.isCallExpression() && !_core.types.isImport(path.node.callee)) return;
                if (path.isCallExpression()) {
                    if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
                        {
                            console.warn(MISSING_PLUGIN_WARNING);
                        }
                    }
                } else {
                    if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
                        throw new Error(MISSING_PLUGIN_ERROR);
                    }
                }
                path.replaceWith((0, _helperModuleTransforms.buildDynamicImport)(path.node, false, true, (specifier)=>_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("import")), [
                        specifier
                    ])));
            },
            MetaProperty (path, state) {
                if (path.node.meta.name === "import" && path.node.property.name === "meta") {
                    path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("meta")));
                }
            },
            ReferencedIdentifier (path, state) {
                if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
                    path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier("id")));
                }
            },
            Program: {
                enter (path, state) {
                    state.contextIdent = path.scope.generateUid("context");
                    state.stringSpecifiers = new Set();
                    if (!allowTopLevelThis) {
                        (0, _helperModuleTransforms.rewriteThis)(path);
                    }
                },
                exit (path, state) {
                    const scope = path.scope;
                    const exportIdent = scope.generateUid("export");
                    const { contextIdent, stringSpecifiers } = state;
                    const exportMap = Object.create(null);
                    const modules = [];
                    const beforeBody = [];
                    const setters = [];
                    const sources = [];
                    const variableIds = [];
                    const removedPaths = [];
                    function addExportName(key, val) {
                        exportMap[key] = exportMap[key] || [];
                        exportMap[key].push(val);
                    }
                    function pushModule(source, key, specifiers) {
                        let module;
                        modules.forEach(function(m) {
                            if (m.key === source) {
                                module = m;
                            }
                        });
                        if (!module) {
                            modules.push(module = {
                                key: source,
                                imports: [],
                                exports: []
                            });
                        }
                        module[key] = module[key].concat(specifiers);
                    }
                    function buildExportCall(name, val) {
                        return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [
                            _core.types.stringLiteral(name),
                            val
                        ]));
                    }
                    const exportNames = [];
                    const exportValues = [];
                    const body = path.get("body");
                    for (const path of body){
                        if (path.isFunctionDeclaration()) {
                            beforeBody.push(path.node);
                            removedPaths.push(path);
                        } else if (path.isClassDeclaration()) {
                            variableIds.push(_core.types.cloneNode(path.node.id));
                            path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));
                        } else if (path.isVariableDeclaration()) {
                            path.node.kind = "var";
                        } else if (path.isImportDeclaration()) {
                            const source = path.node.source.value;
                            pushModule(source, "imports", path.node.specifiers);
                            for (const name of Object.keys(path.getBindingIdentifiers())){
                                scope.removeBinding(name);
                                variableIds.push(_core.types.identifier(name));
                            }
                            path.remove();
                        } else if (path.isExportAllDeclaration()) {
                            pushModule(path.node.source.value, "exports", path.node);
                            path.remove();
                        } else if (path.isExportDefaultDeclaration()) {
                            const declar = path.node.declaration;
                            if (_core.types.isClassDeclaration(declar)) {
                                const id = declar.id;
                                if (id) {
                                    exportNames.push("default");
                                    exportValues.push(scope.buildUndefinedNode());
                                    variableIds.push(_core.types.cloneNode(id));
                                    addExportName(id.name, "default");
                                    path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(id), _core.types.toExpression(declar))));
                                } else {
                                    exportNames.push("default");
                                    exportValues.push(_core.types.toExpression(declar));
                                    removedPaths.push(path);
                                }
                            } else if (_core.types.isFunctionDeclaration(declar)) {
                                const id = declar.id;
                                if (id) {
                                    beforeBody.push(declar);
                                    exportNames.push("default");
                                    exportValues.push(_core.types.cloneNode(id));
                                    addExportName(id.name, "default");
                                } else {
                                    exportNames.push("default");
                                    exportValues.push(_core.types.toExpression(declar));
                                }
                                removedPaths.push(path);
                            } else {
                                path.replaceWith(buildExportCall("default", declar));
                            }
                        } else if (path.isExportNamedDeclaration()) {
                            const declar = path.node.declaration;
                            if (declar) {
                                path.replaceWith(declar);
                                if (_core.types.isFunction(declar)) {
                                    const name = declar.id.name;
                                    addExportName(name, name);
                                    beforeBody.push(declar);
                                    exportNames.push(name);
                                    exportValues.push(_core.types.cloneNode(declar.id));
                                    removedPaths.push(path);
                                } else if (_core.types.isClass(declar)) {
                                    const name = declar.id.name;
                                    exportNames.push(name);
                                    exportValues.push(scope.buildUndefinedNode());
                                    variableIds.push(_core.types.cloneNode(declar.id));
                                    path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));
                                    addExportName(name, name);
                                } else {
                                    if (_core.types.isVariableDeclaration(declar)) {
                                        declar.kind = "var";
                                    }
                                    for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))){
                                        addExportName(name, name);
                                    }
                                }
                            } else {
                                const specifiers = path.node.specifiers;
                                if (specifiers != null && specifiers.length) {
                                    if (path.node.source) {
                                        pushModule(path.node.source.value, "exports", specifiers);
                                        path.remove();
                                    } else {
                                        const nodes = [];
                                        for (const specifier of specifiers){
                                            const { local, exported } = specifier;
                                            const binding = scope.getBinding(local.name);
                                            const exportedName = getExportSpecifierName(exported, stringSpecifiers);
                                            if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {
                                                exportNames.push(exportedName);
                                                exportValues.push(_core.types.cloneNode(local));
                                            } else if (!binding) {
                                                nodes.push(buildExportCall(exportedName, local));
                                            }
                                            addExportName(local.name, exportedName);
                                        }
                                        path.replaceWithMultiple(nodes);
                                    }
                                } else {
                                    path.remove();
                                }
                            }
                        }
                    }
                    modules.forEach(function(specifiers) {
                        const setterBody = [];
                        const target = scope.generateUid(specifiers.key);
                        for (let specifier of specifiers.imports){
                            if (_core.types.isImportNamespaceSpecifier(specifier)) {
                                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.identifier(target))));
                            } else if (_core.types.isImportDefaultSpecifier(specifier)) {
                                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier("default"));
                            }
                            if (_core.types.isImportSpecifier(specifier)) {
                                const { imported } = specifier;
                                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === "StringLiteral"))));
                            }
                        }
                        if (specifiers.exports.length) {
                            const exportNames = [];
                            const exportValues = [];
                            let hasExportStar = false;
                            for (const node of specifiers.exports){
                                if (_core.types.isExportAllDeclaration(node)) {
                                    hasExportStar = true;
                                } else if (_core.types.isExportSpecifier(node)) {
                                    const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);
                                    exportNames.push(exportedName);
                                    exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));
                                } else {}
                            }
                            setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));
                        }
                        sources.push(_core.types.stringLiteral(specifiers.key));
                        setters.push(_core.types.functionExpression(null, [
                            _core.types.identifier(target)
                        ], _core.types.blockStatement(setterBody)));
                    });
                    let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                    if (moduleName) moduleName = _core.types.stringLiteral(moduleName);
                    {
                        var _path$scope, _path$scope$hoistVari;
                        (_path$scope$hoistVari = (_path$scope = path.scope).hoistVariables) != null ? _path$scope$hoistVari : _path$scope.hoistVariables = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").Scope.prototype.hoistVariables;
                    }
                    path.scope.hoistVariables((id, hasInit)=>{
                        variableIds.push(id);
                        if (!hasInit && id.name in exportMap) {
                            for (const exported of exportMap[id.name]){
                                exportNames.push(exported);
                                exportValues.push(_core.types.buildUndefinedNode());
                            }
                        }
                    });
                    if (variableIds.length) {
                        beforeBody.unshift(_core.types.variableDeclaration("var", variableIds.map((id)=>_core.types.variableDeclarator(id))));
                    }
                    if (exportNames.length) {
                        beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
                    }
                    path.traverse(reassignmentVisitor, {
                        exports: exportMap,
                        buildCall: buildExportCall,
                        scope
                    });
                    for (const path of removedPaths){
                        path.remove();
                    }
                    let hasTLA = false;
                    path.traverse({
                        AwaitExpression (path) {
                            hasTLA = true;
                            path.stop();
                        },
                        Function (path) {
                            path.skip();
                        },
                        noScope: true
                    });
                    path.node.body = [
                        buildTemplate({
                            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier("register")),
                            BEFORE_BODY: beforeBody,
                            MODULE_NAME: moduleName,
                            SETTERS: _core.types.arrayExpression(setters),
                            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),
                            SOURCES: _core.types.arrayExpression(sources),
                            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),
                            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)
                        })
                    ];
                    path.requeue(path.get("body.0"));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-modules-umd/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _path = __turbopack_require__("[externals]/path [external] (path, cjs)");
var _helperModuleTransforms = __turbopack_require__("[project]/node_modules/@babel/helper-module-transforms/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const buildPrerequisiteAssignment = (0, _core.template)(`
  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}
`);
const buildWrapper = (0, _core.template)(`
  (function (global, factory) {
    if (typeof define === "function" && define.amd) {
      define(MODULE_NAME, AMD_ARGUMENTS, factory);
    } else if (typeof exports !== "undefined") {
      factory(COMMONJS_ARGUMENTS);
    } else {
      var mod = { exports: {} };
      factory(BROWSER_ARGUMENTS);

      GLOBAL_TO_ASSIGN;
    }
  })(
    typeof globalThis !== "undefined" ? globalThis
      : typeof self !== "undefined" ? self
      : this,
    function(IMPORT_NAMES) {
  })
`);
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion(7);
    const { globals, exactGlobals, allowTopLevelThis, strict, strictMode, noInterop, importInterop } = options;
    const constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
    const enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
    function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
        const moduleNameOrBasename = moduleName ? moduleName.value : (0, _path.basename)(filename, (0, _path.extname)(filename));
        let globalToAssign = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(moduleNameOrBasename)));
        let initAssignments = [];
        if (exactGlobals) {
            const globalName = browserGlobals[moduleNameOrBasename];
            if (globalName) {
                initAssignments = [];
                const members = globalName.split(".");
                globalToAssign = members.slice(1).reduce((accum, curr)=>{
                    initAssignments.push(buildPrerequisiteAssignment({
                        GLOBAL_REFERENCE: _core.types.cloneNode(accum)
                    }));
                    return _core.types.memberExpression(accum, _core.types.identifier(curr));
                }, _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(members[0])));
            }
        }
        initAssignments.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", globalToAssign, _core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")))));
        return initAssignments;
    }
    function buildBrowserArg(browserGlobals, exactGlobals, source) {
        let memberExpression;
        if (exactGlobals) {
            const globalRef = browserGlobals[source];
            if (globalRef) {
                memberExpression = globalRef.split(".").reduce((accum, curr)=>_core.types.memberExpression(accum, _core.types.identifier(curr)), _core.types.identifier("global"));
            } else {
                memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(source)));
            }
        } else {
            const requireName = (0, _path.basename)(source, (0, _path.extname)(source));
            const globalName = browserGlobals[requireName] || requireName;
            memberExpression = _core.types.memberExpression(_core.types.identifier("global"), _core.types.identifier(_core.types.toIdentifier(globalName)));
        }
        return memberExpression;
    }
    return {
        name: "transform-modules-umd",
        visitor: {
            Program: {
                exit (path) {
                    if (!(0, _helperModuleTransforms.isModule)(path)) return;
                    const browserGlobals = globals || {};
                    const moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);
                    let moduleNameLiteral;
                    if (moduleName) moduleNameLiteral = _core.types.stringLiteral(moduleName);
                    const { meta, headers } = (0, _helperModuleTransforms.rewriteModuleStatementsAndPrepareHeader)(path, {
                        constantReexports,
                        enumerableModuleMeta,
                        strict,
                        strictMode,
                        allowTopLevelThis,
                        noInterop,
                        importInterop,
                        filename: this.file.opts.filename
                    });
                    const amdArgs = [];
                    const commonjsArgs = [];
                    const browserArgs = [];
                    const importNames = [];
                    if ((0, _helperModuleTransforms.hasExports)(meta)) {
                        amdArgs.push(_core.types.stringLiteral("exports"));
                        commonjsArgs.push(_core.types.identifier("exports"));
                        browserArgs.push(_core.types.memberExpression(_core.types.identifier("mod"), _core.types.identifier("exports")));
                        importNames.push(_core.types.identifier(meta.exportName));
                    }
                    for (const [source, metadata] of meta.source){
                        amdArgs.push(_core.types.stringLiteral(source));
                        commonjsArgs.push(_core.types.callExpression(_core.types.identifier("require"), [
                            _core.types.stringLiteral(source)
                        ]));
                        browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
                        importNames.push(_core.types.identifier(metadata.name));
                        if (!(0, _helperModuleTransforms.isSideEffectImport)(metadata)) {
                            const interop = (0, _helperModuleTransforms.wrapInterop)(path, _core.types.identifier(metadata.name), metadata.interop);
                            if (interop) {
                                const header = _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.identifier(metadata.name), interop));
                                header.loc = meta.loc;
                                headers.push(header);
                            }
                        }
                        headers.push(...(0, _helperModuleTransforms.buildNamespaceInitStatements)(meta, metadata, constantReexports));
                    }
                    (0, _helperModuleTransforms.ensureStatementsHoisted)(headers);
                    path.unshiftContainer("body", headers);
                    const { body, directives } = path.node;
                    path.node.directives = [];
                    path.node.body = [];
                    const umdWrapper = path.pushContainer("body", [
                        buildWrapper({
                            MODULE_NAME: moduleNameLiteral,
                            AMD_ARGUMENTS: _core.types.arrayExpression(amdArgs),
                            COMMONJS_ARGUMENTS: commonjsArgs,
                            BROWSER_ARGUMENTS: browserArgs,
                            IMPORT_NAMES: importNames,
                            GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleNameLiteral)
                        })
                    ])[0];
                    const umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
                    umdFactory.pushContainer("directives", directives);
                    umdFactory.pushContainer("body", body);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-named-capturing-groups-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    const { runtime } = options;
    if (runtime !== undefined && typeof runtime !== "boolean") {
        throw new Error("The 'runtime' option must be boolean");
    }
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-named-capturing-groups-regex",
        feature: "namedCaptureGroups",
        options: {
            runtime
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-new-target/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-new-target",
        visitor: {
            MetaProperty (path) {
                const meta = path.get("meta");
                const property = path.get("property");
                const { scope } = path;
                if (meta.isIdentifier({
                    name: "new"
                }) && property.isIdentifier({
                    name: "target"
                })) {
                    const func = path.findParent((path)=>{
                        if (path.isClass()) return true;
                        if (path.isFunction() && !path.isArrowFunctionExpression()) {
                            if (path.isClassMethod({
                                kind: "constructor"
                            })) {
                                return false;
                            }
                            return true;
                        }
                        return false;
                    });
                    if (!func) {
                        throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
                    }
                    const { node } = func;
                    if (_core.types.isMethod(node)) {
                        path.replaceWith(scope.buildUndefinedNode());
                        return;
                    }
                    const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
                    if (func.isClass()) {
                        path.replaceWith(constructor);
                        return;
                    }
                    if (!node.id) {
                        node.id = scope.generateUidIdentifier("target");
                    } else {
                        let scope = path.scope;
                        const name = node.id.name;
                        while(scope !== func.parentPath.scope){
                            if (scope.hasOwnBinding(name) && !scope.bindingIdentifierEquals(name, node.id)) {
                                scope.rename(name);
                            }
                            scope = scope.parent;
                        }
                    }
                    path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, { loose = false })=>{
    var _api$assumption;
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
    return {
        name: "transform-nullish-coalescing-operator",
        manipulateOptions: (_, parser)=>parser.plugins.push("nullishCoalescingOperator"),
        visitor: {
            LogicalExpression (path) {
                const { node, scope } = path;
                if (node.operator !== "??") {
                    return;
                }
                let ref;
                let assignment;
                if (scope.isStatic(node.left)) {
                    ref = node.left;
                    assignment = _core.types.cloneNode(node.left);
                } else if (scope.path.isPattern()) {
                    path.replaceWith(_core.template.statement.ast`(() => ${path.node})()`);
                    return;
                } else {
                    ref = scope.generateUidIdentifierBasedOnNode(node.left);
                    scope.push({
                        id: _core.types.cloneNode(ref)
                    });
                    assignment = _core.types.assignmentExpression("=", ref, node.left);
                }
                path.replaceWith(_core.types.conditionalExpression(noDocumentAll ? _core.types.binaryExpression("!=", assignment, _core.types.nullLiteral()) : _core.types.logicalExpression("&&", _core.types.binaryExpression("!==", assignment, _core.types.nullLiteral()), _core.types.binaryExpression("!==", _core.types.cloneNode(ref), scope.buildUndefinedNode())), _core.types.cloneNode(ref), node.right));
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-numeric-separator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
function remover({ node }) {
    var _extra$raw;
    const { extra } = node;
    if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_")) {
        extra.raw = extra.raw.replace(/_/g, "");
    }
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return {
        name: "transform-numeric-separator",
        manipulateOptions: (_, parser)=>parser.plugins.push("numericSeparator"),
        visitor: {
            NumericLiteral: remover,
            BigIntLiteral: remover
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-parameters/lib/shadow-utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildScopeIIFE = buildScopeIIFE;
exports.collectShadowedParamsNames = collectShadowedParamsNames;
exports.iifeVisitor = void 0;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
const iifeVisitor = exports.iifeVisitor = {
    "ReferencedIdentifier|BindingIdentifier" (path, state) {
        const { scope, node } = path;
        const { name } = node;
        if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
            state.needsOuterBinding = true;
            path.stop();
        }
    },
    "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": (path)=>path.skip()
};
function collectShadowedParamsNames(param, functionScope, shadowedParams) {
    for (const name of Object.keys(param.getBindingIdentifiers())){
        var _functionScope$bindin;
        const constantViolations = (_functionScope$bindin = functionScope.bindings[name]) == null ? void 0 : _functionScope$bindin.constantViolations;
        if (constantViolations) {
            for (const redeclarator of constantViolations){
                const node = redeclarator.node;
                switch(node.type){
                    case "VariableDeclarator":
                        {
                            if (node.init === null) {
                                const declaration = redeclarator.parentPath;
                                if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                                    redeclarator.remove();
                                    break;
                                }
                            }
                            shadowedParams.add(name);
                            break;
                        }
                    case "FunctionDeclaration":
                        shadowedParams.add(name);
                        break;
                }
            }
        }
    }
}
function buildScopeIIFE(shadowedParams, body) {
    const args = [];
    const params = [];
    for (const name of shadowedParams){
        args.push(_core.types.identifier(name));
        params.push(_core.types.identifier(name));
    }
    return _core.types.returnStatement(_core.types.callExpression(_core.types.arrowFunctionExpression(params, body), args));
} //# sourceMappingURL=shadow-utils.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-parameters/lib/params.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = convertFunctionParams;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _shadowUtils = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/shadow-utils.js [app-ssr] (ecmascript)");
const buildDefaultParam = _core.template.statement(`
  let VARIABLE_NAME =
    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?
      arguments[ARGUMENT_KEY]
    :
      DEFAULT_VALUE;
`);
const buildLooseDefaultParam = _core.template.statement(`
  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {
    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;
  }
`);
const buildLooseDestructuredDefaultParam = _core.template.statement(`
  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;
`);
const buildSafeArgumentsAccess = _core.template.statement(`
  let $0 = arguments.length > $1 ? arguments[$1] : undefined;
`);
function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
    const params = path.get("params");
    const isSimpleParameterList = params.every((param)=>param.isIdentifier());
    if (isSimpleParameterList) return false;
    const { node, scope } = path;
    const body = [];
    const shadowedParams = new Set();
    for (const param of params){
        (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);
    }
    const state = {
        needsOuterBinding: false,
        scope
    };
    if (shadowedParams.size === 0) {
        for (const param of params){
            if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);
            if (state.needsOuterBinding) break;
        }
    }
    let firstOptionalIndex = null;
    for(let i = 0; i < params.length; i++){
        const param = params[i];
        if (shouldTransformParam && !shouldTransformParam(i)) {
            continue;
        }
        const transformedRestNodes = [];
        if (replaceRestElement) {
            replaceRestElement(path, param, transformedRestNodes);
        }
        const paramIsAssignmentPattern = param.isAssignmentPattern();
        if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {
            kind: "set"
        }))) {
            const left = param.get("left");
            const right = param.get("right");
            const undefinedNode = scope.buildUndefinedNode();
            if (left.isIdentifier()) {
                body.push(buildLooseDefaultParam({
                    ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),
                    DEFAULT_VALUE: right.node,
                    UNDEFINED: undefinedNode
                }));
                param.replaceWith(left.node);
            } else if (left.isObjectPattern() || left.isArrayPattern()) {
                const paramName = scope.generateUidIdentifier();
                body.push(buildLooseDestructuredDefaultParam({
                    ASSIGNMENT_IDENTIFIER: left.node,
                    DEFAULT_VALUE: right.node,
                    PARAMETER_NAME: _core.types.cloneNode(paramName),
                    UNDEFINED: undefinedNode
                }));
                param.replaceWith(paramName);
            }
        } else if (paramIsAssignmentPattern) {
            if (firstOptionalIndex === null) firstOptionalIndex = i;
            const left = param.get("left");
            const right = param.get("right");
            const defNode = buildDefaultParam({
                VARIABLE_NAME: left.node,
                DEFAULT_VALUE: right.node,
                ARGUMENT_KEY: _core.types.numericLiteral(i)
            });
            body.push(defNode);
        } else if (firstOptionalIndex !== null) {
            const defNode = buildSafeArgumentsAccess([
                param.node,
                _core.types.numericLiteral(i)
            ]);
            body.push(defNode);
        } else if (param.isObjectPattern() || param.isArrayPattern()) {
            const uid = path.scope.generateUidIdentifier("ref");
            uid.typeAnnotation = param.node.typeAnnotation;
            const defNode = _core.types.variableDeclaration("let", [
                _core.types.variableDeclarator(param.node, uid)
            ]);
            body.push(defNode);
            param.replaceWith(_core.types.cloneNode(uid));
        }
        if ("TURBOPACK compile-time truthy", 1) {
            for (const transformedNode of transformedRestNodes){
                body.push(transformedNode);
            }
        }
    }
    if (firstOptionalIndex !== null) {
        node.params = node.params.slice(0, firstOptionalIndex);
    }
    path.ensureBlock();
    const path2 = path;
    const { async, generator } = node;
    if (generator || state.needsOuterBinding || shadowedParams.size > 0) {
        body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path2.node.body));
        path.set("body", _core.types.blockStatement(body));
        const bodyPath = path2.get("body.body");
        const arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
        arrowPath.arrowFunctionToExpression();
        arrowPath.node.generator = generator;
        arrowPath.node.async = async;
        node.generator = false;
        node.async = false;
        if (async) {
            path2.node.body = _core.template.statement.ast`{
        try {
          ${path2.node.body.body}
        } catch (e) {
          return Promise.reject(e);
        }
      }`;
        }
    } else {
        path2.get("body").unshiftContainer("body", body);
    }
    return true;
} //# sourceMappingURL=params.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-parameters/lib/rest.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = convertFunctionRest;
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _shadowUtils = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/shadow-utils.js [app-ssr] (ecmascript)");
const buildRest = _core.template.statement(`
  for (var LEN = ARGUMENTS.length,
           ARRAY = new Array(ARRAY_LEN),
           KEY = START;
       KEY < LEN;
       KEY++) {
    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];
  }
`);
const restIndex = _core.template.expression(`
  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]
`);
const restIndexImpure = _core.template.expression(`
  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]
`);
const restLength = _core.template.expression(`
  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET
`);
function referencesRest(path, state) {
    if (path.node.name === state.name) {
        return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
    }
    return false;
}
const memberExpressionOptimisationVisitor = {
    Scope (path, state) {
        if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
            path.skip();
        }
    },
    Flow (path) {
        if (path.isTypeCastExpression()) return;
        path.skip();
    },
    Function (path, state) {
        const oldNoOptimise = state.noOptimise;
        state.noOptimise = true;
        path.traverse(memberExpressionOptimisationVisitor, state);
        state.noOptimise = oldNoOptimise;
        path.skip();
    },
    ReferencedIdentifier (path, state) {
        const { node } = path;
        if (node.name === "arguments") {
            state.deopted = true;
        }
        if (!referencesRest(path, state)) return;
        if (state.noOptimise) {
            state.deopted = true;
        } else {
            const { parentPath } = path;
            if (parentPath.listKey === "params" && parentPath.key < state.offset) {
                return;
            }
            if (parentPath.isMemberExpression({
                object: node
            })) {
                const grandparentPath = parentPath.parentPath;
                const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
                    operator: "delete"
                }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);
                if (argsOptEligible) {
                    if (parentPath.node.computed) {
                        if (parentPath.get("property").isBaseType("number")) {
                            state.candidates.push({
                                cause: "indexGetter",
                                path
                            });
                            return;
                        }
                    } else if (parentPath.node.property.name === "length") {
                        state.candidates.push({
                            cause: "lengthGetter",
                            path
                        });
                        return;
                    }
                }
            }
            if (state.offset === 0 && parentPath.isSpreadElement()) {
                const call = parentPath.parentPath;
                if (call.isCallExpression() && call.node.arguments.length === 1) {
                    state.candidates.push({
                        cause: "argSpread",
                        path
                    });
                    return;
                }
            }
            state.references.push(path);
        }
    },
    BindingIdentifier (path, state) {
        if (referencesRest(path, state)) {
            state.deopted = true;
        }
    }
};
function getParamsCount(node) {
    let count = node.params.length;
    if (count > 0 && _core.types.isIdentifier(node.params[0], {
        name: "this"
    })) {
        count -= 1;
    }
    return count;
}
function hasRest(node) {
    const length = node.params.length;
    return length > 0 && _core.types.isRestElement(node.params[length - 1]);
}
function optimiseIndexGetter(path, argsId, offset) {
    const offsetLiteral = _core.types.numericLiteral(offset);
    let index;
    const parent = path.parent;
    if (_core.types.isNumericLiteral(parent.property)) {
        index = _core.types.numericLiteral(parent.property.value + offset);
    } else if (offset === 0) {
        index = parent.property;
    } else {
        index = _core.types.binaryExpression("+", parent.property, _core.types.cloneNode(offsetLiteral));
    }
    const { scope, parentPath } = path;
    if (!scope.isPure(index)) {
        const temp = scope.generateUidIdentifierBasedOnNode(index);
        scope.push({
            id: temp,
            kind: "var"
        });
        parentPath.replaceWith(restIndexImpure({
            ARGUMENTS: argsId,
            OFFSET: offsetLiteral,
            INDEX: index,
            REF: _core.types.cloneNode(temp)
        }));
    } else {
        parentPath.replaceWith(restIndex({
            ARGUMENTS: argsId,
            OFFSET: offsetLiteral,
            INDEX: index
        }));
        const replacedParentPath = parentPath;
        const offsetTestPath = replacedParentPath.get("test");
        const valRes = offsetTestPath.get("left").evaluate();
        if (valRes.confident) {
            if (valRes.value === true) {
                replacedParentPath.replaceWith(scope.buildUndefinedNode());
            } else {
                offsetTestPath.replaceWith(offsetTestPath.get("right"));
            }
        }
    }
}
function optimiseLengthGetter(path, argsId, offset) {
    if (offset) {
        path.parentPath.replaceWith(restLength({
            ARGUMENTS: argsId,
            OFFSET: _core.types.numericLiteral(offset)
        }));
    } else {
        path.replaceWith(argsId);
    }
}
function convertFunctionRest(path) {
    const { node, scope } = path;
    if (!hasRest(node)) return false;
    const restPath = path.get(`params.${node.params.length - 1}.argument`);
    if (!restPath.isIdentifier()) {
        const shadowedParams = new Set();
        (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);
        let needsIIFE = shadowedParams.size > 0;
        if (!needsIIFE) {
            const state = {
                needsOuterBinding: false,
                scope
            };
            restPath.traverse(_shadowUtils.iifeVisitor, state);
            needsIIFE = state.needsOuterBinding;
        }
        if (needsIIFE) {
            path.ensureBlock();
            path.set("body", _core.types.blockStatement([
                (0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)
            ]));
        }
    }
    let rest = restPath.node;
    node.params.pop();
    if (_core.types.isPattern(rest)) {
        const pattern = rest;
        rest = scope.generateUidIdentifier("ref");
        const declar = _core.types.variableDeclaration("let", [
            _core.types.variableDeclarator(pattern, rest)
        ]);
        path.ensureBlock();
        node.body.body.unshift(declar);
    } else if (rest.name === "arguments") {
        scope.rename(rest.name);
    }
    const argsId = _core.types.identifier("arguments");
    const paramsCount = getParamsCount(node);
    const state = {
        references: [],
        offset: paramsCount,
        argumentsNode: argsId,
        outerBinding: scope.getBindingIdentifier(rest.name),
        candidates: [],
        name: rest.name,
        deopted: false
    };
    path.traverse(memberExpressionOptimisationVisitor, state);
    if (!state.deopted && !state.references.length) {
        for (const { path, cause } of state.candidates){
            const clonedArgsId = _core.types.cloneNode(argsId);
            switch(cause){
                case "indexGetter":
                    optimiseIndexGetter(path, clonedArgsId, state.offset);
                    break;
                case "lengthGetter":
                    optimiseLengthGetter(path, clonedArgsId, state.offset);
                    break;
                default:
                    path.replaceWith(clonedArgsId);
            }
        }
        return true;
    }
    state.references.push(...state.candidates.map(({ path })=>path));
    const start = _core.types.numericLiteral(paramsCount);
    const key = scope.generateUidIdentifier("key");
    const len = scope.generateUidIdentifier("len");
    let arrKey, arrLen;
    if (paramsCount) {
        arrKey = _core.types.binaryExpression("-", _core.types.cloneNode(key), _core.types.cloneNode(start));
        arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(">", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression("-", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));
    } else {
        arrKey = _core.types.identifier(key.name);
        arrLen = _core.types.identifier(len.name);
    }
    const loop = buildRest({
        ARGUMENTS: argsId,
        ARRAY_KEY: arrKey,
        ARRAY_LEN: arrLen,
        START: start,
        ARRAY: rest,
        KEY: key,
        LEN: len
    });
    if (state.deopted) {
        node.body.body.unshift(loop);
    } else {
        let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
        target.findParent((path)=>{
            if (path.isLoop()) {
                target = path;
            } else {
                return path.isFunction();
            }
        });
        target.insertBefore(loop);
    }
    return true;
} //# sourceMappingURL=rest.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-parameters/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "convertFunctionParams", {
    enumerable: true,
    get: function() {
        return _params.default;
    }
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _params = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/params.js [app-ssr] (ecmascript)");
var _rest = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/rest.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion(7);
    const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose;
    const noNewArrows = (_api$assumption2 = api.assumption("noNewArrows")) != null ? _api$assumption2 : true;
    return {
        name: "transform-parameters",
        visitor: {
            Function (path) {
                if (path.isArrowFunctionExpression() && path.get("params").some((param)=>param.isRestElement() || param.isAssignmentPattern())) {
                    path.arrowFunctionToExpression({
                        allowInsertArrowWithRest: false,
                        noNewArrows
                    });
                    if (!path.isFunctionExpression()) return;
                }
                const convertedRest = (0, _rest.default)(path);
                const convertedParams = (0, _params.default)(path, ignoreFunctionLength);
                if (convertedRest || convertedParams) {
                    path.scope.crawl();
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-object-rest-spread/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var pluginTransformParameters = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-parameters/lib/index.js [app-ssr] (ecmascript)");
var helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
function shouldStoreRHSInTemporaryVariable(node) {
    if (!node) return false;
    if (node.type === "ArrayPattern") {
        const nonNullElements = node.elements.filter((element)=>element !== null);
        if (nonNullElements.length > 1) return true;
        else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);
    } else if (node.type === "ObjectPattern") {
        const { properties } = node;
        if (properties.length > 1) return true;
        else if (properties.length === 0) return false;
        else {
            const firstProperty = properties[0];
            if (firstProperty.type === "ObjectProperty") {
                return shouldStoreRHSInTemporaryVariable(firstProperty.value);
            } else {
                return shouldStoreRHSInTemporaryVariable(firstProperty);
            }
        }
    } else if (node.type === "AssignmentPattern") {
        return shouldStoreRHSInTemporaryVariable(node.left);
    } else if (node.type === "RestElement") {
        if (node.argument.type === "Identifier") return true;
        return shouldStoreRHSInTemporaryVariable(node.argument);
    } else {
        return false;
    }
}
var compatData = {
    "Object.assign": {
        chrome: "49",
        opera: "36",
        edge: "13",
        firefox: "36",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "36",
        electron: "0.37"
    }
};
const { isAssignmentPattern, isObjectProperty } = core.types;
{
    const node = core.types.identifier("a");
    const property = core.types.objectProperty(core.types.identifier("key"), node);
    const pattern = core.types.objectPattern([
        property
    ]);
    var ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;
}var index = helperPluginUtils.declare((api, opts)=>{
    var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const targets = api.targets();
    const supportsObjectAssign = !helperCompilationTargets.isRequired("Object.assign", targets, {
        compatData
    });
    const { useBuiltIns = supportsObjectAssign, loose = false } = opts;
    if (typeof loose !== "boolean") {
        throw new Error(".loose must be a boolean, or undefined");
    }
    const ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose;
    const objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose;
    const pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose;
    const setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;
    function getExtendsHelper(file) {
        return useBuiltIns ? core.types.memberExpression(core.types.identifier("Object"), core.types.identifier("assign")) : file.addHelper("extends");
    }
    function hasRestElement(path) {
        let foundRestElement = false;
        visitRestElements(path, (restElement)=>{
            foundRestElement = true;
            restElement.stop();
        });
        return foundRestElement;
    }
    function hasObjectPatternRestElement(path) {
        let foundRestElement = false;
        visitRestElements(path, (restElement)=>{
            if (restElement.parentPath.isObjectPattern()) {
                foundRestElement = true;
                restElement.stop();
            }
        });
        return foundRestElement;
    }
    function visitRestElements(path, visitor) {
        path.traverse({
            Expression (path) {
                const { parent, key } = path;
                if (isAssignmentPattern(parent) && key === "right" || isObjectProperty(parent) && parent.computed && key === "key") {
                    path.skip();
                }
            },
            RestElement: visitor
        });
    }
    function hasSpread(node) {
        for (const prop of node.properties){
            if (core.types.isSpreadElement(prop)) {
                return true;
            }
        }
        return false;
    }
    function extractNormalizedKeys(node) {
        const props = node.properties;
        const keys = [];
        let allPrimitives = true;
        let hasTemplateLiteral = false;
        for (const prop of props){
            const { key } = prop;
            if (core.types.isIdentifier(key) && !prop.computed) {
                keys.push(core.types.stringLiteral(key.name));
            } else if (core.types.isTemplateLiteral(key)) {
                keys.push(core.types.cloneNode(key));
                hasTemplateLiteral = true;
            } else if (core.types.isLiteral(key)) {
                keys.push(core.types.stringLiteral(String(key.value)));
            } else {
                keys.push(core.types.cloneNode(key));
                if (core.types.isMemberExpression(key, {
                    computed: false
                }) && core.types.isIdentifier(key.object, {
                    name: "Symbol"
                }) || core.types.isCallExpression(key) && core.types.matchesPattern(key.callee, "Symbol.for")) ;
                else {
                    allPrimitives = false;
                }
            }
        }
        return {
            keys,
            allPrimitives,
            hasTemplateLiteral
        };
    }
    function replaceImpureComputedKeys(properties, scope) {
        const impureComputedPropertyDeclarators = [];
        for (const propPath of properties){
            const key = propPath.get("key");
            if (propPath.node.computed && !key.isPure()) {
                const name = scope.generateUidBasedOnNode(key.node);
                const declarator = core.types.variableDeclarator(core.types.identifier(name), key.node);
                impureComputedPropertyDeclarators.push(declarator);
                key.replaceWith(core.types.identifier(name));
            }
        }
        return impureComputedPropertyDeclarators;
    }
    function removeUnusedExcludedKeys(path) {
        const bindings = path.getOuterBindingIdentifierPaths();
        Object.keys(bindings).forEach((bindingName)=>{
            const bindingParentPath = bindings[bindingName].parentPath;
            if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
                return;
            }
            bindingParentPath.remove();
        });
    }
    function createObjectRest(path, file, objRef) {
        const props = path.get("properties");
        const last = props[props.length - 1];
        core.types.assertRestElement(last.node);
        const restElement = core.types.cloneNode(last.node);
        last.remove();
        const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);
        const { keys, allPrimitives, hasTemplateLiteral } = extractNormalizedKeys(path.node);
        if (keys.length === 0) {
            return [
                impureComputedPropertyDeclarators,
                restElement.argument,
                core.types.callExpression(getExtendsHelper(file), [
                    core.types.objectExpression([]),
                    core.types.sequenceExpression([
                        core.types.callExpression(file.addHelper("objectDestructuringEmpty"), [
                            core.types.cloneNode(objRef)
                        ]),
                        core.types.cloneNode(objRef)
                    ])
                ])
            ];
        }
        let keyExpression;
        if (!allPrimitives) {
            keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier("map")), [
                file.addHelper("toPropertyKey")
            ]);
        } else {
            keyExpression = core.types.arrayExpression(keys);
            if (!hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {
                const program = path.findParent((path)=>path.isProgram());
                const id = path.scope.generateUidIdentifier("excluded");
                program.scope.push({
                    id,
                    init: keyExpression,
                    kind: "const"
                });
                keyExpression = core.types.cloneNode(id);
            }
        }
        return [
            impureComputedPropertyDeclarators,
            restElement.argument,
            core.types.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? "Loose" : ""}`), [
                core.types.cloneNode(objRef),
                keyExpression
            ])
        ];
    }
    function replaceRestElement(parentPath, paramPath, container) {
        if (paramPath.isAssignmentPattern()) {
            replaceRestElement(parentPath, paramPath.get("left"), container);
            return;
        }
        if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
            const elements = paramPath.get("elements");
            for(let i = 0; i < elements.length; i++){
                replaceRestElement(parentPath, elements[i], container);
            }
        }
        if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
            const uid = parentPath.scope.generateUidIdentifier("ref");
            const declar = core.types.variableDeclaration("let", [
                core.types.variableDeclarator(paramPath.node, uid)
            ]);
            if (container) {
                container.push(declar);
            } else {
                parentPath.ensureBlock();
                parentPath.get("body").unshiftContainer("body", declar);
            }
            paramPath.replaceWith(core.types.cloneNode(uid));
        }
    }
    return {
        name: "transform-object-rest-spread",
        manipulateOptions: (_, parser)=>parser.plugins.push("objectRestSpread"),
        visitor: {
            Function (path) {
                const params = path.get("params");
                const paramsWithRestElement = new Set();
                const idsInRestParams = new Set();
                for(let i = 0; i < params.length; ++i){
                    const param = params[i];
                    if (hasRestElement(param)) {
                        paramsWithRestElement.add(i);
                        for (const name of Object.keys(param.getBindingIdentifiers())){
                            idsInRestParams.add(name);
                        }
                    }
                }
                let idInRest = false;
                const IdentifierHandler = function(path, functionScope) {
                    const name = path.node.name;
                    if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
                        idInRest = true;
                        path.stop();
                    }
                };
                let i;
                for(i = 0; i < params.length && !idInRest; ++i){
                    const param = params[i];
                    if (!paramsWithRestElement.has(i)) {
                        if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {
                            IdentifierHandler(param, path.scope);
                        } else {
                            param.traverse({
                                "Scope|TypeAnnotation|TSTypeAnnotation": (path)=>path.skip(),
                                "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                            }, path.scope);
                        }
                    }
                }
                if (!idInRest) {
                    for(let i = 0; i < params.length; ++i){
                        const param = params[i];
                        if (paramsWithRestElement.has(i)) {
                            replaceRestElement(path, param);
                        }
                    }
                } else {
                    const shouldTransformParam = (idx)=>idx >= i - 1 || paramsWithRestElement.has(idx);
                    pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
                }
            },
            VariableDeclarator (path, file) {
                if (!path.get("id").isObjectPattern()) {
                    return;
                }
                let insertionPath = path;
                const originalPath = path;
                visitRestElements(path.get("id"), (path)=>{
                    if (!path.parentPath.isObjectPattern()) {
                        return;
                    }
                    if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {
                        const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
                        originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init));
                        originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));
                        return;
                    }
                    let ref = originalPath.node.init;
                    const refPropertyPath = [];
                    let kind;
                    path.findParent((path)=>{
                        if (path.isObjectProperty()) {
                            refPropertyPath.unshift(path);
                        } else if (path.isVariableDeclarator()) {
                            kind = path.parentPath.node.kind;
                            return true;
                        }
                    });
                    const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
                    refPropertyPath.forEach((prop)=>{
                        const { node } = prop;
                        ref = core.types.memberExpression(ref, core.types.cloneNode(node.key), node.computed || core.types.isLiteral(node.key));
                    });
                    const objectPatternPath = path.findParent((path)=>path.isObjectPattern());
                    const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);
                    if (pureGetters) {
                        removeUnusedExcludedKeys(objectPatternPath);
                    }
                    core.types.assertIdentifier(argument);
                    insertionPath.insertBefore(impureComputedPropertyDeclarators);
                    insertionPath.insertBefore(impureObjRefComputedDeclarators);
                    insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0];
                    path.scope.registerBinding(kind, insertionPath);
                    if (objectPatternPath.node.properties.length === 0) {
                        objectPatternPath.findParent((path)=>path.isObjectProperty() || path.isVariableDeclarator()).remove();
                    }
                });
            },
            ExportNamedDeclaration (path) {
                const declaration = path.get("declaration");
                if (!declaration.isVariableDeclaration()) return;
                const hasRest = declaration.get("declarations").some((path)=>hasObjectPatternRestElement(path.get("id")));
                if (!hasRest) return;
                const specifiers = [];
                for (const name of Object.keys(path.getOuterBindingIdentifiers(true))){
                    specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));
                }
                path.replaceWith(declaration.node);
                path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));
            },
            CatchClause (path) {
                const paramPath = path.get("param");
                replaceRestElement(path, paramPath);
            },
            AssignmentExpression (path, file) {
                const leftPath = path.get("left");
                if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
                    const nodes = [];
                    const refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
                    nodes.push(core.types.variableDeclaration("var", [
                        core.types.variableDeclarator(core.types.identifier(refName), path.node.right)
                    ]));
                    const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));
                    if (impureComputedPropertyDeclarators.length > 0) {
                        nodes.push(core.types.variableDeclaration("var", impureComputedPropertyDeclarators));
                    }
                    const nodeWithoutSpread = core.types.cloneNode(path.node);
                    nodeWithoutSpread.right = core.types.identifier(refName);
                    nodes.push(core.types.expressionStatement(nodeWithoutSpread));
                    nodes.push(core.types.expressionStatement(core.types.assignmentExpression("=", argument, callExpression)));
                    nodes.push(core.types.expressionStatement(core.types.identifier(refName)));
                    path.replaceWithMultiple(nodes);
                }
            },
            ForXStatement (path) {
                const { node, scope } = path;
                const leftPath = path.get("left");
                const left = node.left;
                if (!hasObjectPatternRestElement(leftPath)) {
                    return;
                }
                if (!core.types.isVariableDeclaration(left)) {
                    const temp = scope.generateUidIdentifier("ref");
                    node.left = core.types.variableDeclaration("var", [
                        core.types.variableDeclarator(temp)
                    ]);
                    path.ensureBlock();
                    const body = path.node.body;
                    if (body.body.length === 0 && path.isCompletionRecord()) {
                        body.body.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));
                    }
                    body.body.unshift(core.types.expressionStatement(core.types.assignmentExpression("=", left, core.types.cloneNode(temp))));
                } else {
                    const pattern = left.declarations[0].id;
                    const key = scope.generateUidIdentifier("ref");
                    node.left = core.types.variableDeclaration(left.kind, [
                        core.types.variableDeclarator(key, null)
                    ]);
                    path.ensureBlock();
                    const body = node.body;
                    body.body.unshift(core.types.variableDeclaration(node.left.kind, [
                        core.types.variableDeclarator(pattern, core.types.cloneNode(key))
                    ]));
                }
            },
            ArrayPattern (path) {
                const objectPatterns = [];
                visitRestElements(path, (path)=>{
                    if (!path.parentPath.isObjectPattern()) {
                        return;
                    }
                    const objectPattern = path.parentPath;
                    const uid = path.scope.generateUidIdentifier("ref");
                    objectPatterns.push(core.types.variableDeclarator(objectPattern.node, uid));
                    objectPattern.replaceWith(core.types.cloneNode(uid));
                    path.skip();
                });
                if (objectPatterns.length > 0) {
                    const statementPath = path.getStatementParent();
                    const statementNode = statementPath.node;
                    const kind = statementNode.type === "VariableDeclaration" ? statementNode.kind : "var";
                    statementPath.insertAfter(core.types.variableDeclaration(kind, objectPatterns));
                }
            },
            ObjectExpression (path, file) {
                if (!hasSpread(path.node)) return;
                let helper;
                if (setSpreadProperties) {
                    helper = getExtendsHelper(file);
                } else {
                    {
                        try {
                            helper = file.addHelper("objectSpread2");
                        } catch (_unused) {
                            this.file.declarations["objectSpread2"] = null;
                            helper = file.addHelper("objectSpread");
                        }
                    }
                }
                let exp = null;
                let props = [];
                function make() {
                    const hadProps = props.length > 0;
                    const obj = core.types.objectExpression(props);
                    props = [];
                    if (!exp) {
                        exp = core.types.callExpression(helper, [
                            obj
                        ]);
                        return;
                    }
                    if (pureGetters) {
                        if (hadProps) {
                            exp.arguments.push(obj);
                        }
                        return;
                    }
                    exp = core.types.callExpression(core.types.cloneNode(helper), [
                        exp,
                        ...hadProps ? [
                            core.types.objectExpression([]),
                            obj
                        ] : []
                    ]);
                }
                for (const prop of path.node.properties){
                    if (core.types.isSpreadElement(prop)) {
                        make();
                        exp.arguments.push(prop.argument);
                    } else {
                        props.push(prop);
                    }
                }
                if (props.length) make();
                path.replaceWith(exp);
            }
        }
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-object-super/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperReplaceSupers = __turbopack_require__("[project]/node_modules/@babel/helper-replace-supers/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function replacePropertySuper(path, getObjectRef, file) {
    const replaceSupers = new _helperReplaceSupers.default({
        getObjectRef: getObjectRef,
        methodPath: path,
        file: file
    });
    replaceSupers.replace();
}
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    const newLets = new Set();
    return {
        name: "transform-object-super",
        visitor: {
            Loop: {
                exit (path) {
                    newLets.forEach((v)=>{
                        if (v.scopePath === path) {
                            path.scope.push({
                                id: v.id,
                                kind: "let"
                            });
                            path.scope.crawl();
                            path.requeue();
                            newLets.delete(v);
                        }
                    });
                }
            },
            ObjectExpression (path, state) {
                let objectRef;
                const getObjectRef = ()=>objectRef = objectRef || path.scope.generateUidIdentifier("obj");
                path.get("properties").forEach((propPath)=>{
                    if (!propPath.isMethod()) return;
                    replacePropertySuper(propPath, getObjectRef, state.file);
                });
                if (objectRef) {
                    const scopePath = path.findParent((p)=>p.isFunction() || p.isProgram() || p.isLoop());
                    const useLet = scopePath.isLoop();
                    if (useLet) {
                        newLets.add({
                            scopePath,
                            id: _core.types.cloneNode(objectRef)
                        });
                    } else {
                        path.scope.push({
                            id: _core.types.cloneNode(objectRef),
                            kind: "var"
                        });
                    }
                    path.replaceWith(_core.types.assignmentExpression("=", _core.types.cloneNode(objectRef), path.node));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-optional-catch-binding/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return {
        name: "transform-optional-catch-binding",
        manipulateOptions: (_, parser)=>parser.plugins.push("optionalCatchBinding"),
        visitor: {
            CatchClause (path) {
                if (!path.node.param) {
                    const uid = path.scope.generateUidIdentifier("unused");
                    const paramPath = path.get("param");
                    paramPath.replaceWith(uid);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var helperSkipTransparentExpressionWrappers = __turbopack_require__("[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)");
function willPathCastToBoolean(path) {
    const maybeWrapped = findOutermostTransparentParent(path);
    const { node, parentPath } = maybeWrapped;
    if (parentPath.isLogicalExpression()) {
        const { operator, right } = parentPath.node;
        if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
            return willPathCastToBoolean(parentPath);
        }
    }
    if (parentPath.isSequenceExpression()) {
        const { expressions } = parentPath.node;
        if (expressions[expressions.length - 1] === node) {
            return willPathCastToBoolean(parentPath);
        } else {
            return true;
        }
    }
    return parentPath.isConditional({
        test: node
    }) || parentPath.isUnaryExpression({
        operator: "!"
    }) || parentPath.isLoop({
        test: node
    });
}
function findOutermostTransparentParent(path) {
    let maybeWrapped = path;
    path.findParent((p)=>{
        if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;
        maybeWrapped = p;
    });
    return maybeWrapped;
}
const last = (arr)=>arr[arr.length - 1];
function isSimpleMemberExpression(expression) {
    expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);
    return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
}
function needsMemoize(path) {
    let optionalPath = path;
    const { scope } = path;
    while(optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()){
        const { node } = optionalPath;
        const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get("object") : optionalPath.get("callee"));
        if (node.optional) {
            return !scope.isStatic(childPath.node);
        }
        optionalPath = childPath;
    }
}
const NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);
const NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);
const NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);
const NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);
function transformOptionalChain(path, { pureGetters, noDocumentAll }, replacementPath, ifNullish, wrapLast) {
    const { scope } = path;
    if (scope.path.isPattern() && needsMemoize(path)) {
        replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node})()`);
        return;
    }
    const optionals = [];
    let optionalPath = path;
    while(optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()){
        const { node } = optionalPath;
        if (node.optional) {
            optionals.push(node);
        }
        if (optionalPath.isOptionalMemberExpression()) {
            optionalPath.node.type = "MemberExpression";
            optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
        } else if (optionalPath.isOptionalCallExpression()) {
            optionalPath.node.type = "CallExpression";
            optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
        }
    }
    if (optionals.length === 0) {
        return;
    }
    const checks = [];
    let tmpVar;
    for(let i = optionals.length - 1; i >= 0; i--){
        const node = optionals[i];
        const isCall = core.types.isCallExpression(node);
        const chainWithTypes = isCall ? node.callee : node.object;
        const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
        let ref;
        let check;
        if (isCall && core.types.isIdentifier(chain, {
            name: "eval"
        })) {
            check = ref = chain;
            node.callee = core.types.sequenceExpression([
                core.types.numericLiteral(0),
                ref
            ]);
        } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
            check = ref = node.callee;
        } else if (scope.isStatic(chain)) {
            check = ref = chainWithTypes;
        } else {
            if (!tmpVar || isCall) {
                tmpVar = scope.generateUidIdentifierBasedOnNode(chain);
                scope.push({
                    id: core.types.cloneNode(tmpVar)
                });
            }
            ref = tmpVar;
            check = core.types.assignmentExpression("=", core.types.cloneNode(tmpVar), chainWithTypes);
            if (isCall) {
                node.callee = ref;
            } else {
                node.object = ref;
            }
        }
        if (isCall && core.types.isMemberExpression(chain)) {
            if (pureGetters && isSimpleMemberExpression(chain)) {
                node.callee = chainWithTypes;
            } else {
                const { object } = chain;
                let context;
                if (core.types.isSuper(object)) {
                    context = core.types.thisExpression();
                } else {
                    const memoized = scope.maybeGenerateMemoised(object);
                    if (memoized) {
                        context = memoized;
                        chain.object = core.types.assignmentExpression("=", memoized, object);
                    } else {
                        context = object;
                    }
                }
                node.arguments.unshift(core.types.cloneNode(context));
                node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
            }
        }
        const data = {
            check: core.types.cloneNode(check),
            ref: core.types.cloneNode(ref)
        };
        Object.defineProperty(data, "ref", {
            enumerable: false
        });
        checks.push(data);
    }
    let result = replacementPath.node;
    if (wrapLast) result = wrapLast(result);
    const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);
    const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;
    const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {
        operator: "void"
    });
    const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;
    const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;
    const logicalOp = ifNullishFalse ? "&&" : "||";
    const check = checks.map(tpl).reduce((expr, check)=>core.types.logicalExpression(logicalOp, expr, check));
    replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));
}
function transform(path, assumptions) {
    const { scope } = path;
    const maybeWrapped = findOutermostTransparentParent(path);
    const { parentPath } = maybeWrapped;
    if (parentPath.isUnaryExpression({
        operator: "delete"
    })) {
        transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));
    } else {
        let wrapLast;
        if (parentPath.isCallExpression({
            callee: maybeWrapped.node
        }) && path.isOptionalMemberExpression()) {
            wrapLast = (replacement)=>{
                var _baseRef;
                const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
                let baseRef;
                if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {
                    baseRef = scope.maybeGenerateMemoised(object);
                    if (baseRef) {
                        replacement.object = core.types.assignmentExpression("=", baseRef, object);
                    }
                }
                return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [
                    core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)
                ]);
            };
        }
        transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);
    }
}
var index = helperPluginUtils.declare((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const { loose = false } = options;
    const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
    const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
    return {
        name: "transform-optional-chaining",
        manipulateOptions: (_, parser)=>parser.plugins.push("optionalChaining"),
        visitor: {
            "OptionalCallExpression|OptionalMemberExpression" (path) {
                transform(path, {
                    noDocumentAll,
                    pureGetters
                });
            }
        }
    };
});
exports.default = index;
exports.transform = transform;
exports.transformOptionalChain = transformOptionalChain; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-private-methods/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCreateClassFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-class-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return (0, _helperCreateClassFeaturesPlugin.createClassFeaturePlugin)({
        name: "transform-private-methods",
        api,
        feature: _helperCreateClassFeaturesPlugin.FEATURES.privateMethods,
        loose: options.loose,
        manipulateOptions (opts, parserOpts) {
            {
                parserOpts.plugins.push("classPrivateMethods");
            }
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-private-property-in-object/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCreateClassFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-class-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperAnnotateAsPure = __turbopack_require__("[project]/node_modules/@babel/helper-annotate-as-pure/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opt)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const { types: t, template } = api;
    const { loose } = opt;
    const classWeakSets = new WeakMap();
    const fieldsWeakSets = new WeakMap();
    function unshadow(name, targetScope, scope) {
        while(scope !== targetScope){
            if (scope.hasOwnBinding(name)) scope.rename(name);
            scope = scope.parent;
        }
    }
    function injectToFieldInit(fieldPath, expr, before = false) {
        if (fieldPath.node.value) {
            const value = fieldPath.get("value");
            if (before) {
                value.insertBefore(expr);
            } else {
                value.insertAfter(expr);
            }
        } else {
            fieldPath.set("value", t.unaryExpression("void", expr));
        }
    }
    function injectInitialization(classPath, init) {
        let firstFieldPath;
        let constructorPath;
        for (const el of classPath.get("body.body")){
            if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {
                firstFieldPath = el;
                break;
            }
            if (!constructorPath && el.isClassMethod({
                kind: "constructor"
            })) {
                constructorPath = el;
            }
        }
        if (firstFieldPath) {
            injectToFieldInit(firstFieldPath, init, true);
        } else {
            (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [
                t.expressionStatement(init)
            ]);
        }
    }
    function getWeakSetId(weakSets, outerClass, reference, name = "", inject) {
        let id = weakSets.get(reference.node);
        if (!id) {
            id = outerClass.scope.generateUidIdentifier(`${name || ""} brandCheck`);
            weakSets.set(reference.node, id);
            inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);
            const newExpr = t.newExpression(t.identifier("WeakSet"), []);
            (0, _helperAnnotateAsPure.default)(newExpr);
            outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);
        }
        return t.cloneNode(id);
    }
    return {
        name: "transform-private-property-in-object",
        manipulateOptions: (_, parser)=>parser.plugins.push("privateIn"),
        pre () {
            (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);
        },
        visitor: {
            BinaryExpression (path, state) {
                const { node } = path;
                const { file } = state;
                if (node.operator !== "in") return;
                if (!t.isPrivateName(node.left)) return;
                const { name } = node.left.id;
                let privateElement;
                const outerClass = path.findParent((path)=>{
                    if (!path.isClass()) return false;
                    privateElement = path.get("body.body").find(({ node })=>t.isPrivate(node) && node.key.id.name === name);
                    return !!privateElement;
                });
                if (outerClass.parentPath.scope.path.isPattern()) {
                    outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);
                    return;
                }
                if (privateElement.node.type === "ClassPrivateMethod") {
                    if (privateElement.node.static) {
                        if (outerClass.node.id) {
                            unshadow(outerClass.node.id.name, outerClass.scope, path.scope);
                        } else {
                            outerClass.set("id", path.scope.generateUidIdentifier("class"));
                        }
                        path.replaceWith(template.expression.ast`
                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}
              `);
                    } else {
                        var _outerClass$node$id;
                        const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);
                        path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
                    }
                } else {
                    const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);
                    path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-property-literals/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-property-literals",
        visitor: {
            ObjectProperty: {
                exit ({ node }) {
                    const key = node.key;
                    if (!node.computed && _core.types.isIdentifier(key) && !_core.types.isValidES3Identifier(key.name)) {
                        node.key = _core.types.stringLiteral(key.name);
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
}}),
"[project]/node_modules/@babel/plugin-transform-regenerator/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _regeneratorTransform = __turbopack_require__("[project]/node_modules/regenerator-transform/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)(({ types: t, assertVersion })=>{
    assertVersion(7);
    return {
        name: "transform-regenerator",
        inherits: _regeneratorTransform.default,
        visitor: {
            CallExpression (path) {
                {
                    var _this$availableHelper;
                    if (!((_this$availableHelper = this.availableHelper) != null && _this$availableHelper.call(this, "regeneratorRuntime"))) {
                        return;
                    }
                }
                const callee = path.get("callee");
                if (!callee.isMemberExpression()) return;
                const obj = callee.get("object");
                if (obj.isIdentifier({
                    name: "regeneratorRuntime"
                })) {
                    const helper = this.addHelper("regeneratorRuntime");
                    {
                        if (t.isArrowFunctionExpression(helper)) {
                            obj.replaceWith(helper.body);
                            return;
                        }
                    }
                    obj.replaceWith(t.callExpression(helper, []));
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-regexp-modifiers/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.19.0 || >8.0.0-alpha <8.0.0-beta");
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-regexp-modifiers",
        feature: "modifiers"
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-reserved-words/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-reserved-words",
        visitor: {
            "BindingIdentifier|ReferencedIdentifier" (path) {
                if (!_core.types.isValidES3Identifier(path.node.name)) {
                    path.scope.rename(path.node.name);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-shorthand-properties/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-shorthand-properties",
        visitor: {
            ObjectMethod (path) {
                const { node } = path;
                if (node.kind === "method") {
                    const func = _core.types.functionExpression(null, node.params, node.body, node.generator, node.async);
                    func.returnType = node.returnType;
                    const computedKey = _core.types.toComputedKey(node);
                    if (_core.types.isStringLiteral(computedKey, {
                        value: "__proto__"
                    })) {
                        path.replaceWith(_core.types.objectProperty(computedKey, func, true));
                    } else {
                        path.replaceWith(_core.types.objectProperty(node.key, func, node.computed));
                    }
                }
            },
            ObjectProperty (path) {
                const { node } = path;
                if (node.shorthand) {
                    const computedKey = _core.types.toComputedKey(node);
                    if (_core.types.isStringLiteral(computedKey, {
                        value: "__proto__"
                    })) {
                        path.replaceWith(_core.types.objectProperty(computedKey, node.value, true));
                    } else {
                        node.shorthand = false;
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-spread/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperSkipTransparentExpressionWrappers = __turbopack_require__("[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _options$allowArrayLi;
    api.assertVersion(7);
    const iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
    const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
    function getSpreadLiteral(spread, scope) {
        if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {
            name: "arguments"
        })) {
            return spread.argument;
        } else {
            const node = spread.argument;
            if (_core.types.isIdentifier(node)) {
                const binding = scope.getBinding(node.name);
                if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
                    return node;
                }
            }
            if (_core.types.isArrayExpression(node)) {
                return node;
            }
            if (_core.types.isIdentifier(node, {
                name: "arguments"
            })) {
                return _core.template.expression.ast`
          Array.prototype.slice.call(${node})
        `;
            }
            const args = [
                node
            ];
            let helperName = "toConsumableArray";
            if (arrayLikeIsIterable) {
                args.unshift(scope.path.hub.addHelper(helperName));
                helperName = "maybeArrayLike";
            }
            return _core.types.callExpression(scope.path.hub.addHelper(helperName), args);
        }
    }
    function hasHole(spread) {
        return spread.elements.includes(null);
    }
    function hasSpread(nodes) {
        for(let i = 0; i < nodes.length; i++){
            if (_core.types.isSpreadElement(nodes[i])) {
                return true;
            }
        }
        return false;
    }
    function push(_props, nodes) {
        if (!_props.length) return _props;
        nodes.push(_core.types.arrayExpression(_props));
        return [];
    }
    function build(props, scope, file) {
        const nodes = [];
        let _props = [];
        for (const prop of props){
            if (_core.types.isSpreadElement(prop)) {
                _props = push(_props, nodes);
                let spreadLiteral = getSpreadLiteral(prop, scope);
                if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {
                    spreadLiteral = _core.types.callExpression(file.addHelper("arrayWithoutHoles"), [
                        spreadLiteral
                    ]);
                }
                nodes.push(spreadLiteral);
            } else {
                _props.push(prop);
            }
        }
        push(_props, nodes);
        return nodes;
    }
    return {
        name: "transform-spread",
        visitor: {
            ArrayExpression (path) {
                const { node, scope } = path;
                const elements = node.elements;
                if (!hasSpread(elements)) return;
                const nodes = build(elements, scope, this.file);
                let first = nodes[0];
                if (nodes.length === 1 && first !== elements[0].argument) {
                    path.replaceWith(first);
                    return;
                }
                if (!_core.types.isArrayExpression(first)) {
                    first = _core.types.arrayExpression([]);
                } else {
                    nodes.shift();
                }
                path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
            },
            CallExpression (path) {
                const { node, scope } = path;
                const args = node.arguments;
                if (!hasSpread(args)) return;
                const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get("callee"));
                if (calleePath.isSuper()) {
                    throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
                }
                let contextLiteral = scope.buildUndefinedNode();
                node.arguments = [];
                let nodes;
                if (args.length === 1 && _core.types.isIdentifier(args[0].argument, {
                    name: "arguments"
                })) {
                    nodes = [
                        args[0].argument
                    ];
                } else {
                    nodes = build(args, scope, this.file);
                }
                const first = nodes.shift();
                if (nodes.length) {
                    node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes));
                } else {
                    node.arguments.push(first);
                }
                const callee = calleePath.node;
                if (_core.types.isMemberExpression(callee)) {
                    const temp = scope.maybeGenerateMemoised(callee.object);
                    if (temp) {
                        callee.object = _core.types.assignmentExpression("=", temp, callee.object);
                        contextLiteral = temp;
                    } else {
                        contextLiteral = _core.types.cloneNode(callee.object);
                    }
                }
                node.callee = _core.types.memberExpression(node.callee, _core.types.identifier("apply"));
                if (_core.types.isSuper(contextLiteral)) {
                    contextLiteral = _core.types.thisExpression();
                }
                node.arguments.unshift(_core.types.cloneNode(contextLiteral));
            },
            NewExpression (path) {
                const { node, scope } = path;
                if (!hasSpread(node.arguments)) return;
                const nodes = build(node.arguments, scope, this.file);
                const first = nodes.shift();
                let args;
                if (nodes.length) {
                    args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier("concat")), nodes);
                } else {
                    args = first;
                }
                path.replaceWith(_core.types.callExpression(path.hub.addHelper("construct"), [
                    node.callee,
                    args
                ]));
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-sticky-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-sticky-regex",
        visitor: {
            RegExpLiteral (path) {
                const { node } = path;
                if (!node.flags.includes("y")) return;
                path.replaceWith(_core.types.newExpression(_core.types.identifier("RegExp"), [
                    _core.types.stringLiteral(node.pattern),
                    _core.types.stringLiteral(node.flags)
                ]));
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-template-literals/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion(7);
    const ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
    const mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
    let helperName = "taggedTemplateLiteral";
    if (mutableTemplateObject) helperName += "Loose";
    function buildConcatCallExpressions(items) {
        let avail = true;
        return items.reduce(function(left, right) {
            let canBeInserted = _core.types.isLiteral(right);
            if (!canBeInserted && avail) {
                canBeInserted = true;
                avail = false;
            }
            if (canBeInserted && _core.types.isCallExpression(left)) {
                left.arguments.push(right);
                return left;
            }
            return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [
                right
            ]);
        });
    }
    return {
        name: "transform-template-literals",
        visitor: {
            TaggedTemplateExpression (path) {
                const { node } = path;
                const { quasi } = node;
                const strings = [];
                const raws = [];
                let isStringsRawEqual = true;
                for (const elem of quasi.quasis){
                    const { raw, cooked } = elem.value;
                    const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
                    strings.push(value);
                    raws.push(_core.types.stringLiteral(raw));
                    if (raw !== cooked) {
                        isStringsRawEqual = false;
                    }
                }
                const helperArgs = [
                    _core.types.arrayExpression(strings)
                ];
                if (!isStringsRawEqual) {
                    helperArgs.push(_core.types.arrayExpression(raws));
                }
                const tmp = path.scope.generateUidIdentifier("templateObject");
                path.scope.getProgramParent().push({
                    id: _core.types.cloneNode(tmp)
                });
                path.replaceWith(_core.types.callExpression(node.tag, [
                    _core.template.expression.ast`
              ${_core.types.cloneNode(tmp)} || (
                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})
              )
            `,
                    ...quasi.expressions
                ]));
            },
            TemplateLiteral (path) {
                if (path.parent.type === "TSLiteralType") {
                    return;
                }
                const nodes = [];
                const expressions = path.get("expressions");
                let index = 0;
                for (const elem of path.node.quasis){
                    if (elem.value.cooked) {
                        nodes.push(_core.types.stringLiteral(elem.value.cooked));
                    }
                    if (index < expressions.length) {
                        const expr = expressions[index++];
                        const node = expr.node;
                        if (!_core.types.isStringLiteral(node, {
                            value: ""
                        })) {
                            nodes.push(node);
                        }
                    }
                }
                if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {
                    nodes.unshift(_core.types.stringLiteral(""));
                }
                let root = nodes[0];
                if (ignoreToPrimitiveHint) {
                    for(let i = 1; i < nodes.length; i++){
                        root = _core.types.binaryExpression("+", root, nodes[i]);
                    }
                } else if (nodes.length > 1) {
                    root = buildConcatCallExpressions(nodes);
                }
                path.replaceWith(root);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-typeof-symbol/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return {
        name: "transform-typeof-symbol",
        visitor: {
            Scope ({ scope }) {
                if (!scope.getBinding("Symbol")) {
                    return;
                }
                scope.rename("Symbol");
            },
            UnaryExpression (path) {
                const { node, parent } = path;
                if (node.operator !== "typeof") return;
                if (path.parentPath.isBinaryExpression() && _core.types.EQUALITY_BINARY_OPERATORS.includes(parent.operator)) {
                    const opposite = path.getOpposite();
                    if (opposite.isStringLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
                        return;
                    }
                }
                let isUnderHelper = path.findParent((path)=>{
                    if (path.isFunction()) {
                        var _path$get;
                        return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
                    }
                });
                if (isUnderHelper) return;
                const helper = this.addHelper("typeof");
                isUnderHelper = path.findParent((path)=>{
                    return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
                });
                if (isUnderHelper) {
                    return;
                }
                const call = _core.types.callExpression(helper, [
                    node.argument
                ]);
                const arg = path.get("argument");
                if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
                    const unary = _core.types.unaryExpression("typeof", _core.types.cloneNode(node.argument));
                    path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("===", unary, _core.types.stringLiteral("undefined")), _core.types.stringLiteral("undefined"), call));
                } else {
                    path.replaceWith(call);
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-unicode-escapes/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    const surrogate = /[\ud800-\udfff]/g;
    const unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;
    function escape(code) {
        {
            let str = code.toString(16);
            while(str.length < 4)str = "0" + str;
            return "\\u" + str;
        }
    }
    function replacer(match, backslashes, code) {
        if (backslashes.length % 2 === 0) {
            return match;
        }
        const char = String.fromCodePoint(parseInt(code, 16));
        const escaped = backslashes.slice(0, -1) + escape(char.charCodeAt(0));
        return char.length === 1 ? escaped : escaped + escape(char.charCodeAt(1));
    }
    function replaceUnicodeEscapes(str) {
        return str.replace(unicodeEscape, replacer);
    }
    function getUnicodeEscape(str) {
        let match;
        while(match = unicodeEscape.exec(str)){
            if (match[1].length % 2 === 0) continue;
            unicodeEscape.lastIndex = 0;
            return match[0];
        }
        return null;
    }
    return {
        name: "transform-unicode-escapes",
        manipulateOptions ({ generatorOpts }) {
            var _generatorOpts$jsescO, _generatorOpts$jsescO2;
            if (!generatorOpts.jsescOption) {
                generatorOpts.jsescOption = {};
            }
            (_generatorOpts$jsescO2 = (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal) != null ? _generatorOpts$jsescO2 : _generatorOpts$jsescO.minimal = false;
        },
        visitor: {
            Identifier (path) {
                const { node, key } = path;
                const { name } = node;
                const replaced = name.replace(surrogate, (c)=>{
                    return `_u${c.charCodeAt(0).toString(16)}`;
                });
                if (name === replaced) return;
                const str = _core.types.inherits(_core.types.stringLiteral(name), node);
                if (key === "key") {
                    path.replaceWith(str);
                    return;
                }
                const { parentPath, scope } = path;
                if (parentPath.isMemberExpression({
                    property: node
                }) || parentPath.isOptionalMemberExpression({
                    property: node
                })) {
                    parentPath.node.computed = true;
                    path.replaceWith(str);
                    return;
                }
                const binding = scope.getBinding(name);
                if (binding) {
                    scope.rename(name, scope.generateUid(replaced));
                    return;
                }
                throw path.buildCodeFrameError(`Can't reference '${name}' as a bare identifier`);
            },
            "StringLiteral|DirectiveLiteral" (path) {
                const { node } = path;
                const { extra } = node;
                if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
            },
            TemplateElement (path) {
                const { node, parentPath } = path;
                const { value } = node;
                const firstEscape = getUnicodeEscape(value.raw);
                if (!firstEscape) return;
                const grandParent = parentPath.parentPath;
                if (grandParent.isTaggedTemplateExpression()) {
                    throw path.buildCodeFrameError(`Can't replace Unicode escape '${firstEscape}' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.`);
                }
                value.raw = replaceUnicodeEscapes(value.raw);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-unicode-property-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const { useUnicodeFlag = true } = options;
    if (typeof useUnicodeFlag !== "boolean") {
        throw new Error(".useUnicodeFlag must be a boolean, or undefined");
    }
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-unicode-property-regex",
        feature: "unicodePropertyEscape",
        options: {
            useUnicodeFlag
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-unicode-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-unicode-regex",
        feature: "unicodeFlag"
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-transform-unicode-sets-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "transform-unicode-sets-regex",
        feature: "unicodeSetsFlag",
        manipulateOptions (opts, parserOpts) {
            {
                parserOpts.plugins.push("regexpUnicodeSets");
            }
        }
    });
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-async-arrows-in-class/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
/**
 * Safari 10.3 had an issue where async arrow function expressions within any class method would throw.
 * After an initial fix, any references to the instance via `this` within those methods would also throw.
 * This is fixed by converting arrow functions in class methods into equivalent function expressions.
 * @see https://bugs.webkit.org/show_bug.cgi?id=166879
 *
 * @example
 *   class X{ a(){ async () => {}; } }   // throws
 *   class X{ a(){ async function() {}; } }   // works
 *
 * @example
 *   class X{ a(){
 *     async () => this.a;   // throws
 *   } }
 *   class X{ a(){
 *     var _this=this;
 *     async function() { return _this.a };   // works
 *   } }
 */ const OPTS = {
    allowInsertArrow: false,
    specCompliant: false
};
var _default = ({ types: t })=>({
        name: "transform-async-arrows-in-class",
        visitor: {
            ArrowFunctionExpression (path) {
                if (path.node.async && path.findParent(t.isClassMethod)) {
                    path.arrowFunctionToExpression(OPTS);
                }
            }
        }
    });
exports.default = _default;
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-edge-default-parameters/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
/**
 * Converts destructured parameters with default values to non-shorthand syntax.
 * This fixes the only arguments-related bug in ES Modules-supporting browsers (Edge 16 & 17).
 * Use this plugin instead of @babel/plugin-transform-parameters when targeting ES Modules.
 */ var _default = ({ types: t })=>{
    const isArrowParent = (p)=>p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
    return {
        name: "transform-edge-default-parameters",
        visitor: {
            AssignmentPattern (path) {
                const arrowArgParent = path.find(isArrowParent);
                if (arrowArgParent && path.parent.shorthand) {
                    // In Babel 7+, there is no way to force non-shorthand properties.
                    path.parent.shorthand = false;
                    (path.parent.extra || {}).shorthand = false; // So, to ensure non-shorthand, rename the local identifier so it no longer matches:
                    path.scope.rename(path.parent.key.name);
                }
            }
        }
    };
};
exports.default = _default;
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-edge-function-name/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
/**
 * Edge 16 & 17 do not infer function.name from variable assignment.
 * All other `function.name` behavior works fine, so we can skip most of @babel/transform-function-name.
 * @see https://kangax.github.io/compat-table/es6/#test-function_name_property_variables_(function)
 *
 * Note: contrary to various Github issues, Edge 16+ *does* correctly infer the name of Arrow Functions.
 * The variable declarator name inference issue only affects function expressions, so that's all we fix here.
 *
 * A Note on Minification: Terser undoes this transform *by default* unless `keep_fnames` is set to true.
 * There is by design - if Function.name is critical to your application, you must configure
 * your minifier to preserve function names.
 */ var _default = ({ types: t })=>({
        name: "transform-edge-function-name",
        visitor: {
            FunctionExpression: {
                exit (path) {
                    if (!path.node.id && t.isIdentifier(path.parent.id)) {
                        const id = t.cloneNode(path.parent.id);
                        const binding = path.scope.getBinding(id.name); // if the binding gets reassigned anywhere, rename it
                        if (binding == null ? void 0 : binding.constantViolations.length) {
                            path.scope.rename(id.name);
                        }
                        path.node.id = id;
                    }
                }
            }
        }
    });
exports.default = _default;
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-tagged-template-caching/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
/**
 * Converts destructured parameters with default values to non-shorthand syntax.
 * This fixes the only Tagged Templates-related bug in ES Modules-supporting browsers (Safari 10 & 11).
 * Use this plugin instead of `@babel/plugin-transform-template-literals` when targeting ES Modules.
 *
 * @example
 *   // Bug 1: Safari 10/11 doesn't reliably return the same Strings value.
 *   // The value changes depending on invocation and function optimization state.
 *   function f() { return Object`` }
 *   f() === new f()  // false, should be true.
 *
 * @example
 *   // Bug 2: Safari 10/11 use the same cached strings value when the string parts are the same.
 *   // This behavior comes from an earlier version of the spec, and can cause tricky bugs.
 *   Object``===Object``  // true, should be false.
 *
 * Benchmarks: https://jsperf.com/compiled-tagged-template-performance
 */ var _default = ({ types: t })=>({
        name: "transform-tagged-template-caching",
        visitor: {
            TaggedTemplateExpression (path, state) {
                // tagged templates we've already dealt with
                let processed = state.get("processed");
                if (!processed) {
                    processed = new WeakSet();
                    state.set("processed", processed);
                }
                if (processed.has(path.node)) return path.skip(); // Grab the expressions from the original tag.
                //   tag`a${'hello'}`  // ['hello']
                const expressions = path.node.quasi.expressions; // Create an identity function helper:
                //   identity = t => t
                let identity = state.get("identity");
                if (!identity) {
                    identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
                    state.set("identity", identity);
                    const binding = path.scope.getBinding(identity.name);
                    binding.path.get("init").replaceWith(t.arrowFunctionExpression([
                        t.identifier("t")
                    ], t.identifier("t")));
                } // Use the identity function helper to get a reference to the template's Strings.
                // We replace all expressions with `0` ensure Strings has the same shape.
                //   identity`a${0}`
                const template = t.taggedTemplateExpression(t.cloneNode(identity), t.templateLiteral(path.node.quasi.quasis, expressions.map(()=>t.numericLiteral(0))));
                processed.add(template); // Install an inline cache at the callsite using the global variable:
                //   _t || (_t = identity`a${0}`)
                const ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
                path.scope.getBinding(ident.name).path.parent.kind = "let";
                const inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", t.cloneNode(ident), template)); // The original tag function becomes a plain function call.
                // The expressions omitted from the cached Strings tag are directly applied as arguments.
                //   tag(_t || (_t = Object`a${0}`), 'hello')
                const node = t.callExpression(path.node.tag, [
                    inlineCache,
                    ...expressions
                ]);
                path.replaceWith(node);
            }
        }
    });
exports.default = _default;
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-safari-block-shadowing/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = _default;
/**
 * Fixes block-shadowed let/const bindings in Safari 10/11.
 * https://kangax.github.io/compat-table/es6/#test-let_scope_shadow_resolution
 */ function _default({ types: t }) {
    return {
        name: "transform-safari-block-shadowing",
        visitor: {
            VariableDeclarator (path) {
                // the issue only affects let and const bindings:
                const kind = path.parent.kind;
                if (kind !== "let" && kind !== "const") return; // ignore non-block-scoped bindings:
                const block = path.scope.block;
                if (t.isFunction(block) || t.isProgram(block)) return;
                const bindings = t.getOuterBindingIdentifiers(path.node.id);
                for (const name of Object.keys(bindings)){
                    let scope = path.scope; // ignore parent bindings (note: impossible due to let/const?)
                    if (!scope.hasOwnBinding(name)) continue; // check if shadowed within the nearest function/program boundary
                    while(scope = scope.parent){
                        if (scope.hasOwnBinding(name)) {
                            path.scope.rename(name);
                            break;
                        }
                        if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
                            break;
                        }
                    }
                }
            }
        }
    };
}
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/preset-modules/lib/plugins/transform-safari-for-shadowing/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
/**
 * Safari ~11 has an issue where variable declarations in a For statement throw if they shadow parameters.
 * This is fixed by renaming any declarations in the left/init part of a For* statement so they don't shadow.
 * @see https://bugs.webkit.org/show_bug.cgi?id=171041
 *
 * @example
 *   e => { for (let e of []) e }   // throws
 *   e => { for (let _e of []) _e }   // works
 */ function handle(declaration) {
    if (!declaration.isVariableDeclaration()) return;
    const fn = declaration.getFunctionParent();
    const { name } = declaration.node.declarations[0].id; // check if there is a shadowed binding coming from a parameter
    if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
        declaration.scope.rename(name);
    }
}
var _default = ()=>({
        name: "transform-safari-for-shadowing",
        visitor: {
            ForXStatement (path) {
                handle(path.get("left"));
            },
            ForStatement (path) {
                handle(path.get("init"));
            }
        }
    });
exports.default = _default;
module.exports = exports.default;
}}),
"[project]/node_modules/@babel/plugin-bugfix-firefox-class-in-computed-class-key/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _traverse = __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)(({ types: t, assertVersion })=>{
    assertVersion(7);
    const containsClassExpressionVisitor = {
        ClassExpression (path, state) {
            state.found = true;
            path.stop();
        },
        Function (path) {
            path.skip();
        }
    };
    const containsYieldOrAwaitVisitor = _traverse.visitors.environmentVisitor({
        YieldExpression (path, state) {
            state.yield = true;
            if (state.await) path.stop();
        },
        AwaitExpression (path, state) {
            state.await = true;
            if (state.yield) path.stop();
        }
    });
    function containsClassExpression(path) {
        if (t.isClassExpression(path.node)) return true;
        if (t.isFunction(path.node)) return false;
        const state = {
            found: false
        };
        path.traverse(containsClassExpressionVisitor, state);
        return state.found;
    }
    function wrap(path) {
        const context = {
            yield: t.isYieldExpression(path.node),
            await: t.isAwaitExpression(path.node)
        };
        path.traverse(containsYieldOrAwaitVisitor, context);
        let replacement;
        if (context.yield) {
            const fn = t.functionExpression(null, [], t.blockStatement([
                t.returnStatement(path.node)
            ]), true, context.await);
            replacement = t.yieldExpression(t.callExpression(t.memberExpression(fn, t.identifier("call")), [
                t.thisExpression(),
                t.identifier("arguments")
            ]), true);
        } else {
            const fn = t.arrowFunctionExpression([], path.node, context.await);
            replacement = t.callExpression(fn, []);
            if (context.await) replacement = t.awaitExpression(replacement);
        }
        path.replaceWith(replacement);
    }
    return {
        name: "bugfix-firefox-class-in-computed-class-key",
        visitor: {
            Class (path) {
                const hasPrivateElement = path.node.body.body.some((node)=>t.isPrivate(node));
                if (!hasPrivateElement) return;
                for (const elem of path.get("body.body")){
                    if ("computed" in elem.node && elem.node.computed && containsClassExpression(elem.get("key"))) {
                        wrap(elem.get("key"));
                    }
                }
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
function shouldTransform(path) {
    const { node } = path;
    const functionId = node.id;
    if (!functionId) return false;
    const name = functionId.name;
    const paramNameBinding = path.scope.getOwnBinding(name);
    if (paramNameBinding === undefined) {
        return false;
    }
    if (paramNameBinding.kind !== "param") {
        return false;
    }
    if (paramNameBinding.identifier === paramNameBinding.path.node) {
        return false;
    }
    return name;
}
var index = helperPluginUtils.declare((api)=>{
    api.assertVersion("^7.16.0");
    return {
        name: "plugin-bugfix-safari-id-destructuring-collision-in-function-expression",
        visitor: {
            FunctionExpression (path) {
                const name = shouldTransform(path);
                if (name) {
                    const { scope } = path;
                    const newParamName = scope.generateUid(name);
                    scope.rename(name, newParamName);
                }
            }
        }
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-bugfix-safari-class-field-initializer-scope/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function needsWrapping(node) {
    if (core.types.isLiteral(node) && !core.types.isTemplateLiteral(node)) {
        return false;
    }
    if (core.types.isCallExpression(node) || core.types.isOptionalCallExpression(node) || core.types.isNewExpression(node)) {
        return needsWrapping(node.callee) || node.arguments.some(needsWrapping);
    }
    if (core.types.isTemplateLiteral(node)) {
        return node.expressions.some(needsWrapping);
    }
    if (core.types.isTaggedTemplateExpression(node)) {
        return needsWrapping(node.tag) || needsWrapping(node.quasi);
    }
    if (core.types.isArrayExpression(node)) {
        return node.elements.some(needsWrapping);
    }
    if (core.types.isObjectExpression(node)) {
        return node.properties.some((prop)=>{
            if (core.types.isObjectProperty(prop)) {
                return needsWrapping(prop.value) || prop.computed && needsWrapping(prop.key);
            }
            if (core.types.isObjectMethod(prop)) {
                return false;
            }
            return false;
        });
    }
    if (core.types.isMemberExpression(node) || core.types.isOptionalMemberExpression(node)) {
        return needsWrapping(node.object) || node.computed && needsWrapping(node.property);
    }
    if (core.types.isFunctionExpression(node) || core.types.isArrowFunctionExpression(node) || core.types.isClassExpression(node)) {
        return false;
    }
    if (core.types.isThisExpression(node)) {
        return false;
    }
    if (core.types.isSequenceExpression(node)) {
        return node.expressions.some(needsWrapping);
    }
    return true;
}
function wrapInitializer(path) {
    const { value } = path.node;
    if (value && needsWrapping(value)) {
        path.node.value = core.types.callExpression(core.types.arrowFunctionExpression([], value), []);
    }
}
var index = helperPluginUtils.declare((api)=>{
    api.assertVersion("^7.16.0");
    return {
        name: "plugin-bugfix-safari-class-field-initializer-scope",
        visitor: {
            ClassProperty (path) {
                wrapInitializer(path);
            },
            ClassPrivateProperty (path) {
                wrapInitializer(path);
            }
        }
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-bugfix-v8-spread-parameters-in-optional-chaining/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var pluginTransformOptionalChaining = __turbopack_require__("[project]/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js [app-ssr] (ecmascript)");
var helperSkipTransparentExpressionWrappers = __turbopack_require__("[project]/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js [app-ssr] (ecmascript)");
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
function matchAffectedArguments(argumentNodes) {
    const spreadIndex = argumentNodes.findIndex((node)=>core.types.isSpreadElement(node));
    return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
}
function shouldTransform(path) {
    let optionalPath = path;
    const chains = [];
    for(;;){
        if (optionalPath.isOptionalMemberExpression()) {
            chains.push(optionalPath.node);
            optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
        } else if (optionalPath.isOptionalCallExpression()) {
            chains.push(optionalPath.node);
            optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
        } else {
            break;
        }
    }
    for(let i = 0; i < chains.length; i++){
        const node = chains[i];
        if (core.types.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {
            if (node.optional) {
                return true;
            }
            const callee = chains[i + 1];
            if (core.types.isOptionalMemberExpression(callee, {
                optional: true
            })) {
                return true;
            }
        }
    }
    return false;
}
var index = helperPluginUtils.declare((api)=>{
    var _api$assumption, _api$assumption2;
    api.assertVersion(7);
    const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : false;
    const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : false;
    return {
        name: "bugfix-v8-spread-parameters-in-optional-chaining",
        visitor: {
            "OptionalCallExpression|OptionalMemberExpression" (path) {
                if (shouldTransform(path)) {
                    pluginTransformOptionalChaining.transform(path, {
                        noDocumentAll,
                        pureGetters
                    });
                }
            }
        }
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-bugfix-v8-static-class-fields-redefine-readonly/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
var core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
function isNameOrLength(key) {
    if (core.types.isIdentifier(key)) {
        return key.name === "name" || key.name === "length";
    }
    if (core.types.isStringLiteral(key)) {
        return key.value === "name" || key.value === "length";
    }
    return false;
}
function isStaticFieldWithValue(node) {
    return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;
}
const hasReferenceVisitor = {
    ReferencedIdentifier (path, state) {
        if (path.node.name === state.name) {
            state.ref();
            path.stop();
        }
    },
    Scope (path, { name }) {
        if (path.scope.hasOwnBinding(name)) {
            path.skip();
        }
    }
};
function isReferenceOrThis(node, name) {
    return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {
        name
    });
}
const hasReferenceOrThisVisitor = {
    "ThisExpression|ReferencedIdentifier" (path, state) {
        if (isReferenceOrThis(path.node, state.name)) {
            state.ref();
            path.stop();
        }
    },
    FunctionParent (path, state) {
        if (path.isArrowFunctionExpression()) return;
        if (state.name && !path.scope.hasOwnBinding(state.name)) {
            path.traverse(hasReferenceVisitor, state);
        }
        path.skip();
        if (path.isMethod()) {
            if (path.requeueComputedKeyAndDecorators) {
                path.requeueComputedKeyAndDecorators();
            } else {
                __turbopack_require__("[project]/node_modules/@babel/traverse/lib/index.js [app-ssr] (ecmascript)").NodePath.prototype.requeueComputedKeyAndDecorators.call(path);
            }
        }
    }
};
function getPotentiallyBuggyFieldsIndexes(path) {
    var _path$node$id;
    const buggyPublicStaticFieldsIndexes = [];
    let classReferenced = false;
    const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
    const hasReferenceState = {
        name: className,
        ref: ()=>classReferenced = true
    };
    if (className) {
        for (const el of path.get("body.body")){
            if (el.node.computed) {
                el.get("key").traverse(hasReferenceVisitor, hasReferenceState);
                if (classReferenced) break;
            }
        }
    }
    let nextPotentiallyBuggy = false;
    const { body } = path.node.body;
    for(let i = 0; i < body.length; i++){
        const node = body[i];
        if (!nextPotentiallyBuggy) {
            if (core.types.isStaticBlock(node)) {
                classReferenced = true;
                nextPotentiallyBuggy = true;
            } else if (isStaticFieldWithValue(node)) {
                if (!classReferenced) {
                    if (isReferenceOrThis(node.value, className)) {
                        classReferenced = true;
                    } else {
                        path.get(`body.body.${i}.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);
                    }
                }
                if (classReferenced) {
                    nextPotentiallyBuggy = !path.scope.isPure(node.value);
                }
            }
        }
        if (core.types.isClassProperty(node, {
            static: true
        }) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {
            buggyPublicStaticFieldsIndexes.push(i);
        }
    }
    return buggyPublicStaticFieldsIndexes;
}
function getNameOrLengthStaticFieldsIndexes(path) {
    const indexes = [];
    const { body } = path.node.body;
    for(let i = 0; i < body.length; i++){
        const node = body[i];
        if (core.types.isClassProperty(node, {
            static: true,
            computed: false
        }) && isNameOrLength(node.key)) {
            indexes.push(i);
        }
    }
    return indexes;
}
function toRanges(nums) {
    const ranges = [];
    if (nums.length === 0) return ranges;
    let start = nums[0];
    let end = start + 1;
    for(let i = 1; i < nums.length; i++){
        if (nums[i] <= nums[i - 1]) {
            throw new Error("Internal Babel error: nums must be in ascending order");
        }
        if (nums[i] === end) {
            end++;
        } else {
            ranges.push([
                start,
                end
            ]);
            start = nums[i];
            end = start + 1;
        }
    }
    ranges.push([
        start,
        end
    ]);
    return ranges;
}
function buildFieldsReplacement(fields, scope, file) {
    return core.types.staticBlock(fields.map((field)=>{
        const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);
        return core.types.expressionStatement(core.types.callExpression(file.addHelper("defineProperty"), [
            core.types.thisExpression(),
            key,
            field.value || scope.buildUndefinedNode()
        ]));
    }));
}
var index = helperPluginUtils.declare((api)=>{
    api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
    const setPublicClassFields = api.assumption("setPublicClassFields");
    return {
        name: "bugfix-v8-static-class-fields-redefine-readonly",
        visitor: {
            Class (path) {
                const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));
                for(let i = ranges.length - 1; i >= 0; i--){
                    const [start, end] = ranges[i];
                    const startPath = path.get("body.body")[start];
                    startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));
                    for(let j = end - 1; j > start; j--){
                        path.get("body.body")[j].remove();
                    }
                }
            }
        }
    };
});
exports.default = index; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@babel/plugin-syntax-unicode-sets-regex/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperCreateRegexpFeaturesPlugin = __turbopack_require__("[project]/node_modules/@babel/helper-create-regexp-features-plugin/lib/index.js [app-ssr] (ecmascript)");
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _default = (0, _helperPluginUtils.declare)((api)=>{
    api.assertVersion(7);
    return (0, _helperCreateRegexpFeaturesPlugin.createRegExpFeaturePlugin)({
        name: "syntax-unicode-sets-regex",
        feature: "unicodeSetsFlag_syntax",
        manipulateOptions (opts, parserOpts) {
            parserOpts.plugins.push("regexpUnicodeSets");
        }
    });
});
exports.default = _default;
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.createUtilsGetter = createUtilsGetter;
exports.getImportSource = getImportSource;
exports.getRequireSource = getRequireSource;
exports.has = has;
exports.intersection = intersection;
exports.resolveKey = resolveKey;
exports.resolveSource = resolveSource;
var _babel = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const { types: t, template: template } = _babel.default || _babel;
function intersection(a, b) {
    const result = new Set();
    a.forEach((v)=>b.has(v) && result.add(v));
    return result;
}
function has(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
}
function getType(target) {
    return Object.prototype.toString.call(target).slice(8, -1);
}
function resolveId(path) {
    if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, /* noGlobals */ true)) {
        return path.node.name;
    }
    if (path.isPure()) {
        const { deopt } = path.evaluate();
        if (deopt && deopt.isIdentifier()) {
            return deopt.node.name;
        }
    }
}
function resolveKey(path, computed = false) {
    const { scope } = path;
    if (path.isStringLiteral()) return path.node.value;
    const isIdentifier = path.isIdentifier();
    if (isIdentifier && !(computed || path.parent.computed)) {
        return path.node.name;
    }
    if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
        name: "Symbol"
    }) && !scope.hasBinding("Symbol", /* noGlobals */ true)) {
        const sym = resolveKey(path.get("property"), path.node.computed);
        if (sym) return "Symbol." + sym;
    }
    if (isIdentifier ? scope.hasBinding(path.node.name, /* noGlobals */ true) : path.isPure()) {
        const { value } = path.evaluate();
        if (typeof value === "string") return value;
    }
}
function resolveSource(obj) {
    if (obj.isMemberExpression() && obj.get("property").isIdentifier({
        name: "prototype"
    })) {
        const id = resolveId(obj.get("object"));
        if (id) {
            return {
                id,
                placement: "prototype"
            };
        }
        return {
            id: null,
            placement: null
        };
    }
    const id = resolveId(obj);
    if (id) {
        return {
            id,
            placement: "static"
        };
    }
    if (obj.isRegExpLiteral()) {
        return {
            id: "RegExp",
            placement: "prototype"
        };
    } else if (obj.isFunction()) {
        return {
            id: "Function",
            placement: "prototype"
        };
    } else if (obj.isPure()) {
        const { value } = obj.evaluate();
        if (value !== undefined) {
            return {
                id: getType(value),
                placement: "prototype"
            };
        }
    }
    return {
        id: null,
        placement: null
    };
}
function getImportSource({ node }) {
    if (node.specifiers.length === 0) return node.source.value;
}
function getRequireSource({ node }) {
    if (!t.isExpressionStatement(node)) return;
    const { expression } = node;
    if (t.isCallExpression(expression) && t.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t.isStringLiteral(expression.arguments[0])) {
        return expression.arguments[0].value;
    }
}
function hoist(node) {
    // @ts-expect-error
    node._blockHoist = 3;
    return node;
}
function createUtilsGetter(cache) {
    return (path)=>{
        const prog = path.findParent((p)=>p.isProgram());
        return {
            injectGlobalImport (url, moduleName) {
                cache.storeAnonymous(prog, url, moduleName, (isScript, source)=>{
                    return isScript ? template.statement.ast`require(${source})` : t.importDeclaration([], source);
                });
            },
            injectNamedImport (url, name, hint = name, moduleName) {
                return cache.storeNamed(prog, url, name, moduleName, (isScript, source, name)=>{
                    const id = prog.scope.generateUidIdentifier(hint);
                    return {
                        node: isScript ? hoist(template.statement.ast`
                  var ${id} = require(${source}).${name}
                `) : t.importDeclaration([
                            t.importSpecifier(id, name)
                        ], source),
                        name: id.name
                    };
                });
            },
            injectDefaultImport (url, hint = url, moduleName) {
                return cache.storeNamed(prog, url, "default", moduleName, (isScript, source)=>{
                    const id = prog.scope.generateUidIdentifier(hint);
                    return {
                        node: isScript ? hoist(template.statement.ast`var ${id} = require(${source})`) : t.importDeclaration([
                            t.importDefaultSpecifier(id)
                        ], source),
                        name: id.name
                    };
                });
            }
        };
    };
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/imports-injector.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
var _babel = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const { types: t } = _babel.default || _babel;
class ImportsCachedInjector {
    constructor(resolver, getPreferredIndex){
        this._imports = new WeakMap();
        this._anonymousImports = new WeakMap();
        this._lastImports = new WeakMap();
        this._resolver = resolver;
        this._getPreferredIndex = getPreferredIndex;
    }
    storeAnonymous(programPath, url, moduleName, getVal) {
        const key = this._normalizeKey(programPath, url);
        const imports = this._ensure(this._anonymousImports, programPath, Set);
        if (imports.has(key)) return;
        const node = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)));
        imports.add(key);
        this._injectImport(programPath, node, moduleName);
    }
    storeNamed(programPath, url, name, moduleName, getVal) {
        const key = this._normalizeKey(programPath, url, name);
        const imports = this._ensure(this._imports, programPath, Map);
        if (!imports.has(key)) {
            const { node, name: id } = getVal(programPath.node.sourceType === "script", t.stringLiteral(this._resolver(url)), t.identifier(name));
            imports.set(key, id);
            this._injectImport(programPath, node, moduleName);
        }
        return t.identifier(imports.get(key));
    }
    _injectImport(programPath, node, moduleName) {
        var _this$_lastImports$ge;
        const newIndex = this._getPreferredIndex(moduleName);
        const lastImports = (_this$_lastImports$ge = this._lastImports.get(programPath)) != null ? _this$_lastImports$ge : [];
        const isPathStillValid = (path)=>path.node && // Sometimes the AST is modified and the "last import"
            // we have has been replaced
            path.parent === programPath.node && path.container === programPath.node.body;
        let last;
        if (newIndex === Infinity) {
            // Fast path: we can always just insert at the end if newIndex is `Infinity`
            if (lastImports.length > 0) {
                last = lastImports[lastImports.length - 1].path;
                if (!isPathStillValid(last)) last = undefined;
            }
        } else {
            for (const [i, data] of lastImports.entries()){
                const { path, index } = data;
                if (isPathStillValid(path)) {
                    if (newIndex < index) {
                        const [newPath] = path.insertBefore(node);
                        lastImports.splice(i, 0, {
                            path: newPath,
                            index: newIndex
                        });
                        return;
                    }
                    last = path;
                }
            }
        }
        if (last) {
            const [newPath] = last.insertAfter(node);
            lastImports.push({
                path: newPath,
                index: newIndex
            });
        } else {
            const [newPath] = programPath.unshiftContainer("body", node);
            this._lastImports.set(programPath, [
                {
                    path: newPath,
                    index: newIndex
                }
            ]);
        }
    }
    _ensure(map, programPath, Collection) {
        let collection = map.get(programPath);
        if (!collection) {
            collection = new Collection();
            map.set(programPath, collection);
        }
        return collection;
    }
    _normalizeKey(programPath, url, name = "") {
        const { sourceType } = programPath.node;
        // If we rely on the imported binding (the "name" parameter), we also need to cache
        // based on the sourceType. This is because the module transforms change the names
        // of the import variables.
        return `${name && sourceType}::${url}::${name}`;
    }
}
exports.default = ImportsCachedInjector;
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/debug-utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.presetEnvSilentDebugHeader = void 0;
exports.stringifyTargets = stringifyTargets;
exports.stringifyTargetsMultiline = stringifyTargetsMultiline;
var _helperCompilationTargets = __turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)");
const presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";
exports.presetEnvSilentDebugHeader = presetEnvSilentDebugHeader;
function stringifyTargetsMultiline(targets) {
    return JSON.stringify((0, _helperCompilationTargets.prettifyTargets)(targets), null, 2);
}
function stringifyTargets(targets) {
    return JSON.stringify(targets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/normalize-options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.applyMissingDependenciesDefaults = applyMissingDependenciesDefaults;
exports.validateIncludeExclude = validateIncludeExclude;
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)");
function patternToRegExp(pattern) {
    if (pattern instanceof RegExp) return pattern;
    try {
        return new RegExp(`^${pattern}$`);
    } catch (_unused) {
        return null;
    }
}
function buildUnusedError(label, unused) {
    if (!unused.length) return "";
    return `  - The following "${label}" patterns didn't match any polyfill:\n` + unused.map((original)=>`    ${String(original)}\n`).join("");
}
function buldDuplicatesError(duplicates) {
    if (!duplicates.size) return "";
    return `  - The following polyfills were matched both by "include" and "exclude" patterns:\n` + Array.from(duplicates, (name)=>`    ${name}\n`).join("");
}
function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
    let current;
    const filter = (pattern)=>{
        const regexp = patternToRegExp(pattern);
        if (!regexp) return false;
        let matched = false;
        for (const polyfill of polyfills.keys()){
            if (regexp.test(polyfill)) {
                matched = true;
                current.add(polyfill);
            }
        }
        return !matched;
    };
    // prettier-ignore
    const include = current = new Set();
    const unusedInclude = Array.from(includePatterns).filter(filter);
    // prettier-ignore
    const exclude = current = new Set();
    const unusedExclude = Array.from(excludePatterns).filter(filter);
    const duplicates = (0, _utils.intersection)(include, exclude);
    if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
        throw new Error(`Error while validating the "${provider}" provider options:\n` + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
    }
    return {
        include,
        exclude
    };
}
function applyMissingDependenciesDefaults(options, babelApi) {
    const { missingDependencies = {} } = options;
    if (missingDependencies === false) return false;
    const caller = babelApi.caller((caller)=>caller == null ? void 0 : caller.name);
    const { log = "deferred", inject = caller === "rollup-plugin-babel" ? "throw" : "import", all = false } = missingDependencies;
    return {
        log,
        inject,
        all
    };
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/usage.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)");
function isRemoved(path) {
    if (path.removed) return true;
    if (!path.parentPath) return false;
    if (path.listKey) {
        var _path$parentPath$node;
        if (!((_path$parentPath$node = path.parentPath.node) != null && (_path$parentPath$node = _path$parentPath$node[path.listKey]) != null && _path$parentPath$node.includes(path.node))) return true;
    } else {
        if (path.parentPath.node[path.key] !== path.node) return true;
    }
    return isRemoved(path.parentPath);
}
var _default = (callProvider)=>{
    function property(object, key, placement, path) {
        return callProvider({
            kind: "property",
            object,
            key,
            placement
        }, path);
    }
    function handleReferencedIdentifier(path) {
        const { node: { name }, scope } = path;
        if (scope.getBindingIdentifier(name)) return;
        callProvider({
            kind: "global",
            name
        }, path);
    }
    function analyzeMemberExpression(path) {
        const key = (0, _utils.resolveKey)(path.get("property"), path.node.computed);
        return {
            key,
            handleAsMemberExpression: !!key && key !== "prototype"
        };
    }
    return {
        // Symbol(), new Promise
        ReferencedIdentifier (path) {
            const { parentPath } = path;
            if (parentPath.isMemberExpression({
                object: path.node
            }) && analyzeMemberExpression(parentPath).handleAsMemberExpression) {
                return;
            }
            handleReferencedIdentifier(path);
        },
        "MemberExpression|OptionalMemberExpression" (path) {
            const { key, handleAsMemberExpression } = analyzeMemberExpression(path);
            if (!handleAsMemberExpression) return;
            const object = path.get("object");
            let objectIsGlobalIdentifier = object.isIdentifier();
            if (objectIsGlobalIdentifier) {
                const binding = object.scope.getBinding(object.node.name);
                if (binding) {
                    if (binding.path.isImportNamespaceSpecifier()) return;
                    objectIsGlobalIdentifier = false;
                }
            }
            const source = (0, _utils.resolveSource)(object);
            let skipObject = property(source.id, key, source.placement, path);
            skipObject || (skipObject = !objectIsGlobalIdentifier || path.shouldSkip || object.shouldSkip || isRemoved(object));
            if (!skipObject) handleReferencedIdentifier(object);
        },
        ObjectPattern (path) {
            const { parentPath, parent } = path;
            let obj;
            // const { keys, values } = Object
            if (parentPath.isVariableDeclarator()) {
                obj = parentPath.get("init");
            // ({ keys, values } = Object)
            } else if (parentPath.isAssignmentExpression()) {
                obj = parentPath.get("right");
            // !function ({ keys, values }) {...} (Object)
            // resolution does not work after properties transform :-(
            } else if (parentPath.isFunction()) {
                const grand = parentPath.parentPath;
                if (grand.isCallExpression() || grand.isNewExpression()) {
                    if (grand.node.callee === parent) {
                        obj = grand.get("arguments")[path.key];
                    }
                }
            }
            let id = null;
            let placement = null;
            if (obj) ({ id, placement } = (0, _utils.resolveSource)(obj));
            for (const prop of path.get("properties")){
                if (prop.isObjectProperty()) {
                    const key = (0, _utils.resolveKey)(prop.get("key"));
                    if (key) property(id, key, placement, prop);
                }
            }
        },
        BinaryExpression (path) {
            if (path.node.operator !== "in") return;
            const source = (0, _utils.resolveSource)(path.get("right"));
            const key = (0, _utils.resolveKey)(path.get("left"), true);
            if (!key) return;
            callProvider({
                kind: "in",
                object: source.id,
                key,
                placement: source.placement
            }, path);
        }
    };
};
exports.default = _default;
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/entry.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = void 0;
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)");
var _default = (callProvider)=>({
        ImportDeclaration (path) {
            const source = (0, _utils.getImportSource)(path);
            if (!source) return;
            callProvider({
                kind: "import",
                source
            }, path);
        },
        Program (path) {
            path.get("body").forEach((bodyPath)=>{
                const source = (0, _utils.getRequireSource)(bodyPath);
                if (!source) return;
                callProvider({
                    kind: "import",
                    source
                }, bodyPath);
            });
        }
    });
exports.default = _default;
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.usage = exports.entry = void 0;
var _usage = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/usage.js [app-ssr] (ecmascript)"));
exports.usage = _usage.default;
var _entry = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/entry.js [app-ssr] (ecmascript)"));
exports.entry = _entry.default;
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/node/dependencies.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.has = has;
exports.laterLogMissing = laterLogMissing;
exports.logMissing = logMissing;
exports.resolve = resolve;
var _path = _interopRequireDefault(__turbopack_require__("[externals]/path [external] (path, cjs)"));
var _lodash = _interopRequireDefault(__turbopack_require__("[project]/node_modules/lodash.debounce/index.js [app-ssr] (ecmascript)"));
var _resolve = _interopRequireDefault(__turbopack_require__("[project]/node_modules/resolve/index.js [app-ssr] (ecmascript)"));
var _module = __turbopack_require__("[externals]/module [external] (module, cjs)");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const nativeRequireResolve = parseFloat(process.versions.node) >= 8.9;
// eslint-disable-line
function myResolve(name, basedir) {
    if (nativeRequireResolve) {
        return (()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })().replace(/\\/g, "/");
    } else {
        return _resolve.default.sync(name, {
            basedir
        }).replace(/\\/g, "/");
    }
}
function resolve(dirname, moduleName, absoluteImports) {
    if (absoluteImports === false) return moduleName;
    let basedir = dirname;
    if (typeof absoluteImports === "string") {
        basedir = _path.default.resolve(basedir, absoluteImports);
    }
    try {
        return myResolve(moduleName, basedir);
    } catch (err) {
        if (err.code !== "MODULE_NOT_FOUND") throw err;
        throw Object.assign(new Error(`Failed to resolve "${moduleName}" relative to "${dirname}"`), {
            code: "BABEL_POLYFILL_NOT_FOUND",
            polyfill: moduleName,
            dirname
        });
    }
}
function has(basedir, name) {
    try {
        myResolve(name, basedir);
        return true;
    } catch (_unused) {
        return false;
    }
}
function logMissing(missingDeps) {
    if (missingDeps.size === 0) return;
    const deps = Array.from(missingDeps).sort().join(" ");
    console.warn("\nSome polyfills have been added but are not present in your dependencies.\n" + "Please run one of the following commands:\n" + `\tnpm install --save ${deps}\n` + `\tyarn add ${deps}\n`);
    process.exitCode = 1;
}
let allMissingDeps = new Set();
const laterLogMissingDependencies = (0, _lodash.default)(()=>{
    logMissing(allMissingDeps);
    allMissingDeps = new Set();
}, 100);
function laterLogMissing(missingDeps) {
    if (missingDeps.size === 0) return;
    missingDeps.forEach((name)=>allMissingDeps.add(name));
    laterLogMissingDependencies();
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/meta-resolver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = createMetaResolver;
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)");
const PossibleGlobalObjects = new Set([
    "global",
    "globalThis",
    "self",
    "window"
]);
function createMetaResolver(polyfills) {
    const { static: staticP, instance: instanceP, global: globalP } = polyfills;
    return (meta)=>{
        if (meta.kind === "global" && globalP && (0, _utils.has)(globalP, meta.name)) {
            return {
                kind: "global",
                desc: globalP[meta.name],
                name: meta.name
            };
        }
        if (meta.kind === "property" || meta.kind === "in") {
            const { placement, object, key } = meta;
            if (object && placement === "static") {
                if (globalP && PossibleGlobalObjects.has(object) && (0, _utils.has)(globalP, key)) {
                    return {
                        kind: "global",
                        desc: globalP[key],
                        name: key
                    };
                }
                if (staticP && (0, _utils.has)(staticP, object) && (0, _utils.has)(staticP[object], key)) {
                    return {
                        kind: "static",
                        desc: staticP[object][key],
                        name: `${object}$${key}`
                    };
                }
            }
            if (instanceP && (0, _utils.has)(instanceP, key)) {
                return {
                    kind: "instance",
                    desc: instanceP[key],
                    name: `${key}`
                };
            }
        }
    };
}
}}),
"[project]/node_modules/@babel/helper-define-polyfill-provider/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
exports.__esModule = true;
exports.default = definePolyfillProvider;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _helperCompilationTargets = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@babel/helper-compilation-targets/lib/index.js [app-ssr] (ecmascript)"));
var _utils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/utils.js [app-ssr] (ecmascript)");
var _importsInjector = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/imports-injector.js [app-ssr] (ecmascript)"));
var _debugUtils = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/debug-utils.js [app-ssr] (ecmascript)");
var _normalizeOptions = __turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/normalize-options.js [app-ssr] (ecmascript)");
var v = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/visitors/index.js [app-ssr] (ecmascript)"));
var deps = _interopRequireWildcard(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/node/dependencies.js [app-ssr] (ecmascript)"));
var _metaResolver = _interopRequireDefault(__turbopack_require__("[project]/node_modules/@babel/helper-define-polyfill-provider/lib/meta-resolver.js [app-ssr] (ecmascript)"));
const _excluded = [
    "method",
    "targets",
    "ignoreBrowserslistConfig",
    "configPath",
    "debug",
    "shouldInjectPolyfill",
    "absoluteImports"
];
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for(i = 0; i < sourceKeys.length; i++){
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
    }
    return target;
}
const getTargets = _helperCompilationTargets.default.default || _helperCompilationTargets.default;
function resolveOptions(options, babelApi) {
    const { method, targets: targetsOption, ignoreBrowserslistConfig, configPath, debug, shouldInjectPolyfill, absoluteImports } = options, providerOptions = _objectWithoutPropertiesLoose(options, _excluded);
    if (isEmpty(options)) {
        throw new Error(`\
This plugin requires options, for example:
    {
      "plugins": [
        ["<plugin name>", { method: "usage-pure" }]
      ]
    }

See more options at https://github.com/babel/babel-polyfills/blob/main/docs/usage.md`);
    }
    let methodName;
    if (method === "usage-global") methodName = "usageGlobal";
    else if (method === "entry-global") methodName = "entryGlobal";
    else if (method === "usage-pure") methodName = "usagePure";
    else if (typeof method !== "string") {
        throw new Error(".method must be a string");
    } else {
        throw new Error(`.method must be one of "entry-global", "usage-global"` + ` or "usage-pure" (received ${JSON.stringify(method)})`);
    }
    if (typeof shouldInjectPolyfill === "function") {
        if (options.include || options.exclude) {
            throw new Error(`.include and .exclude are not supported when using the` + ` .shouldInjectPolyfill function.`);
        }
    } else if (shouldInjectPolyfill != null) {
        throw new Error(`.shouldInjectPolyfill must be a function, or undefined` + ` (received ${JSON.stringify(shouldInjectPolyfill)})`);
    }
    if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
        throw new Error(`.absoluteImports must be a boolean, a string, or undefined` + ` (received ${JSON.stringify(absoluteImports)})`);
    }
    let targets;
    if (// If any browserslist-related option is specified, fallback to the old
    // behavior of not using the targets specified in the top-level options.
    targetsOption || configPath || ignoreBrowserslistConfig) {
        const targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
            browsers: targetsOption
        } : targetsOption;
        targets = getTargets(targetsObj, {
            ignoreBrowserslistConfig,
            configPath
        });
    } else {
        targets = babelApi.targets();
    }
    return {
        method,
        methodName,
        targets,
        absoluteImports: absoluteImports != null ? absoluteImports : false,
        shouldInjectPolyfill,
        debug: !!debug,
        providerOptions: providerOptions
    };
}
function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
    const { method, methodName, targets, debug, shouldInjectPolyfill, providerOptions, absoluteImports } = resolveOptions(options, babelApi);
    // eslint-disable-next-line prefer-const
    let include, exclude;
    let polyfillsSupport;
    let polyfillsNames;
    let filterPolyfills;
    const getUtils = (0, _utils.createUtilsGetter)(new _importsInjector.default((moduleName)=>deps.resolve(dirname, moduleName, absoluteImports), (name)=>{
        var _polyfillsNames$get, _polyfillsNames;
        return (_polyfillsNames$get = (_polyfillsNames = polyfillsNames) == null ? void 0 : _polyfillsNames.get(name)) != null ? _polyfillsNames$get : Infinity;
    }));
    const depsCache = new Map();
    const api = {
        babel: babelApi,
        getUtils,
        method: options.method,
        targets,
        createMetaResolver: _metaResolver.default,
        shouldInjectPolyfill (name) {
            if (polyfillsNames === undefined) {
                throw new Error(`Internal error in the ${factory.name} provider: ` + `shouldInjectPolyfill() can't be called during initialization.`);
            }
            if (!polyfillsNames.has(name)) {
                console.warn(`Internal error in the ${providerName} provider: ` + `unknown polyfill "${name}".`);
            }
            if (filterPolyfills && !filterPolyfills(name)) return false;
            let shouldInject = (0, _helperCompilationTargets.isRequired)(name, targets, {
                compatData: polyfillsSupport,
                includes: include,
                excludes: exclude
            });
            if (shouldInjectPolyfill) {
                shouldInject = shouldInjectPolyfill(name, shouldInject);
                if (typeof shouldInject !== "boolean") {
                    throw new Error(`.shouldInjectPolyfill must return a boolean.`);
                }
            }
            return shouldInject;
        },
        debug (name) {
            var _debugLog, _debugLog$polyfillsSu;
            debugLog().found = true;
            if (!debug || !name) return;
            if (debugLog().polyfills.has(providerName)) return;
            debugLog().polyfills.add(name);
            (_debugLog$polyfillsSu = (_debugLog = debugLog()).polyfillsSupport) != null ? _debugLog$polyfillsSu : _debugLog.polyfillsSupport = polyfillsSupport;
        },
        assertDependency (name, version = "*") {
            if (missingDependencies === false) return;
            if (absoluteImports) {
                // If absoluteImports is not false, we will try resolving
                // the dependency and throw if it's not possible. We can
                // skip the check here.
                return;
            }
            const dep = version === "*" ? name : `${name}@^${version}`;
            const found = missingDependencies.all ? false : mapGetOr(depsCache, `${name} :: ${dirname}`, ()=>deps.has(dirname, name));
            if (!found) {
                debugLog().missingDeps.add(dep);
            }
        }
    };
    const provider = factory(api, providerOptions, dirname);
    const providerName = provider.name || factory.name;
    if (typeof provider[methodName] !== "function") {
        throw new Error(`The "${providerName}" provider doesn't support the "${method}" polyfilling method.`);
    }
    if (Array.isArray(provider.polyfills)) {
        polyfillsNames = new Map(provider.polyfills.map((name, index)=>[
                name,
                index
            ]));
        filterPolyfills = provider.filterPolyfills;
    } else if (provider.polyfills) {
        polyfillsNames = new Map(Object.keys(provider.polyfills).map((name, index)=>[
                name,
                index
            ]));
        polyfillsSupport = provider.polyfills;
        filterPolyfills = provider.filterPolyfills;
    } else {
        polyfillsNames = new Map();
    }
    ({ include, exclude } = (0, _normalizeOptions.validateIncludeExclude)(providerName, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []));
    let callProvider;
    if (methodName === "usageGlobal") {
        callProvider = (payload, path)=>{
            var _ref;
            const utils = getUtils(path);
            return (_ref = provider[methodName](payload, utils, path)) != null ? _ref : false;
        };
    } else {
        callProvider = (payload, path)=>{
            const utils = getUtils(path);
            provider[methodName](payload, utils, path);
            return false;
        };
    }
    return {
        debug,
        method,
        targets,
        provider,
        providerName,
        callProvider
    };
}
function definePolyfillProvider(factory) {
    return (0, _helperPluginUtils.declare)((babelApi, options, dirname)=>{
        babelApi.assertVersion("^7.0.0 || ^8.0.0-alpha.0");
        const { traverse } = babelApi;
        let debugLog;
        const missingDependencies = (0, _normalizeOptions.applyMissingDependenciesDefaults)(options, babelApi);
        const { debug, method, targets, provider, providerName, callProvider } = instantiateProvider(factory, options, missingDependencies, dirname, ()=>debugLog, babelApi);
        const createVisitor = method === "entry-global" ? v.entry : v.usage;
        const visitor = provider.visitor ? traverse.visitors.merge([
            createVisitor(callProvider),
            provider.visitor
        ]) : createVisitor(callProvider);
        if (debug && debug !== _debugUtils.presetEnvSilentDebugHeader) {
            console.log(`${providerName}: \`DEBUG\` option`);
            console.log(`\nUsing targets: ${(0, _debugUtils.stringifyTargetsMultiline)(targets)}`);
            console.log(`\nUsing polyfills with \`${method}\` method:`);
        }
        const { runtimeName } = provider;
        return {
            name: "inject-polyfills",
            visitor,
            pre (file) {
                var _provider$pre;
                if (runtimeName) {
                    if (file.get("runtimeHelpersModuleName") && file.get("runtimeHelpersModuleName") !== runtimeName) {
                        console.warn(`Two different polyfill providers` + ` (${file.get("runtimeHelpersModuleProvider")}` + ` and ${providerName}) are trying to define two` + ` conflicting @babel/runtime alternatives:` + ` ${file.get("runtimeHelpersModuleName")} and ${runtimeName}.` + ` The second one will be ignored.`);
                    } else {
                        file.set("runtimeHelpersModuleName", runtimeName);
                        file.set("runtimeHelpersModuleProvider", providerName);
                    }
                }
                debugLog = {
                    polyfills: new Set(),
                    polyfillsSupport: undefined,
                    found: false,
                    providers: new Set(),
                    missingDeps: new Set()
                };
                (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
            },
            post () {
                var _provider$post;
                (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);
                if (missingDependencies !== false) {
                    if (missingDependencies.log === "per-file") {
                        deps.logMissing(debugLog.missingDeps);
                    } else {
                        deps.laterLogMissing(debugLog.missingDeps);
                    }
                }
                if (!debug) return;
                if (this.filename) console.log(`\n[${this.filename}]`);
                if (debugLog.polyfills.size === 0) {
                    console.log(method === "entry-global" ? debugLog.found ? `Based on your targets, the ${providerName} polyfill did not add any polyfill.` : `The entry point for the ${providerName} polyfill has not been found.` : `Based on your code and targets, the ${providerName} polyfill did not add any polyfill.`);
                    return;
                }
                if (method === "entry-global") {
                    console.log(`The ${providerName} polyfill entry has been replaced with ` + `the following polyfills:`);
                } else {
                    console.log(`The ${providerName} polyfill added the following polyfills:`);
                }
                for (const name of debugLog.polyfills){
                    var _debugLog$polyfillsSu2;
                    if ((_debugLog$polyfillsSu2 = debugLog.polyfillsSupport) != null && _debugLog$polyfillsSu2[name]) {
                        const filteredTargets = (0, _helperCompilationTargets.getInclusionReasons)(name, targets, debugLog.polyfillsSupport);
                        const formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
                        console.log(`  ${name} ${formattedTargets}`);
                    } else {
                        console.log(`  ${name}`);
                    }
                }
            }
        };
    });
}
function mapGetOr(map, key, getDefault) {
    let val = map.get(key);
    if (val === undefined) {
        val = getDefault();
        map.set(key, val);
    }
    return val;
}
function isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
}}),
"[project]/node_modules/@babel/plugin-transform-react-constant-elements/lib/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _helperPluginUtils = __turbopack_require__("[project]/node_modules/@babel/helper-plugin-utils/lib/index.js [app-ssr] (ecmascript)");
var _core = __turbopack_require__("[project]/node_modules/@babel/core/lib/index.js [app-ssr] (ecmascript)");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options)=>{
    api.assertVersion(7);
    const { allowMutablePropsOnTags } = options;
    if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
        throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
    }
    const HOISTED = new WeakMap();
    function declares(node, scope) {
        if (_core.types.isJSXIdentifier(node, {
            name: "this"
        }) || _core.types.isJSXIdentifier(node, {
            name: "arguments"
        }) || _core.types.isJSXIdentifier(node, {
            name: "super"
        }) || _core.types.isJSXIdentifier(node, {
            name: "new"
        })) {
            const { path } = scope;
            return path.isFunctionParent() && !path.isArrowFunctionExpression();
        }
        return scope.hasOwnBinding(node.name);
    }
    function isHoistingScope({ path }) {
        return path.isFunctionParent() || path.isLoop() || path.isProgram();
    }
    function getHoistingScope(scope) {
        while(!isHoistingScope(scope))scope = scope.parent;
        return scope;
    }
    const targetScopeVisitor = {
        ReferencedIdentifier (path, state) {
            const { node } = path;
            let { scope } = path;
            while(scope !== state.jsxScope){
                if (declares(node, scope)) return;
                scope = scope.parent;
            }
            while(scope){
                if (scope === state.targetScope) return;
                if (declares(node, scope)) break;
                scope = scope.parent;
            }
            state.targetScope = getHoistingScope(scope);
        }
    };
    const immutabilityVisitor = {
        enter (path, state) {
            var _expressionResult$deo;
            const stop = ()=>{
                state.isImmutable = false;
                path.stop();
            };
            const skip = ()=>{
                path.skip();
            };
            if (path.isJSXClosingElement()) {
                skip();
                return;
            }
            if (path.isJSXIdentifier({
                name: "ref"
            }) && path.parentPath.isJSXAttribute({
                name: path.node
            })) {
                stop();
                return;
            }
            if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName() || path.isImmutable()) {
                return;
            }
            if (path.isIdentifier()) {
                const binding = path.scope.getBinding(path.node.name);
                if (binding != null && binding.constant) return;
            }
            const { mutablePropsAllowed } = state;
            if (mutablePropsAllowed && path.isFunction()) {
                path.traverse(targetScopeVisitor, state);
                skip();
                return;
            }
            if (!path.isPure()) {
                stop();
                return;
            }
            const expressionResult = path.evaluate();
            if (expressionResult.confident) {
                const { value } = expressionResult;
                if (mutablePropsAllowed || value === null || typeof value !== "object" && typeof value !== "function") {
                    skip();
                    return;
                }
            } else if ((_expressionResult$deo = expressionResult.deopt) != null && _expressionResult$deo.isIdentifier()) {
                return;
            }
            stop();
        }
    };
    const hoistingVisitor = Object.assign({}, immutabilityVisitor, targetScopeVisitor);
    return {
        name: "transform-react-constant-elements",
        visitor: {
            "JSXElement|JSXFragment" (path) {
                var _jsxScope;
                if (HOISTED.has(path.node)) return;
                let mutablePropsAllowed = false;
                let name;
                if (path.isJSXElement()) {
                    name = path.node.openingElement.name;
                    if (allowMutablePropsOnTags != null) {
                        let lastSegment = name;
                        while(_core.types.isJSXMemberExpression(lastSegment)){
                            lastSegment = lastSegment.property;
                        }
                        const elementName = lastSegment.name;
                        mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);
                    }
                } else {
                    name = path.node;
                }
                let jsxScope;
                let current = path;
                while(!jsxScope && current.parentPath.isJSX()){
                    current = current.parentPath;
                    jsxScope = HOISTED.get(current.node);
                }
                (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = path.scope;
                HOISTED.set(path.node, jsxScope);
                const visitorState = {
                    isImmutable: true,
                    mutablePropsAllowed,
                    jsxScope,
                    targetScope: path.scope.getProgramParent()
                };
                path.traverse(hoistingVisitor, visitorState);
                if (!visitorState.isImmutable) return;
                const { targetScope } = visitorState;
                for(let currentScope = jsxScope;;){
                    if (targetScope === currentScope) return;
                    if (isHoistingScope(currentScope)) break;
                    currentScope = currentScope.parent;
                    if (!currentScope) {
                        throw new Error("Internal @babel/plugin-transform-react-constant-elements error: " + "targetScope must be an ancestor of jsxScope. " + "This is a Babel bug, please report it.");
                    }
                }
                const id = path.scope.generateUidBasedOnNode(name);
                targetScope.push({
                    id: _core.types.identifier(id)
                });
                HOISTED.set(path.node, targetScope);
                let replacement = _core.template.expression.ast`
          ${_core.types.identifier(id)} || (${_core.types.identifier(id)} = ${path.node})
        `;
                if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute() || path.parentPath.isJSXFragment()) {
                    replacement = _core.types.jsxExpressionContainer(replacement);
                }
                path.replaceWith(replacement);
            }
        }
    };
}); //# sourceMappingURL=index.js.map
}}),

};

//# sourceMappingURL=node_modules_%40babel_6812b7._.js.map