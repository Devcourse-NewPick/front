{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/source-map.ts"],"sourcesContent":["import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport {\n  type SourceMapInput,\n  originalPositionFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | { [sourceFileName: string]: string },\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code[sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number,\n    column: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: {\n      source: string | null;\n      name?: string | null;\n      line: number | null;\n      column: number | null;\n    };\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName,\n          line: line,\n          column: column,\n        };\n      }\n    }\n\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n"],"names":["_genMapping","require","_traceMapping","SourceMap","constructor","opts","code","_opts$sourceFileName","_map","_rawMappings","_sourceFileName","_lastGenLine","_lastSourceLine","_lastSourceColumn","_inputMap","map","GenMapping","sourceRoot","sourceFileName","replace","undefined","inputSourceMap","TraceMap","resolvedSources","length","i","_this$_inputMap$sourc","setSourceContent","sourcesContent","Object","keys","get","toEncodedMap","getDecoded","toDecodedMap","getRawMappings","allMappings","mark","generated","line","column","identifierName","identifierNamePos","filename","_originalMapping","originalMapping","originalPositionFor","name","originalIdentifierMapping","source","maybeAddMapping","original","exports","default"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 93, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/buffer.ts"],"sourcesContent":["import type SourceMap from \"./source-map.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n  index: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n"],"names":["Buffer","constructor","map","indentChar","_map","_buf","_str","_appendCount","_last","_queue","_queueCursor","_canMarkIdName","_indentChar","_fastIndentations","_position","line","column","_sourcePosition","identifierName","undefined","identifierNamePos","filename","i","push","repeat","_allocQueue","queue","char","_pushQueue","cursor","length","item","_popQueue","Error","get","_flush","result","code","trimRight","decodedMap","getDecoded","__mergedMap","resultMap","value","Object","defineProperty","writable","rawMappings","mappings","getRawMappings","append","str","maybeNewline","_append","appendChar","_appendChar","sourcePosition","queueIndentation","queueCursor","sourcePos","fastIndentation","String","fromCharCode","_mark","len","position","charCodeAt","indexOf","last","_this$_map","mark","removeTrailingNewline","removeLastSemicolon","getLastChar","getNewlineCount","count","endsWithCharAndNewline","lastCp","hasContent","exactSource","loc","cb","source","prop","_normalizePosition","sourceWithOffset","columnOffset","pos","target","Math","max","getCurrentColumn","lastIndex","getCurrentLine","exports","default"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/node/whitespace.ts"],"sourcesContent":["import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index.ts\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected here…\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : 0) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : 0)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n"],"names":["_t","require","FLIPPED_ALIAS_KEYS","isArrayExpression","isAssignmentExpression","isBinary","isBlockStatement","isCallExpression","isFunction","isIdentifier","isLiteral","isMemberExpression","isObjectExpression","isOptionalCallExpression","isOptionalMemberExpression","isStringLiteral","crawlInternal","node","state","object","computed","property","left","right","hasCall","callee","hasFunction","hasHelper","isHelper","crawl","name","charCodeAt","isType","nodes","exports","AssignmentExpression","SwitchCase","parent","consequent","length","cases","LogicalExpression","Literal","value","CallExpression","OptionalCallExpression","VariableDeclaration","i","declarations","declar","enabled","id","init","IfStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","properties","ObjectTypeCallProperty","_parent$properties","callProperties","ObjectTypeIndexer","_parent$properties2","_parent$callPropertie","indexers","ObjectTypeInternalSlot","_parent$properties3","_parent$callPropertie2","_parent$indexers","internalSlots","forEach","type","amounts","concat","ret"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 566, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/node/parentheses.ts"],"sourcesContent":["import {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 0],\n  [\"|>\", 0],\n  [\"&&\", 1],\n  [\"|\", 2],\n  [\"^\", 3],\n  [\"&\", 4],\n  [\"==\", 5],\n  [\"===\", 5],\n  [\"!=\", 5],\n  [\"!==\", 5],\n  [\"<\", 6],\n  [\">\", 6],\n  [\"<=\", 6],\n  [\">=\", 6],\n  [\"in\", 6],\n  [\"instanceof\", 6],\n  [\">>\", 7],\n  [\"<<\", 7],\n  [\">>>\", 7],\n  [\"+\", 8],\n  [\"-\", 8],\n  [\"*\", 9],\n  [\"/\", 9],\n  [\"%\", 9],\n  [\"**\", 10],\n]);\n\nfunction getBinaryPrecedence(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  nodeType: string,\n): number;\nfunction getBinaryPrecedence(\n  node: t.Node,\n  nodeType: string,\n): number | undefined;\nfunction getBinaryPrecedence(node: t.Node, nodeType: string) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get((node as t.Binary).operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\n\nfunction isTSTypeExpression(nodeType: string) {\n  return (\n    nodeType === \"TSAsExpression\" ||\n    nodeType === \"TSSatisfiesExpression\" ||\n    nodeType === \"TSTypeAssertion\"\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => {\n  const parentType = parent.type;\n  return (\n    (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) => {\n  const parentType = parent.type;\n  return (\n    ((parentType === \"MemberExpression\" ||\n      parentType === \"OptionalMemberExpression\") &&\n      parent.object === node) ||\n    ((parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\") &&\n      parent.callee === node) ||\n    (parentType === \"TaggedTemplateExpression\" && parent.tag === node) ||\n    parentType === \"TSNonNullExpression\"\n  );\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  const parentType = parent.type;\n  return (\n    // (() => A) | (() => B)\n    parentType === \"UnionTypeAnnotation\" ||\n    // (() => A) & (() => B)\n    parentType === \"IntersectionTypeAnnotation\" ||\n    // (() => A)[]\n    parentType === \"ArrayTypeAnnotation\" ||\n    Boolean(tokenContext & TokenContext.arrowFlowReturnType)\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return Boolean(\n    tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody),\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && Boolean(tokenContext & TokenContext.expressionStatement)\n  );\n}\n\nexport function Binary(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean | undefined {\n  const parentType = parent.type;\n  if (\n    node.type === \"BinaryExpression\" &&\n    node.operator === \"**\" &&\n    parentType === \"BinaryExpression\" &&\n    parent.operator === \"**\"\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"AwaitExpression\"\n  ) {\n    return true;\n  }\n\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parentType === \"BinaryExpression\" &&\n        parent.right === node) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n\n  return undefined;\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"ArrayTypeAnnotation\" ||\n    parentType === \"NullableTypeAnnotation\" ||\n    parentType === \"IntersectionTypeAnnotation\" ||\n    parentType === \"UnionTypeAnnotation\"\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    (parent.type === \"AssignmentExpression\" ||\n      parent.type === \"AssignmentPattern\") &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parent.type === \"BinaryExpression\" &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return Binary(node, parent);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSArrayType\" ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSRestType\"\n  );\n}\n\nexport { TSUnionType as TSIntersectionType };\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return parentType === \"TSArrayType\" || parentType === \"TSOptionalType\";\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  const parentType = parent.type;\n  return (\n    (parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\" ||\n      parentType === \"TSInstantiationExpression\") &&\n    !!parent.typeParameters\n  );\n}\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n  tokenContext: unknown,\n  inForStatementInit: boolean,\n): boolean {\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return node.operator === \"in\" && inForStatementInit;\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"SequenceExpression\" ||\n    parentType === \"ParenthesizedExpression\" ||\n    (parentType === \"MemberExpression\" && parent.property === node) ||\n    (parentType === \"OptionalMemberExpression\" && parent.property === node) ||\n    parentType === \"TemplateLiteral\"\n  ) {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    hasPostfixPart(node, parent) ||\n    (parentType === \"AwaitExpression\" && isYieldExpression(node)) ||\n    (parentType === \"ConditionalExpression\" && node === parent.test) ||\n    isClassExtendsClause(node, parent) ||\n    isTSTypeExpression(parentType)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    (isBinaryExpression(parent) &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    (parentType === \"ConditionalExpression\" && parent.test === node) ||\n    parentType === \"AwaitExpression\" ||\n    isTSTypeExpression(parentType)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    (isCallExpression(parent) && parent.callee === node) ||\n    (isMemberExpression(parent) && parent.object === node)\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    isObjectPattern(node.left)\n  ) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  tokenContext: number,\n  _inForInit: boolean,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  const parentType = parent.type;\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    parentType === \"AssignmentExpression\" &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    if (\n      isFollowedByBracket &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forHead |\n          TokenContext.forInHead)\n    ) {\n      return true;\n    }\n    return Boolean(tokenContext & TokenContext.forOfHead);\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    node.name === \"async\" &&\n    isForOfStatement(parent, { left: node, await: false })\n  );\n}\n"],"names":["_t","require","_index","isArrayTypeAnnotation","isBinaryExpression","isCallExpression","isForOfStatement","isIndexedAccessType","isMemberExpression","isObjectPattern","isOptionalMemberExpression","isYieldExpression","isStatement","PRECEDENCE","Map","getBinaryPrecedence","node","nodeType","get","operator","isTSTypeExpression","isClassExtendsClause","parent","parentType","type","superClass","hasPostfixPart","object","callee","tag","NullableTypeAnnotation","FunctionTypeAnnotation","tokenContext","Boolean","TokenContext","arrowFlowReturnType","UpdateExpression","needsParenBeforeExpressionBrace","expressionStatement","arrowBody","ObjectExpression","DoExpression","async","Binary","left","parentPos","nodePos","right","undefined","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSUnionType","TSInferType","TSInstantiationExpression","typeParameters","BinaryExpression","inForStatementInit","SequenceExpression","property","YieldExpression","test","ClassExpression","exportDefault","UnaryLike","FunctionExpression","ConditionalExpression","OptionalMemberExpression","AssignmentExpression","LogicalExpression","Identifier","_inForInit","getRawIdentifier","_node$extra","extra","parenthesized","rightType","id","name","isFollowedByBracket","computed","optional","forHead","forInHead","forOfHead","await"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/node/index.ts"],"sourcesContent":["import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport const enum TokenContext {\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  forHead = 1 << 3,\n  forInHead = 1 << 4,\n  forOfHead = 1 << 5,\n  arrowFlowReturnType = 1 << 6,\n}\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  inForStatementInit?: boolean,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R;\n\nexport type NodeHandlers<R> = {\n  [K in string]?: NodeHandler<R>;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack, inForInit, getRawIdentifier) {\n            return (\n              fn(node, parent, stack, inForInit, getRawIdentifier) ??\n              func(node, parent, stack, inForInit, getRawIdentifier)\n            );\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  inForInit?: boolean,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  if (isDecorator(parent)) {\n    return (\n      !isDecoratorMemberExpression(node) &&\n      !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) &&\n      !isParenthesizedExpression(node)\n    );\n  }\n\n  return expandedParens.get(node.type)?.(\n    node,\n    parent,\n    tokenContext,\n    inForInit,\n    getRawIdentifier,\n  );\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n"],"names":["whitespace","require","parens","_t","FLIPPED_ALIAS_KEYS","VISITOR_KEYS","isCallExpression","isDecorator","isExpressionStatement","isMemberExpression","isNewExpression","isParenthesizedExpression","TokenContext","exports","expressionStatement","arrowBody","exportDefault","forHead","forInHead","forOfHead","arrowFlowReturnType","expandAliases","obj","map","Map","add","type","func","fn","get","set","node","parent","stack","inForInit","getRawIdentifier","_fn","Object","keys","aliases","alias","expandedParens","expandedWhitespaceNodes","nodes","isOrHasCallExpression","object","needsWhitespace","_expandedWhitespaceNo","expression","flag","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","tokenContext","_expandedParens$get","callee","isDecoratorMemberExpression","computed","property","isLastChild","child","visitorKeys","i","length","val","Array","isArray","j"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 993, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 998, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/token-map.ts"],"sourcesContent":["import type * as t from \"@babel/types\";\nimport type { Token } from \"@babel/parser\";\n\nimport { traverseFast, VISITOR_KEYS } from \"@babel/types\";\n\nexport class TokenMap {\n  _tokens: Token[];\n  _source: string;\n\n  _nodesToTokenIndexes: Map<t.Node, number[]> = new Map();\n  _nodesOccurrencesCountCache: Map<\n    t.Node,\n    { test: string; count: number; i: number }\n  > = new Map();\n\n  _tokensCache = new Map<t.Node, { first: number; last: number }>();\n\n  constructor(ast: t.Node, tokens: Token[], source: string) {\n    this._tokens = tokens;\n    this._source = source;\n\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n\n    this._tokensCache = null;\n  }\n\n  has(node: t.Node): boolean {\n    return this._nodesToTokenIndexes.has(node);\n  }\n\n  getIndexes(node: t.Node): readonly number[] | undefined {\n    return this._nodesToTokenIndexes.get(node);\n  }\n\n  find(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n\n  findLastIndex(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): number {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n\n  findMatching(\n    node: t.Node,\n    test: string,\n    occurrenceCount: number = 0,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n\n      // To avoid O(n^2) search when printing lists (such as arrays), we\n      // cache the last index of a given token for a given occurrence count.\n      // If then we are asked to find the next occurrence of the same token,\n      // we start from the index of the previously found token.\n      // This cache only kicks in after 2 tokens of the same type, to avoid\n      // overhead in the simple case of having unique tokens per node.\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache && cache.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, { test, count, i });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n\n  matchesOriginal(token: Token, test: string) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n\n  startMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  endMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  _getTokensIndexesOfNode(node: t.Node): number[] {\n    if (node.start == null || node.end == null) return [];\n\n    const { first, last } = this._findTokensOfNode(\n      node,\n      0,\n      this._tokens.length - 1,\n    );\n\n    let low = first;\n\n    const children = childrenIterator(node);\n\n    if (\n      (node.type === \"ExportNamedDeclaration\" ||\n        node.type === \"ExportDefaultDeclaration\") &&\n      node.declaration &&\n      node.declaration.type === \"ClassDeclaration\"\n    ) {\n      // Exported class declarations can be not properly nested inside\n      // the export declaration that contains them. For example, in\n      // `@dec export class Foo {}` the `export` is covered by the\n      // ClassDeclaration range. Skip the class declaration from the list\n      // of children to skip, so that when looking for `export` we also\n      // traverse its tokens.\n      children.next();\n    }\n\n    const indexes = [];\n\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n\n      const childTok = this._findTokensOfNode(child, low, last);\n\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n\n      low = childTok.last + 1;\n    }\n\n    for (let k = low; k <= last; k++) indexes.push(k);\n\n    return indexes;\n  }\n\n  _findTokensOfNode(node: t.Node, low: number, high: number) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n\n    const first = this._findFirstTokenOfNode(node.start, low, high);\n    const last = this._findLastTokenOfNode(node.end, first, high);\n\n    this._tokensCache.set(node, { first, last });\n    return { first, last };\n  }\n\n  _findFirstTokenOfNode(start: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n\n  _findLastTokenOfNode(end: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\n\nfunction* childrenIterator(node: t.Node) {\n  // We need special handling to iterate TemplateLiteral\n  // children in order, since the two lists are interleaved.\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = (node as any)[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n"],"names":["_t","require","traverseFast","VISITOR_KEYS","TokenMap","constructor","ast","tokens","source","_tokens","_source","_nodesToTokenIndexes","Map","_nodesOccurrencesCountCache","_tokensCache","node","indexes","_getTokensIndexesOfNode","length","set","has","getIndexes","get","find","condition","k","index","tok","findLastIndex","findMatching","test","occurrenceCount","i","count","cache","matchesOriginal","token","end","start","value","startsWith","startMatches","endMatches","first","last","_findTokensOfNode","low","children","childrenIterator","type","declaration","next","child","childTok","high","push","cached","_findFirstTokenOfNode","_findLastTokenOfNode","mid","exports","quasis","expressions","keys","key","Array","isArray"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1185, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/template-literals.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag);\n  this.print(node.typeParameters); // TS\n  this.print(node.quasi);\n}\n\nexport function TemplateElement(this: Printer) {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  const quasis = node.quasis;\n\n  let partRaw = \"`\";\n\n  for (let i = 0; i < quasis.length; i++) {\n    partRaw += quasis[i].value.raw;\n\n    if (i + 1 < quasis.length) {\n      this.token(partRaw + \"${\", true);\n      this.print(node.expressions[i]);\n      partRaw = \"}\";\n\n      // In Babel 7 we have indivirual tokens for ${ and }, so the automatic\n      // catchup logic does not work. Manually look for those tokens.\n      if (!process.env.BABEL_8_BREAKING && this.tokenMap) {\n        const token = this.tokenMap.findMatching(node, \"}\", i);\n        if (token) this._catchUpTo(token.loc.start);\n      }\n    }\n  }\n\n  this.token(partRaw + \"`\", true);\n}\n"],"names":["TaggedTemplateExpression","node","print","tag","typeParameters","quasi","TemplateElement","Error","TemplateLiteral","quasis","partRaw","i","length","value","raw","token","expressions","tokenMap","findMatching","_catchUpTo","loc","start"],"mappings":";;;;;;;AAGO,SAASA,wBAAwBA,CAEtCC,IAAgC,EAChC;IACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAAC;IACpB,IAAI,CAACD,KAAK,CAACD,IAAI,CAACG,cAAc,CAAC;IAC/B,IAAI,CAACF,KAAK,CAACD,IAAI,CAACI,KAAK,CAAC;AACxB;AAEO,SAASC,eAAeA,CAAA,EAAgB;IAC7C,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;AAC3E;AAEO,SAASC,eAAeA,CAAgBP,IAAuB,EAAE;IACtE,MAAMQ,MAAM,GAAGR,IAAI,CAACQ,MAAM;IAE1B,IAAIC,OAAO,GAAG,GAAG;IAEjB,IAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACG,MAAM,EAAED,CAAC,EAAE,CAAE;QACtCD,OAAO,IAAID,MAAM,CAACE,CAAC,CAAC,CAACE,KAAK,CAACC,GAAG;QAE9B,IAAIH,CAAC,GAAG,CAAC,GAAGF,MAAM,CAACG,MAAM,EAAE;YACzB,IAAI,CAACG,KAAK,CAACL,OAAO,GAAG,IAAI,EAAE,IAAI,CAAC;YAChC,IAAI,CAACR,KAAK,CAACD,IAAI,CAACe,WAAW,CAACL,CAAC,CAAC,CAAC;YAC/BD,OAAO,GAAG,GAAG;YAIb,IAAqC,IAAI,CAACO,QAAQ,EAAE;gBAClD,MAAMF,KAAK,GAAG,IAAI,CAACE,QAAQ,CAACC,YAAY,CAACjB,IAAI,EAAE,GAAG,EAAEU,CAAC,CAAC;gBACtD,IAAII,KAAK,EAAE,IAAI,CAACI,UAAU,CAACJ,KAAK,CAACK,GAAG,CAACC,KAAK,CAAC;YAC7C;QACF;IACF;IAEA,IAAI,CAACN,KAAK,CAACL,OAAO,GAAG,GAAG,EAAE,IAAI,CAAC;AACjC","ignoreList":[0]}},
    {"offset": {"line": 1217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/expressions.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments); // Flow\n  this.print(node.typeParameters); // TS\n\n  // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n  if (node.optional) {\n    // TODO: This can never happen\n    this.token(\"?.\");\n  }\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  this.print(node.expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  this.print(node.typeParameters); // TS\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments); // Flow\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments); // Flow\n  this.print(node.typeParameters); // TS\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument);\n  }\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  this.word(\"yield\", true);\n\n  if (node.delegate) {\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument);\n    }\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property);\n    this.token(\"]\");\n    exit();\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n"],"names":["_t","require","_index","isCallExpression","isLiteral","isMemberExpression","isNewExpression","isPattern","UnaryExpression","node","operator","word","space","token","print","argument","DoExpression","async","body","ParenthesizedExpression","exit","enterDelimited","expression","rightParens","UpdateExpression","prefix","ConditionalExpression","test","consequent","alternate","NewExpression","parent","callee","format","minified","arguments","length","optional","typeArguments","typeParameters","tokenMap","endMatches","printList","shouldPrintTrailingComma","SequenceExpression","expressions","ThisExpression","Super","_shouldPrintDecoratorsBeforeExport","decoratorsBeforeExport","start","declaration","Decorator","newline","OptionalMemberExpression","computed","property","object","TypeError","value","OptionalCallExpression","CallExpression","Import","AwaitExpression","printTerminatorless","YieldExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","tokenContext","TokenContext","expressionStatement","AssignmentPattern","left","type","typeAnnotation","right","AssignmentExpression","_endsWithDiv","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","id","V8IntrinsicIdentifier","name","ModuleExpression","indent","directives","dedent","rightBrace"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1499, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1504, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/statements.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  {\n    const exit = this.enterForStatementInit();\n    this.tokenContext |= TokenContext.forHead;\n    this.print(node.init);\n    exit();\n  }\n\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(\";\", false, 1);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction ForXStatement(this: Printer, node: t.ForXStatement) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  {\n    const exit = isForOf ? null : this.enterForStatementInit();\n    this.tokenContext |= isForOf\n      ? TokenContext.forOfHead\n      : TokenContext.forInHead;\n    this.print(node.left);\n    exit?.();\n  }\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport const ForInStatement = ForXStatement;\nexport const ForOfStatement = ForXStatement;\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(printer: Printer, node: t.Node) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label);\n  this.token(\":\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(\n    node.cases,\n    true,\n    undefined,\n    function addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    },\n  );\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  if (kind === \"await using\") {\n    this.word(\"await\");\n    this.space();\n    this.word(\"using\", true);\n  } else {\n    this.word(kind, kind === \"using\");\n  }\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(\n    node.declarations,\n    undefined,\n    undefined,\n    node.declarations.length > 1,\n    hasInits\n      ? function (this: Printer, occurrenceCount: number) {\n          this.token(\",\", false, occurrenceCount);\n          this.newline();\n        }\n      : undefined,\n  );\n\n  if (isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id);\n  if (node.definite) this.token(\"!\"); // TS\n  // @ts-ignore(Babel 7 vs Babel 8) Property 'typeAnnotation' does not exist on type 'MemberExpression'.\n  this.print(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init);\n  }\n}\n"],"names":["_t","require","_index","isFor","isForStatement","isIfStatement","isStatement","WithStatement","node","word","space","token","print","object","printBlock","IfStatement","test","needsBlock","alternate","getLastStatement","consequent","newline","indent","printAndIndentOnComments","dedent","endsWith","statement","body","ForStatement","exit","enterForStatementInit","tokenContext","TokenContext","forHead","init","update","WhileStatement","ForXStatement","isForOf","type","await","noIndentInnerCommentsHere","forOfHead","forInHead","left","right","ForInStatement","exports","ForOfStatement","DoWhileStatement","semicolon","printStatementAfterKeyword","printer","printTerminatorless","BreakStatement","label","ContinueStatement","ReturnStatement","argument","ThrowStatement","LabeledStatement","TryStatement","block","handlers","handler","finalizer","CatchClause","param","typeAnnotation","SwitchStatement","discriminant","printSequence","cases","undefined","addNewlines","leading","cas","length","rightBrace","SwitchCase","DebuggerStatement","VariableDeclaration","parent","declare","kind","hasInits","declar","declarations","printList","occurrenceCount","VariableDeclarator","id","definite"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1774, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1779, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/classes.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !this._shouldPrintDecoratorsBeforeExport(\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n\n  this.print(node.typeParameters);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(node.superTypeParameters);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n\n  this.space();\n  this.print(node.body);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator?.(-1); // print leading semicolons in preserveFormat mode\n\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true);\n    exit();\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nfunction classBodyEmptySemicolonsPrinter(printer: Printer, node: t.ClassBody) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n\n  // \"empty statements\" in class bodies are not represented in the AST.\n  // Print them by checking if there are any ; tokens between the current AST\n  // member and the next one.\n\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n\n  let k = 1; // start from 1 to skip '{'\n\n  let occurrenceCount = 0;\n\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (\n      nextLocIndex < node.body.length &&\n      node.body[nextLocIndex].start == null\n    ) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n\n  return (i: number) => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n\n    const end =\n      nextLocIndex === node.body.length\n        ? node.end\n        : node.body[nextLocIndex].start;\n\n    let tok;\n    while (\n      k < indexes.length &&\n      printer.tokenMap.matchesOriginal(\n        (tok = printer._tokens[indexes[k]]),\n        \";\",\n      ) &&\n      tok.start < end\n    ) {\n      printer.token(\";\", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators);\n\n  if (!node.static && !this.format.preserveFormat) {\n    // catch up to property key, avoid line break\n    // between member TS modifiers and the property key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  this.tsPrintClassMemberModifiers(node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.key);\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators);\n\n  if (!this.format.preserveFormat) {\n    // catch up to method key, avoid line break\n    // between member modifiers/method heads and the method key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n"],"names":["_t","require","isExportDefaultDeclaration","isExportNamedDeclaration","ClassDeclaration","node","parent","inExport","_shouldPrintDecoratorsBeforeExport","printJoin","decorators","declare","word","space","abstract","id","print","typeParameters","superClass","superTypeParameters","implements","printList","body","ClassBody","token","length","newline","separator","classBodyEmptySemicolonsPrinter","exit","enterDelimited","endsWith","rightBrace","printer","tokenMap","start","end","indexes","getIndexes","k","occurrenceCount","nextLocIndex","advanceNextLocIndex","i","tok","matchesOriginal","_tokens","undefined","ClassProperty","static","format","preserveFormat","_node$key$loc","endLine","key","loc","line","catchUp","tsPrintClassMemberModifiers","computed","_variance","optional","definite","typeAnnotation","value","semicolon","ClassAccessorProperty","_node$key$loc2","ClassPrivateProperty","ClassMethod","_classMethodHead","ClassPrivateMethod","_node$key$loc3","_methodHead","StaticBlock","printSequence"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1982, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1987, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/methods.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName,\n  parentNode: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, \")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: string,\n) {\n  const exit = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.token(\",\", null, i);\n      this.space();\n    }\n  }\n\n  this.token(endToken);\n  exit();\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    undefined,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n"],"names":["_t","require","_index","isIdentifier","_params","node","idNode","parentNode","print","typeParameters","nameInfo","_getFuncIdName","call","sourceIdentifierName","name","pos","token","_parameters","params","noLineTerminator","type","returnType","_noLineTerminator","parameters","endToken","exit","enterDelimited","trailingComma","shouldPrintTrailingComma","paramLength","length","i","_param","space","parameter","printJoin","decorators","optional","typeAnnotation","_methodHead","kind","key","word","async","generator","computed","undefined","_predicate","noLineTerminatorAfter","predicate","_functionHead","parent","format","preserveFormat","_endsWithInnerRaw","id","FunctionExpression","body","ArrowFunctionExpression","_shouldPrintArrowParamsParens","printInnerComments","tokenContext","TokenContext","arrowBody","_firstParam$leadingCo","_firstParam$trailingC","firstParam","leadingComments","trailingComments","tokenMap","loc","findMatching","arrowToken","start","line","retainLines","parentType","left","_id$loc","_id$loc2","identifierName","_id$loc3","_id$loc4","value"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2180, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2185, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/modules.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\n\nlet warningShown = false;\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] }>,\n  hasPreviousBrace: boolean,\n) {\n  const { importAttributesKeyword } = this.format;\n  const { attributes, assertions } = node;\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    attributes &&\n    !importAttributesKeyword &&\n    // In the production build only show the warning once.\n    // We want to show it per-usage locally for tests.\n    (!process.env.IS_PUBLISH || !warningShown)\n  ) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n\n  const useAssertKeyword =\n    importAttributesKeyword === \"assert\" ||\n    (!importAttributesKeyword && assertions);\n\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n\n  if (\n    !process.env.BABEL_8_BREAKING &&\n    !useAssertKeyword &&\n    importAttributesKeyword !== \"with\"\n  ) {\n    // with-legacy\n    this.printList(attributes || assertions);\n    return;\n  }\n\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n\n  this.token(\"{\", null, occurrenceCount);\n  this.space();\n  this.printList(attributes || assertions, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", null, occurrenceCount);\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    printer._shouldPrintDecoratorsBeforeExport(\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    let hasBrace = false;\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      hasBrace = true;\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length || node.assertions?.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options);\n  }\n  this.token(\")\");\n}\n"],"names":["_t","require","_index","isClassDeclaration","isExportDefaultSpecifier","isExportNamespaceSpecifier","isImportDefaultSpecifier","isImportNamespaceSpecifier","isStatement","ImportSpecifier","node","importKind","word","space","print","imported","local","name","ImportDefaultSpecifier","ExportDefaultSpecifier","exported","ExportSpecifier","exportKind","ExportNamespaceSpecifier","token","warningShown","_printAttributes","hasPreviousBrace","importAttributesKeyword","format","attributes","assertions","console","warn","useAssertKeyword","printList","occurrenceCount","shouldPrintTrailingComma","ExportAllDeclaration","_node$attributes","_node$assertions","length","source","semicolon","maybePrintDecoratorsBeforeExport","printer","declaration","_shouldPrintDecoratorsBeforeExport","printJoin","decorators","ExportNamedDeclaration","declar","specifiers","slice","hasSpecial","first","shift","hasBrace","_node$attributes2","_node$assertions2","ExportDefaultDeclaration","noIndentInnerCommentsHere","tokenContext","TokenContext","exportDefault","ImportDeclaration","_node$attributes3","_node$assertions3","isTypeKind","module","phase","hasSpecifiers","ImportAttribute","key","value","ImportNamespaceSpecifier","ImportExpression","options"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2457, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/types.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nlet lastRawIdentNode: t.Identifier | null = null;\nlet lastRawIdentResult: string = \"\";\nexport function _getRawIdentifier(this: Printer, node: t.Identifier) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n\n  const { name } = node;\n  const token = this.tokenMap.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return (lastRawIdentResult = node.name);\n}\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(node.loc?.identifierName || node.name);\n\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(\"}\"), true, true);\n    this.space();\n    exit();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value);\n      return;\n    }\n\n    this.print(node.key);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  const exit = this.enterDelimited();\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.token(\",\", false, i);\n      }\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\", false, i);\n    }\n  }\n\n  exit();\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#{\";\n    endToken = \"}\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"{|\";\n      endToken = \"|}\";\n    } else if (\n      this.format.recordAndTupleSyntaxType !== \"hash\" &&\n      this.format.recordAndTupleSyntaxType != null\n    ) {\n      throw new Error(\n        `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n          this.format.recordAndTupleSyntaxType,\n        )} received).`,\n      );\n    } else {\n      startToken = \"#{\";\n      endToken = \"}\";\n    }\n  }\n\n  this.token(startToken);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (process.env.BABEL_8_BREAKING) {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n      startToken = \"[|\";\n      endToken = \"|]\";\n    } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n      startToken = \"#[\";\n      endToken = \"]\";\n    } else {\n      throw new Error(\n        `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n      );\n    }\n  }\n\n  this.token(startToken);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {\n        this.token(\",\", false, i);\n      }\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\n// TODO: Remove in Babel 8\nexport function DecimalLiteral(this: Printer, node: any) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n"],"names":["_t","require","_jsesc","isAssignmentPattern","isIdentifier","lastRawIdentNode","lastRawIdentResult","_getRawIdentifier","node","name","token","tokenMap","find","tok","value","_originalCode","slice","start","end","Identifier","_node$loc","sourceIdentifierName","loc","identifierName","word","ArgumentPlaceholder","RestElement","print","argument","ObjectExpression","props","properties","length","exit","enterDelimited","space","printList","shouldPrintTrailingComma","sourceWithOffset","ObjectMethod","printJoin","decorators","_methodHead","body","ObjectProperty","computed","key","left","shorthand","ArrayExpression","elems","elements","len","i","elem","RecordExpression","startToken","endToken","format","recordAndTupleSyntaxType","Error","JSON","stringify","TupleExpression","RegExpLiteral","pattern","flags","BooleanLiteral","NullLiteral","NumericLiteral","raw","getPossibleRaw","opts","jsescOption","str","numbers","number","jsesc","minified","StringLiteral","undefined","val","BigIntLiteral","DecimalLiteral","validTopicTokenSet","Set","TopicReference","topicToken","has","givenTopicTokenJSON","validTopics","Array","from","v","join","PipelineTopicExpression","expression","PipelineBareFunction","callee","PipelinePrimaryTopicReference"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAAA,EAAA,GAAAC,OAAA;AAEA,IAAAC,MAAA,GAAAD,OAAA;AAA0B,MAAA,EAFjBE,mBAAmB,EAAEC,YAAAA,EAAY,GAAAJ,EAAA;AAI1C,IAAIK,gBAAqC,GAAG,IAAI;AAChD,IAAIC,kBAA0B,GAAG,EAAE;AAC5B,SAASC,iBAAiBA,CAAgBC,IAAkB,EAAE;IACnE,IAAIA,IAAI,KAAKH,gBAAgB,EAAE,OAAOC,kBAAkB;IACxDD,gBAAgB,GAAGG,IAAI;IAEvB,MAAM,EAAEC,IAAAA,EAAM,GAAGD,IAAI;IACrB,MAAME,KAAK,GAAG,IAAI,CAACC,QAAQ,CAACC,IAAI,CAACJ,IAAI,GAAEK,GAAG,GAAIA,GAAG,CAACC,KAAK,KAAKL,IAAI,CAAC;IACjE,IAAIC,KAAK,EAAE;QACTJ,kBAAkB,GAAG,IAAI,CAACS,aAAa,CAACC,KAAK,CAACN,KAAK,CAACO,KAAK,EAAEP,KAAK,CAACQ,GAAG,CAAC;QACrE,OAAOZ,kBAAkB;IAC3B;IACA,OAAQA,kBAAkB,GAAGE,IAAI,CAACC,IAAI;AACxC;AAEO,SAASU,UAAUA,CAAgBX,IAAkB,EAAE;IAAA,IAAAY,SAAA;IAC5D,IAAI,CAACC,oBAAoB,CAAC,CAAA,CAAAD,SAAA,GAAAZ,IAAI,CAACc,GAAG,KAAA,OAAA,KAAA,IAARF,SAAA,CAAUG,cAAc,KAAIf,IAAI,CAACC,IAAI,CAAC;IAEhE,IAAI,CAACe,IAAI,CAAC,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACJ,iBAAiB,CAACC,IAAI,CAAC,GAAGA,IAAI,CAACC,IAAI,CAAC;AACrE;AAEO,SAASgB,mBAAmBA,CAAA,EAAgB;IACjD,IAAI,CAACf,SAAK,CAAA,EAAI,CAAC;AACjB;AAEO,SAASgB,WAAWA,CAAgBlB,IAAmB,EAAE;IAC9D,IAAI,CAACE,KAAK,CAAC,KAAK,CAAC;IACjB,IAAI,CAACiB,KAAK,CAACnB,IAAI,CAACoB,QAAQ,CAAC;AAC3B;AAIO,SAASC,gBAAgBA,CAAgBrB,IAAwB,EAAE;IACxE,MAAMsB,KAAK,GAAGtB,IAAI,CAACuB,UAAU;IAE7B,IAAI,CAACrB,SAAK,CAAA,GAAI,CAAC;IAEf,IAAIoB,KAAK,CAACE,MAAM,EAAE;QAChB,MAAMC,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;QAClC,IAAI,CAACC,KAAK,CAAC,CAAC;QACZ,IAAI,CAACC,SAAS,CAACN,KAAK,EAAE,IAAI,CAACO,wBAAwB,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;QACrE,IAAI,CAACF,KAAK,CAAC,CAAC;QACZF,IAAI,CAAC,CAAC;IACR;IAEA,IAAI,CAACK,gBAAgB,CAAC,KAAK,EAAE9B,IAAI,CAACc,GAAG,EAAE,CAAC,CAAC,CAAC;IAE1C,IAAI,CAACZ,SAAK,CAAA,GAAI,CAAC;AACjB;AAIO,SAAS6B,YAAYA,CAAgB/B,IAAoB,EAAE;IAChE,IAAI,CAACgC,SAAS,CAAChC,IAAI,CAACiC,UAAU,CAAC;IAC/B,IAAI,CAACC,WAAW,CAAClC,IAAI,CAAC;IACtB,IAAI,CAAC2B,KAAK,CAAC,CAAC;IACZ,IAAI,CAACR,KAAK,CAACnB,IAAI,CAACmC,IAAI,CAAC;AACvB;AAEO,SAASC,cAAcA,CAAgBpC,IAAsB,EAAE;IACpE,IAAI,CAACgC,SAAS,CAAChC,IAAI,CAACiC,UAAU,CAAC;IAE/B,IAAIjC,IAAI,CAACqC,QAAQ,EAAE;QACjB,IAAI,CAACnC,SAAK,CAAA,EAAI,CAAC;QACf,IAAI,CAACiB,KAAK,CAACnB,IAAI,CAACsC,GAAG,CAAC;QACpB,IAAI,CAACpC,SAAK,CAAA,EAAI,CAAC;IACjB,CAAC,MAAM;QAEL,IACEP,mBAAmB,CAACK,IAAI,CAACM,KAAK,CAAC,IAC/BV,YAAY,CAACI,IAAI,CAACsC,GAAG,CAAC,IAEtBtC,IAAI,CAACsC,GAAG,CAACrC,IAAI,KAAKD,IAAI,CAACM,KAAK,CAACiC,IAAI,CAACtC,IAAI,EACtC;YACA,IAAI,CAACkB,KAAK,CAACnB,IAAI,CAACM,KAAK,CAAC;YACtB;QACF;QAEA,IAAI,CAACa,KAAK,CAACnB,IAAI,CAACsC,GAAG,CAAC;QAGpB,IACEtC,IAAI,CAACwC,SAAS,IACd5C,YAAY,CAACI,IAAI,CAACsC,GAAG,CAAC,IACtB1C,YAAY,CAACI,IAAI,CAACM,KAAK,CAAC,IACxBN,IAAI,CAACsC,GAAG,CAACrC,IAAI,KAAKD,IAAI,CAACM,KAAK,CAACL,IAAI,EACjC;YACA;QACF;IACF;IAEA,IAAI,CAACC,SAAK,CAAA,EAAI,CAAC;IACf,IAAI,CAACyB,KAAK,CAAC,CAAC;IACZ,IAAI,CAACR,KAAK,CAACnB,IAAI,CAACM,KAAK,CAAC;AACxB;AAEO,SAASmC,eAAeA,CAAgBzC,IAAuB,EAAE;IACtE,MAAM0C,KAAK,GAAG1C,IAAI,CAAC2C,QAAQ;IAC3B,MAAMC,GAAG,GAAGF,KAAK,CAAClB,MAAM;IAExB,IAAI,CAACtB,SAAK,CAAA,EAAI,CAAC;IAEf,MAAMuB,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;IAElC,IAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAAClB,MAAM,EAAEqB,CAAC,EAAE,CAAE;QACrC,MAAMC,IAAI,GAAGJ,KAAK,CAACG,CAAC,CAAC;QACrB,IAAIC,IAAI,EAAE;YACR,IAAID,CAAC,GAAG,CAAC,EAAE,IAAI,CAAClB,KAAK,CAAC,CAAC;YACvB,IAAI,CAACR,KAAK,CAAC2B,IAAI,CAAC;YAChB,IAAID,CAAC,GAAGD,GAAG,GAAG,CAAC,IAAI,IAAI,CAACf,wBAAwB,CAAC,GAAG,CAAC,EAAE;gBACrD,IAAI,CAAC3B,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE2C,CAAC,CAAC;YAC3B;QACF,CAAC,MAAM;YAML,IAAI,CAAC3C,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE2C,CAAC,CAAC;QAC3B;IACF;IAEApB,IAAI,CAAC,CAAC;IAEN,IAAI,CAACvB,SAAK,CAAA,EAAI,CAAC;AACjB;AAIO,SAAS6C,gBAAgBA,CAAgB/C,IAAwB,EAAE;IACxE,MAAMsB,KAAK,GAAGtB,IAAI,CAACuB,UAAU;IAE7B,IAAIyB,UAAU;IACd,IAAIC,QAAQ;IAIL;QACL,IAAI,IAAI,CAACC,MAAM,CAACC,wBAAwB,KAAK,KAAK,EAAE;YAClDH,UAAU,GAAG,IAAI;YACjBC,QAAQ,GAAG,IAAI;QACjB,CAAC,MAAM,IACL,IAAI,CAACC,MAAM,CAACC,wBAAwB,KAAK,MAAM,IAC/C,IAAI,CAACD,MAAM,CAACC,wBAAwB,IAAI,IAAI,EAC5C;YACA,MAAM,IAAIC,KAAK,CACb,CAAA,yEAAA,EAA4EC,IAAI,CAACC,SAAS,CACxF,IAAI,CAACJ,MAAM,CAACC,wBACd,CAAC,CAAA,WAAA,CACH,CAAC;QACH,CAAC,MAAM;YACLH,UAAU,GAAG,IAAI;YACjBC,QAAQ,GAAG,GAAG;QAChB;IACF;IAEA,IAAI,CAAC/C,KAAK,CAAC8C,UAAU,CAAC;IAEtB,IAAI1B,KAAK,CAACE,MAAM,EAAE;QAChB,IAAI,CAACG,KAAK,CAAC,CAAC;QACZ,IAAI,CAACC,SAAS,CAACN,KAAK,EAAE,IAAI,CAACO,wBAAwB,CAACoB,QAAQ,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;QAC1E,IAAI,CAACtB,KAAK,CAAC,CAAC;IACd;IACA,IAAI,CAACzB,KAAK,CAAC+C,QAAQ,CAAC;AACtB;AAEO,SAASM,eAAeA,CAAgBvD,IAAuB,EAAE;IACtE,MAAM0C,KAAK,GAAG1C,IAAI,CAAC2C,QAAQ;IAC3B,MAAMC,GAAG,GAAGF,KAAK,CAAClB,MAAM;IAExB,IAAIwB,UAAU;IACd,IAAIC,QAAQ;IAIL;QACL,IAAI,IAAI,CAACC,MAAM,CAACC,wBAAwB,KAAK,KAAK,EAAE;YAClDH,UAAU,GAAG,IAAI;YACjBC,QAAQ,GAAG,IAAI;QACjB,CAAC,MAAM,IAAI,IAAI,CAACC,MAAM,CAACC,wBAAwB,KAAK,MAAM,EAAE;YAC1DH,UAAU,GAAG,IAAI;YACjBC,QAAQ,GAAG,GAAG;QAChB,CAAC,MAAM;YACL,MAAM,IAAIG,KAAK,CACb,GAAG,IAAI,CAACF,MAAM,CAACC,wBAAwB,CAAA,0CAAA,CACzC,CAAC;QACH;IACF;IAEA,IAAI,CAACjD,KAAK,CAAC8C,UAAU,CAAC;IAEtB,IAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAAClB,MAAM,EAAEqB,CAAC,EAAE,CAAE;QACrC,MAAMC,IAAI,GAAGJ,KAAK,CAACG,CAAC,CAAC;QACrB,IAAIC,IAAI,EAAE;YACR,IAAID,CAAC,GAAG,CAAC,EAAE,IAAI,CAAClB,KAAK,CAAC,CAAC;YACvB,IAAI,CAACR,KAAK,CAAC2B,IAAI,CAAC;YAChB,IAAID,CAAC,GAAGD,GAAG,GAAG,CAAC,IAAI,IAAI,CAACf,wBAAwB,CAACoB,QAAQ,CAAC,EAAE;gBAC1D,IAAI,CAAC/C,KAAK,CAAC,GAAG,EAAE,KAAK,EAAE2C,CAAC,CAAC;YAC3B;QACF;IACF;IAEA,IAAI,CAAC3C,KAAK,CAAC+C,QAAQ,CAAC;AACtB;AAEO,SAASO,aAAaA,CAAgBxD,IAAqB,EAAE;IAClE,IAAI,CAACgB,IAAI,CAAC,CAAA,CAAA,EAAIhB,IAAI,CAACyD,OAAO,CAAA,CAAA,EAAIzD,IAAI,CAAC0D,KAAK,EAAE,CAAC;AAC7C;AAEO,SAASC,cAAcA,CAAgB3D,IAAsB,EAAE;IACpE,IAAI,CAACgB,IAAI,CAAChB,IAAI,CAACM,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;AAC1C;AAEO,SAASsD,WAAWA,CAAA,EAAgB;IACzC,IAAI,CAAC5C,IAAI,CAAC,MAAM,CAAC;AACnB;AAEO,SAAS6C,cAAcA,CAAgB7D,IAAsB,EAAE;IACpE,MAAM8D,GAAG,GAAG,IAAI,CAACC,cAAc,CAAC/D,IAAI,CAAC;IACrC,MAAMgE,IAAI,GAAG,IAAI,CAACd,MAAM,CAACe,WAAW;IACpC,MAAM3D,KAAK,GAAGN,IAAI,CAACM,KAAK;IACxB,MAAM4D,GAAG,GAAG5D,KAAK,GAAG,EAAE;IACtB,IAAI0D,IAAI,CAACG,OAAO,EAAE;QAChB,IAAI,CAACC,MAAM,CAACC,MAAK,CAAC/D,KAAK,EAAE0D,IAAI,CAAC,EAAE1D,KAAK,CAAC;IACxC,CAAC,MAAM,IAAIwD,GAAG,IAAI,IAAI,EAAE;QACtB,IAAI,CAACM,MAAM,CAACF,GAAG,EAAE5D,KAAK,CAAC;IACzB,CAAC,MAAM,IAAI,IAAI,CAAC4C,MAAM,CAACoB,QAAQ,EAAE;QAC/B,IAAI,CAACF,MAAM,CAACN,GAAG,CAACtC,MAAM,GAAG0C,GAAG,CAAC1C,MAAM,GAAGsC,GAAG,GAAGI,GAAG,EAAE5D,KAAK,CAAC;IACzD,CAAC,MAAM;QACL,IAAI,CAAC8D,MAAM,CAACN,GAAG,EAAExD,KAAK,CAAC;IACzB;AACF;AAEO,SAASiE,aAAaA,CAAgBvE,IAAqB,EAAE;IAClE,MAAM8D,GAAG,GAAG,IAAI,CAACC,cAAc,CAAC/D,IAAI,CAAC;IACrC,IAAI,CAAC,IAAI,CAACkD,MAAM,CAACoB,QAAQ,IAAIR,GAAG,KAAKU,SAAS,EAAE;QAC9C,IAAI,CAACtE,KAAK,CAAC4D,GAAG,CAAC;QACf;IACF;IAEA,MAAMW,GAAG,GAAGJ,MAAK,CAACrE,IAAI,CAACM,KAAK,EAAE,IAAI,CAAC4C,MAAM,CAACe,WAAW,CAAC;IAEtD,IAAI,CAAC/D,KAAK,CAACuE,GAAG,CAAC;AACjB;AAEO,SAASC,aAAaA,CAAgB1E,IAAqB,EAAE;IAClE,MAAM8D,GAAG,GAAG,IAAI,CAACC,cAAc,CAAC/D,IAAI,CAAC;IACrC,IAAI,CAAC,IAAI,CAACkD,MAAM,CAACoB,QAAQ,IAAIR,GAAG,KAAKU,SAAS,EAAE;QAC9C,IAAI,CAACxD,IAAI,CAAC8C,GAAG,CAAC;QACd;IACF;IACA,IAAI,CAAC9C,IAAI,CAAChB,IAAI,CAACM,KAAK,GAAG,GAAG,CAAC;AAC7B;AAGO,SAASqE,cAAcA,CAAgB3E,IAAS,EAAE;IACvD,MAAM8D,GAAG,GAAG,IAAI,CAACC,cAAc,CAAC/D,IAAI,CAAC;IACrC,IAAI,CAAC,IAAI,CAACkD,MAAM,CAACoB,QAAQ,IAAIR,GAAG,KAAKU,SAAS,EAAE;QAC9C,IAAI,CAACxD,IAAI,CAAC8C,GAAG,CAAC;QACd;IACF;IACA,IAAI,CAAC9C,IAAI,CAAChB,IAAI,CAACM,KAAK,GAAG,GAAG,CAAC;AAC7B;AAGA,MAAMsE,kBAAkB,GAAG,IAAIC,GAAG,CAAC;IAAC,IAAI;IAAE,IAAI;IAAE,GAAG;IAAE,GAAG;IAAE,GAAG;CAAC,CAAC;AACxD,SAASC,cAAcA,CAAA,EAAgB;IAC5C,MAAM,EAAEC,UAAAA,EAAY,GAAG,IAAI,CAAC7B,MAAM;IAElC,IAAI0B,kBAAkB,CAACI,GAAG,CAACD,UAAU,CAAC,EAAE;QACtC,IAAI,CAAC7E,KAAK,CAAC6E,UAAU,CAAC;IACxB,CAAC,MAAM;QACL,MAAME,mBAAmB,GAAG5B,IAAI,CAACC,SAAS,CAACyB,UAAU,CAAC;QACtD,MAAMG,WAAW,GAAGC,KAAK,CAACC,IAAI,CAACR,kBAAkB,GAAES,CAAC,GAAIhC,IAAI,CAACC,SAAS,CAAC+B,CAAC,CAAC,CAAC;QAC1E,MAAM,IAAIjC,KAAK,CACb,CAAA,iDAAA,CAAmD,GACjD,GAAG8B,WAAW,CAACI,IAAI,CAAC,IAAI,CAAC,CAAA,EAAA,EAAKL,mBAAmB,CAAA,mBAAA,CACrD,CAAC;IACH;AACF;AAGO,SAASM,uBAAuBA,CAErCvF,IAA+B,EAC/B;IACA,IAAI,CAACmB,KAAK,CAACnB,IAAI,CAACwF,UAAU,CAAC;AAC7B;AAEO,SAASC,oBAAoBA,CAElCzF,IAA4B,EAC5B;IACA,IAAI,CAACmB,KAAK,CAACnB,IAAI,CAAC0F,MAAM,CAAC;AACzB;AAEO,SAASC,6BAA6BA,CAAA,EAAgB;IAC3D,IAAI,CAACzF,SAAK,CAAA,EAAI,CAAC;AACjB","ignoreList":[0]}},
    {"offset": {"line": 2696, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2701, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/flow.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8) Remove this comment, since we'll remove the Noop node\n  this.print(node.id.typeAnnotation.typeAnnotation);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(\n  this: Printer,\n  node: t.TypeAnnotation,\n  parent: t.Node,\n) {\n  this.token(\":\");\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= TokenContext.arrowFlowReturnType;\n  } else if (\n    // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n    node.optional\n  ) {\n    this.token(\"?\");\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params);\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(\n      props,\n      true,\n      true,\n      undefined,\n      undefined,\n      function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n    );\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification);\n  this.token(\".\");\n  this.print(node.id);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n"],"names":["_t","require","_modules","_index","_types2","isDeclareExportDeclaration","isStatement","AnyTypeAnnotation","word","ArrayTypeAnnotation","node","print","elementType","token","BooleanTypeAnnotation","BooleanLiteralTypeAnnotation","value","NullLiteralTypeAnnotation","DeclareClass","parent","space","_interfaceish","DeclareFunction","id","typeAnnotation","predicate","semicolon","InferredPredicate","DeclaredPredicate","DeclareInterface","InterfaceDeclaration","DeclareModule","body","DeclareModuleExports","DeclareTypeAlias","TypeAlias","DeclareOpaqueType","OpaqueType","DeclareVariable","DeclareExportDeclaration","default","FlowExportDeclaration","call","DeclareExportAllDeclaration","ExportAllDeclaration","EnumDeclaration","enumExplicitType","context","name","hasExplicitType","enumBody","members","indent","newline","member","hasUnknownMembers","dedent","EnumBooleanBody","explicitType","EnumNumberBody","EnumStringBody","EnumSymbolBody","EnumDefaultedMember","enumInitializedMember","init","EnumBooleanMember","EnumNumberMember","EnumStringMember","declaration","declar","specifiers","length","printList","source","ExistsTypeAnnotation","FunctionTypeAnnotation","typeParameters","this","params","rest","type","method","returnType","FunctionTypeParam","optional","InterfaceExtends","_node$extends","extends","_node$mixins","_node$implements","mixins","implements","_variance","_node$variance","kind","variance","andSeparator","occurrenceCount","InterfaceTypeAnnotation","_node$extends2","IntersectionTypeAnnotation","printJoin","types","undefined","MixedTypeAnnotation","EmptyTypeAnnotation","NullableTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeofTypeAnnotation","argument","right","TypeAnnotation","tokenContext","TokenContext","arrowFlowReturnType","TypeParameterInstantiation","TypeParameter","bound","supertype","impltype","ObjectTypeAnnotation","exact","props","properties","callProperties","indexers","internalSlots","addNewlines","leading","inexact","ObjectTypeInternalSlot","static","ObjectTypeCallProperty","ObjectTypeIndexer","key","ObjectTypeProperty","proto","ObjectTypeSpreadProperty","QualifiedTypeIdentifier","qualification","SymbolTypeAnnotation","orSeparator","UnionTypeAnnotation","TypeCastExpression","expression","Variance","VoidTypeAnnotation","IndexedAccessType","objectType","indexType","OptionalIndexedAccessType"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3347, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3352, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/base.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter);\n  }\n\n  this.print(node.program);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, true);\n\n  exit();\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n"],"names":["File","node","program","print","interpreter","Program","_node$directives","noIndentInnerCommentsHere","printInnerComments","directivesLen","directives","length","_node$directives$trai","newline","body","printSequence","undefined","trailingComments","BlockStatement","_node$directives2","token","exit","enterDelimited","_node$directives$trai2","rightBrace","Directive","value","semicolon","unescapedSingleQuoteRE","unescapedDoubleQuoteRE","DirectiveLiteral","raw","getPossibleRaw","format","minified","test","Error","InterpreterDirective","Placeholder","name","expectedNode"],"mappings":";;;;;;;;;;;AAGO,SAASA,IAAIA,CAAgBC,IAAY,EAAE;IAChD,IAAIA,IAAI,CAACC,OAAO,EAAE;QAGhB,IAAI,CAACC,KAAK,CAACF,IAAI,CAACC,OAAO,CAACE,WAAW,CAAC;IACtC;IAEA,IAAI,CAACD,KAAK,CAACF,IAAI,CAACC,OAAO,CAAC;AAC1B;AAEO,SAASG,OAAOA,CAAgBJ,IAAe,EAAE;IAAA,IAAAK,gBAAA;IAGtD,IAAI,CAACC,yBAAyB,CAAC,CAAC;IAChC,IAAI,CAACC,kBAAkB,CAAC,CAAC;IAEzB,MAAMC,aAAa,GAAA,CAAAH,gBAAA,GAAGL,IAAI,CAACS,UAAU,KAAA,OAAA,KAAA,IAAfJ,gBAAA,CAAiBK,MAAM;IAC7C,IAAIF,aAAa,EAAE;QAAA,IAAAG,qBAAA;QACjB,MAAMC,OAAO,GAAGZ,IAAI,CAACa,IAAI,CAACH,MAAM,GAAG,CAAC,GAAG,CAAC;QACxC,IAAI,CAACI,aAAa,CAACd,IAAI,CAACS,UAAU,EAAEM,SAAS,EAAEH,OAAO,CAAC;QACvD,IAAI,CAAA,CAAA,CAAAD,qBAAA,GAACX,IAAI,CAACS,UAAU,CAACD,aAAa,GAAG,CAAC,CAAC,CAACQ,gBAAgB,KAAA,QAAnDL,qBAAA,CAAqDD,MAAM,GAAE;YAChE,IAAI,CAACE,OAAO,CAACA,OAAO,CAAC;QACvB;IACF;IAEA,IAAI,CAACE,aAAa,CAACd,IAAI,CAACa,IAAI,CAAC;AAC/B;AAEO,SAASI,cAAcA,CAAgBjB,IAAsB,EAAE;IAAA,IAAAkB,iBAAA;IACpE,IAAI,CAACC,SAAK,CAAA,GAAI,CAAC;IACf,MAAMC,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;IAElC,MAAMb,aAAa,GAAA,CAAAU,iBAAA,GAAGlB,IAAI,CAACS,UAAU,KAAA,OAAA,KAAA,IAAfS,iBAAA,CAAiBR,MAAM;IAC7C,IAAIF,aAAa,EAAE;QAAA,IAAAc,sBAAA;QACjB,MAAMV,OAAO,GAAGZ,IAAI,CAACa,IAAI,CAACH,MAAM,GAAG,CAAC,GAAG,CAAC;QACxC,IAAI,CAACI,aAAa,CAACd,IAAI,CAACS,UAAU,EAAE,IAAI,EAAEG,OAAO,CAAC;QAClD,IAAI,CAAA,CAAA,CAAAU,sBAAA,GAACtB,IAAI,CAACS,UAAU,CAACD,aAAa,GAAG,CAAC,CAAC,CAACQ,gBAAgB,KAAA,QAAnDM,sBAAA,CAAqDZ,MAAM,GAAE;YAChE,IAAI,CAACE,OAAO,CAACA,OAAO,CAAC;QACvB;IACF;IAEA,IAAI,CAACE,aAAa,CAACd,IAAI,CAACa,IAAI,EAAE,IAAI,CAAC;IAEnCO,IAAI,CAAC,CAAC;IACN,IAAI,CAACG,UAAU,CAACvB,IAAI,CAAC;AACvB;AAEO,SAASwB,SAASA,CAAgBxB,IAAiB,EAAE;IAC1D,IAAI,CAACE,KAAK,CAACF,IAAI,CAACyB,KAAK,CAAC;IACtB,IAAI,CAACC,SAAS,CAAC,CAAC;AAClB;AAGA,MAAMC,sBAAsB,GAAG,uBAAuB;AACtD,MAAMC,sBAAsB,GAAG,uBAAuB;AAE/C,SAASC,gBAAgBA,CAAgB7B,IAAwB,EAAE;IACxE,MAAM8B,GAAG,GAAG,IAAI,CAACC,cAAc,CAAC/B,IAAI,CAAC;IACrC,IAAI,CAAC,IAAI,CAACgC,MAAM,CAACC,QAAQ,IAAIH,GAAG,KAAKf,SAAS,EAAE;QAC9C,IAAI,CAACI,KAAK,CAACW,GAAG,CAAC;QACf;IACF;IAEA,MAAM,EAAEL,KAAAA,EAAO,GAAGzB,IAAI;IAMtB,IAAI,CAAC4B,sBAAsB,CAACM,IAAI,CAACT,KAAK,CAAC,EAAE;QACvC,IAAI,CAACN,KAAK,CAAC,CAAA,CAAA,EAAIM,KAAK,CAAA,CAAA,CAAG,CAAC;IAC1B,CAAC,MAAM,IAAI,CAACE,sBAAsB,CAACO,IAAI,CAACT,KAAK,CAAC,EAAE;QAC9C,IAAI,CAACN,KAAK,CAAC,CAAA,CAAA,EAAIM,KAAK,CAAA,CAAA,CAAG,CAAC;IAC1B,CAAC,MAAM;QACL,MAAM,IAAIU,KAAK,CACb,mEAAmE,GACjE,2CACJ,CAAC;IACH;AACF;AAEO,SAASC,oBAAoBA,CAElCpC,IAA4B,EAC5B;IACA,IAAI,CAACmB,KAAK,CAAC,CAAA,EAAA,EAAKnB,IAAI,CAACyB,KAAK,EAAE,CAAC;IAC7B,IAAI,CAACb,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC;AACvB;AAEO,SAASyB,WAAWA,CAAgBrC,IAAmB,EAAE;IAC9D,IAAI,CAACmB,KAAK,CAAC,IAAI,CAAC;IAChB,IAAI,CAACjB,KAAK,CAACF,IAAI,CAACsC,IAAI,CAAC;IACrB,IAAI,CAACnB,KAAK,CAAC,IAAI,CAAC;IAEhB,IAAInB,IAAI,CAACuC,YAAY,KAAK,WAAW,EAAE;QACrC,IAAI,CAACb,SAAS,CAAC,CAAC;IAClB;AACF","ignoreList":[0]}},
    {"offset": {"line": 3434, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3439, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/jsx.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace);\n  this.token(\":\");\n  this.print(node.name);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingElement);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name);\n  this.print(node.typeParameters); // TS\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/\");\n  }\n  this.token(\">\");\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"<\");\n  this.token(\"/\");\n  this.print(node.name);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n"],"names":["JSXAttribute","node","print","name","value","token","JSXIdentifier","word","JSXNamespacedName","namespace","JSXMemberExpression","object","property","JSXSpreadAttribute","argument","rightBrace","JSXExpressionContainer","expression","JSXSpreadChild","JSXText","raw","getPossibleRaw","undefined","JSXElement","open","openingElement","selfClosing","indent","child","children","dedent","closingElement","spaceSeparator","space","JSXOpeningElement","typeParameters","attributes","length","printJoin","JSXClosingElement","JSXEmptyExpression","printInnerComments","JSXFragment","openingFragment","closingFragment","JSXOpeningFragment","JSXClosingFragment"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3557, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3562, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/typescript.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      (process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n          parent.returnType\n        : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n          parent.typeAnnotation) === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap.matchesOriginal(t, \",\"),\n    );\n    // Preseve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (node.name as unknown as string)\n      : (node.name as unknown as t.Identifier).name,\n  );\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.params\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.returnType\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  this.print(node.typeName, !!node.typeParameters);\n  this.print(node.typeParameters);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, null, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.word(node.key.name);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.word(node.typeParameter.name);\n  }\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.print(node.constraint);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.print(node.typeParameter.constraint);\n  }\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(\n  this: Printer,\n  // TODO(Babel 8): Just use t.TSClassImplements\n  node: Extract<\n    t.Node,\n    { type: \"TSClassImplements\" | \"TSExpressionWithTypeArguments\" }\n  >,\n) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\n\nexport {\n  // TODO: Remove this in Babel 8\n  TSClassImplements as TSExpressionWithTypeArguments,\n  TSClassImplements as TSInterfaceHeritage,\n};\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id, members } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  printBraced(this, node, () =>\n    this.printList(\n      members,\n      // TODO: Default to false for consistency with everything else\n      this.shouldPrintTrailingComma(\"}\") ?? true,\n      true,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, id, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (process.env.BABEL_8_BREAKING) {\n    if (kind !== \"global\") {\n      this.word(kind);\n      this.space();\n    }\n\n    this.print(node.id);\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n    this.space();\n    this.print(node.body);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    if (!node.global) {\n      this.word(kind ?? (id.type === \"Identifier\" ? \"namespace\" : \"module\"));\n      this.space();\n    }\n\n    this.print(id);\n\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n\n    let body = node.body;\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    while (body.type === \"TSModuleDeclaration\") {\n      this.token(\".\");\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      this.print(body.id);\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      body = body.body;\n    }\n\n    this.space();\n    this.print(body);\n  }\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { argument, qualifier, typeParameters } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument);\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  if (typeParameters) {\n    this.print(typeParameters);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { isExport, id, moduleReference } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? node.params\n    : node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  const returnType = process.env.BABEL_8_BREAKING\n    ? node.returnType\n    : node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isField && node.declare && \"declare\",\n    node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    node.override && \"override\",\n    node.abstract && \"abstract\",\n    isField && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n"],"names":["TSTypeAnnotation","node","parent","token","type","typeAnnotation","space","optional","print","TSTypeParameterInstantiation","printTrailingSeparator","params","length","tokenMap","start","end","find","t","matchesOriginal","shouldPrintTrailingComma","printList","TSTypeParameter","in","word","out","name","constraint","default","TSParameterProperty","accessibility","readonly","_param","parameter","TSDeclareFunction","declare","_functionHead","semicolon","TSDeclareMethod","_classMethodHead","TSQualifiedName","left","right","TSCallSignatureDeclaration","tsPrintSignatureDeclarationBase","maybePrintTrailingCommaOrSemicolon","printer","endMatches","TSConstructSignatureDeclaration","TSPropertySignature","tsPrintPropertyOrMethodName","computed","key","TSMethodSignature","kind","TSIndexSignature","static","isStatic","_parameters","parameters","TSAnyKeyword","TSBigIntKeyword","TSUnknownKeyword","TSNumberKeyword","TSObjectKeyword","TSBooleanKeyword","TSStringKeyword","TSSymbolKeyword","TSVoidKeyword","TSUndefinedKeyword","TSNullKeyword","TSNeverKeyword","TSIntrinsicKeyword","TSThisType","TSFunctionType","tsPrintFunctionOrConstructorType","TSConstructorType","abstract","typeParameters","returnType","TSTypeReference","typeName","TSTypePredicate","asserts","parameterName","TSTypeQuery","exprName","TSTypeLiteral","printBraced","printJoin","members","TSArrayType","elementType","TSTupleType","elementTypes","TSOptionalType","TSRestType","TSNamedTupleMember","label","TSUnionType","tsPrintUnionOrIntersectionType","TSIntersectionType","sep","_printer$tokenMap","hasLeadingToken","startMatches","types","undefined","i","TSConditionalType","checkType","extendsType","trueType","falseType","TSInferType","typeParameter","TSParenthesizedType","TSTypeOperator","operator","TSIndexedAccessType","objectType","indexType","TSMappedType","nameType","exit","enterDelimited","tokenIfPlusMinus","self","tok","TSLiteralType","literal","TSClassImplements","expression","TSInterfaceDeclaration","id","extends","extendz","body","TSInterfaceBody","TSTypeAliasDeclaration","TSTypeExpression","TSTypeAssertion","TSInstantiationExpression","TSEnumDeclaration","const","isConst","_this$shouldPrintTrai","TSEnumMember","initializer","TSModuleDeclaration","global","TSModuleBlock","printSequence","TSImportType","argument","qualifier","TSImportEqualsDeclaration","isExport","moduleReference","TSExternalModuleReference","TSNonNullExpression","TSExportAssignment","TSNamespaceExportDeclaration","tsPrintClassMemberModifiers","isField","printModifiersList","override","cb","rightBrace","modifiers","_printer$tokenMap2","modifiersSet","Set","modifier","add","has","value","delete","size"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4214, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4219, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/generators/index.ts"],"sourcesContent":["export * from \"./template-literals.ts\";\nexport * from \"./expressions.ts\";\nexport * from \"./statements.ts\";\nexport * from \"./classes.ts\";\nexport * from \"./methods.ts\";\nexport * from \"./modules.ts\";\nexport * from \"./types.ts\";\nexport * from \"./flow.ts\";\nexport * from \"./base.ts\";\nexport * from \"./jsx.ts\";\nexport * from \"./typescript.ts\";\n"],"names":["_templateLiterals","require","Object","keys","forEach","key","exports","defineProperty","enumerable","get","_expressions","_statements","_classes","_methods","_modules","_types","_flow","_base","_jsx","_typescript"],"mappings":";;;;AAAA,IAAAA,iBAAA,GAAAC,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAH,iBAAA,EAAAI,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAL,iBAAA,CAAAK,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAT,iBAAA,CAAAK,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAK,YAAA,GAAAT,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAO,YAAA,EAAAN,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAK,YAAA,CAAAL,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAC,YAAA,CAAAL,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAM,WAAA,GAAAV,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAQ,WAAA,EAAAP,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAM,WAAA,CAAAN,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAE,WAAA,CAAAN,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAO,QAAA,GAAAX,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAS,QAAA,EAAAR,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAO,QAAA,CAAAP,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAG,QAAA,CAAAP,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAQ,QAAA,GAAAZ,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAU,QAAA,EAAAT,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAQ,QAAA,CAAAR,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAI,QAAA,CAAAR,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAS,QAAA,GAAAb,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAW,QAAA,EAAAV,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAS,QAAA,CAAAT,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAK,QAAA,CAAAT,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAU,MAAA,GAAAd,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAY,MAAA,EAAAX,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAU,MAAA,CAAAV,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAM,MAAA,CAAAV,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAW,KAAA,GAAAf,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAa,KAAA,EAAAZ,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAW,KAAA,CAAAX,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAO,KAAA,CAAAX,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAY,KAAA,GAAAhB,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAc,KAAA,EAAAb,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAY,KAAA,CAAAZ,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAQ,KAAA,CAAAZ,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAa,IAAA,GAAAjB,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAe,IAAA,EAAAd,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAa,IAAA,CAAAb,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAS,IAAA,CAAAb,GAAA,CAAA;QAAA;IAAA;AAAA;AACA,IAAAc,WAAA,GAAAlB,OAAA;AAAAC,MAAA,CAAAC,IAAA,CAAAgB,WAAA,EAAAf,OAAA,CAAA,SAAAC,GAAA;IAAA,IAAAA,GAAA,KAAA,aAAAA,GAAA,KAAA,cAAA;IAAA,IAAAA,GAAA,IAAAC,OAAA,IAAAA,OAAA,CAAAD,GAAA,CAAA,KAAAc,WAAA,CAAAd,GAAA,CAAA,EAAA;IAAAH,MAAA,CAAAK,cAAA,CAAAD,OAAA,EAAAD,GAAA,EAAA;QAAAG,UAAA,EAAA;QAAAC,GAAA,EAAA,SAAAA,CAAA;YAAA,OAAAU,WAAA,CAAAd,GAAA,CAAA;QAAA;IAAA;AAAA","ignoreList":[0]}},
    {"offset": {"line": 4344, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4349, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/printer.ts"],"sourcesContent":["import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\nimport type { GeneratorOptions } from \"./index.ts\";\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap,\n    tokens?: Token[],\n    originalCode?: string,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n\n  inForStatementInit: boolean = false;\n  enterForStatementInit() {\n    if (this.inForStatementInit) return () => {};\n    this.inForStatementInit = true;\n    return () => {\n      this.inForStatementInit = false;\n    };\n  }\n\n  enterDelimited() {\n    const oldInForStatementInit = this.inForStatementInit;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (\n      oldInForStatementInit === false &&\n      oldNoLineTerminatorAfterNode === null\n    ) {\n      return () => {};\n    }\n    this.inForStatementInit = false;\n    this._noLineTerminatorAfterNode = null;\n    return () => {\n      this.inForStatementInit = oldInForStatementInit;\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    };\n  }\n\n  tokenContext: number = 0;\n\n  _tokens: Token[] = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _endsWithDiv = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n  tokenMap: TokenMap = null;\n\n  _boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens, this._originalCode);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent--;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode);\n        this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(charCodes.semicolon);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    const { format } = this;\n    if (format.compact || format.preserveFormat) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext = 0;\n\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (this._endsWithDiv && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(str: string, maybeNewline = false, occurrenceCount = 0): void {\n    this.tokenContext = 0;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this.tokenContext = 0;\n\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap.findMatching(\n      this._currentNode,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._buf.appendChar(charCodes.semicolon);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _queue(char: number) {\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const { format } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const parent = this._currentNode;\n    this._currentNode = node;\n\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      (parenthesized && format.preserveFormat) ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(\n        node,\n        parent,\n        this.tokenContext,\n        this.inForStatementInit,\n        format.preserveFormat ? this._boundGetRawIdentifier : undefined,\n      );\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (this.format.retainLines &&\n          node.loc &&\n          node.loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    let oldInForStatementInitWasTrue;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        n.isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.inForStatementInit) {\n        oldInForStatementInitWasTrue = true;\n        this.inForStatementInit = false;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(\n      loc,\n      // @ts-expect-error Expected 1 arguments, but got 3.\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldInForStatementInitWasTrue) this.inForStatementInit = true;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"],\n    printTrailingSeparator?: boolean,\n    addNewlines?: PrintJoinOptions[\"addNewlines\"],\n    iterator?: PrintJoinOptions[\"iterator\"],\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const boundSeparator = separator?.bind(this);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n\n      iterator?.(node, i);\n\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);\n        else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n\n      if (statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    if (this._endsWithInnerRaw) {\n      this.printInnerComments(\n        this.tokenMap?.findMatching(\n          this._currentNode,\n          nextTokenStr,\n          nextTokenOccurrenceCount,\n        ),\n      );\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments(nextToken?: Token) {\n    const node = this._currentNode;\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(\n      COMMENT_TYPE.INNER,\n      comments,\n      node,\n      undefined,\n      undefined,\n      nextToken,\n    );\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    trailingCommentsLineOffset?: number,\n    addNewlines?: PrintSequenceOptions[\"addNewlines\"],\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      addNewlines,\n      undefined,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[],\n    printTrailingSeparator?: boolean,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    iterator?: PrintListOptions[\"iterator\"],\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      undefined,\n      iterator,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token =>\n      this.tokenMap.matchesOriginal(token, listEnd),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], \",\");\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace &&\n      lastCharCode !== charCodes.leftParenthesis\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid converting a / operator into a line comment by appending /* to it\n    if (this._endsWithDiv) this._space();\n\n    if (this.tokenMap) {\n      const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =\n        this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n    nextToken?: Token,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumDeclaration(parent);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n"],"names":["_buffer","require","n","_t","_tokenMap","generatorFunctions","isExpression","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumDeclaration","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","type","test","value","needsParens","Printer","constructor","format","map","tokens","originalCode","inForStatementInit","tokenContext","_tokens","_originalCode","_currentNode","_indent","_indentRepeat","_insideAux","_noLineTerminator","_noLineTerminatorAfterNode","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_endsWithDiv","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","tokenMap","_boundGetRawIdentifier","_getRawIdentifier","bind","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","indent","style","length","_inputMap","_buf","Buffer","enterForStatementInit","enterDelimited","oldInForStatementInit","oldNoLineTerminatorAfterNode","generate","ast","preserveFormat","TokenMap","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","_appendChar","node","start","end","endMatches","getCurrentLine","indexes","getIndexes","_catchUpTo","loc","_queue","rightBrace","minified","removeLastSemicolon","sourceWithOffset","token","rightParens","space","_space","hasContent","lastCp","getLastChar","word","str","noLineTerminatorAfter","_maybePrintInnerComments","_catchUpToCurrentToken","charCodeAt","_append","number","isNonDecimalLiteral","secondChar","Number","isInteger","maybeNewline","occurrenceCount","lastChar","strFirst","tokenChar","char","String","fromCharCode","newline","i","retainLines","getNewlineCount","j","_newline","endsWith","endsWithCharAndNewline","removeTrailingNewline","exactSource","cb","_catchUp","source","prop","columnOffset","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","findMatching","appendChar","_maybeIndent","append","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","catchUp","line","count","column","index","spacesCount","getCurrentColumn","spaces","slice","replace","repeat","printTerminatorless","trailingCommentsLineOffset","_node$extra","_node$leadingComments","_node$leadingComments2","nodeType","oldConcise","_compact","printMethod","undefined","ReferenceError","JSON","stringify","name","parent","oldInAux","parenthesized","extra","shouldPrintParens","retainFunctionParens","leadingComments","parentType","callee","indentParenthesized","some","oldInForStatementInitWasTrue","isLastChild","_node$trailingComment","trailingComments","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","statement","separator","printTrailingSeparator","addNewlines","iterator","_nodes$0$loc","startLine","newlineOpts","nextNodeStartLine","boundSeparator","len","_printNewline","_node$trailingComment2","_nextNode$loc","nextNode","printAndIndentOnComments","printBlock","body","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","_this$tokenMap","printInnerComments","nextToken","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","shouldPrintTrailingComma","listEnd","listEndIndex","findLastIndex","matchesOriginal","newLine","opts","lastCommentLine","offset","_shouldPrintComment","ignore","has","commentTok","find","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","_comment$loc","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","Object","assign","prototype","Noop","_default","exports","default","last"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5093, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5098, "column": 0}, "map": {"version":3,"sources":["file:///Users/hyeon/Desktop/coding/4thTeamProject/node_modules/%40babel/generator/src/index.ts"],"sourcesContent":["import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | { [filename: string]: string },\n  opts: GeneratorOptions,\n  ast: t.Node,\n): Format {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\",\n      );\n    }\n    if (!opts.retainLines) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires `retainLines` to be set to `true`\",\n      );\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `compact` option\",\n      );\n    }\n    if (opts.minified) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `minified` option\",\n      );\n    }\n    if (opts.jsescOption) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `jsescOption` option\",\n      );\n    }\n    if (!Array.isArray((ast as any).tokens)) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.\",\n      );\n    }\n  }\n\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: process.env.BABEL_8_BREAKING ? true : false,\n      ...opts.jsescOption,\n    },\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword,\n  };\n\n  if (!process.env.BABEL_8_BREAKING) {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n    format.recordAndTupleSyntaxType = opts.recordAndTupleSyntaxType ?? \"hash\";\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Preserve the input code format while printing the transformed code.\n   * This is experimental, and may have breaking changes in future\n   * patch releases. It will be removed in a future minor release,\n   * when it will graduate to stable.\n   */\n  experimental_preserveFormat?: boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"©\";\n   * @deprecated use `jsescOptions: { json: true }` instead\n   */\n  jsonCompatibleStrings?: boolean;\n\n  /**\n   * Set to true to enable support for experimental decorators syntax before\n   * module exports. If not specified, decorators will be printed in the same\n   * position as they were in the input source code.\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the recordAndTuple token.\n   * @deprecated It will be removed in Babel 8.\n   */\n  recordAndTupleSyntaxType?: \"bar\" | \"hash\";\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies’ topic references.\n   */\n  topicToken?: \"%\" | \"#\" | \"@@\" | \"^^\" | \"^\";\n\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * We originally exported the Generator class above, but to make it extra clear that it is a private API,\n   * we have moved that to an internal class instance and simplified the interface to the two public methods\n   * that we wish to support.\n   */\n\n  // eslint-disable-next-line no-restricted-globals\n  exports.CodeGenerator = class CodeGenerator {\n    private _ast: t.Node;\n    private _format: Format | undefined;\n    private _map: SourceMap | null;\n    constructor(ast: t.Node, opts: GeneratorOptions = {}, code?: string) {\n      this._ast = ast;\n      this._format = normalizeOptions(code, opts, ast);\n      this._map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n    }\n    generate(): GeneratorResult {\n      const printer = new Printer(this._format, this._map);\n\n      return printer.generate(this._ast);\n    }\n  };\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport default function generate(\n  ast: t.Node,\n  opts: GeneratorOptions = {},\n  code?: string | { [filename: string]: string },\n): GeneratorResult {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n\n  const printer = new Printer(\n    format,\n    map,\n    (ast as any).tokens,\n    typeof code === \"string\" ? code : null,\n  );\n\n  return printer.generate(ast);\n}\n"],"names":["_sourceMap","require","_printer","normalizeOptions","code","opts","ast","experimental_preserveFormat","Error","retainLines","compact","minified","jsescOption","Array","isArray","tokens","format","auxiliaryCommentBefore","auxiliaryCommentAfter","shouldPrintComment","preserveFormat","retainFunctionParens","comments","concise","indent","adjustMultilineComment","style","Object","assign","quotes","wrap","minimal","topicToken","importAttributesKeyword","_opts$recordAndTupleS","decoratorsBeforeExport","json","jsonCompatibleStrings","recordAndTupleSyntaxType","value","includes","length","console","error","filename","undefined","exports","CodeGenerator","constructor","_ast","_format","_map","sourceMaps","SourceMap","generate","printer","Printer","map"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}